;default to PET
#ifndef VIC20
#define PET
#endif

#if 0

What is Vorth?

Vorth is a minimalist Forth for VIC-20.  By minimalist, I mean it doesn't even have an interpreter or compiler aboard, but such things can be built if needed.  Instead, the Vorth source code is hosted in a PETTIL system and metacompiled to object code that will run in its entirety on an unexpanded VIC-20.  Such things as virtual memory on cassette tape can even be included in Vorth programs.

VIC20:                          PET:
6560sys4109                     6502sys1037

chitselb@gmail.com

#endif

;===============================
;===============================
;===============================

#ifdef PET
    BRKVEC      = $0092
    VIDRAM      = $8000
    BASIC       = $0401
#endif
#ifdef VIC20
    BRKVEC      = $0316
    BASIC       = $1001
    VIC         = $9000
    VIDRAM      = $1E00
    COLORAM     = $9600
#endif

    STACK       = $60

    *           = BASIC-2
    .word       BASIC
;-------------------------------
#if 0

BASIC

#endif
basic
    .word basend
    .word 6502
    .byt $9E    ; SYS
#ifdef PET
    .byt '1037'
#endif
#ifdef VIC20
    .byt '4109'
#endif
    .byt 0
    .word 0
;===============================
basend
#ifdef VIC20
    lda #$FF
    sta VIC+15
#endif ; VIC20
    lda #<(enter)
    sta BRKVEC
    lda #>(enter)
    sta BRKVEC+1

;-------------------------------
#if 0

RESTART

#endif
restart
    jmp (userstartup)

;-------------------------------
#if 0

EXIT

              ;0107,x
              ;0106,x RTI hi    iphi ; <-- set IPHI to this page
              ;0105,x RTI lo    ; <-- points to where BRK instruction is +2
              ;0104,x P
              ;0103,x A
              ;0102,x X         ; data stack pointer
              ;0101,x Y         ; IPLO
              ;0100,x           ; <-- next stack entry goes here
                                ; X = stack pointer
                                ; A = #$10
                                ; Y = IPLO
#endif
exit
    pla
    tay ;iplo
    pla
    pla
    pla
    pla
    pla ;iphi
gotoay
    sta iphi
    bne nextx                   ; bra

;-------------------------------
#if 0

SP!

#endif
spstore
    ldx #0
    ;fall through
;-------------------------------
#if 0

NEXT

#endif
nextx
    stx STACK
next
    iny
iphi = *+2                      ; low byte of `ip` expected to stay '00'
nexto
    ldx $1700,y                 ; outermost word should *never* execute sham token
    lda cfahi,x
    pha
    lda cfalo,x
    pha
    ldx STACK
    rts

;-------------------------------
#if 0

BUMPIP

also sets a zero page copy of IP

#endif
bumpip
    clc
    tya
    iny
    bne bumpip01
    inc iphi
bumpip01
    sta iphi
    sta $05
    rts

;-------------------------------
#if 0

ENTER

              ;    brk
              ;($FFFE) ; --> $E61B
              ;    pha
              ;    txa
              ;    pha
              ;    tya
              ;    pha
              ;    tsx
              ;    lda $0104,x
              ;    and #$10
              ;    beq +
              ;    jmp ($0092)  ; --> enter
              ;+
              ;    jmp ($0090)

              ;0107,x
              ;0106,x RTI hi    iphi ; <-- set IPHI to this page
              ;0105,x RTI lo    ; <-- points to where BRK instruction is +2
              ;0104,x P
              ;0103,x A
              ;0102,x X         ; data stack pointer
              ;0101,x Y         ; IPLO
              ;0100,x           ; <-- next stack entry goes here
                                ; X = stack pointer
                                ; A = #$10
                                ; Y = IPLO
#endif
enter
    ldy $0106,x
    lda iphi
    sta $0106,x
    sty iphi
    ldy $0105,x
    dey
    jmp nexto
                                ; 00
;-------------------------------
#if 0

BRANCH

$04-05 is used as temporary IP storage because $04 is initialized to 00 by ROM

#endif
branch
    jsr bumpip
    adc ($04),y
                                ; what does V flag tell us?
                                ; what do other flags indicate?
                                ; page boundary crossings?
    tay
branch01
    jmp nexto

;-------------------------------
#if 0

?BRANCH

#endif
qbranch
    jmp next

;-------------------------------
#if 0

(.")

#endif
pdq
    sty $84
    lda iphi
    sta $85
    ldy #0
    lda ($84),y
    pha
    tax
pdq01
    iny
    lda ($84),y
    jsr $ffd2
    dex
    bne pdq01
    pla
    clc
    adc $84
    tay
    lda iphi
    adc #0
    sta iphi
    jmp next

;-------------------------------
#if 0

.CR

#endif
dotcr
    lda #$0D
    .byt $2C
    ;fall through
;-------------------------------
#if 0

SIMPLEST

#endif
simplest
    lda #$2A
    jsr $FFD2
    jmp next


;-------------------------------
#if 0

SIMPLY

#endif
_simply
    brk
    .byt <(tksimplest-cfalo)
    .byt <(tksimplest-cfalo)
;   .byt <(tkexit-cfalo)

;-------------------------------
#if 0

SAMPLE

#endif
_sample
    brk
    .byt <(tksimplest-cfalo)
    ; branching, works like 6502 branching
    .byt <(tkbranch-cfalo)
    .byt $FE ; should be an infinite loop
    .byt <(tksimplest-cfalo)
    .byt <(tksimply-cfalo)
    .byt <(tksimply-cfalo)
    ; branching, works like 6502 branching
    .byt <(tkbranch-cfalo)
    .byt $FE ; should be an infinite loop
    ; b8 50 fe
    ;   clv
    ;chill
    ;   bvc chill
    ;unless the S.O. pin wakes us from slumber
;   .byt <(tkexit-cfalo)

;-------------------------------
#if 0

FLY

#endif
_fly
    brk
    .byt tkpdq-cfalo
    .byt fly01-*-1              ; len
    .byt 'abcdef'
fly01
    .byt tkexit-cfalo

;-------------------------------
#if 0

STARTUP

#endif
userstartup
    .word _sample

;-------------------------------
#if 0

CFA table

#endif
cfalo
tkexit
    .byt <(exit-1)              ; 00
tkbranch
    .byt <(branch-1)
tkqbranch
    .byt <(qbranch-1)
tkpdq
    .byt <(pdq-1)
tkdotcr
    .byt >(dotcr-1)
tksimplest
    .byt <(simplest-1)
tksimply
    .byt <(_simply-1)
tksample
    .byt <(_sample-1)
tkfly
    .byt <(_fly-1)

cfahi
    .byt >(exit-1)
    .byt >(branch-1)
    .byt >(qbranch-1)
    .byt >(pdq-1)
    .byt >(dotcr-1)
    .byt >(simplest-1)
    .byt >(_simply-1)
    .byt >(_sample-1)
    .byt >(_fly-1)

