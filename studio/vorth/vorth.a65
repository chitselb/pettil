;default to PET
#ifndef VIC20
#define PET
#endif

#if 0

What is Vorth?

Vorth is a minimalist Forth for VIC-20.  By minimalist, I mean it doesn't even have an interpreter or compiler aboard, but such things can be built if needed.  Instead, the Vorth source code is hosted in a PETTIL system and metacompiled to object code that will run in its entirety on an unexpanded VIC-20.  Such things as virtual memory on cassette tape can even be included in Vorth programs.

VIC20:                          PET:
6560sys4109                     6502sys1037

chitselb@gmail.com

#endif

;===============================
;===============================
;===============================

#ifdef PET
    BRKVEC      = $0092
    VIDRAM      = $8000
    BASIC       = $0401
#endif
#ifdef VIC20
    BRKVEC      = $0316
    BASIC       = $1001
    VIC         = $9000
    VIDRAM      = $1E00
    COLORAM     = $9600
#endif

    STACK       = $60

    *           = BASIC-2
    .word       BASIC
;-------------------------------
#if 0

BASIC

#endif
basic
    .word basend
    .word 6502
    .byt $9E    ; SYS
#ifdef PET
    .byt '1037'
#endif
#ifdef VIC20
    .byt '4109'
#endif
    .byt 0
    .word 0
;===============================
basend
#ifdef VIC20
    lda #$FF
    sta VIC+15
#endif ; VIC20
    lda #<(enter)
    sta BRKVEC
    lda #>(enter)
    sta BRKVEC+1

;-------------------------------
#if 0

RESTART

#endif
restart
    jmp (userstartup)

;-------------------------------
#if 0

EXIT

              ;0107,x
              ;0106,x RTI hi    iphi ; <-- set IPHI to this page
              ;0105,x RTI lo    ; <-- points to where BRK instruction is +2
              ;0104,x P
              ;0103,x A
              ;0102,x X         ; data stack pointer
              ;0101,x Y         ; IPLO
              ;0100,x           ; <-- next stack entry goes here
                                ; X = stack pointer
                                ; A = #$10
                                ; Y = IPLO
#endif
exit
    pla
    tay ;iplo
    pla
    pla
    pla
    pla
    pla ;iphi
gotoay
    sta iphi
    bne nextx                   ; bra

;-------------------------------
#if 0

SP!

#endif
spstore
    ldx #0
    ;fall through
;-------------------------------
#if 0

NEXT

#endif
nextx
    stx STACK
next
    iny
iphi = *+2                      ; low byte of `ip` expected to stay '00'
nexto
    ldx $1700,y                 ; outermost word should *never* execute sham token
    lda cfahi,x
    pha
    lda cfalo,x
    pha
    ldx STACK
    rts

;-------------------------------
#if 0

BUMPIP

also sets a zero page copy of IP

#endif
bumpip
    clc
    iny
    bne bumpip01
    inc iphi
bumpip01
    lda iphi
    sta $05
    rts

;-------------------------------
#if 0

ENTER

              ;    brk
              ;($FFFE) ; --> $E61B
              ;    pha
              ;    txa
              ;    pha
              ;    tya
              ;    pha
              ;    tsx
              ;    lda $0104,x
              ;    and #$10
              ;    beq +
              ;    jmp ($0092)  ; --> enter
              ;+
              ;    jmp ($0090)

              ;0107,x
              ;0106,x RTI hi    iphi ; <-- set IPHI to this page
              ;0105,x RTI lo    ; <-- points to where BRK instruction is +2
              ;0104,x P
              ;0103,x A
              ;0102,x X         ; data stack pointer
              ;0101,x Y         ; IPLO
              ;0100,x           ; <-- next stack entry goes here
                                ; X = stack pointer
                                ; A = #$10
                                ; Y = IPLO
#endif
enter
    ldy $0106,x
    lda iphi
    sta $0106,x
    sty iphi
    ldy $0105,x
    dey
    jmp nexto
                                ; 00
;-------------------------------
#if 0

BRANCH

$04-05 is used as temporary IP storage because $04 is initialized to 00 by ROM

#endif
branch
    jsr bumpip
    tya
    adc ($04),y
                                ; what does V flag tell us?
                                ; what do other flags indicate?
                                ; page boundary crossings?
    tay
 branch01
    jmp next

;-------------------------------
#if 0

?BRANCH

#endif
qbranch
    jmp next

;-------------------------------
#if 0

(.")

#endif
pdq
    sty $84
    lda iphi
    sta $85
    ldy #0
    lda ($84),y
    pha
    tax
pdq01
    iny
    lda ($84),y
    jsr $ffd2
    dex
    bne pdq01
    pla
    clc
    adc $84
    tay
    lda iphi
    adc #0
    sta iphi
    jmp next

;-------------------------------
#if 0

.CR

#endif
dotcr
    lda #$0D
    .byt $2C
    ;fall through
;-------------------------------
#if 0

SIMPLEST

#endif
simplest
    lda #$2A
    .byt $2C
    ;fall through
;-------------------------------
#if 0

EMIT

#endif
emit
    lda STACK,x
    jsr $FFD2
    jmp next

;-------------------------------
#if 0

DROP

#endif
drop
    inc STACK
    jmp next

;-------------------------------
#if 0

THIRD

#endif
third
    ;ldx STACK
    lda STACK+2,x
    .byt $2C
    ;fall through
;-------------------------------
#if 0

OVER

#endif
over
    ;ldx STACK
    lda STACK+1,x
    .byt $2C
    ;fall through
;-------------------------------
#if 0

DUP

#endif
dup
    ;ldx STACK
    lda STACK,x
    ;
    sta STACK-1,x
    dec STACK
    jmp next

;-------------------------------
#if 0

SIMPLY

#endif
_simply
    brk
    .byt <(tksimplest-cfalo)
    .byt <(tksimplest-cfalo)
;   .byt <(tkexit-cfalo)

;-------------------------------
#if 0

SAMPLE

#endif
_sample
    brk
sample01
    .byt <(tksimply-cfalo)
    .byt <(tksimplest-cfalo)
    .byt <(tkrandu-cfalo)
    .byt <(tkemit-cfalo)
    .byt <(tkdrop-cfalo)
    ; branching, works like 6502 branching
    .byt <(tkbranch-cfalo)
    .byt <(*-sample01-1)        ; infinite loop
    ; B8 50 FE, unless the S.O. pin wakes us from slumber
;   .byt <(tkexit-cfalo)

;-------------------------------
#if 0

-
    ( n1 n2 -- n3 )

#endif
minus
    lda STACK+1,x
    eor #$FF
    sta STACK+1,x
    sec
    .byt $29
    ;fall through
;-------------------------------
#if 0

+
    ( n1 n2 -- n3 )

#endif
plus
    clc
    ;
    lda STACK,x
    adc STACK+1,x
plus01
    sta STACK+1,x
    inc STACK
    jmp next

;-------------------------------
#if 0

OR
    ( n1 n2 -- n3 )

#endif
or
    lda STACK,x
    ora STACK+1,x
    jmp plus01

;-------------------------------
#if 0

AND
    ( n1 n2 -- n3 )

#endif
andx
    lda STACK,x
    and STACK+1,x
    jmp plus01

;-------------------------------
#if 0

XOR
    ( n1 n2 -- n3 )

#endif
xor
    lda STACK,x
    eor STACK+1,x
    jmp plus01

;-------------------------------
#if 0

RANDU
    ( -- rnd )

#endif
randu
    sec
    lda random+1
    adc random+4
    adc random+5
    sta random
    ldx #4
ripl
    lda random,x
    sta random+1,x
    dex
    bpl ripl
    dec STACK
    ldx STACK
    sta STACK,x
    jmp next

random
    .dsb 6,$AB

;-------------------------------
#if 0

FLY

#endif
_fly
    brk
    .byt tkpdq-cfalo
    .byt fly01-*-1              ; len
    .byt 'abcdef'
fly01
    .byt tkexit-cfalo

;-------------------------------
#if 0

STARTUP

#endif
userstartup
    .word _sample

;-------------------------------
#if 0

CFA table

#endif
cfalo
tkexit
    .byt <(exit-1)              ; 00
tkbranch
    .byt <(branch-1)
tkqbranch
    .byt <(qbranch-1)
tkpdq
    .byt <(pdq-1)
tkdotcr
    .byt >(dotcr-1)
tksimplest
    .byt <(simplest-1)
tksimply
    .byt <(_simply-1)
tksample
    .byt <(_sample-1)
tkfly
    .byt <(_fly-1)
tkrandu
    .byt <(randu-1)
tkemit
    .byt <(emit-1)
tkover
    .byt <(over-1)
tkdup
    .byt <(dup-1)
tkdrop
    .byt <(drop-1)
tkminus
    .byt <(minus-1)
tkplus
    .byt <(plus-1)
tkor
    .byt <(or-1)
tkand
    .byt <(andx-1)
tkxor
    .byt <(xor-1)

cfahi
    .byt >(exit-1)
    .byt >(branch-1)
    .byt >(qbranch-1)
    .byt >(pdq-1)
    .byt >(dotcr-1)
    .byt >(simplest-1)
    .byt >(_simply-1)
    .byt >(_sample-1)
    .byt >(_fly-1)
    .byt >(randu-1)
    .byt >(emit-1)
    .byt >(over-1)
    .byt >(dup-1)
    .byt >(drop-1)
    .byt >(minus-1)
    .byt >(plus-1)
    .byt >(or-1)
    .byt >(andx-1)
    .byt >(xor-1)

