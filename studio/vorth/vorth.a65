#if 0

What is Vorth?

Vorth is a minimalist Forth for VIC-20.  By minimalist, I mean it doesn't even have an interpreter or compiler aboard, but such things can be built if needed.  Instead, the Vorth source code is hosted in a PETTIL system and metacompiled to object code that will run in its entirety on an unexpanded VIC-20.  Such things as virtual memory on cassette tape can even be included in Vorth programs.

The top line of Vorth source is a backslash (\) followed by blank-delimited names corresponding with
Vorth words.  Code is metacompiled recursively from a single outermost definition, which is hooked in `startup`  An example might be easier:

\ fly
: fly   ( -- )
    begin
        flap flap flit
        ?terminal
    until ;

: flap   ( -- )
    4 1 do
        i frame zz
    loop 0 frame ;

: flit   ( -- )
    " udlr" randu 3 and + c@ emit ;

variable delay        delay off
create animation      10 allot
variable frames       frames off

: zz   ( -- )
    delay @ jiffies ;

: frame   ( index -- )
    2* animation + @ goto ;

: +frame   ( addr -- )
    <builds ,
        frames 1+!
    does>
        @ $. ;

"    lll" +frame
" UWIlll" +frame
" @W@lll" +frame
" JWKlll" +frame
" @W@lll" +frame


(C:$1090) p 1000
    4096
(C:$1090) p 100d
    4109

VIC20:
6560sys4109

PET:
6502sys1037

(C:$e5e8) m 1000
>C:1000  00 0b 10 a0  19 9e 34 31  30 39 00 00  00 a9 ff 8d   ......4109......
>C:1010  0f 90 a9 30  8d 16 03 a9  11 8d 17 03  ad 30 10 ac   ...0.........0..
>C:1020  31 10 4c 40  10 00 00 00  00 00 00 00  00 00 00 00   1.L@............
>C:1030  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
>C:1040  85 80 00 00  00 00 00 00  00 00 00 00  00 00 00 00   ................
2018-12-23T22:16:21-05:00

2018-12-24T01:14:13-05:00
next moves --
sys $xx0D

#endif

;default to PET
#ifndef VIC20
#define PET
#endif

#ifdef PET
    BRKVEC      = $0092
    VIDRAM      = $8000
    BASIC       = $0401
#endif
#ifdef VIC20
    BRKVEC      = $0316
    BASIC       = $1001
    VIC         = $9000
    VIDRAM      = $1E00
    COLORAM     = $9600
#endif

    STACK       = $60

    *           = BASIC-2
    .word       BASIC
basic
    .word basend
    .word 6502
    .byt $9E    ; SYS
#ifdef PET
    .byt '1037'
#endif
#ifdef VIC20
    .byt '4109'
#endif
    .byt 0
    .word 0
basend
#ifdef VIC20
    lda #$FF
    sta VIC+15
#endif ; VIC20
    lda #<(enter)
    sta BRKVEC
    lda #>(enter)
    sta BRKVEC+1

;-------------------------------
#if 0

RESTART

#endif
restart
    jmp (userstartup)

;-------------------------------
#if 0

EXIT

              ;0107,x
              ;0106,x RTI hi    iphi ; <-- set IPHI to this page
              ;0105,x RTI lo    ; <-- points to where BRK instruction is +2
              ;0104,x P
              ;0103,x A
              ;0102,x X         ; data stack pointer
              ;0101,x Y         ; IPLO
              ;0100,x           ; <-- next stack entry goes here
                                ; X = stack pointer
                                ; A = #$10
                                ; Y = IPLO
#endif
exit
    pla
    tay ;iplo
    pla
    pla
    pla
    pla
    pla ;iphi
gotoay
    sta iphi
    bne nextx                   ; bra

;-------------------------------
#if 0

SP!

#endif
spstore
    ldx #0
    ;fall through
;-------------------------------
#if 0

NEXT

#endif
nextx
    stx STACK
next
    iny
iphi = *+2                      ; low byte of `ip` expected to stay '00'
nexto
    lda $1700,y                 ; outermost word should *never* execute sham token
    tax
    lda cfahi,x
    pha
    lda cfalo,x
    pha
    rts

simplest
    lda #$2E
    jsr $FFD2
    jmp next


;-------------------------------
#if 0

ENTER

              ;    brk
              ;($FFFE) ; --> $E61B
              ;    pha
              ;    txa
              ;    pha
              ;    tya
              ;    pha
              ;    tsx
              ;    lda $0104,x
              ;    and #$10
              ;    beq +
              ;    jmp ($0092)  ; --> enter
              ;+
              ;    jmp ($0090)

              ;0107,x
              ;0106,x RTI hi    iphi ; <-- set IPHI to this page
              ;0105,x RTI lo    ; <-- points to where BRK instruction is +2
              ;0104,x P
              ;0103,x A
              ;0102,x X         ; data stack pointer
              ;0101,x Y         ; IPLO
              ;0100,x           ; <-- next stack entry goes here
                                ; X = stack pointer
                                ; A = #$10
                                ; Y = IPLO
#endif
enter
    ldy $0106,x
    lda iphi
    sta $0106,x
    sty iphi
    ldy $0105,x
    dey
    jmp nexto
                                ; 00

;-------------------------------
#if 0

BRANCH

#endif
branch
    lda iphi
    sta 5
    clc
    tya
    adc (4),y
    tay
    bcc branch01
    dec iphi
branch01
    jmp next

;-------------------------------
#if 0

?BRANCH

#endif
qbranch
    jmp next

#if 0

Vorth
* interpret
** never executes code, only generates compiled output
** iterative searches through, stacks, and resolves names to source blocks.
** related words may be combined on a source block
** `-->` word to create multiblock source
** parse off a word
** is it in the symbol table already?
** Vorth symbol table structure (same as PETTIL)
*** cfa
*** len/flags 8-bit
*** name 8-bit string

* interpret

compilation statuses
* pending compilation
** has negative token id
** lowest number is compiled next
* compiling



CFA table, first low bytes then high bytes
~ use a skip list to calculate token -> high byte, #words on each page
token ids increment as each new entry is added to the dictionary
words are assigned a token id when they reach compile status
words are assigned a negative token id when they are in pending status
primitives created by `code` are compiled when encountered


#endif
userstartup
    .word _sample

;-------------------------------
#if 0

(.")

#endif
pdq
    sty $84
    lda iphi
    sta $85
    ldy #0
    lda ($84),y
    pha
    tax
pdq01
    iny
    lda ($84),y
    jsr $ffd2
    dex
    bne pdq01
    pla
    clc
    adc $84
    tay
    lda iphi
    adc #0
    sta iphi
    jmp next

.dsb 300,0

_simply
    brk
    .byt <(tksimplest-cfalo)
    .byt <(tksimplest-cfalo)
;   .byt <(tkexit-cfalo)

_sample
    brk
    .byt <(tksimplest-cfalo)
    .byt <(tksimplest-cfalo)
    .byt <(tksimply-cfalo)
    .byt <(tksimply-cfalo)
    ; branching, works like 6502 branching
    .byt <(tkbranch-cfalo)
    .byt $FE ; should be an infinite loop
    ; b8 50 fe
    ;   clv
    ;chill
    ;   bvc chill
    ;unless the S.O. pin wakes us from slumber

;   .byt <(tkexit-cfalo)

_fly
    brk
    .byt tkpdq-cfalo
    .byt fly01-*+1              ; len
    .byt 'abcdef'
fly01
    .byt tkexit-cfalo

.dsb 300,0

cfalo
tkexit
    .byt <(exit-1)
tkbranch
    .byt <(branch-1)
tkqbranch
    .byt <(qbranch-1)
tkpdq
    .byt <(pdq-1)
tksimplest
    .byt <(simplest-1)
tksimply
    .byt <(_simply-1)
tksample
    .byt <(_sample-1)
tkfly
    .byt <(_fly-1)

cfahi
    .byt >(exit-1)
    .byt >(branch-1)
    .byt >(qbranch-1)
    .byt >(pdq-1)
    .byt >(simplest-1)
    .byt >(_simply-1)
    .byt >(_sample-1)
    .byt >(_fly-1)

