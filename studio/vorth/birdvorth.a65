;default to VIC20
#ifndef PET
#define VIC20
#endif

#if 0

vorth \ activate meta-compiler!
code 3.

create delay 5 c,
code jiffies
    STACK ,x lda,
    TIME 2+  adc,
         begin,
    TIME 2+  cmp,
         0=
         until,
    drop     jmp,
end-code
create compass
petscii" [dn]" c,
petscii" [rt]" c,
petscii" [up]" c,
petscii" [lf]" c,
: flit   ( -- )
    randu 3 and compass + c@ emit ;
: fly   ( -- )
    begin
        flap flap flit
        ?terminal
    until ;
' fly startup !
save-vorth

What is Vorth?

Vorth is a minimalist Forth for VIC-20.  By minimalist, I mean it doesn't even have an interpreter or compiler aboard, but such things can be built if needed.  Instead, the Vorth source code is hosted in a PETTIL system and metacompiled to object code that will run in its entirety on an unexpanded VIC-20.  Such things as virtual memory on cassette tape can even be included in Vorth programs.

VIC20:                          PET:
6560sys4109                     6502sys1037

chitselb@gmail.com

#endif

;===============================
;===============================
;===============================

#ifdef PET
    TIME        = $008D
    BRKVEC      = $0092
    BASIC       = $0401
    VIDRAM      = $8000
#endif
#ifdef VIC20
    TIME        = $00A0
    BRKVEC      = $0316
    BASIC       = $1001
    VIDRAM      = $1E00
    VIC         = $9000
    COLORAM     = $9600
#endif

    STACK       = $60

    *           = BASIC-2
    .word       *+2             ; load address

;-------------------------------
#if 0

BASIC

#endif
basic
    .word basend
    .word 6502
    .byt $9E    ; SYS
#ifdef PET
    .byt '1037'
#endif
#ifdef VIC20
    .byt '4109'
#endif
    .byt 0
    .word 0
;===============================
basend
#ifdef VIC20
    lda #0
    sta $04
    lda #$FF
    sta VIC+15
#endif ; VIC20
    lda #<(enter)
    sta BRKVEC
    lda #>(enter)
    sta BRKVEC+1

;-------------------------------
#if 0

RESTART

#endif
restart
    jmp (userstartup)

;-------------------------------
#if 0

DELAY
    ( -- addr )

    pause for `delay` jiffies

#endif
delay
    jsr docreate
    .byt 5

;-------------------------------
#if 0

EXIT

              ;0107,x
              ;0106,x RTI hi    iphi ; <-- set IPHI to this page
              ;0105,x RTI lo    ; <-- points to where BRK instruction is +2
              ;0104,x P
              ;0103,x A
              ;0102,x X         ; data stack pointer
              ;0101,x Y         ; IPLO
              ;0100,x           ; <-- next stack entry goes here
                                ; X = stack pointer
                                ; A = #$10
                                ; Y = IPLO
#endif
exit
    pla
    tay                         ;iplo
    pla
    pla
    pla
    pla
    pla                         ;iphi
gotoay
    sta iphi
    bne nextx                   ; bra

;-------------------------------
#if 0

SP!

#endif
spstore
    ldx #0
    ;fall through
;-------------------------------
#if 0

NEXT

#endif
nextx
    stx STACK
next
    iny
iphi = *+2                      ; `iplo` is expected to stay '00'
nexto
    ldx $1700,y                 ; outermost word should *never* execute sham token
    lda cfahi,x
    pha
    lda cfalo,x
    pha
    ldx STACK
    rts

;-------------------------------
#if 0

BUMPIP

also sets a zero page copy of IP

#endif
bumpip
    iny
    bne bumpip01
    inc iphi
bumpip01
    lda iphi
    sta $05
    rts

;-------------------------------
#if 0

ENTER

              ;    brk
              ;($FFFE) ; --> $E61B
              ;    pha
              ;    txa
              ;    pha
              ;    tya
              ;    pha
              ;    tsx
              ;    lda $0104,x
              ;    and #$10
              ;    beq +
              ;    jmp ($0092)  ; --> enter
              ;+
              ;    jmp ($0090)

              ;0107,x
              ;0106,x RTI hi    iphi ; <-- set IPHI to this page
              ;0105,x RTI lo    ; <-- points to where BRK instruction is +2
              ;0104,x P
              ;0103,x A
              ;0102,x X         ; data stack pointer
              ;0101,x Y         ; IPLO
              ;0100,x           ; <-- next stack entry goes here
                                ; X = stack pointer
                                ; A = #$10
                                ; Y = IPLO
#endif
enter
    cli                         ; re-enable interrupts
    ldy $0106,x
    lda iphi
    sta $0106,x
    sty iphi
    ldy $0105,x
    dey
    jmp nexto
                                ; 00
;-------------------------------
#if 0

?BRANCH
    ( flag -- )

#endif
qbranch
    jsr bumpip
    inx
    lda STACK,x
    bne branch01
    jmp nextx

;-------------------------------
#if 0

BRANCH
    ( -- )

$04-05 is used as temporary IP storage because $04 is initialized to 00 by ROM

#endif
branch
    jsr bumpip
branch01
    tya
                                ; what does N flag tell us?
    clc
    adc ($04),y
                                ; what does V flag tell us?
                                ; what does N flag tell us?
                                ; what is Y.N ^ A.N?
                                ; what do other flags indicate?
                                ; page boundary crossings?
    tay
    jmp nextx

;-------------------------------
#if 0

C@
    ( addr -- char )

#endif
cfetch
    lda (STACK,x)
    sta STACK+1,x
    jmp drop

;-------------------------------
#if 0

EMIT
    ( c -- c )

#endif
emit
    lda STACK,x
    ;
    jsr $FFD2
    ;fall through
;-------------------------------
#if 0

DROP

#endif
drop
    inx
    jmp nextx

;-------------------------------
#if 0

3

#endif
three
    ;ldx STACK
    lda #3
    .byt $2C
    ;fall through
;-------------------------------
#if 0

BL

#endif
bl
    ;ldx STACK
    lda #$20
    .byt $2C
    ;fall through
;-------------------------------
#if 0

THIRD

#endif
third
    ;ldx STACK
    lda STACK+2,x
    .byt $2C
    ;fall through
;-------------------------------
#if 0

OVER

#endif
over
    ;ldx STACK
    lda STACK+1,x
    .byt $2C
    ;fall through
;-------------------------------
#if 0

DUP
    ( n -- n n )

#endif
dup
    ;ldx STACK
    lda STACK,x
    ;
    dex
    sta STACK,x
    jmp nextx

;-------------------------------
#if 0

SWAP
    ( a b -- b a )

#endif
swap
    lda STACK,x
    pha
    lda STACK+1,x
    sta STACK,x
    pla
    sta STACK+1,x
    jmp next

;-------------------------------
#if 0

ROT
    ( a b c -- b c a )

#endif
rot
    lda STACK,x
    pha
    lda STACK+1,x
    pha
    lda STACK+2,x
    sta STACK,x
    pla
    sta STACK+2,x
    pla
    sta STACK+1,x
    jmp next

;-------------------------------
#if 0

-
    ( n1 n2 -- n3 )

#endif
minus
    lda STACK+1,x
    eor #$FF
    sta STACK+1,x
    sec
    .byt $29
    ;fall through
;-------------------------------
#if 0

M+
    ( d1 u -- d2 )

Add 8-bit `u` to 16-bit `d1`
returning 16-bit sum `d2`
#endif
mplus
    clc
    ;
    lda STACK,x
    adc STACK+1,x
    bcc mplus01
    inc STACK+2,x
mplus01
    sta STACK+1,x
    inx
    jmp nextx

;-------------------------------
#if 0

OR
    ( n1 n2 -- n3 )

#endif
or
    lda STACK,x
    ora STACK+1,x
    jmp mplus01

;-------------------------------
#if 0

AND
    ( n1 n2 -- n3 )

#endif
andx
    lda STACK,x
    and STACK+1,x
    jmp mplus01

;-------------------------------
#if 0

XOR
    ( n1 n2 -- n3 )

#endif
xor
    lda STACK,x
    eor STACK+1,x
    jmp mplus01

;-------------------------------
#if 0

1+
    ( n1 -- n1+1 )

#endif
oneplus
    inc STACK,x
    bne oneplus01
    inc STACK+1,x
oneplus01
    jmp next

;-------------------------------
#if 0

(CREATE)
    ( -- addr )

    unload return stack
    push address following this token to stack
#endif
docreate
    dex
    dex
    pla
    sta STACK,x
    pla
    sta STACK+1,x
    stx STACK
    jmp oneplus

;-------------------------------
#if 0

RANDU
    ( -- rnd )

#endif
randu
    sec
    lda random+1
    adc random+4
    adc random+5
    sta random
    ldx #4
ripl
    lda random,x
    sta random+1,x
    dex
    bpl ripl
    ldx STACK
    dex
    sta STACK,x
    jmp nextx

random
    .dsb 6,$AB

;-------------------------------
#if 0

?TERMINAL
    ( -- flag )

#endif
qterminal
    jsr $FFE1                   ; STOP
    bne pushz
notz
    clc
    .byt $29
pushz
    sec
    ;
    lda #0
    sbc #0
    dex
    sta STACK,x
    jmp nextx

;-------------------------------
#if 0

3.
    ( -- )

    output the next 3 (inline) bytes

#endif
threedot
    ldx #3
threedot01
    jsr bumpip
    lda ($04),y
    jsr $FFD2
    dex
    bne threedot01
    jmp next

;-------------------------------
#if 0

JIFFIES
    ( n -- )

    pause for `n` jiffies
code jiffies
    STACK ,x lda,
    TIME  2+ adc,
         begin,
    TIME  2+ cmp,
         0=
         until,
    drop     jmp,
end-code

#endif
jiffies
    lda STACK,x
    clc
    adc TIME+2
jiffies01
    cmp TIME+2
    bne jiffies01
    jmp drop

;-------------------------------
#if 0

COMPASS
    ( -- addr )

    table of cursor directions

#endif
compass
    jsr docreate
    .byt $1D,$9D,$11,$91

;-------------------------------
#if 0

3<-
    ( -- )

    output 3 cursor left characters

#endif
_threelf
    brk
    .byt <(tkthreedot-cfalo)
    .byt $9D,$9D,$9D            ; [lf][lf][lf]
;    .byt 0

;-------------------------------
#if 0

ZZ
    ( -- )

    pause for `delay` jiffies

#endif
_zz
    brk
    .byt <(tkdelay-cfalo)
    .byt <(tkcfetch-cfalo)
    .byt <(tkjiffies-cfalo)
;    .byt 0

;-------------------------------
#if 0

FLAP
    ( -- )

: flap   ( -- )
    " JWK" 3. 3<- zz " @W@" 3. 3<- zz
    " UWI" 3. 3<- zz " @W@" 3. 3<- zz
    ."    " 3<- ;
#endif
_flap
    brk
    .byt <(tkthreedot-cfalo)
    .byt $D5,$D7,$C9
    .byt <(tkthreelf-cfalo)
    .byt <(tkzz-cfalo)
    .byt <(tkthreedot-cfalo)
    .byt $C0,$D7,$C0
    .byt <(tkthreelf-cfalo)
    .byt <(tkzz-cfalo)
    .byt <(tkthreedot-cfalo)
    .byt $CA,$D7,$CB
    .byt <(tkthreelf-cfalo)
    .byt <(tkzz-cfalo)
    .byt <(tkthreedot-cfalo)
    .byt $C0,$D7,$C0
    .byt <(tkthreelf-cfalo)
    .byt <(tkzz-cfalo)
    .byt <(tkthreedot-cfalo)
    .byt "   "
    .byt <(tkthreelf-cfalo)
;    .byt 0

;-------------------------------
#if 0

FLIT
    ( -- )

: flit   ( -- )
    randu 3 and compass + c@ emit ;

#endif
_flit
    brk
    .byt <(tkcompass-cfalo)
    .byt <(tkrandu-cfalo)
    .byt <(tkthree-cfalo)
    .byt <(tkand-cfalo)
    .byt <(tkmplus-cfalo)
    .byt <(tkcfetch-cfalo)
    .byt <(tkemit-cfalo)
;    .byt 0

;-------------------------------
#if 0

FLY
    ( -- )


: fly   ( -- )
    begin
        flap flap flit
        ?terminal
    until ;
' fly startup !
#endif
_fly
    brk
fly01
    .byt <(tkflap-cfalo)
    .byt <(tkflap-cfalo)
    .byt <(tkflit-cfalo)
    .byt <(tkqterminal-cfalo)
    .byt <(tkqbranch-cfalo)
    .byt <(fly01-*-1)
;    .byt 0                     ; exit unnecessary, infinite loop

;-------------------------------
#if 0

STARTUP

#endif
userstartup
    .word _fly

;-------------------------------
#if 0

CFA table

#endif
cfalo
tkexit
    .byt <(exit-1)
tkdelay
    .byt <(delay-1)
tkspstore
    .byt <(spstore-1)
tknext
    .byt <(next-1)
tkenter
    .byt <(enter-1)
tkqbranch
    .byt <(qbranch-1)
tkbranch
    .byt <(branch-1)
tkcfetch
    .byt <(cfetch-1)
tkemit
    .byt <(emit-1)
tkdrop
    .byt <(drop-1)
tkthree
    .byt <(three-1)
tkbl
    .byt <(bl-1)
tkthird
    .byt <(third-1)
tkover
    .byt <(over-1)
tkdup
    .byt <(dup-1)
tkswap
    .byt <(swap-1)
tkrot
    .byt <(rot-1)
tkminus
    .byt <(minus-1)
tkmplus
    .byt <(mplus-1)
tkor
    .byt <(or-1)
tkand
    .byt <(andx-1)
tkxor
    .byt <(xor-1)
tkrandu
    .byt <(randu-1)
tkqterminal
    .byt <(qterminal-1)
tknotz
    .byt <(notz-1)
tkpushz
    .byt <(pushz-1)
tkthreedot
    .byt <(threedot-1)
tkjiffies
    .byt <(jiffies-1)
tkthreelf
    .byt <(_threelf-1)
tkzz
    .byt <(_zz-1)
tkflap
    .byt <(_flap-1)
tkcompass
    .byt <(compass-1)
tkflit
    .byt <(_flit-1)
tkfly
    .byt <(_fly-1)
tkuserstartup
    .byt <(userstartup-1)



;-------------------------------
#if 0

CFA table

#endif
cfahi
    .byt >(exit-1)
    .byt >(delay-1)
    .byt >(spstore-1)
    .byt >(next-1)
    .byt >(enter-1)
    .byt >(qbranch-1)
    .byt >(branch-1)
    .byt >(cfetch-1)
    .byt >(emit-1)
    .byt >(drop-1)
    .byt >(three-1)
    .byt >(bl-1)
    .byt >(third-1)
    .byt >(over-1)
    .byt >(dup-1)
    .byt >(swap-1)
    .byt >(rot-1)
    .byt >(minus-1)
    .byt >(mplus-1)
    .byt >(or-1)
    .byt >(andx-1)
    .byt >(xor-1)
    .byt >(randu-1)
    .byt >(qterminal-1)
    .byt >(notz-1)
    .byt >(pushz-1)
    .byt >(threedot-1)
    .byt >(jiffies-1)
    .byt >(_threelf-1)
    .byt >(_zz-1)
    .byt >(_flap-1)
    .byt >(compass-1)
    .byt >(_flit-1)
    .byt >(_fly-1)
    .byt >(userstartup-1)
