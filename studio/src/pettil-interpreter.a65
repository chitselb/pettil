; pettil-interpreter.a65
#echo .       pettil-interpreter.a65    Outer Interpreter

;--------------------------------------------------------------
#if 0
name=~ Error messages
tags=general,nosymbol
PETTIL system messages, output by [[FAIL]]
#endif
errptr
    .word msg00,msg01,msg02,msg03,msg04,msg05,msg06,msg07
    .word msg08,msg09,msg10,msg11,msg12,msg13
msg00
    .byt msg01-*-1
    .asc CR,"WELCOME TO PETTIL"
#ifdef ROM_PET_4
    .asc " (4.0 ROM)"
#endif
#ifdef ROM_PET_UPGRADE
    .asc " (UPGRADE ROM)"
#endif
#ifdef ROM_PET_ORIGINAL
    .asc " (ORIGINAL ROM)"      -- good luck on this
#endif
#ifdef ROM_VIC20
    .asc " FOR VIC-20!"
#endif
#ifdef ROM_C64
    .asc " C=64!"
#endif
msg01
    .byt msg02-*-1
    .asc "STACK UNDERFLOW"
msg02
    .byt msg03-*-1
    .asc "STACK OVERFLOW"
msg03
    .byt msg04-*-1
    .asc "NOT FOUND"
msg04
    .byt msg05-*-1
    .asc "MISSING NAME"
msg05
    .byt msg06-*-1
    .asc "COMPILATION ONLY"
msg06
    .byt msg07-*-1
    .asc "UNPAIRED CONDITIONALS"
msg07
    .byt msg08-*-1
    .asc "CAN'T FORGET BELOW FENCE"
msg08
    .byt msg09-*-1
    .asc "BLOCK OUT OF RANGE"
msg09
    .byt msg10-*-1
    .asc "UNCLOSED QUOTES"
msg10
    .byt msg11-*-1
    .byt "CORRUPT VIRTUAL MEMORY"
msg11
    .byt msg12-*-1
    .byt "BAD ADDRESSING MODE"
msg12
    .byt msg13-*-1
    .byt "BAD VM PACKET"
msg13
    .byt msg14-*-1
    .byt RVSON,"STO","P"
msg14

;--------------------------------------------------------------
#if 0
name=ERROR.MSG
stack=( -- addr flag )
tags=interpreter,ext,nosymbol
Instead of RESTART performing an ABORT at the end to start the
QUIT-INTERPRET loop, it does a FENCE @ (FORGET) and sends us here.

If WARNING is non-zero, FAIL executes it, which also points here.
When WARNING is 0, FAIL will perform

WARNING @  ?: WARNING STARTUP  @ EXECUTE

* Prints an error message
* performs ABORT
```
```
#endif
#include "align.i65"
_errormsg
    jsr enter
#include "page.i65"
    .word twostar
#include "pass.i65"
    .word plit
    .word errptr
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _space
#include "page.i65"
    .word _stringdot
#include "page.i65"
    .word cr
#include "pass.i65"
    .word _abort

;--------------------------------------------------------------
#if 0
name=?CHAR
stack=( char -- addr )
tags=compiler,nosymbol
Scans ahead in the input stream until `char` is found.  Moves >IN beyond
that character.
#endif
#include "align.i65"
_qchar
    jsr enter
#include "page.i65"
    .word _name
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplusstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-->
stack=( -- )
tags=interpreter
flags=immediate
An immediate word which loads the next screen of Forth source

!!! pronounced: "next-block"

```
: -->   ( -- )
    blk 1+!  >in off  source! ; immediate
```
: -->
    ?loading 0 in !
    b/scr blk @ over mod -
    blk +! ;
L18be .byt 3 | bit7 | bit6
 .byt "--",">"|bit7
 .word L1885
DASHDASHGT
 .word DOCOL
 .word QLOADING
 .word ZERO
 .word IN
 .word STORE
 .word BSCR
 .word BLK
 .word FETCH
 .word OVER
 .word MOD
 .word NEGATE
 .word BLK
 .word PSTORE
 .word SEMIS
#endif
#include "align.i65"
_nextblock
    jsr enter
#include "page.i65"
    .word blk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word backslash
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=\
stack=( "text$ -- )
tags=extra,todo
flags=immediate,locals
set SPAN to 0
set N8 to 0

An immediate word that ignores all text following `\` on the current line

Begins a Forth comment, terminated by the end of the current logical line

When the entered line contains `\`, [[INTERPRET]] will not echo ` ok`

[[\]] also signals empty line buffer to outer interpreter

```
: \   ( -- )
   span off ; immediate
```
#endif
backslash
    lda #0
    sta userspan                ; ~wut? does not bother with high byte of SPAN
    jmp next

;--------------------------------------------------------------
#if 0
name=INTERPRET
stack=( -- )
tags=fig,forth-83,interpreter,nosymbol
The Forth interpreter loop

Interpret only exits (without flags) when the one-line input buffer is empty


consistent eager-loaded approach
[[TIB]] source comes already loaded from [[QUIT]]
[[BLK]] source comes already loaded from [[BLOCK]]
[[SCR]] source will eager-load each line from the block buffer, already loaded
by [[BLOCK]]

```
create jumptable  next ,   dlit ,  drop ,  droplit ,
                \ double  double,  single    single,
: interpret   ( -- )
    begin
        ?stack                  \ make sure things are okay
        blk 'n2 6 cmove
        \ refill? leaves false when we're loading a screen
        \ refill? leaves true right after it does : QUERY  TIB 80 EXPECT ;
        <.N8 ( flag ) ?: exit query  ?exit  \ get out if we refilled TIB buffer
                                \ get something in the line buffer
                                \ N8 contains SPAN after REFILL?
        bl name   ( addr )
        dup c@    ( addr len )  \ WORD returns both zeroes zero when EOT
    while
        found ?dup
        if        ( cfa findflag )
            \               find -1    find +1
            \             ____________________
            \ state -1   | compile     execute
            \ state 0    | execute     execute
            compiling? <>  ?: execute ,xt
        else      ( here )
            number
            jumptable  dpl @ 0< 2*  compiling? + 2* -
            @ execute
        then
    repeat
    drop ;

: interpret
    begin
        ?stack  ?refill
        bl name  ?dup           ( nfa true | 0(eob) false )
    while
        found ?dup              ( nfa -1|0|1 [ -1|1 ])
        if  compiling? <>  ?:  execute ,xt
        else
            number
            jumptable
            dpl @ 0< 2*
            compiling? + 2* -
            @ execute
        then
    repeat  [compile] \ ;       \ span off

: interpret   ( -- )
    begin
        ?stack
        bl name  ?dup           ( nfa true | 0(eob) false )
    while
        found ?dup              ( cfa -1|0|1 [ -1|1 ])
        if  compiling?  <>      \ compiling & normal            ,xt
                                \ interpret & normal            execute
                                \ compiling & immediate         execute
                                \ interpret & immediate         execute
            ?: execute ,xt      ( -- )
        else
            number
        then
    repeat  [compile] \ ;       \ span off
```
#endif
#include "align.i65"
_interpret
    jsr enter
#include "page.i65"
interpret01
    .word qstack
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name                 ;( nfa | 0 )
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word qbranch
    .byt <(interpret04-*+1)
#include "page.i65"             ;( nfa 0 ; not found )
    .word _foundq               ;( cfa -1 ; found, normal )
#include "page.i65"             ;( cfa 1 ; found, immediate )
    .word qdup
#include "pass.i65"
    .word qbranch
    .byt <(interpret02-*+1)
#include "page.i65"
    .word compilingq
#include "page.i65"
    .word ne
#include "pass.i65"
    .word pquerycolon
    .word execute
    .word _xtcomma
#include "pass.i65"
    .word branch
    .byt <(interpret03-*+1)
#include "page.i65"
interpret02
    .word _number
#include "page.i65"
interpret03
    .word eosq
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word orx
#include "page.i65"
    .word _qexit
#include "pass.i65"
    .word branch
    .byt <(interpret01-*+1)
#include "pass.i65"
interpret04
    .word exit

eosq
    lda userin+1
    cmp #LPERSCR
    bcc eosq01
    jsr plugh
eosq01
    jmp xpushc                  ; `true` means end of screen reached
;xpushc
;    jsr slip
;    jmp putc

;--------------------------------------------------------------
#if 0
name=QUIT
stack=( -- )
tags=forth-83,interpreter
This is the infinite outer interpreter loop:
      - resets the return stack (RP!)
      - outputs a carriage return (CR)
      - waits for a line of input (QUERY)
      - interprets that line

```
: quit
    rp! blk 12 erase            \ erases line editing uservars
    begin                       \ `interpret` will get new line from keyboard
        interpret
        compiling? 0=
        if  ." OK" then
    again ;
```
#endif
#include "align.i65"
_quit
    jsr enter
#include "page.i65"
    .word rpstore               ; reset return stack pointer
#include "page.i65"
    .word blk
#include "pass.i65"
    .word clit
    .byt 12                     ; `blk` `in` `span` `#out` `#line` `editing`
#include "page.i65"
    .word erase
#include "page.i65"
quit01                          ; BEGIN
    .word _interpret            ; outer interpreter main loop
#include "page.i65"
    .word compilingq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch               ; IF
    .byt <(quit01-*+1)
#include "pass.i65"
    .word _pdq                  ; both blk and state must be 0 to see this
    .byt (quit02-*-1)
    .asc    " OK"
quit02
#include "page.i65"
    .word cr                    ; this way for proper `#line` and `#out`
#include "pass.i65"             ; THEN AGAIN
    .word branch
    .byt <(quit01-*+1)
;#include "pass.i65"            ; you can check out any time you like
;    .word exit                 ; but you can never leave

;--------------------------------------------------------------
#if 0
name=ABORT
stack=( -- )
tags=fig,forth-79,forth-83,interpreter,startup
* Clears data stack
* Resets vocabulary to [[CORE]]
* performs a [[QUIT]]

Pretty standard fare, this is where things begin in the outer interpreter.
Errors display as either a numbered error (CORE) or a message (TDICT)

```
    ldx usersp0
    dex

```
#endif
#include "align.i65"
_abort
    jsr enter
#include "page.i65"
    .word spstore               ; reset data stack
#include "page.i65"
    .word _forth                ; resset `vocabs` to core-only
#include "page.i65"
    .word definitions           ; set `core` as `current`
#include "pass.i65"
    .word _quit

;--------------------------------------------------------------
#if 0
name=LOAD
stack=( u -- )
tags=interpreter,forth-83
Redirect the input stream to screen `u` of Forth source and `interpret` it.

* 1 is the lowest block which may be loaded, as 0 is the keyboard
* `load` will not create empty blocks
* `u` must be presently available in `vmbuf`
* error conditions (`BLOCK OUT OF RANGE`)
** `u` < 1
** `u` >= `#blk`



 The contents of >IN and BLK , which locate the current input
 stream, are saved.  The input stream is then redirected to
 the beginning of screen u by setting >IN to zero and BLK to
 u.  The screen is then interpreted.  If interpretation from
 screen u is not terminated explicitly it will be terminated
 when the input stream is exhausted and then the contents of
 >IN and BLK will be restored.  An error condition exists if
 u is zero.  See  [[>IN]] [[BLK]] [[BLOCK]]



```
: load   ( scr -- )
    ?dup
    if
    dup #blk @ > ?exit
        blk 2@ ( >in @ ) 2>r
        blk !  source! interpret
        2r> ( >in ! ) blk 2!  source!
    then ;

: load   ( blk -- )
    0 #blk @ third between? 0= 8 ?error
    0 over < #blk @ third > or
  \ checks requested block within range 0 .. #blk or error message
  \ pushes >in and blk to return stack
  \ resets >in
  \ interpret
  \ restores blk and >in from return stack
  0 2dup  #blk @  between? 0=
  8 ?error
  blk 2@ ( >in @ )  2>r
  blk 2! ( >in off )
  interpret
  2r>  blk 2! ( >in ! ) ;
```
#endif
#include "align.i65"
_load
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word tuck
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word betweenq
#include "page.i65"
    .word zeq
#include "pass.i65"
    .word qerror
    .byt 8
#include "page.i65"
    .word blk
#include "page.i65"
    .word tuck
#include "page.i65"
    .word threefetchtor         ; stash `blk` `in` `span` on return stack
#include "page.i65"
    .word _storeplus            ; `scr` to `blk`
#include "page.i65"
    .word twooff                ; `in` and `span` both off
#include "page.i65"
    .word _interpret            ; interpret has two clients, `load` and `quit`
#include "page.i65"
    .word blk
#include "page.i65"
    .word threerfromstore       ; restore prior `blk` `in` `span`
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EXISTS?
stack=( -- addr flag )
tags=interpreter,ext,nosymbol
parses the next token in the input stream.  Returns either the
address of the (unfound) token at HERE and a 0, or the code
field address of the word and -1 for normal, +1 for immediate
words

```
: exists?
   bl word dup c@ ?: find 0 ;
```
#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name            ; ~~2
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "pass.i65"
    .word pquerycolon
    .word _foundq
    .word zero
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name='
stack=( -- cfa )
tags=forth-83
Parse the next token in the input stream and search for it,
returning the CFA if successful.  Otherwise aborts with the
message "NOT FOUND"

```
: '   ( "name" -- cfa )
    exists? 0=  3 ?error ;
```
#endif
#include "align.i65"
_tick
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word zeq
#include "pass.i65"
    .word qerror
    .byt 3                      ; NOT FOUND
#include "pass.i65"
    .word exit

#print (*-errptr)
