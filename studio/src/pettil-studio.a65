; pettil-studio.a65
#echo .       pettil-studio.a65
#echo .       PETTIL Developer Studio (intepreter, compiler, editor, assembler)

#include "options.def"
#include "sweet16.def"
#include "cbm.def"
#include "../../tmp/pettil-core.def"

hitop=$HITOP
#print hitop

#ifdef ROM_OPTIONS
#echo ROM_OPTIONS
#echo (ROM_OPTIONS & ROM_PET_CHITSELB)
#echo ROM_PET_CHITSELB & ROM_OPTIONS
;#print ROM_PET_CHITSELB
#echo ROM_PET_4
;#print ROM_PET_4
#echo ROM_PET_UPGRADE
;#print ROM_PET_UPGRADE
#echo ROM_VIC20
;#print ROM_VIC20
#echo ROM_PET_80
;#print ROM_PET_80
#echo ROM_C64
;#print ROM_C64
#endif

;hitop=VIDRAM-$1B00   ; BLKBUF 5200
;hitop=VIDRAM-$1D00   ; BLKBUF 5000
;hitop=VIDRAM-$2300   ; BLKBUF 4A00, coexist with SUPERMON 7A33
;hitop=VIDRAM-$2300              ; <--- ~#resizetdict here, also lower down

    .word hitop-2               ; load address
    .word tdictend-hitop        ; size of the transient dictionary in bytes
                                ; startup CFA (LIFTOFF) from `pettil-core` COLD
*=hitop
#echo Transient Dictionary
#print *

;--------------------------------------------------------------
#if 0
name=STUDIO
stack=( -- )
tags=system,startup,throwaway,nosymbol
One time startup code

* start `splash` entertainment
* cmove `symtab`
* `symdex`
* `deadbeef`
* `warm`

```
<0400> core
<1B68> fence
{ disappearing startup code }
<1F6F> there
hitop-2
tdict.size
{ disappearing tdict startup code }
{ deadbeef }
<56FE> vmbuf

<00> zeropage
<01> stack
<0200> buffers
<0400> core
<1A24> here
{ disappearing banner startup code }
{ deadbeef }
<56FE> vmbuf
<5700> blkbuf
<5B00> symtab
<6900> { disappearing startup code & deadbeef }
<6A00> tdict (studio code)
<7E84> tdp
<8000> VIDRAM

: studio
    ['] there+2 @+ + 32 - symtab !
    chilly cmove
    ." banner message"
    cold


: studio   ( -- )



```
#endif
#include "align.i65"
_studio
    jsr enter
;#include "pass.i65"
;    .word plits
;    .byt 3
;    .word user0tdict            ; cmove
;    .word usertdict
;    .word utdict-user0tdict
;#include "page.i65"
;    .word cmove                 ; reset `tdict` `tdp` `#voc`
#include "page.i65"
    .word _qletter              ; all caught up on big letters
#include "page.i65"
    .word xyzzy


#include "page.i65"
    .word bl
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word pl0
#include "page.i65"
    .word bl
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word pl1
#include "page.i65"
    .word bl
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word pl2
#include "page.i65"
    .word bl
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word pl3
#include "page.i65"
    .word bl
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word pl4
#include "page.i65"
    .word bl
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word pl5
#include "page.i65"
    .word bl
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word pl6
#include "page.i65"
    .word bl
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word pl7
#include "page.i65"
    .word bl
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word pl8
#include "page.i65"
    .word bl
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word pl9
#include "page.i65"
    .word bl
#include "page.i65"
    .word _jiffies
#include "page.i65"
    .word xyzzy
#include "pass.i65"
    .word dlit
    .word there+2
    .word EAL
#include "page.i65"
    .word fetchplus
#include "page.i65"
    .word plus
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word minus
#include "page.i65"
    .word cmovegt
#include "page.i65"
    .word bl
#include "page.i65"
    .word minus
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word symtab                ; points to unindexed symbol list
#include "page.i65"
    .word store
#include "pass.i65"
    .word plits
    .byt 7
    .word _warm                 ; !
    .word userstartup
    .word _mackinac
    .word userwarning
    .word user0tdict            ; cmove
    .word usertdict
    .word utdict-user0tdict
#include "page.i65"
    .word cmove                 ; reset `tdict` `tdp` `#voc`
#include "page.i65"
    .word store                 ; set `warning` to `mackinac`
#include "page.i65"
    .word store                 ; set `startup` to `warm`
#include "page.i65"
    .word _symdex
#include "page.i65"
    .word _emptybuffers
#include "pass.i65"
    .word restart               ; and bounce it (#3) (fake)`warm`

#ifdef IS_VIC20
#include "pass.i65"
    .word plits
    .byt 3
    .word splashirq
    .word VIDRAM+11*22
    .word 12*22
#else
#include "pass.i65"
    .word plits
    .byt 3
    .word splashirq
    .word VIDRAM+11*40
    .word 14*40
#endif
#include "page.i65"
    .word blank


#include "align.i65"
_qletter
    jsr enter
#include "pass.i65"
qletter01
    .word plit
    .word actionidx
;   .byt 0
;actionnow
;   .byt 0
#include "page.i65"
    .word fetch
#include "page.i65"
    .word csplit
#include "page.i65"
    .word eq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word _nextaction           ; ( -- false )
#include "pass.i65"
    .word plit
    .word actionnow
#include "page.i65"
    .word oneplusstore
#include "pass.i65"
    .word branch
    .byt <(qletter01-*+1)

;--------------------------------------------------------------
#if 0
name=NEXTACTION
stack=( -- )
tags=system,startup,nosymbol


```
: nextaction   ( -- )
    actioncfa dup>r @ @+ execute r> ! ;
```
#endif
#include "align.i65"
_nextaction
    jsr enter
#include "pass.i65"
    .word plit
    .word actioncfa
#include "page.i65"
    .word duptor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word fetchplus
#include "page.i65"
    .word execute
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SYMDEX
stack=( -- )
tags=system,startup,nosymbol
Build thread index for `symtab`

```
: symdex   ( -- )
    ;
```
#endif
#include "align.i65"
_symdex
    jsr enter
#include "page.i65"
    .word xyzzy
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MACKINAC
stack=( -- )
tags=system,startup,nosymbol
Part of cold start, connect lower `core` and upper `tdict` dictionaries

6976
5C20
d56

41CF
347A
d55

gross trick: the error path out of `warm` gets us here.  Once here,
fix the error handler (`warning`) and `warm` now kicks out to `abort`


: mackinac
    (automem)
    ( lowmem symtab symtab.size ) cmove


#endif
#include "align.i65"
_mackinac
    jsr enter
#include "page.i65"
    .word drop                  ; `warm` sent us an error #
#include "page.i65"
    .word here                  ; `here` now points to `there`
#include "page.i65"
    .word _pforget
#include "pass.i65"
    .word plits
    .byt 5
    .word userdp
    .word userfence             ; @ swap !
    .word _errormsg
    .word userwarning           ; !
    .word MAINIRQ               ; irq!
#include "page.i65"
;~~~    .word irqstore              ; restore default IRQ handler
#include "page.i65"
    .word store                 ; set `warning` to `error.msg`
#include "page.i65"
    .word fetch                 ; fix DP to reclaim startup code area
#include "page.i65"
    .word swap
#include "page.i65"
    .word store
#include "page.i65"
    .word pl11
#include "page.i65"
    .word _deadbeef
#include "page.i65"
    .word _emptybuffers         ; do this again here, because DEADBEEF
#include "pass.i65"
    .word restart               ; restart #4 -> `warm`

;--------------------------------------------------------------
#if 0
name=(FORGET).PASS
stack=( -- )
tags=system,startup,nosymbol

#endif
#include "align.i65"
_pfpass
    jsr enter
#include "pass.i65"
pfpass01
    .word zpfrom
    .byt ACC+2*N4
#include "pass.i65"
    .word pquerycolon
    .word _pforgetpass1
    .word _pforgetpass2
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEADBEEF
stack=( -- )
tags=startup,nosymbol
Fill available memory with the 32-bit value `$DEADBEEF` . Discarded after
running once at startup.  Used to assist in debugging.

#endif
#include "align.i65"
_deadbeef
    jsr enter
#include "pass.i65"
    .word _pdq
    .byt deadbeef00-*-1
    .asc HOME,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN
    .asc CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN
    .asc CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRDOWN,CRSRLEFT,CRSRLEFT,CRSRLEFT
    .asc CRSRLEFT,CRSRLEFT,RVSON,"DEAD",CRSRLEFT,CRSRLEFT,CRSRLEFT,CRSRLEFT
deadbeef00
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "pass.i65"
deadbeef01
    .word dlit
    .word $adde,$efbe           ; little-endian makes pretty 8-bit hex dumps
#include "page.i65"
    .word rot
#include "page.i65"
    .word four
#include "page.i65"
    .word minus
#include "page.i65"
    .word here
#include "page.i65"
    .word over
#include "page.i65"
    .word lt
#include "pass.i65"
    .word qbranch
    .byt <(deadbeef02-*+1)
#include "page.i65"
    .word dashrot
#include "page.i65"
    .word third
#include "page.i65"
    .word twostore
#include "pass.i65"
    .word branch
    .byt <(deadbeef01-*+1)
#include "page.i65"
deadbeef02
    .word drop
#include "page.i65"
    .word here
#include "page.i65"
    .word twostore
#include "pass.i65"
    .word _pdq
    .byt deadbeef03-*-1
    .asc    RVSOFF,"BEEF",CR,CR
deadbeef03
#include "pass.i65"
    .word exit

#print *
    .dsb hitop+$300-*,$EA       ; ~#resizetdict
#print *

;
;
;
;
;
;
;         .     .              .            .
;                        .             .                   .
;   .     .        .             .              .     .
;   .        .        .        .        .        .        .
;.     .     .     .     .     .     .     .     .     .     .
;   .   .   .   .   .   .   .   .   .   .   .   .   .   .   .
; .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .
;. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
;.. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..
;... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ..
;..............................................................
;-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
;--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--.--
;---.---.---.---.---.---.---.---.---.---.---.---.---.---.---.--
;--------------------------------------------------------------
;---=---=---=---=---=---=---=---=---=---=---=---=---=---=---=--
;=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
;==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==-==
;===-===-===-===-===-===-===-===-===-===-===-===-===-===-===-==
;==============================================================
;==============================================================
;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
;==============================================================
; code above this point is void memory after startup
#print *

#if 0
name=TDICTBASE
stack=( -- )
tags=nosymbol
Bottom edge of PETTIL Studio.  [[TDICT]] contains this address.
#endif
tdictbase

;--------------------------------------------------------------
user0tdict      .word tdictbase
user0tdp        .word tdictend
user0numvoc     .word 2         ; `editor` & `assembler`
user0vocabs     .byt 9
utdict

; ---- copy from initialization values
usertdict       = uendcore+0    ;1
usertdp         = uendcore+2    ;2
usernumvoc      = uendcore+4    ;3
uservocabs      = uendcore+6    ;                                       10-byte

; ---- WARM will set to 0
usercsp         = uendcore+16
usercurrent     = uendcore+18
userredefined   = uendcore+20
usernewest      = uendcore+22
userstate       = uendcore+24
userpwrap       = uendcore+26   ;                                        4-byte
userpaste       = uendcore+30
usersymnew      = uendcore+32   ;1
usersymtail     = uendcore+34   ;2
userbloom       = uendcore+36   ;3                                       64-bit
userpassbits    = uendcore+44   ;                                        32-bit
utend = uendcore+48

;--------------------------------------------------------------
#if 0
name=WARM
stack=( -- )
tags=startup

#endif
_warm
    jsr aloha
#include "align.i65"
    jsr enter
#include "pass.i65"
    .word plits
    .byt 5
    .word uservocabs+1          ; erase
    .word usersymnew-uservocabs-1
    .word user0tdict            ; cmove
    .word usertdict
    .word utdict-tdictbase
#include "page.i65"
    .word cmove                 ; reset `tdict` `tdp` `#voc`
#include "page.i65"
    .word erase                 ; reset
#include "page.i65"
    .word zero
#include "pass.i65"
    .word fail

;==============================================================
#include "pettil-name.a65"
#print *
#include "pettil-number.a65"
#print *
#include "pettil-user.a65"
#print *
#include "pettil-dictionary.a65"
#print *
#include "pettil-interpreter.a65"
#print *
#include "pettil-compiler.a65"
#print *
#include "pettil-utils.a65"
#print *
#include "pettil-editor.a65"
#print *
#include "pettil-assembler.a65"
#print *

.dsb ($FF00 & (* + $100))  - * , $BB

;--------------------------------------------------------------
#if 0
name=TDICTEND
stack=( -- )
tags=nosymbol,nosymbol
This label marks the upper boundary of the transient dictionary ([[TDP]])
#endif
tdictend
;==============================================================

#print (*-tdictbase)
