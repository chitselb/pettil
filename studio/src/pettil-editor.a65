; pettil-editor.a65
#echo .       pettil-editor.a65         PET screen editor for Forth

;--------------------------------------------------------------
#if 0
name=EDITOR
stack=( -- )
tags=assembler,vocabulary,extension
Include `editor` vocabulary in search `vocabs` (context)

#endif
editor
    jsr dovocab
    .byt 2                      ; vocabulary identifier

;--------------------------------------------------------------
#if 0
name=CLRSCR
stack=( -- )
tags=editor
Clear the screen

#endif
#include "align.i65"
_clrscr
    jsr enter
#include "pass.i65"
    .word clit
    .byt CLR
#include "page.i65"
    .word emit
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FLIPSCR
stack=( -- )
tags=editor

 invert the entire screen

#endif
flipscr
    ldy #0
flipscr01
    lda VIDRAM,y        ; [4]
    eor #$80            ; [2]
    sta VIDRAM,y        ; [5]
    lda VIDRAM+$100,y
    eor #$80
    sta VIDRAM+$100,y
    lda VIDRAM+$200,y
    eor #$80
    sta VIDRAM+$200,y
    lda VIDRAM+$300,y
    eor #$80
    sta VIDRAM+$300,y
    iny                 ; [2]
    bne flipscr01       ; [3]   ; 49 * 256 = 12544 clocks
    jmp next

;--------------------------------------------------------------
#if 0
name=LINESA
stack=( -- size addr )
tags=editor,primitive
 Returns the `addr` of the logical line for the current physical cursor
 address.

The value returned is the first/top/upper line if this logical line has
80 characters.

#endif
linesa
    stx z
    ldx TBLX
    inx
linesa01
    dex
    ldy LDTB1,x
    bpl linesa01
    stx ACC+2*N7                ; logical line
    lda #0
    pha
    lda #40
    cpx #LPERSCR-1
    bcs linesa02                ; bottom line is never 80-chars
    ldy LDTB1+1,x
    bmi linesa02
    asl
linesa02
    pha
    sta ACC+2*N7+1              ; 40|80
    lda LDTB1,x
    pha
    lda WRAPLO,x
    pha
    ldx z
    jmp tworfrom

;--------------------------------------------------------------
#if 0
name=EOSS
stack=( addr -- addr size )
tags=editor,primitive
 Returns the `size` in bytes from `addr` to the end of the screen

```
: eoss   ( addr -- addr size )
    eoscr over - ;
```
#endif
#include "align.i65"
_eoss
    jsr enter
#include "page.i65"
    .word eoscr
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WRAPPASTE
stack=( -- )
tags=editor,nosymbol
Combine three linewrap tables into one during a paste

|`wrap@`|above current line|
|`pwrap`|paste buffer|
|`wrap@`|current line to `eos`|

#endif
#include "align.i65"
_wrappaste
    jsr enter
#include "page.i65"
    .word wrapfetch
#include "page.i65"
    .word pwrap
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word paste
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _pad
#include "page.i65"
    .word minus
#include "page.i65"
    .word slashmod40
#include "page.i65"
    .word nip                   ; ( wrap@d pwrapd pastelines -- )
#include "page.i65"
    .word pwrappaste
#include "pass.i65"
    .word exit

pwrappaste
    jsr wrapzap12
    jsr harvests10              ; wrap -> N0 N1
    stx z

    ldx #ACC+2*N0               ; point to `wrap@`
    jsr wrapumax                ; left-align `wrap@` bits in `n0..n1`
    ldy #$00
    jsr pwrapbitsalt            ; lower entry point, doesn't test line `0`

    ldx #ACC+2*N2               ; let's look at `pwrap`
    jsr wrapumax                ; left-align `pwrap` bits in `n2..n3`
    ;clc
    tya
    adc ACC+2*N4                ; # of 40-char lines in paste buffer
    sta ACC+2*N7
    jsr pwrapbits
    ldx #ACC+2*N0               ; back to `wrap@`
    lda #LPERSCR
    sta ACC+2*N7
    jsr pwrapbits
    ldx z
    jmp drop

pwrapbits
    iny
    cpy ACC+2*N7
    bcs pwrapbits09
pwrapbitsalt
    jsr pwrapbit
    bcc pwrapbits               ; bra
pwrapbits09
    dey
    rts

pwrapbit
    lda LDTB1,y
    asl
    jsr wraprolls
    ror
    sta LDTB1,y
    rts

;--------------------------------------------------------------
#if 0
name=WRAPUMAX
stack=( -- )
tags=editor,subroutine,nosymbol
Iteratively double a 32-bit `wrapd` until it is left-aligned (as close to
`umax` as possible without going over)

!!!pronounced: "wrap umax"
#endif
wrapumax
    jsr wraprolls
    bpl wrapumax
    rts

;--------------------------------------------------------------
#if 0
name=WRAPDEL
stack=( logline 40|80 -- )
tags=editor,nosymbol
Rolls the screen linewrap table up one or two lines when deleting a logical
line in the `editor`

#endif
wrapdel
    stx z
    bit ACC+2*N7+1              ; 40 or 80?
    .byt $29                    ; AND # opcode
wrapdel01
    clv
    ldx ACC+2*N7
    asl LDTB1,x
wrapdel02
    cpx #LPERSCR-1
    bcs wrapdel03
    asl LDTB1+1,x
    ror LDTB1,x
    inx
    bne wrapdel02
wrapdel03
    sec
    ror LDTB1,x
    bvs wrapdel01
    ldx z
    jmp next
;[31]

;--------------------------------------------------------------
#if 0
name=WRAPCOPY?
stack=( -- f )
tags=editor,secondary,nosymbol
Attempts to append the current logical linewrap to `pwrap`.  Uses 40|80 flag in `n7`

Returns a flag,
`false` if the paste buffer is full,
`true` if 1 or 2 bits were appended.

|`pwrap`||
|`pwraph`|`1` means 25 lines are in the buffer|
|`n7l`||
|`n7h`||

```
: wrapcopy?
    pwrap 2@ (wrapcopy?) ;
```
#endif
#include "align.i65"
wrapcopyq
    brk
    .byt set | N0
    .word userpwrap+4
    .byt popd | N0
    .byt st | N3
    .byt popd | N0
    .byt st | N2
    .byt sub | ACC
    .byt push
    .byt rtn
pwrapcopyq
    stx z
    ldx #ACC+2*N2
    sec
    bit ACC+2*N7+1              ; copy 40|80 bit to `V` flag
    .byt $29                    ; AND # opcode
pwrapcopyq01
    clv
    ;
    lda ACC+2*N3+1
    bne pwrapcopyq02
    dec tos+1
    jsr wraprolls
    ;clc
    bvs pwrapcopyq01
pwrapcopyq02
    ldx z
    brk
    .byt ld | N2
    .byt std | N0
    .byt ld | N3
    .byt std | N0
    .byt nxt

;--------------------------------------------------------------
#if 0
name=+WRAPEOS
stack=( d1 d2 -- d3 )
tags=editor,nosymbol
Append the linewrap bits in `d2` to the linewrap bits in `d1` yielding `d3`

#endif
#include "align.i65"
pluswrapeos
    jsr plugh
    jsr harvests6
    stx z
    lda ACC+2*N0+1
    bne pweos02
    clc
    ldx #<(-4)
pweos01
    rol tos+4,x
    rol tos+1
    rol ACC+2*N0
    rol ACC+2*N0+1
    bcc pweos01
pweos02
    ldx z
    jmp next

;--------------------------------------------------------------
#if 0
name=EDITCOPIER
stack=( 40|80 addr -- )
tags=editor,nosymbol
Append the text of the current logical line to the `paste` buffer.  Wrap bits
are handled separately, see `wrapcopy?`

```
: editcopier   ( 40|80 addr -- )
    paste @  third cmove paste +! ;
```
#endif
#include "align.i65"
_editcopier
    jsr enter
#include "page.i65"
    .word paste
#include "page.i65"
    .word fetch
#include "page.i65"
    .word third
#include "page.i65"
    .word cmove
#include "page.i65"
    .word paste
#include "page.i65"
    .word plusstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITCOPY
stack=( -- )
tags=editor,nosymbol
STOP-C Copy Line

Appends a copy of the current logical screen line to the paste buffer

```
: editcopy
:editcopy
    ...
```
#endif
#include "align.i65"
_editcopy
    jsr enter
    ;fall through
;--------------------------------------------------------------
#if 0
name=:EDITCOPY
stack=( -- )
tags=editor,nosymbol
STOP-C Copy Line

Appends a copy of the current logical screen line to the paste buffer

```
:editcopy   ( -- )
    logline lineinfo >r paste @  r@ cmove
    paste r@ +!
    pwrap 2@ r> 40/mod nip wrap+ pwrap 2! ;

:editcopy
    linea paste @ lines  paste under +!  cmove ;
```
#endif
#include "page.i65"
__editcopy
    .word linesa
#include "page.i65"
    .word wrapcopyq
#include "pass.i65"
    .word pquerycolon
    .word _editcopier
    .word twodrop
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:EDITDEL
stack=( -- )
tags=editor,nosymbol
STOP-D Delete Line

Append the current logical screen line and delete it from the
screen

```
: editdel   ( -- )
    editcopy linesa 2up + 2dup eoss
    dup>r cmove r> + swap blank
    wrapdel ;
```
#endif
#include "page.i65"
__editdel
    .word _editcopy             ; append logical line at cursor to `pad`
#include "page.i65"
    .word linesa                ; get `size` and `addr` of current line
#include "page.i65"
    .word twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word twodup
#include "page.i65"
    .word _eoss
#include "page.i65"
    .word duptor
#include "page.i65"
    .word cmove
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word plus
#include "page.i65"
    .word swap
#include "page.i65"
    .word blank
#include "page.i65"
    .word wrapdel               ; linewrap handler for `STOP-D`
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:EDITPASTE
stack=( -- )
tags=editor,nosymbol

STOP-P

Insert paste buffer before current logical line

```
:editpaste   ( -- )
    linesa nip dup>r  paste @   ( vidaddr paste R; vidaddr )
    r@ eoss  cmove              \ concatenate rest of screen to `paste`
    pad r@ r> eoss cmove        \ fill to end of screen from `pad`
    linesa nip dup>r  paste @   (  )
    wrappaste ;
```
#endif
#include "page.i65"
__editpaste
    .word linesa
#include "page.i65"
    .word nip
#include "page.i65"
    .word duptor
#include "page.i65"
    .word paste
#include "page.i65"
    .word fetch
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word _eoss
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _pad
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _eoss
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _wrappaste            ; linewrap handler for `STOP-P`
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:EDITNOWRAP
stack=( -- )
tags=editor,nosymbol
Reset the linewrap table and force this packet to be a screen

~#packrat
#endif
#include "align.i65"
__editnowrap
    .word _nowrap
#include "pass.i65"
    .word peditnowrap
peditnowrap
    ldy #1
    lda (ACC+2*N8),y
    ora #$80
    sta (ACC+2*N8),y
    jmp exit

;--------------------------------------------------------------
#if 0
name=:EDITTOPSCR
stack=( -- )
tags=editor,nosymbol

 from the top (first) screen

```
:edittopscr   ( -- )
    0 >edit ;
```
#endif
#include "align.i65"
__edittopscr
    .word zero
#include "page.i65"
    .word _toedit
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:EDITQUIT
stack=( -- )
tags=editor,nosymbol
STOP-_   Quit the editor
STOP-Q

```
:editquit   ( -- )
    editing off  rdrop rdrop ;
```
#endif
#include "page.i65"
__editquit
    .word _update
#include "page.i65"
    .word editing
#include "page.i65"
    .word off
#include "page.i65"
    .word rdrop                 ; discard returns
#include "page.i65"
    .word rdrop                 ; discard returns
#include "pass.i65"
    .word exit                  ; exiting from EDIT

;--------------------------------------------------------------
#if 0
name=:EDITINDEX
stack=( -- )
tags=editor,nosymbol,unimplemented

STOP-I   Present an index screen and let the user select one to edit

```
:editindex   ( -- ) ;
```
~wut? write this
#endif
#include "page.i65"
__editindex
    .word exit

;--------------------------------------------------------------
#if 0
name=:EDITSAVE
stack=( -- )
tags=editor,nosymbol

 STOP-S   Save all buffers to a PRG file

```
:editsave   ( -- ) ;
```
#endif
#include "page.i65"
__editsave
    .word _update
#include "page.i65"
    .word _clrscr
#include "page.i65"
    .word _savebuffers
#include "pass.i65"
    .word branch
    .byt <(__editrestore-*+1)

;--------------------------------------------------------------
#if 0
name=:EDITLOAD
stack=( -- )
tags=editor,nosymbol

 STOP-L   Load a group of buffers from a PRG file

```
:editload   ( -- ) ;
```
#endif
#include "page.i65"
__editload
    .word _clrscr
#include "page.i65"
    .word _loadbuffers
#include "page.i65"
    .word scr
#include "page.i65"
    .word off
#include "pass.i65"
    .word branch
    .byt <(__editrestore-*+1)

;--------------------------------------------------------------
#if 0
name=:EDITVERIFY
stack=( -- )
tags=editor,nosymbol

 STOP-V   Verify a buffer file vs. memory

```
:editverify   ( -- )
   clrscr verify-buffers true pause :editrestore
```
#endif
#include "page.i65"
__editverify
    .word _clrscr
#include "page.i65"
    .word _verifybuffers
#include "page.i65"
    .word true
#include "page.i65"
    .word _pause
#include "pass.i65"
    .word branch
    .byt <(__editrestore-*+1)

;--------------------------------------------------------------
#if 0
name=EDITZILCH
stack=( -- )
tags=editor,nosymbol

#endif
#include "align.i65"
_editzilch
    jsr enter
    ;fall through
;--------------------------------------------------------------
#if 0
name=:EDITZILCH
stack=( -- )
tags=editor,nosymbol

 STOP-Z   Zilch the paste buffer

```
:editzilch   ( -- )
     pad paste !  pwrap 4 erase  pwrap 1+! ;
```
#endif
#include "page.i65"
__editzilch
    .word _pad
#include "page.i65"
    .word paste
#include "page.i65"
    .word store
#include "page.i65"
    .word pwrap
#include "page.i65"
    .word twooff
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:EDITRESTORE
stack=( -- )
tags=editor,nosymbol

 STOP-R   Restore the current screen from the buffer

```
:editrestore   ( -- )
    scr @ block drop ;
```
#endif
#include "page.i65"
__editrestore
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _block
#include "page.i65"
    .word drop
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:EDITDELSCR
stack=( -- )
tags=editor,nosymbol,unimplemented

 STOP-DEL delete the current screen.  restore from next, then prev, then blank

Deletes the current screen from the packet buffer.  The edit
screen is replaced by the first available of:

* The next screen in the packet buffer, if it already exists
* The previous screen in the packet buffer
* Screen 0 is blanked and written to the packet buffer

```
:editdelscr   ( scr -- packet )
    >pkt
    vmbuf floor size +move
    #blk! scr @ #blk @ 1- max
    >edit ;
```
~wut? write this
#endif
#include "page.i65"
__editdelscr
    .word exit

;--------------------------------------------------------------
#if 0
name=:EDITINSSCR
stack=( -- )
tags=editor,nosymbol,unimplemented

 insert a new, blank screen

```
:editinsscr   ( scr -- packet )
    update vmbuf @ scr @ >pkt

```
~wut? fix this
~ still a little goofy when inserting multiple screens
#endif
#include "page.i65"
__editinsscr
    .word _update
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word duptor
#include "page.i65"
    .word oneplus
#include "pass.i65"
    .word plit
    .word -5
#include "page.i65"
    .word dup
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word _plusmove
#include "pass.i65"
    .word plit
    .word editinsscr01
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word five
#include "page.i65"
    .word cmove
#include "page.i65"
    .word numblk
#include "page.i65"
    .word oneplusstore
#include "pass.i65"
    .word branch
    .byt <(__editrestore-*+1)

editinsscr01
    .byt $ff, $ff, $ff, $05, $80

;--------------------------------------------------------------
#if 0
name=:EDITINFO
stack=( -- )
tags=editor,nosymbol
Show the user an info screen

```
:editinfo   ( -- )
    update vmbuf @ scr @ >pkt

```
#endif
#include "page.i65"
__editinfo
    .word _update
#include "page.i65"
    .word _clrscr
#include "page.i65"
    .word _info
#include "page.i65"
    .word true
#include "page.i65"
    .word _pause
#include "page.i65"
    .word _clrscr
#include "pass.i65"
    .word branch
    .word <(__editrestore-*+1)

;--------------------------------------------------------------
#if 0
name=:EDITSPACE
stack=( -- )
tags=editor,nosymbol

scan for shifted spaces

```
:editspace   ( -- )
     vidram b/scr + vidram
     do
       i c@ $60 =
       if $E0 i c! then
    loop ;

peditspace
    ldy #0
    lda (tos),y
    eor #$60
    bne +

```
#endif
#include "page.i65"
__editspace
    .word vidram
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word plus
#include "page.i65"
    .word vidram
#include "pass.i65"
    .word pdo
    .byt <(editspace03-*+1)
#include "page.i65"
editspace01
    .word i
#include "page.i65"
    .word cfetch
#include "pass.i65"
    .word clit
    .byt $60
#include "page.i65"
    .word eq
#include "pass.i65"
    .word qbranch               ; IF
    .byt <(editspace02-*+1)
#include "page.i65"
    .word clit
    .byte $E0
#include "page.i65"
    .word i
#include "page.i65"
    .word cstore
#include "pass.i65"
editspace02
    .word ploop
    .byt <(editspace01-*+1)
#include "page.i65"
editspace03
    .word exit

;--------------------------------------------------------------
#if 0
name=:EDITNEXTSCR
stack=( -- )
tags=editor,nosymbol
restore from the next screen or append a blank one

```
:editnextscr   ( -- )
    1 +edit ;

```
#endif
#include "page.i65"
__editnextscr
    .word one
#include "page.i65"
    .word _plusedit
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:EDITPREVSCR
stack=( -- )
tags=editor,nosymbol

 restore from the previous screen or insert a blank one

```
:editprevscr   ( -- )
    -1 +edit ;
```
#endif
#include "page.i65"
__editprevscr
    .word minusone
#include "page.i65"
    .word _plusedit
    .word exit

;--------------------------------------------------------------
#if 0
name=EDITCMD
stack=( -- )
tags=editor,nosymbol

 get a key and perform that command

#endif
#include "align.i65"
_editcmd
    jsr enter
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word editmenu
#include "page.i65"
    .word key                   ; ( editmenu char )
#include "page.i65"
    .word flipscr
#include "page.i65"
    .word dolindex
#include "page.i65"
    .word twostar
#include "pass.i65"
    .word _dodispatch
    .word editspace03-2         ; `exit`
    .word __editquit-2
    .word __editquit-2
    .word __editindex-2
    .word __editsave-2
    .word __editload-2
    .word __editverify-2
    .word __editzilch-2
    .word __editrestore-2
    .word __editdel-2
    .word __editcopy-2
    .word __editpaste-2
    .word __editspace-2
    .word __editinfo-2
    .word __editdelscr-2
    .word __editinsscr-2
    .word __edittopscr-2
    .word __editnowrap-2
    .word __editnextscr-2
    .word __editprevscr-2

;--------------------------------------------------------------
#if 0
name=EDITMENU
tags=editor,nosymbol
editor menu commands (no `cfa`)
#endif
editmenu
    jsr docreate
    .byt editmenuz-*-1
    .asc "_QISLVZRDCP ?"        ; command keys
    .byt DELETE, INSERT, HOME, CLR, CRSRDOWN, CRSRUP
editmenuz

;--------------------------------------------------------------
#if 0
name=(EDIT)
stack=( scr -- )
tags=editor,nosymbol
#endif
pedit
    stx z                       ; preserve Forth data stack pointer
    tsx
    stx n                       ; preserve machine stack frame pointer

pedit01                         ; PET screen editor forever loop
    jsr CHRIN                   ; Kernel - blink the cursor, wait for a line of input, ignore it
    lda #CR                     ; don't just leave the cursor two characters past end of line
    jsr CHROUT                  ; Kernel - so echo the carriage return
    jmp pedit01                 ; ... do this forever

pedit02                         ; this is edit's IRQ handler, enabled/disabled by _editirqtoggle
    lda STKEY                   ; $9B flag -- STOP/RVS keys
    cmp #$EF                    ; test STOP key
    bne pedit03
                                ; someone pressed STOP. Exit the editor
                                ; but not so fast!  Are we in quotes or inserts?
    lda QTSW                    ; $CD nonzero=quotes mode
    ora KBINS                   ; $DC number of inserts pending
    beq pedit04
pedit03
    jmp MAINIRQ                 ; not yet?  perform normal system IRQ

; if we get here, clean up from cursor wink and bail out of the IRQ
pedit04
    jsr UDTIM                   ; keep the clock running even if someone leans on STOP
    ;sec                        ; because f7a1 debounce loop always sets carry
    inc $a7                     ; turn off cursor
    lda $a9                     ; true character at cursor position
    jsr FIX_CHR                 ; ROM $E606 on 40-column BASIC4 PET
    ldx n
    txs                         ; reset stack frame
    ldx z                       ; restore Forth stack pointer
    jmp next

;--------------------------------------------------------------
#if 0
name=EDITMODE
stack=( scr -- )
tags=editor,nosymbol

#endif
#include "align.i65"
_editmode
    jsr enter
#include "page.i65"
    .word editor
#include "page.i65"
editmode01
    .word editing
#include "page.i65"
    .word on
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>EDIT
stack=( scr -- )
tags=editor,nosymbol

* Turn on edit mode
* Save current screen in packet buffer

```
: >edit   ( scr -- )
    editmode  update  0 max block drop ;
```
~#packrat
#endif
#include "align.i65"
_toedit
    jsr enter
#include "page.i65"
    .word _editmode
#include "page.i65"
    .word _update
#include "page.i65"
    .word zero
#include "page.i65"
    .word max
#include "page.i65"
    .word dup
#include "page.i65"
    .word scr
#include "page.i65"
    .word store
#include "page.i65"
    .word _block
#include "page.i65"
    .word drop
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=+EDIT
stack=( n -- )
tags=editor,nosymbol

Save current editor screen in packet buffer, edit the screen
`n` screens away from the current [[SCR]]

```
: +edit   ( n -- )
    scr @ + >edit ;
```
#endif
#include "align.i65"
_plusedit
    jsr enter
#include "page.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word _toedit
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EDIT
stack=( scr -- )
tags=editor
PETTIL's editor leverages the wonderful ROM screen editor
on the PET, using the `STOP` key as a substitute for escape,
not present on early PET keyboards.
#endif
#include "align.i65"
_edit
    jsr enter
#include "page.i65"
    .word _editmode
#include "page.i65"
    .word _block
#include "page.i65"
    .word drop
#include "page.i65"
    .word _editzilch
#include "pass.i65"
edit00                          ; reentry to editor here
    .word plit
    .word pedit02
#include "page.i65"
    .word irqstore              ; enable STOP key trap
#include "page.i65"
    .word pedit
#include "pass.i65"
    .word plit
    .word MAINIRQ
#include "page.i65"
    .word irqstore              ; disable STOP key trap, also does CLI
#include "page.i65"
    .word _editcmd              ; get and perform editor command
#include "pass.i65"
    .word branch
    .byt <(edit00-*+1)          ; AGAIN

;--------------------------------------------------------------
#if 0
name=_
stack=( -- )
tags=editor
A shortcut to get back into the editor. On the PET keyboard, there is no
underscore, it's the left-arrow character.

```
: _   ( -- )
    scr @ edit ;
```
!!!pronounced: "back"
#endif
#include "align.i65"
_back
    jsr enter
#include "page.i65"
    .word _editmode
#include "page.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _edit
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=^
stack=( -- )
tags=editor
The capture word `^` first captures the contents (including linewrap)
of the current display into a new editor packet, which is created and
appended to the end of the [[VMBUF]] area. Then the editor is invoked.

```
: ^   ( -- )
    #blk @  scr ! editing on vidram scrpkt !  0 mkpkts  update _ ;

: ^   ( -- )
    editmode pkt+ update _ ;
    #blk @  scr ! pkt+ update _ ;
```
!!!pronounced: "capture"
~#packrat
#endif
#include "align.i65"
_caret
    jsr enter
#include "page.i65"
    .word _editmode
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word scr
#include "page.i65"
    .word store
#include "page.i65"
    .word _pktplus
#include "page.i65"
    .word _update
#include "page.i65"
    .word _back
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LIST
stack=( scr -- )
tags=editor
List the specified screen and set `scr`; Invoke `editor` vocabulary
#endif
#include "align.i65"
_list
    jsr enter
#include "page.i65"
    .word editor
#include "page.i65"
    .word editing
#include "page.i65"
    .word on
#include "page.i65"
    .word _block
#include "page.i65"
    .word drop
#include "page.i65"
    .word editing
#include "page.i65"
    .word off
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=L
stack=( -- )
tags=editor
vocab=2
List the current screen and set `scr`
#endif
#include "align.i65"
_l
    jsr enter
#include "page.i65"
    .word scr
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _list
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>NP
stack=( -- )
tags=editor,nosymbol
List the specified screen and set [[SCR]]

//pronounced: do N-P//
#endif
#include "align.i65"
_donp
    jsr enter
#include "page.i65"
    .word scr
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word rot
#include "page.i65"
    .word plus
#include "page.i65"
    .word tuck
#include "page.i65"
    .word zero
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch
#include "page.i65"
;    .word betweenq             ~wut? use `within`
#include "pass.i65"
    .word pquerycolon
    .word store
    .word twodrop
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=N
stack=( -- )
tags=editor
vocab=2
List the specified screen and set [[SCR]]
#endif
#include "align.i65"
_n
    jsr enter
    .word one
#include "pass.i65"
    .word _donp
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=P
stack=( -- )
tags=editor
vocab=2
List the specified screen and set [[SCR]]
#endif
#include "align.i65"
_p
    jsr enter
#include "page.i65"
    .word minusone
#include "pass.i65"
    .word _donp
#include "pass.i65"
    .word exit

#print (*-editor)
