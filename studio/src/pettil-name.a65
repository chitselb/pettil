; pettil-name.a65
#echo .       pettil-name.a65           Text parser

;--------------------------------------------------------------
#if 0
name=SKIP
stack=( delim -- offset )
tags=nosymbol
`addr1` is the starting address in the input stream where up
to `size1` bytes are skipped *WHILE* they match `delim`.  Returns
`addr2` as the address of the first non-matching character and
`count2` as the remaining number of bytes in the buffer.
#endif
skip
    lda #$F0                    ; BEQ opcode
    .byt $2C                    ; BIT abs
    ;fall through
;--------------------------------------------------------------
#if 0
name=SCAN
stack=( delim -- offset )
tags=self-modifying,nosymbol
Pass through the input stream until `delim` either matches (or
for `skip`, does not match).  Leave the `offset` into the line
buffer on the stack.
#endif
scan
    lda #$D0                    ; BNE opcode
    sta skipscan03              ; #selfmodifying
    ldy userin                  ; `in`
    dey
skipscan01
    iny
    cpy userspan                ; Carry true at end of line
    bcc skipscan02
    lda #0                      ; oh, we done
    sta userspan                ; `span off`
    beq skipscan04
skipscan02
    lda (ACC+2*N6),y            ; get char from buffer
    eor tos                     ; compare to character we seek
skipscan03
    bvc skipscan01              ; dummy opcode, BEQ(skip) BNE(scan)
skipscan04
    sty userin                  ; found char !, move `in`
    tya
    jmp put0a                   ;( offset )


;--------------------------------------------------------------
#if 0
name=?LOADING
stack=( -- )
tags=outer,extra,nosymbol
If loading, restore the cursor and increment `lin` etc.. This executes just after `sib` line input buffer was filled by `expect`


```
: ?loading   ( -- )
    blk@ 0= ?exit
    rdrop \ the thing that called us
    cursor!

    in 1+ 1+!
    lin  height @



```
#endif
#include "align.i65"
_qloading
    jsr enter
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word rdrop
#include "page.i65"
    .word cursorstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=!STREAM
stack=( -- )
tags=outer,extra,nosymbol
Set up input stream, refilling from the keyboard or `vmbuf` as needed.

```
: (stream)   ( -- )
    blk@ ?: sib tib  >n6        ( _ib )
    span @ ?exit
    blk@ ?: line.size eighty    ( _ib size )
    expect
    ?loading ;
```
#endif
#include "align.i65"
_pstream
    jsr enter
#include "page.i65"
    .word blkfetch
#include "pass.i65"
    .word pquerycolon
    .word sib
    .word tib
#include "pass.i65"
    .word tozp
    .byt ACC+2*N6
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word pquerycolon
    .word _linesize
    .word eighty
#include "page.i65"
    .word expect
#include "page.i65"
    .word _qloading
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CURSOR@
stack=( -- )
tags=primitive,extra,nosymbol
Fetch hardware cursor (to return stack)

#endif
cursorfetch
    lda PNT+1
    pha
    lda PNT
    pha
    lda PNTR
    pha
    lda LNMX
    pha
    lda TBLX
    pha
    lda DFLTN
    pha
    jmp next

;--------------------------------------------------------------
#if 0
name=CURSOR!
stack=( -- )
tags=primitive,extra
Set hardware cursor (from return stack)

This is a lighter version pending implementation of general cursor words: `:cursor` `<cursor` `=cursor` `>cursor`

#endif
cursorstore
    pla
    sta DFLTN
    pla
    sta TBLX
    pla
    sta LNMX
    pla
    sta PNTR
    pla
    sta PNT
    pla
    sta PNT+1
    jmp next

;--------------------------------------------------------------
#if 0
name=REFILL
stack=( -- )
tags=outer,extra
Sets up the input stream, refilling from the keyboard or `vmbuf` as needed.

```
: refill
    blk@ if
        cursor@ <n6 line.size
        expect
        cursor!
    else
        <n6 80
        expect
    then ;

: line.setup
    blk@ if
        cursor@
        sib
        3
          blk@ block lin 40* +
          0 0 0 0 cursor!
    else
        tib eighty
    then ;


: refill   ( -- )
    line.setup                  ( ?cursor buf size )
    expect                      ( ?cursor )
    blk@ if cursor! then ;      ( -- )
```
#endif
#include "align.i65"
_refill
    jsr enter
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6               ; tib or sib
#include "page.i65"
    .word blkfetch
#include "pass.i65"
    .word pquerycolon
    .word cursorfetch
    .word next
#include "page.i65"
refill02
    .word blkfetch
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word pquerycolon
    .word _linesize
    .word eighty
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word qbranch
    .byt <(refill02-*+1)
#include "page.i65"
    .word expect
#include "page.i65"
    .word blkfetch
#include "pass.i65"
    .word pquerycolon
    .word cursorstore
    .word next
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>LINE
stack=( -- addr size )
tags=outer,extra
Return `addr` and `size` of line# `lin`

```
: >line    ( -- addr size )
    blk@ block lin 40* +
    lin bufwrap >bit cbit@
    ?: forty eighty
    -trailing nip ;

ptickstream
    lda #3
    sta DFLTN                   ; $AF Default Input Device
    lda tos
    sta userspan
    sta LNMX                    ; $D5 logical line length (39 or 79)
    lda userin
    sta PNTR                    ; $C6 cursor column on current line
    lda userlin
    sta TBLX                    ; $D8 cursor physical line number
    cmp #LPERSCR
    bit LNMX
    inc userlin
    bvc ptickstream01
    inc userlin
ptickstream01
    bcc ptickstream02
    jsr plugh
    inx
    inx
    jmp putnotc
ptickstream02
    jmp next

: line.size   ( u -- 40|80 )
    block lin 40* +
    lin buf.wrap >bit cbit@
    in 1+ over ?: 1+! 2+!
    ?: 40 80
    -trailing ('stream) ;
```
#endif
#include "align.i65"
_toline
    jsr enter
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word _block
#include "page.i65"
    .word lin
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word plus                  ;( line.addr )
#include "page.i65"
    .word lin
#include "page.i65"
    .word _bufwrap
#include "page.i65"
    .word tobit
#include "page.i65"
    .word cbitfetch             ;( addr wrapbit )
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplus               ; 'lin is high byte of `in`
#include "page.i65"
    .word over
#include "pass.i65"
    .word pquerycolon           ; `lin` points to next line
    .word oneplusstore          ; 40 column
    .word twoplusstore          ; 80 column
#include "pass.i65"
    .word pquerycolon
    .word forty
    .word eighty
#include "page.i65"
    .word dashtrailing
#include "page.i65"
    .word nip                   ; ( addr size )
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LINESIZE
stack=( -- size )
tags=outer,extra,nosymbol
Return `size` of either a line input from the keyboard
or when loading, set hardware cursor to line# `lin` of `blk`
advances `lin`

```
: line.size   ( -- size )
    cursor@ !loading
    <n6
    block lin 40* +
    lin buf.wrap >bit cbit@
    in 1+ over ?: 1+! 2+!
    ?: 40 80
    -trailing ;
```
#endif
#include "align.i65"
_linesize
    jsr enter
#include "page.i65"
    .word cursorfetch
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6
#include "page.i65"
    .word _block
#include "page.i65"
    .word lin
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word plus                  ;( addr )
#include "page.i65"
    .word lin
#include "page.i65"
    .word _bufwrap
#include "page.i65"
    .word tobit
#include "page.i65"
    .word cbitfetch             ;( addr wrapbit )
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word over
#include "page.i65"
    .word pquerycolon
    .word oneplusstore
    .word twoplusstore
#include "pass.i65"
    .word pquerycolon
    .word forty
    .word eighty
#include "page.i65"
    .word dashtrailing
#include "page.i65"
    .word setloading
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?REFILL
stack=( char -- char )
tags=primitive,outer,extra,nosymbol
Load either `sib` or `tib` with a logical line of input.

tib|sib (n6)

!!blk
blk?
`block` tests `blk` = `prev` to skip unpacking part
!blk
`load` sets `blk` to index of an available packet (positive unsigned)
0blk
`quit` sets `blk` to 0 (interactive session)
`?refill` sets block to 0 after interpreting last line

!!in
in?
!in
0in
`quit` sets in to 0 (interactive session)

!! lin
lin?
!lin
0lin

!!span
span?
!span
0span

!!prev
prev?
!prev
`#blk!` sets `prev` -1 to
0prev

scr
prev
blk
in
 lin
span



Is span off?

Do we want to turn span off?

Return `size` of either a line input from the keyboard
or when loading, set hardware cursor to line# `lin` of `blk`
advances `lin`

#endif
#include "align.i65"
_qrefill
    jsr enter
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=!LOADING
stack=( -- )
tags=primitive,outer,extra,nosymbol
Return `size` of either a line input from the keyboard
or when loading, set hardware cursor to line# `lin` of `blk`
advances `lin`

#endif
setloading
    lda #3
    sta DFLTN                   ; $AF Default Input Device
    lda stackl,x
    sta PNT
    lda stackh,x
    sta PNT+1
    lda tos
    sta userspan
    sta LNMX                    ; $D5 logical line length (39 or 79)
    lda userin
    sta PNTR                    ; $C6 cursor column on current line
    lda userlin
    sta TBLX                    ; $D8 cursor physical line number
    jmp nip

;--------------------------------------------------------------
#if 0
name=NAME
stack=( char -- nfa|0 )
tags=outer,extra
Parse the next `word` from the `input stream`.  Return `false` if the
`input stream` is exhausted, or the `nfa` of the found word, built
directly within the input stream.  Advance `in` past the parsed `word`.

Leading delimiters are ignored.   If the delimiter is not found the value of
IN is the size of the input stream.  If the delimiter is found IN is
 adjusted to indicate the offset to the character following
 the delimiter.  `span` is unmodified.

In PETTIL `name` replaces the function of Forth-83 //required// reserved
word `word`, which is //omitted//.

As much of the `ugly` as I could for the `blk` conspiracy goes in here.
Isolating conspiracy support in as few words as possible will hopefully
reduce overall system complexity and present clear transitions between the
phases of the outer interpreter.

```
: name   ( char -- nfa|0 )
    !stream
    dup skip dup>r 1- <n6 +
    swap scan r> - >n8 dup
    ?: nfa! nip ;

: name   ( char -- nfa|0 )
    'stream
    dup skip
    dup>r 1- <n6 +
    swap scan
    r> - >n8 ( len )
    nfa! ;
name=NFA!
stack=( addr size -- nfa )

: name   ( u -- nfa|0 )
    ('stream) dup
    skip dup>r 1- <n6 + swap
    scan r> - >n8
    over c!  in 1+! ;

```
#endif
#include "align.i65"
_name
    jsr enter
#include "page.i65"
    .word _qrefill
#include "page.i65"
    .word dup
#include "page.i65"
    .word skip                  ; start of name
#include "page.i65"
    .word duptor
#include "page.i65"
    .word oneminus
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6               ; buf
#include "page.i65"
    .word plus
#include "page.i65"
    .word swap
#include "page.i65"
    .word scan                  ; end of name (and/or buffer)
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word minus
#include "pass.i65"
    .word tozp
    .byt ACC+2*N8               ; name.len
#include "page.i65"
    .word over
#include "page.i65"
    .word cstore
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplusstore          ; move `in` past the name-ending whitespace
#include "pass.i65"
    .word exit

#print (*-skip)
