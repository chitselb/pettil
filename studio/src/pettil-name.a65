; pettil-name.a65
#echo .       pettil-name.a65           Text parser
;" cursor@ cursor! !loading skip scan ?loading 'stream? linesize ?refill name
;" nfa!

;--------------------------------------------------------------
#if 0
name=SKIP
stack=( delim -- offset )
tags=nosymbol
`addr1` is the starting address in the input stream where up
to `size1` bytes are skipped *WHILE* they match `delim`.  Returns
`addr2` as the address of the first non-matching character and
`count2` as the remaining number of bytes in the buffer.
#endif
skip
    lda #$F0                    ; BEQ opcode
    .byt $2C                    ; BIT abs
    ;fall through
;--------------------------------------------------------------
#if 0
name=SCAN
stack=( -- offset )
tags=self-modifying,nosymbol
Pass through the input stream until `delim` either matches (or for `skip`, does not match).  Leave the `offset` into the line buffer on the stack.

N6 line buffer
N7 char delimiter
#endif
scan
    lda #$D0                    ; BNE opcode
    sta skipscan03              ; #selfmodifying
    ldy userin                  ; `in`
    dey
skipscan01
    iny
    cpy userspan                ; Carry true at end of line
    bcc skipscan02
    lda #0                      ; oh, we done
    sta userspan                ; `span off`
;    sta userin
    beq skipscan04
skipscan02
    lda (ACC+2*N6),y            ; get char from buffer
    eor ACC+2*N7                ; compare to character we seek
skipscan03
    bvc skipscan01              ; dummy opcode, BEQ(skip) BNE(scan)
skipscan04
    sty userin                  ; found char !, move `in`
    tya
    jmp push0a                  ;( offset )

;--------------------------------------------------------------
#if 0
name=?LOADING
stack=( -- )
tags=outer,extra,nosymbol
If loading, restore the cursor and increment `lin` etc.. This executes just after `sib` line input buffer was filled by `expect`


```
: ?loading   ( -- )
    blk@
    if
        0 =cursor
    then ;
```
#endif
#include "align.i65"
_qloading
    jsr enter
#include "page.i65"
    .word blkfetch
#include "pass.i65"
    .word qbranch
    .word <(qloading01-*+1)
#include "page.i65"
    .word zero
#include "page.i65"
    .word exchgcursor
#include "pass.i65"
qloading01
    .word exit

;--------------------------------------------------------------
#if 0
name=LINESIZE
stack=( -- size )
tags=outer,extra,nosymbol
Return `size` of either a line input from the keyboard
or when loading, set hardware cursor to line# `lin` of `blk`
advances `lin`

```
: line.size   ( u -- size|0 )
    <n6 swap block  lin 40* +   \ (C4)
    lin buf.wrap >bit cbit@
    in 1+ over  ?: 1+! 2+!
    ?: forty eighty  -trailing ; \ D5
```
#endif
#include "align.i65"
_linesize
    jsr enter
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6
#include "page.i65"
    .word swap
#include "page.i65"
    .word _block
#include "page.i65"
    .word lin
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word plus                  ;( addr )
#include "page.i65"
    .word lin
#include "page.i65"
    .word _bufwrap
#include "page.i65"
    .word tobit
#include "page.i65"
    .word cbitfetch             ;( addr wrapbit )
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word over
#include "page.i65"
    .word pquerycolon
    .word oneplusstore
    .word twoplusstore
#include "pass.i65"
    .word pquerycolon
    .word forty
    .word eighty
#include "page.i65"
    .word dashtrailing
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REFILL?
stack=( -- size|0 )
tags=primitive,outer,extra,nosymbol
Load either `sib` or `tib` with a logical line of input.  An interactive session always return the value 80.  Zero will only be returned when `loading?` from a screen.  Otherwise the return value  is the number of characters, after `-trailing` spaces are removed, on the current logical line of the `blk` that is loading.

|^`prev`|^reset by `#blk!`|^set and|^tested by `block`|
|^`blk`|^set by `load`|^reset by `!loading`|^tested|
|^`in`|^reset by `expect`|^set by `skip` `scan`,|^final value at eol = `??`|
|^`lin`|^reset by `expect`|^set by `line.size` tested/cleared by `??`|
|^`span`|^set by `expect`|^tested/cleared by `??`|


```
: refill?   ( -- size|0 )
    span @ ?exit  <n6 blk@
    ?dup ?: line.size eighty  tuck
    ?loading !loading expect ?loading ;

: refill?   ( -- size|0 )
    span @ ?dup ?exit

      <n6
    begin
        blk@ ?dup
    while
        line.size
        dup
    until

    ?dup ?: line.size eighty  tuck
    ?loading !loading expect ?loading ;


```
#endif
#include "align.i65"
_refillq
    jsr enter
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _qexit                ; exit if something is in this line buffer?
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6               ; line buffer address sib|tib
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word pquerycolon
    .word _linesize             ; ( sib blk -- sib size )
    .word eighty                ; ( tib -- tib 80 )
#include "page.i65"
    .word tuck
#include "page.i65"
    .word _qloading
#include "page.i65"
    .word setloading
#include "page.i65"
    .word expect
#include "page.i65"
    .word _qloading
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME.PARSE
stack=( -- nfa|0 )
tags=secondary,outer,extra,nosymbol

* set n6 line buffer addr
* set n7 delimiter char
* refill the line buffer (if empty)
* skip/scan move `in` past token
* set n8 token length
* put length before text in buffer
* move `in` past trailing space

```
: name.parse   ( -- nfa|0 )
    skip dup 1- <n6 +
    scan rot -
    dup ?: !nfa nip ;

: !nfa
    >n8 over c!  in 1+! ;
```
#endif
#include "align.i65"
_nameparse
    jsr enter
#include "page.i65"
    .word skip                  ; start of name
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6               ; buf
#include "page.i65"
    .word plus
#include "page.i65"
    .word scan                  ; end of name (and/or buffer)
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus                 ; length
#include "page.i65"
    .word dup
#include "pass.i65"
    .word pquerycolon
    .word _setnfa
    .word nip
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=!NFA
stack=( char -- nfa|0 )
tags=secondary,outer,extra,nosymbol
* set `n8` to len
* set length in line buffer
* increment `in` past space after token

```
: !nfa   ( nfa len -- nfa )
    >n8 over c!  in 1+! ;
```
#endif
#include "align.i65"
_setnfa
    jsr enter
#include "pass.i65"
    .word tozp
    .byt ACC+2*N8               ; name.len
#include "page.i65"
    .word over
#include "page.i65"
    .word cstore
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplusstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME
stack=( char -- nfa|0 )
tags=outer,extra
Parse the next `word` from the `input stream`.  Return `false` if the input stream is exhausted, or returns the `nfa` of the found word, which will be a counted string somewhere in `tib` or `sib`.

Leading delimiters are ignored.   If the delimiter `char` is not found the value of `in` will be the size of the input stream.  If `char` is found, `in` will point to the character following the delimiter. When the end of the input line is reached, `name.parse` clears `span` to let us exit.  Similarly, `line.size` will clear `blk` when `lin` reaches the `height` physical line of `blkbuf` to exit after loading a screen.

This is one of PETTIL's slight departures from the Forth-83 standard.  In PETTIL `name` replaces the //required// reserved word `word`. The reason is that PETTIL uses a lazy loading design while the standard uses active loading.

|What is a WORD?|<|<|h
|1|word|entry in the Forth dictionary|
|2|word|16 bits of memory|
|3|word|an English word|
|4|word|//required// reserved Forth-83 standard word to parse the input stream|
|5|word|things Cameo say before `up`|

Here we see that `word` means (at least) five things, and we are dispensing with one of those (meaning #4) by renaming `word` to `name` and altering the stack diagram slightly.

* set `n6` line buffer addr
* set `n7` delimiter char
* refill the line buffer (if empty)
* test if line buffer (and screen buffer, if loading) exhausted
* set `n8` length
* return `false` or `nfa`
* Advance `in` past the parsed `word`.

Three variables

||0|non-0|reset|set|test|h
|prev||||||
|scr||||||
|blk|`quit`|`load`||||


```
: name   ( char -- nfa|0 )
    blk@ ?: sib tib  n6 2!      \ set line buffer (`tib` or `sib`)
                                \ and word delimiter (`bl`)
    refill? dup
    if
        name.parse
    then ;
```
#endif
#include "align.i65"
_name
    jsr enter
#include "page.i65"
    .word blkfetch
#include "pass.i65"
    .word pquerycolon
    .word sib
    .word tib
#include "pass.i65"
    .word clit
    .byt ACC+2*N6               ; `n6` line input buffer (`sib` or `tib`)
#include "page.i65"
    .word twostore              ; `n7` delim char
#include "page.i65"
    .word _refillq              ; ( nfa|0 )
#include "pass.i65"
    .word qbranch
    .byt <(name02-*+1)
#include "page.i65"
    .word _nameparse
#include "pass.i65"
name02
    .word exit

;--------------------------------------------------------------
#if 0
name=!LOADING
stack=( -- )
tags=primitive,outer,extra,nosymbol
Return `size` of either a line input from the keyboard
or when loading, set hardware cursor to line# `lin` of `blk`
advances `lin`

* test `blk` - do not reroute cursor unless `loading?`
* reset `blk` when `lin` reaches 25
#endif
setloading
    lda userblk
    beq setloading02            ; exit unless `loading?`
    lda #3
    sta DFLTN                   ; $AF Default Input Device
    lda userlin
    cmp #LPERSCR
    bcc setloading01
    lda #0
    sta userblk                 ; end of screen reached
setloading01
    sta TBLX                    ; $D8 cursor physical line number
    lda tos
    sta LNMX                    ; $D5 logical line length (39 or 79)
    lda userin
    sta PNTR                    ; $C6 cursor column on current line
    lda stackl,x
    sta PNT                     ; ($C4) pointer start of current screen line
    lda stackh,x
    sta PNT+1
setloading02
    jmp next

#print (*-skip)
