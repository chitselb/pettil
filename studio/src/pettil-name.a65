; pettil-name.a65
#echo .       pettil-name.a65           Text parser
;" cursor@ cursor! !loading skip scan ?loading 'stream? linesize ?refill name
;" nfa!

;--------------------------------------------------------------
#if 0
name=SKIP
stack=( delim -- offset )
tags=nosymbol
`addr1` is the starting address in the input stream where up
to `size1` bytes are skipped *WHILE* they match `delim`.  Returns
`addr2` as the address of the first non-matching character and
`count2` as the remaining number of bytes in the buffer.
#endif
skip
    lda #$F0                    ; BEQ opcode
    .byt $2C                    ; BIT abs
    ;fall through
;--------------------------------------------------------------
#if 0
name=SCAN
stack=( -- offset )
tags=self-modifying,nosymbol
Pass through the input stream until `delim` either matches (or for `skip`, does not match).  Leave the `offset` into the line buffer on the stack.

N6 line buffer
N7 char delimiter
#endif
scan
    lda #$D0                    ; BNE opcode
    sta skipscan03              ; #selfmodifying
    ldy userin                  ; `in`
    dey
skipscan01
    iny
    cpy userspan                ; Carry true at end of line
    bcc skipscan02
    lda #0                      ; oh, we done
    sta userspan                ; `span off`
;    sta userin
    beq skipscan04
skipscan02
    lda (ACC+2*N6),y            ; get char from buffer
    eor ACC+2*N7                ; compare to character we seek
skipscan03
    bvc skipscan01              ; dummy opcode, BEQ(skip) BNE(scan)
skipscan04
    sty userin                  ; found char !, move `in`
    tya
    jmp put0a                   ;( offset )


;--------------------------------------------------------------
#if 0
name=?LOADING
stack=( -- )
tags=outer,extra,nosymbol
If loading, restore the cursor and increment `lin` etc.. This executes just after `sib` line input buffer was filled by `expect`


```
: ?loading   ( -- )
    blk@ 0= ?exit
    r>
    cursor!
    >r ;

    in 1+ 1+!
    lin  height @
```
#endif
#include "align.i65"
_qloading
    jsr enter
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word cursorstore
#include "page.i65"
    .word tor
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LINESIZE
stack=( -- size )
tags=outer,extra,nosymbol
Return `size` of either a line input from the keyboard
or when loading, set hardware cursor to line# `lin` of `blk`
advances `lin`

```
: line.size   ( -- size )
    cursor@ !loading
    <n6
    block lin 40* +
    lin buf.wrap >bit cbit@
    in 1+ over ?: 1+! 2+!
    ?: 40 80
    -trailing ;

: >line    ( -- addr size )
    blk@ block lin 40* +
    lin bufwrap >bit cbit@
    ?: forty eighty
    -trailing nip ;

_pstream
    jsr enter
    .word blkfetch
    .word pquerycolon
    .word sib
    .word tib
    .word tozp
    .byt ACC+2*N6
    .word span
    .word fetch
    .word _qexit
    .word blkfetch
    .word qdup
    .word pquerycolon
    .word _linesize
    .word eighty
    .word expect
    .word _qloading
    .word exit

ptickstream
    lda #3
    sta DFLTN                   ; $AF Default Input Device
    lda tos
    sta userspan
    sta LNMX                    ; $D5 logical line length (39 or 79)
    lda userin
    sta PNTR                    ; $C6 cursor column on current line
    lda userlin
    sta TBLX                    ; $D8 cursor physical line number
    cmp #LPERSCR
    bit LNMX
    inc userlin
    bvc ptickstream01
    inc userlin
ptickstream01
    bcc ptickstream02
    jsr plugh
    inx
    inx
    jmp putnotc
ptickstream02
    jmp next

: line.size   ( u -- 40|80 )
    block lin 40* +
    lin buf.wrap >bit cbit@
    in 1+ over ?: 1+! 2+!
    ?: 40 80
    -trailing ('stream) ;

: >line   ( sib blk -- sib size )
    block lin 40* +  <n6
    lin buf.wrap >bit cbit@
    in 1+  over ?: 1+! 2+!
    ?: forty eighty  -trailing
    cursor@ !cursor ;

_toline
    jsr enter
    .word blkfetch
    .word _block
    .word lin
    .word fortytimes
    .word plus                  ;( line.addr )
    .word lin
    .word _bufwrap
    .word tobit
    .word cbitfetch             ;( addr wrapbit )
    .word in
    .word oneplus               ; 'lin is high byte of `in`
    .word over
    .word pquerycolon           ; `lin` points to next line
    .word oneplusstore          ; 40 column
    .word twoplusstore          ; 80 column
    .word pquerycolon
    .word forty
    .word eighty
    .word dashtrailing
    .word nip                   ; ( addr size )
    .word exit
```
#endif
#include "align.i65"
_linesize
    jsr enter
#include "page.i65"
    .word cursorfetch
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6
#include "page.i65"
    .word _block
#include "page.i65"
    .word lin
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word plus                  ;( addr )
#include "page.i65"
    .word lin
#include "page.i65"
    .word _bufwrap
#include "page.i65"
    .word tobit
#include "page.i65"
    .word cbitfetch             ;( addr wrapbit )
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word over
#include "page.i65"
    .word pquerycolon
    .word oneplusstore
    .word twoplusstore
#include "pass.i65"
    .word pquerycolon
    .word forty
    .word eighty
#include "page.i65"
    .word dashtrailing
#include "page.i65"
    .word setloading
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?REFILL
stack=( char -- char )
tags=primitive,outer,extra,nosymbol
Load either `sib` or `tib` with a logical line of input.

tib|sib (n6)

!!blk
blk?
`block` tests `blk` = `prev` to skip unpacking part
!blk
`load` sets `blk` to index of an available packet (positive unsigned)
0blk
`quit` sets `blk` to 0 (interactive session)
`?refill` sets block to 0 after interpreting last line

!!in
in?
!in
0in
`quit` sets in to 0 (interactive session)

!! lin
lin?
!lin
0lin

!!span
span?
!span
0span

!!prev
prev?
!prev
`#blk!` sets `prev` -1 to
0prev

scr
prev
blk
in
 lin
span



Is span off?

Do we want to turn span off?

Return `size` of either a line input from the keyboard
or when loading, set hardware cursor to line# `lin` of `blk`
advances `lin`

`n6` needs to be set



: ?refill   ( -- )
    span @ ?exit
    blk@ ?: sib tib  >n6        ( _ib )
    blk@ ?dup ?: line.size eighty    ( _ib size )
    expect
    ?loading ;

#endif
#include "align.i65"
_qrefill
    jsr enter
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _qexit                ; exit if something is in this line buffer?
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6               ; line buffer address sib|tib
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word pquerycolon
    .word _linesize             ; ( sib blk -- sib size )
    .word eighty                ; ( tib -- tib 80 )
#include "page.i65"
    .word expect
#include "page.i65"
    .word _qloading
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PARSENAME
stack=( -- nfa|0 )
tags=secondary,outer,extra,nosymbol

```
: name   ( char -- nfa|0 )

    ?refill
    dup skip dup>r 1- <n6 +
    swap scan r> - >n8 dup
    ?: nfa! nip ;

: name   ( char -- nfa|0 )
    'stream
    dup skip
    dup>r 1- <n6 +
    swap scan
    r> - >n8 ( len )
    nfa! ;
name=NFA!
stack=( addr size -- nfa )

: parsename
    skip dup 1- <n6 +
    scan rot - >n8
    over c!  in 1+!

    skip
    scan
    - >n8
    c!

* set n6 line buffer addr
* set n7 delimiter char
* refill the line buffer (if empty)


: parsename
    skip dup 1- <n6 +
    scan rot - >n8
    over c!  in 1+!
```
#endif
#include "align.i65"
_parsename
    jsr enter
#include "page.i65"
    .word dup
#include "pass.i65"
    .word qbranch
    .byt <(name01-*+1)
#include "page.i65"
    .word skip                  ; start of name
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6               ; buf
#include "page.i65"
    .word plus
#include "page.i65"
    .word scan                  ; end of name (and/or buffer)
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus
#include "pass.i65"
    .word tozp
    .byt ACC+2*N8               ; name.len
#include "page.i65"
    .word over
#include "page.i65"
    .word cstore
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplusstore          ; move `in` past the name-ending whitespace

;--------------------------------------------------------------
#if 0
name=NAME
stack=( char -- nfa|0 )
tags=outer,extra
Parse the next `word` from the `input stream`.  Return `false` if the input stream is exhausted, or returns the `nfa` of the found word, which will be a counted string somewhere in `tib` or `sib`.

Leading delimiters are ignored.   If the delimiter `char` is not found the value of `in` will be the size of the input stream.  If `char` is found, `in` will point to the character following the delimiter. When the end of the input line is reached, `parsename` clears `span` to let us exit.  Similarly, `line.size` will clear `blk` when `lin` reaches the `height` physical line of `blkbuf` to exit after loading a screen.

This is one of PETTIL's slight departures from the Forth-83 standard.  In PETTIL `name` replaces the //required// reserved word `word`. The reason is that PETTIL uses a lazy loading design while the standard uses active loading.

|What is a WORD?|<|<|h
|1|word|entry in the Forth dictionary|
|2|word|16 bits of memory|
|3|word|an English word|
|4|word|//required// reserved Forth-83 standard word to parse the input stream|
|5|word|things Cameo say before `up`|

Here we see that `word` means (at least) five things, and we are dispensing with one of those (meaning #4) by renaming `word` to `name` and altering the stack diagram slightly.

* set `n6` line buffer addr
* set `n7` delimiter char
* refill the line buffer (if empty)
* test if line buffer (and screen buffer, if loading) exhausted
* set `n8` length
* return `false` or `nfa`
* Advance `in` past the parsed `word`.

```
: name   ( char -- nfa|0 )
    blk@ ?: sib tib  n6 2!
    ?refill
    blk @ span @ or
    ?: parsename 0 ;
```
#endif
#include "align.i65"
_name
    jsr enter
#include "page.i65"
    .word blkfetch
#include "pass.i65"
    .word pquerycolon
    .word sib
    .word tib
#include "pass.i65"
    .word clit
    .byt ACC+2*N6               ; `n6` line input buffer (`sib` or `tib`)
#include "page.i65"
    .word twostore              ; `n7` delim char
#include "page.i65"
    .word _qrefill
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word orx
#include "pass.i65"
    .word pquerycolon
    .word _parsename
    .word zero
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CURSOR@
stack=( -- )
tags=primitive,extra,nosymbol
Stash hardware cursor to return stack

#endif
cursorfetch
    lda PNT+1
    pha
    lda PNT
    pha
    lda PNTR
    pha
    lda LNMX
    pha
    lda TBLX
    pha
    lda DFLTN
    pha
    jmp next

;--------------------------------------------------------------
#if 0
name=CURSOR!
stack=( -- )
tags=primitive,extra
Restore hardware cursor from return stack

#endif
cursorstore
    pla
    sta DFLTN
    pla
    sta TBLX
    pla
    sta LNMX
    pla
    sta PNTR
    pla
    sta PNT
    pla
    sta PNT+1
    jmp next

;--------------------------------------------------------------
#if 0
name=!LOADING
stack=( -- )
tags=primitive,outer,extra,nosymbol
Return `size` of either a line input from the keyboard
or when loading, set hardware cursor to line# `lin` of `blk`
advances `lin`

#endif
setloading
    lda #3
    sta DFLTN                   ; $AF Default Input Device
    lda userlin
    cmp userheight
    bcc setloading01
    lda #0
    sta userblk                 ; end of screen reached
setloading01
    sta TBLX                    ; $D8 cursor physical line number
    lda tos
    sta LNMX                    ; $D5 logical line length (39 or 79)
    lda userin
    sta PNTR                    ; $C6 cursor column on current line
    lda stackl,x
    sta PNT                     ; ($C4) pointer start of current screen line
    lda stackh,x
    sta PNT+1
    jmp next

#print (*-skip)
