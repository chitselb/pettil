; pettil-name.a65
#echo .       pettil-name.a65           Text parser

;--------------------------------------------------------------
#if 0
name=SKIP
stack=( -- offset )
tags=nosymbol
`addr1` is the starting address in the input stream where up
to `size1` bytes are skipped *WHILE* they match `delim` in `n6`.  Returns
`addr2` as the address of the first non-matching character and
`count2` as the remaining number of bytes in the buffer.
#endif
skip
    lda #$F0                    ; BEQ opcode
    .byt $2C                    ; BIT abs
    ;fall through
;--------------------------------------------------------------
#if 0
name=SCAN
stack=( -- offset )
tags=self-modifying,nosymbol
Pass through the input stream until `delim` either matches (or for `skip`, does not match).  Leave the `offset` into the line buffer on the stack.

N6 line buffer
N7 char delimiter
#endif
scan
    lda #$D0                    ; BNE opcode
    sta skipscan03              ; #selfmodifying
    ldy userin                  ; `in`
    dey
skipscan01
    iny
    cpy userspan                ; Carry true at end of line
    bcc skipscan02
    lda #0
    sta userspan
    lda userblk
    bne skipscan04
    inc userspan+1              ; set end of input semaphore
    bcs skipscan04              ; bra
skipscan02
    lda (ACC+2*N6),y            ; get char from buffer
    eor ACC+2*N7                ; compare to character we seek
skipscan03
    bvc skipscan01              ; dummy opcode, BEQ(skip) BNE(scan)
skipscan04
    sty userin                  ; found char !, move `in`
    tya
    jmp push0a                  ;( offset )

;--------------------------------------------------------------
#if 0
name=EOI?
stack=( -- flag )
tags=primitive,outer,extra,nosymbol
Return `true` when `in` reaches `span` in `skip`/`scan` triggering `eol`

#endif
eoiq
    lda userlin
    cmp #LPERSCR
    bcs eoiq01
    lsr userspan+1
eoiq01
    jmp xpushc

;--------------------------------------------------------------
#if 0
name=LINE.SIZE
stack=( -- size )
tags=outer,extra,nosymbol
* calculate line size  and apply `-trailing` to the current line `lin` when loading.

Return `size` of either a line input from the keyboard
or when loading, set hardware cursor to line# `lin` of `blk`
advances `lin`

```
: line.size   ( sib blk -- sib size|0 )
    blkbuf lin dup cursor c! 40* +            \ (C4)
    lin buf.wrap >bit cbit@
    in 1+ over  ?: 1+! 2+!
    ?: forty eighty  -trailing ; \ D5
: line.size   ( sib blkbuf -- sib size )
    blk@ block                  \ non-traditional lazy-load
                                \ all `load` source routes through here!
                                \ todo: make entry to `block` a primitive
                                \ that exits early with blkbuf|vidram when
                                \ the block is already loaded (prev==blk)
    lin 40* +                   \ $C4

    lin buf.wrap >bit cbit@
    in 1+ over ?: 1+! 2+!
    ?: forty eighty  -trailing ;

: line.size   ( -- size )
    lin cursor 3 !+  lin c!+
    blk@ block lin 40* +  !+
    lin tuck buf.wrap >bit cbit@
    3 cursor ! cursor

firmwarecursor
    ;    $AF   $D5  $C6  ($C4)     $D8
    .byt DFLTN,TBLX,PNTR,PNT,PNT+1,LNMX
    ;    3     0    lin  lin*40    span
    ;                    +blkbuf


: line.size   ( -- size )
    cursor
    3 !+                        \ AF=3 D5=0
    lin c!+                     \ C6=lin
    blk@ block
    lin 40* + !+                \ (C4)
    lin buf.wrap >bit cbit@
    in 1+ over ?: 1+! 2+!
    ?: forty eighty
    tuck 1- c!+ drop            \ D8=39|79
    -trailing ;


: line.size   ( -- size )
    cursor
    3 !+                        \ AF=3 D5=0
    lin c!+                     \ C6=lin
    blk@ block
    lin 40* +
    !+
    >r
    lin buf.wrap >bit cbit@
    in 1+ over ?: 1+! 2+!
    ?: forty eighty
    -trailing r>
    under c! ;
```
#endif
#include "align.i65"
_linesize
    jsr enter
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word cursor
#include "page.i65"
    .word three
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word lin
#include "page.i65"
    .word cstoreplus
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word _block
#include "page.i65"
    .word lin
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word plus
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word tor
#include "page.i65"
    .word lin
#include "page.i65"
    .word _bufwrap
#include "page.i65"
    .word tobit
#include "page.i65"
    .word cbitfetch
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word over
#include "pass.i65"
    .word pquerycolon
    .word oneplusstore
    .word twoplusstore
#include "pass.i65"
    .word pquerycolon
    .word forty
    .word eighty
#include "page.i65"
    .word dashtrailing
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word under
#include "page.i65"
    .word cstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SPAN@
stack=( -- span )
tags=primitive,outer,extra,nosymbol

#endif
spanfetch
    lda userspan
    jmp push0a

;--------------------------------------------------------------
#if 0
name=!NFA
stack=( nfa len -- nfa )
tags=secondary,outer,extra,nosymbol
* set `n8` to len
* set length in line buffer
* increment `in` past space after token

```
: !nfa   ( nfa len -- nfa )
    >n8 over c!  in 1+! ;
```
#endif
#include "align.i65"
_setnfa
    jsr enter
#include "pass.i65"
    .word tozp
    .byt ACC+2*N8               ; name.len
#include "page.i65"
    .word over
#include "page.i65"
    .word cstore
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplusstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME.PARSE
stack=( -- nfa|0 )
tags=secondary,outer,extra,nosymbol

* set n7 delimiter char
* refill the line buffer (if empty)
* skip/scan move `in` past token
* set n8 token length
* put length before text in buffer
* move `in` past trailing space

```
: name.parse   ( -- nfa|0 )
    skip dup 1- <n6 +
    scan rot -
    dup ?: !nfa nip ;

: !nfa
    >n8 over c!  in 1+! ;
```
#endif
#include "align.i65"
_nameparse
    jsr enter
#include "page.i65"
    .word skip                  ; start of name
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6               ; line buffer
#include "page.i65"
    .word plus
#include "page.i65"
    .word scan                  ; end of name (and/or buffer)
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus                 ; length
#include "page.i65"
    .word dup
#include "pass.i65"
    .word pquerycolon
    .word _setnfa
    .word nip
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REFILL.LOADING
stack=( -- )
tags=primitive,outer,extra,nosymbol
Load either `sib` or `tib` with a logical line of input.  An interactive session always return the value 80.  Return value is the width of the line.  Zero will only be returned when `loading?` at the end of a screen.

```
: refill.loading   ( -- )
    begin 0 =cursor
        sib line.size expect
        0 =cursor
        ; true when last line was reached  (span.h=1)
        ; true when a line has text on it  (span.l>0)
        ; false when this line was empty
        span @
    until ;

: line.size   ( -- size )
    blk@ block lin dup 40* +under
    lin buf.wrap >bit cbit@
    in forty (line.size) 1+
    over ?: 1+! 2+! ?: forty eighty -trailing ;

plinesize
    jsr plugh
    jmp next

```
#endif
#include "align.i65"
_refillloading
    jsr enter
#include "page.i65"
refilll01
    .word sib
#include "page.i65"
    .word _linesize             ; ( sib blk -- sib size )
#include "page.i65"
    .word zero
#include "page.i65"
    .word exchgcursor
#include "page.i65"
    .word expect
#include "page.i65"
    .word zero
#include "page.i65"
    .word exchgcursor
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "pass.i65"
    .word qbranch
    .byt <(refilll01-*+1)
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REFILL?
stack=( -- span )
tags=primitive,outer,extra,nosymbol
Load either `sib` or `tib` with a logical line of input.  An interactive session always return the value 80.  Return value is the width of the line.  Zero will only be returned when `loading?` at the end of a screen.

* `refill?` will refill the proper line buffer, if needed
** set `n6` line buffer addr
** return 0 if no more input is available
*** EOL in an interactive session
*** EOS when loading
** otherwise it leaves something useful and non-0, like span

```
: refill?   ( -- span )
    span @ ?dup ?exit           \ early exit? (after setup `n6` line buffer!)
    blk@ ?: refill.loading query
    span@ ;
```
#endif
#include "align.i65"
_refillq
    jsr enter
#include "page.i65"
    .word spanfetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word eoiq
#include "page.i65"
    .word orx
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word blkfetch
#include "pass.i65"
    .word pquerycolon
    .word _refillloading
    .word _query
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME
stack=( char -- nfa|0 )
tags=outer,extra
Parse the next `word` from the `input stream`.  Return `false` if the input stream is exhausted, or returns the `nfa` of the found word, which will be a counted string somewhere in `tib` or `sib`.

Leading delimiters are ignored.   If the delimiter `char` is not found the value of `in` will be the size of the input stream.  If `char` is found, `in` will point to the character following the delimiter. When the end of the input line is reached, `name.parse` clears `span` to let us exit.  Similarly, `line.size` will clear `blk` when `lin` reaches the `height` physical line of `blkbuf` to exit after loading a screen.

This is one of PETTIL's slight departures from the Forth-83 standard.  In PETTIL `name` replaces the //required// reserved word `word`. The reason is that PETTIL uses a lazy loading design while the standard uses active loading.

|What is a WORD?|<|<|h
|1|word|entry in the Forth dictionary|
|2|word|16 bits of memory|
|3|word|an English word|
|4|word|//required// reserved Forth-83 standard word to parse the input stream|
|5|word|things Cameo say before `up`|

Here we see that `word` means (at least) five things, and we are dispensing with one of those (meaning #4) by renaming `word` to `name` and altering the stack diagram slightly.

* set `n6` to `tib`(interactive) or `sib`(loading)
* set `n7` to delimiter char ' '
* `refill?` will refill the line buffer, if needed

* test if line buffer (and screen buffer, if loading) exhausted
* set `n8` length
* return `false` or `nfa`
* Advance `in` past the parsed `word`.


```
: name   ( char -- nfa|0 )
    blk@ ?: sib tib n6 2!
    refill? ?: name.parse false ;
```
#endif
#include "align.i65"
_name
    jsr enter
#include "page.i65"
    .word blkfetch
#include "pass.i65"
    .word pquerycolon
    .word sib
    .word tib
#include "pass.i65"
    .word clit
    .byt ACC+2*N6
#include "page.i65"
    .word twostore                 ; `n7` delim char
#include "page.i65"
    .word _refillq
#include "pass.i65"
    .word pquerycolon
    .word _nameparse
    .word false
#include "pass.i65"
    .word exit

#print (*-skip)
