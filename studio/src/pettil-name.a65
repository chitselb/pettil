; pettil-name.a65
#echo .       pettil-name.a65           Text parser
;" cursor@ cursor! !loading skip scan ?loading 'stream? linesize ?refill name
;" nfa!

;--------------------------------------------------------------
#if 0
name=SKIP
stack=( delim -- offset )
tags=nosymbol
`addr1` is the starting address in the input stream where up
to `size1` bytes are skipped *WHILE* they match `delim`.  Returns
`addr2` as the address of the first non-matching character and
`count2` as the remaining number of bytes in the buffer.
#endif
skip
    lda #$F0                    ; BEQ opcode
    .byt $2C                    ; BIT abs
    ;fall through
;--------------------------------------------------------------
#if 0
name=SCAN
stack=( -- offset )
tags=self-modifying,nosymbol
Pass through the input stream until `delim` either matches (or for `skip`, does not match).  Leave the `offset` into the line buffer on the stack.

N6 line buffer
N7 char delimiter
#endif
scan
    lda #$D0                    ; BNE opcode
    sta skipscan03              ; #selfmodifying
    ldy userin                  ; `in`
    dey
skipscan01
    iny
    cpy userspan                ; Carry true at end of line
    bcc skipscan02
    lda #0                      ; oh, we done
    sta userspan                ; `span off`
;    sta userin
    beq skipscan04
skipscan02
    lda (ACC+2*N6),y            ; get char from buffer
    eor ACC+2*N7                ; compare to character we seek
skipscan03
    bvc skipscan01              ; dummy opcode, BEQ(skip) BNE(scan)
skipscan04
    sty userin                  ; found char !, move `in`
    tya
    jmp push0a                  ;( offset )

;--------------------------------------------------------------
#if 0
name=?LOADING
stack=( -- )
tags=outer,extra,nosymbol
If loading, restore the cursor and increment `lin` etc.. This executes just after `sib` line input buffer was filled by `expect`


```
: ?loading   ( -- )
    blk@ 0= ?exit
    r>
    cursor!
    >r ;

    in 1+ 1+!
    lin  height @
```
#endif
#include "align.i65"
_qloading
    jsr enter
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word cursorstore
#include "page.i65"
    .word tor
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LINESIZE
stack=( -- size )
tags=outer,extra,nosymbol
Return `size` of either a line input from the keyboard
or when loading, set hardware cursor to line# `lin` of `blk`
advances `lin`

```
: line.size   ( -- size )
    cursor@ <n6 block lin 40* +
    lin buf.wrap >bit cbit@
    in 1+ over ?: 1+! 2+!
    ?: 40 80
    -trailing ;

: line.size   ( -- size )
    <n6 block lin 40* +
    lin buf.wrap >bit cbit@
    in 1+ over ?: 1+! 2+!
    ?: 40 80
    -trailing ;
```
#endif
#include "align.i65"
_linesize
    jsr enter
#include "page.i65"
    .word cursorfetch
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6
#include "page.i65"
    .word swap
#include "page.i65"
    .word _block
#include "page.i65"
    .word lin
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word plus                  ;( addr )
#include "page.i65"
    .word lin
#include "page.i65"
    .word _bufwrap
#include "page.i65"
    .word tobit
#include "page.i65"
    .word cbitfetch             ;( addr wrapbit )
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word over
#include "page.i65"
    .word pquerycolon
    .word oneplusstore
    .word twoplusstore
#include "pass.i65"
    .word pquerycolon
    .word forty
    .word eighty
#include "page.i65"
    .word dashtrailing
#include "page.i65"
    .word setloading
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?REFILL
stack=( -- )
tags=primitive,outer,extra,nosymbol
Load either `sib` or `tib` with a logical line of input.

```
: ?refill   ( -- )
    span @ ?exit
    blk@ ?: sib tib  >n6        ( _ib )
    blk@ ?dup ?: line.size eighty    ( _ib size )
    expect
    ?loading ;
```
#endif
#include "align.i65"
_qrefill
    jsr enter
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _qexit                ; exit if something is in this line buffer?
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6               ; line buffer address sib|tib
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word pquerycolon
    .word _linesize             ; ( sib blk -- sib size )
    .word eighty                ; ( tib -- tib 80 )
#include "page.i65"
    .word expect
#include "page.i65"
    .word _qloading
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PARSENAME
stack=( -- nfa|0 )
tags=secondary,outer,extra,nosymbol

* set n6 line buffer addr
* set n7 delimiter char
* refill the line buffer (if empty)
* skip/scan move `in` past token
* set n8 token length
* put length before text in buffer
* move `in` past trailing space

```
: parsename   ( -- nfa|0 )
    skip dup 1- <n6 +
    scan rot - >n8
    over c!  in 1+! ;
```
#endif
#include "align.i65"
_parsename
    jsr enter
#include "page.i65"
    .word skip                  ; start of name
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N6               ; buf
#include "page.i65"
    .word plus
#include "page.i65"
    .word scan                  ; end of name (and/or buffer)
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus                 ; length
#include "page.i65"
    .word dup
#include "pass.i65"
    .word pquerycolon
    .word _setnfa
    .word nip
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=!NFA
stack=( char -- nfa|0 )
tags=secondary,outer,extra,nosymbol
* set `n8` to len
* set length in line buffer
* increment `in` past space after token

```
: !nfa   ( nfa len -- nfa )
    >n8 over c!  in 1+! ;
```
#endif
#include "align.i65"
_setnfa
    jsr enter
#include "pass.i65"
    .word tozp
    .byt ACC+2*N8               ; name.len
#include "page.i65"
    .word over
#include "page.i65"
    .word cstore
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplusstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME
stack=( char -- nfa|0 )
tags=outer,extra
Parse the next `word` from the `input stream`.  Return `false` if the input stream is exhausted, or returns the `nfa` of the found word, which will be a counted string somewhere in `tib` or `sib`.

Leading delimiters are ignored.   If the delimiter `char` is not found the value of `in` will be the size of the input stream.  If `char` is found, `in` will point to the character following the delimiter. When the end of the input line is reached, `parsename` clears `span` to let us exit.  Similarly, `line.size` will clear `blk` when `lin` reaches the `height` physical line of `blkbuf` to exit after loading a screen.

This is one of PETTIL's slight departures from the Forth-83 standard.  In PETTIL `name` replaces the //required// reserved word `word`. The reason is that PETTIL uses a lazy loading design while the standard uses active loading.

|What is a WORD?|<|<|h
|1|word|entry in the Forth dictionary|
|2|word|16 bits of memory|
|3|word|an English word|
|4|word|//required// reserved Forth-83 standard word to parse the input stream|
|5|word|things Cameo say before `up`|

Here we see that `word` means (at least) five things, and we are dispensing with one of those (meaning #4) by renaming `word` to `name` and altering the stack diagram slightly.

* set `n6` line buffer addr
* set `n7` delimiter char
* refill the line buffer (if empty)
* test if line buffer (and screen buffer, if loading) exhausted
* set `n8` length
* return `false` or `nfa`
* Advance `in` past the parsed `word`.

```
: name   ( char -- nfa|0 )
    blk@ ?: sib tib  n6 2!
    ?refill
    blk@ span @ or
    ?: parsename 0 ;
```
#endif
#include "align.i65"
_name
    jsr enter
#include "page.i65"
    .word blkfetch
#include "pass.i65"
    .word pquerycolon
    .word sib
    .word tib
#include "pass.i65"
    .word clit
    .byt ACC+2*N6               ; `n6` line input buffer (`sib` or `tib`)
#include "page.i65"
    .word twostore              ; `n7` delim char
#include "page.i65"
    .word _qrefill
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word span
#include "page.i65"
    .word fetch
#include "page.i65"
    .word orx
#include "pass.i65"
    .word pquerycolon
    .word _parsename
    .word zero
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CURSOR@
stack=( -- )
tags=primitive,extra,nosymbol
Stash hardware cursor to return stack

#endif
cursorfetch
    lda PNT+1
    pha
    lda PNT
    pha
    lda PNTR
    pha
    lda LNMX
    pha
    lda TBLX
    pha
    lda DFLTN
    pha
    jmp next

;--------------------------------------------------------------
#if 0
name=CURSOR!
stack=( -- )
tags=primitive,extra
Restore hardware cursor from return stack

#endif
cursorstore
    pla
    sta DFLTN
    pla
    sta TBLX
    pla
    sta LNMX
    pla
    sta PNTR
    pla
    sta PNT
    pla
    sta PNT+1
    jmp next

;--------------------------------------------------------------
#if 0
name=!LOADING
stack=( -- )
tags=primitive,outer,extra,nosymbol
Return `size` of either a line input from the keyboard
or when loading, set hardware cursor to line# `lin` of `blk`
advances `lin`

#endif
setloading
    lda #3
    sta DFLTN                   ; $AF Default Input Device
    lda userlin
    cmp userheight
    bcc setloading01
    lda #0
    sta userblk                 ; end of screen reached
setloading01
    sta TBLX                    ; $D8 cursor physical line number
    lda tos
    sta LNMX                    ; $D5 logical line length (39 or 79)
    lda userin
    sta PNTR                    ; $C6 cursor column on current line
    lda stackl,x
    sta PNT                     ; ($C4) pointer start of current screen line
    lda stackh,x
    sta PNT+1
    jmp next

#print (*-skip)
