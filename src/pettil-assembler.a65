; pettil-assembler.a65
#echo .       pettil-assembler.a65      ASSEMBLER Vocabulary (1)

; >FORTH,
;
; compiles a page-aligned jsr toforth

;--------------------------------------------------------------
#if 0
name=ASSEMBLER
stack=( -- )
tags=vocabulary,ext
Sets context to the ASSEMBLER vocabulary
#endif
#include "align.i65"
assembler
    jsr dovocab
    .byt 1                  ; vocabulary identifier

;--------------------------------------------------------------
#if 0
name=XSAVE
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
place to stash the X register

```
ff cconstant xsave
```
#endif
#include "align.i65"
asmxsave
    jsr docconst
    .byt $ff

;--------------------------------------------------------------
#if 0
name=UP
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
User pointer, points to the user variable area

```
84 cconstant up
```
#endif
#include "align.i65"
asmup
    jsr docconst
    .byt <up

;--------------------------------------------------------------
#if 0
name=IP
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
Forth instruction pointer

```
8b cconstant ip
```
#endif
#include "align.i65"
asmip
    jsr docconst
    .byt <ip

;--------------------------------------------------------------
#if 0
name=N
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
N area, a scratch space for primitives

```
4 cconstant n
```
#endif
#include "align.i65"
asmn
    jsr docconst
    .byt <n

;--------------------------------------------------------------
#if 0
name=TOS
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
Top of stack

```
2 cconstant tos
```
#endif
#include "align.i65"
asmtos
    jsr docconst
    .byt <tos

;--------------------------------------------------------------
#if 0
name=STACKL
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
Stack low order side
#endif
#include "align.i65"
asmstackl
    jsr docconst
    .byt <stackl

;--------------------------------------------------------------
#if 0
name=STACKH
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
Stack high order side
#endif
#include "align.i65"
asmstackh
    jsr docconst
    .byt <stackh

;--------------------------------------------------------------
#if 0
name=NEXT
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
Address of NEXT routine

```
86 cconstant next
```
#endif
#include "align.i65"
asmnext
    jsr docconst
    .byt <next

;--------------------------------------------------------------
#if 0
name=POP
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
Address of POP routine
#endif
#include "align.i65"
asmpop
    jsr doconst
    .word drop

;--------------------------------------------------------------
#if 0
name=POPTWO
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
Address of POPTWO routine
#endif
#include "align.i65"
asmpoptwo
    jsr doconst
    .word twodrop

;--------------------------------------------------------------
#if 0
name=PUT
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
Address of NEXT routine

```
86 cconstant next
```
#endif
#include "align.i65"
asmput
    jsr doconst
    .word put

;--------------------------------------------------------------
#if 0
name=PUSHYA
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
Address of PUSHYA routine
#endif
#include "align.i65"
asmpushya
    jsr doconst
    .word pushya

;--------------------------------------------------------------
#if 0
name=LOCALS
stack=( -- n )
tags=vocabulary,ext
vocab=1
!!!Assembler constant
Address of LOCALS routine
#endif
#include "align.i65"
asmlocals
    jsr doconst
    .word locals

;--------------------------------------------------------------
#if 0
name=ASMINDEX
stack=( -- n )
tags=assembler,ext,nosymbol
vocab=1
!!!Assembler constant
Table of addressing modes
#endif
asmindex
    .byt $09,$09,$05,$15,$15,$01,$11,$80
    .byt $09,$80,$0d,$1d,$19,$80,$80,$80
    .byt $80,$00,$04,$14,$14,$80,$80,$80
    .byt $80,$80,$0c,$1c,$1c,$80,$80,$2c

;--------------------------------------------------------------
#if 0
name=MODE
stack=( -- n )
tags=vocabulary,ext,nosymbol
vocab=1
!!!Assembler variable
Current addressing mode
#endif
#include "align.i65"
asmmode
    jsr docreate
    .word 2                 ; variable mode  2 mode !

;--------------------------------------------------------------
#if 0
name=doasmmode
stack=( -- )
tags=vocabulary,ext,nosymbol
vocab=1
!!!Subroutine
Set the addressing mode
#endif
#include "align.i65"
_doasmmode
    jsr enter
#include "page.i65"
    .word _caller
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word asmmode
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=docpu
stack=( -- )
tags=vocabulary,ext,nosymbol
vocab=1
!!!Assembler mode
Indirect addressing mode
#endif
#include "align.i65"
_docpu
    jsr enter
#include "page.i65"
    .word _caller
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word one
#include "page.i65"
    .word _instrcomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=INSTR,
stack=( [ operand ... ] opcode 0|1|2|3 -- )
tags=assembler,nosymbol
vocab=1
encloses the instruction and 0, 1 or 2 bytes of operand


```
 : instr,
    0 do
        c,
    loop ;
```
#endif
#include "align.i65"
_instrcomma
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word pdo
    .byt <(instrcomma02-*+1)
#include "pad.i65"
instrcomma01
    .word _ccomma
#include "page.i65"
    .word ploop
    .byt <(instrcomma01-*+1)
#include "pad.i65"
instrcomma02
    .word asmmem
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DECODE
stack=( addr-1 --  [ [arghi] arglo] opcode n )
tags=assembler,nosymbol
vocab=1
Adjusts the addressing mode
determines the instruction
encloses the instruction and 0, 1 or 2 bytes of operand
#endif
decode
    brk
    .byt ldi | TOS      ; n+0=opcode base
    .byt st | N0
    .byt ldd | TOS
    .byt st | N1        ; n+2=modes.lsb n+3=modes.msb
    .byt sub | ACC
    .byt push
    .byt push           ; TOS=0; 2OS=0; 3OS=junk; [4OS=arg]
    .byt rtn
                        ; y = 0..3  instruction group
                        ;  0 | 1  right side (odd) is 16-bit
                        ; ---+--- left side is 8-bit
                        ;  2 | 3  bottom half has $8x modes.lsb
decode00
    ldy #2              ; assume bottom half
    sty tos             ; assume 16-bit
    lda n+2             ; the lsb of the modes, please
    bmi decode01        ; $8x? (group 2,3)
    ldy #0
    lsr
    bcc decode02
    sty tos
    inx                 ; .A mode, no arguments
    bne decode05        ; bra (quadrant 0)
decode01
    asl
    beq decode03        ; JMP or JSR? 16-bit (quadrant 3)
decode02
    lda stackh+2,x
    beq decode04        ; 8-bit?
decode03
    lda stackl+2,x
    sta stackl+1,x
    lda stackh+2,x
    sta stackl+2,x      ; TOS=0; 2OS=junk; 3OS=arg16.lo; 4OS=arg16.hi
    iny
    bne decode05
decode04
    dec tos             ; left side, 1 argument
    inx                 ; TOS=0; 2OS=junk; 3OS=arg8
decode05
    tya
    asl
    asl
    asl
    ;clc
    ora asmmode+3
    tay
    lda asmindex,y
    bpl decode06
    lda #11                 ; "BAD ADDRESSING MODE"
    jmp error
decode06
    adc n
    sta stackl,x
    inc tos
decode07
    jmp next

;--------------------------------------------------------------
#if 0
name=M/CPU
stack=( -- )
tags=assembler,nosymbol
vocab=1
Adjusts the addressing mode
determines the instruction
encloses the instruction and 0, 1 or 2 bytes of operand

```
: m/cpu  create c, , does>
    dup 1+ @ 80 and
    if
        10 mode +!
    then
    over
    ff00 and upmode upmode
    if
        mem cr latest id.
        abort" has incorrect address mode"
    then
    c@ mode c@
    index + c@ + c,  mode c@ 7 and
    if
        mode c@
        0f and 7 <
        if
            c,
        else
            ,
        then
    then
    mem ;

: m/cpu  create c, , does>
    2r> >r  decode  instr, ;
```
#endif
#include "align.i65"
_domcpu
    jsr enter
#include "page.i65"
    .word _caller
#include "page.i65"
    .word decode
#include "page.i65"
    .word _instrcomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BEGIN,
stack=( -- )
tags=vocabulary,ext
flags=immediate
vocab=1
```
: begin,   here 1 ; immediate
```
#endif
#include "align.i65"
_asmbegin
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word one
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UNTIL,
stack=( -- )
tags=vocabulary,ext
flags=immediate
vocab=1
```
: until,   >r 1 ?pairs r> c, here 1+ - c, ; immediate
```
#endif
#include "align.i65"
_asmuntil
    jsr enter
#include "page.i65"
    .word tor
#include "page.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word here
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word minus
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=IF,
stack=( -- )
tags=vocabulary,ext
flags=immediate
vocab=1
```
: if,   c, here 0 c, 3 ; immediate
```
#endif
#include "align.i65"
_asmif
    jsr enter
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word here
#include "page.i65"
    .word zero
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word three
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=THEN,
stack=( -- )
tags=vocabulary,ext
flags=immediate
vocab=1
```
: then,   abs 3 ?pairs here over c@
    if swap ! else over 1+ - swap c! then ; immediate
```
#endif
#include "align.i65"
_asmthen
    jsr enter
#include "page.i65"
    .word abs
#include "page.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word here
#include "page.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word qbranch
    .byt <(asmthen01-*+1)
#include "pad.i65"
    .word over
#include "page.i65"
    .word branch
    .byt <(asmthen02-*+1)
#include "page.i65"
asmthen01
    .word over
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cstore
#include "page.i65"
asmthen02
    .word exit

;--------------------------------------------------------------
#if 0
name=ELSE,
stack=( -- )
tags=vocabulary,ext
flags=immediate
vocab=1
```
: else,   3 ?pairs here 1+   1 jmp,
    swap here over 1+ - swap c! -3 ; immediate
```
#endif
#include "align.i65"
_asmelse
    jsr enter
#include "page.i65"
    .word three
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word here
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word one
#include "page.i65"
    .word ijmp
#include "page.i65"
    .word swap
#include "page.i65"
    .word here
#include "page.i65"
    .word over
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word minus
#include "page.i65"
    .word swap
#include "page.i65"
    .word cstore
#include "page.i65"
    .word minusthree
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=AGAIN,
stack=( -- )
tags=vocabulary,ext
flags=immediate
vocab=1
```
: again,   1 ?pairs jmp, ; immediate
```
#endif
#include "align.i65"
_asmagain
    jsr enter
#include "page.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word ijmp
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WHILE,
stack=( -- )
tags=vocabulary,ext
flags=immediate
vocab=1
```
: while,   >r dup 1 ?pairs r> [compile] if, 2+ ; immediate
```
#endif
#include "align.i65"
_asmwhile
    jsr enter
#include "page.i65"
    .word tor
#include "page.i65"
    .word dup
#include "page.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word _compile
    .word _asmif
#include "pad.i65"
    .word twoplus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REPEAT,
stack=( -- )
tags=vocabulary,ext
flags=immediate
vocab=1
```
: repeat,   >r >r 1 ?pairs jmp,
    r> r> 2- [compile] then, ; immediate
```
#endif
#include "align.i65"
_asmrepeat
    jsr enter
#include "page.i65"
    .word twotor
#include "page.i65"
    .word one
#include "page.i65"
    .word _qpairs
#include "page.i65"
    .word ijmp
#include "page.i65"
    .word tworfrom
#include "page.i65"
    .word twominus
#include "page.i65"
    .word _compile
    .word _asmthen
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NOT
stack=( -- )
tags=vocabulary,ext
vocab=1
```
: not   20 + ;  ( reverse assembly test )
```
#endif
#include "align.i65"
_asmnot
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CS
stack=( "name" -- )
tags=vocabulary,ext
vocab=1
```
90 cconstant cs ( assembler test for carry set )
```
#endif
#include "align.i65"
_asmcs
    jsr docconst
    .byt $90

;--------------------------------------------------------------
#if 0
name=0=
stack=( -- )
tags=vocabulary,ext
vocab=1
```
d0 cconstant 0= ( assembler test for equal zero )
```
#endif
#include "align.i65"
asmzeq
    jsr docconst
    .byt $d0

;--------------------------------------------------------------
#if 0
name=0<
stack=( -- )
tags=vocabulary,ext
vocab=1
```
10 cconstant 0< ( assembler test for less than or equal zero )
```
#endif
#include "align.i65"
asmzlt
    jsr docconst
    .byt $10

;--------------------------------------------------------------
#if 0
name=>=
stack=( -- )
tags=vocabulary,ext
vocab=1
```
90 cconstant >= ( assembler test for greater or equal zero )
                  ( >= is only correct after sub, or cmp, )
```
#endif
#include "align.i65"
asmge
    jsr docconst
    .byt $90

;--------------------------------------------------------------
#if 0
name=VS
stack=( -- )
tags=vocabulary,ext
vocab=1
```
50 cconstant vs ( assembler test for overflow set )
```
#endif
#include "align.i65"
asmvs
    jsr docconst
    .byt $50

;--------------------------------------------------------------
#if 0
name=CODE-SETUP
stack=( "name" -- )
tags=vocabulary,ext,nosymbol
vocab=1
Creates a symbol table header for a new assembler definition
#endif
#include "align.i65"
_codesetup
    jsr enter
#include "page.i65"
    .word redefined
#include "page.i65"
    .word off                   ; turn REDEFINED off before (CREATE)
#include "page.i65"
    .word here
#include "page.i65"
    .word _pcreate
#include "page.i65"
    .word minusthree
#include "page.i65"
    .word _allot
#include "page.i65"
    .word _latest
#include "page.i65"
    .word smudge
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CODE-FIXUP
stack=( -- )
tags=vocabulary,ext,nosymbol
vocab=1
Adjusts `LATEST` symbol to behave as a new assembler definition
#endif
#include "align.i65"
_codefixup
    jsr enter
#include "page.i65"
    .word _hex
#include "page.i65"
    .word storecsp
#include "page.i65"
    .word assembler
#include "page.i65"
    .word asmmem
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CODE
stack=( "name" -- )
tags=vocabulary,ext
Create a new (smudged) name and invoke the assembler vocabulary
#endif
#include "align.i65"
_code
    jsr enter
#include "page.i65"
    .word _codesetup
#include "page.i65"
    .word _codefixup
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(;CODE)
stack=( -- )
tags=compiler,nosymbol
vocab=1
#endif
#include "align.i65"
_psemicode
    jsr enter
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _latest
#include "page.i65"
    .word namefrom
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=;CODE
stack=( -- )
tags=compiler,unimplemented
flags=immediate
vocab=1
#endif
#include "align.i65"
_semicode
    jsr enter
#include "page.i65"
    .word _qcomp
#include "page.i65"
    .word _compile
    .word _psemicode
#include "pad.i65"
    .word _closedefinition
#include "page.i65"
    .word _codefixup
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=END-CODE
stack=( "name" -- )
vocab=1
tags=vocabulary,ext
vocab=1
Remove [[ASSEMBLER]] vocabulary from VSTACK.  Does this by
(re)invoking the [[ASSEMBLER]] vocabulary to make it the
first one in [[VSTACK]], then sliding the rest of [[VSTACK]]
backward to overwrite it.

```
: end-code   ( -- )
    close-definition assembler vdrop ;
```
#endif
#include "align.i65"
_endcode
    jsr enter
#include "page.i65"
    .word _closedefinition
#include "page.i65"
    .word assembler             ; force assembler to front
#include "page.i65"
    .word _vdrop                ; and drop it
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.A
stack=( -- )
tags=vocabulary,ext
vocab=1
!!!Assembler mode
Accumulator addressing mode
#endif
#include "align.i65"
asmdota
    jsr _doasmmode
    .byt 0

;--------------------------------------------------------------
#if 0
name=#
stack=( -- )
tags=vocabulary,ext
vocab=1
!!!Assembler mode
Immediate addressing mode
#endif
#include "align.i65"
asmimm
    jsr _doasmmode
    .byt 1

;--------------------------------------------------------------
#if 0
name=MEM
stack=( -- )
tags=vocabulary,ext
vocab=1
!!!Assembler mode
Memory addressing mode (absolute or zeropage)
#endif
#include "align.i65"
asmmem
    jsr _doasmmode
    .byt 2

;--------------------------------------------------------------
#if 0
name=,X
stack=( -- )
tags=vocabulary,ext
vocab=1
!!!Assembler mode
Indexed X addressing mode
#endif
#include "align.i65"
asmindexx
    jsr _doasmmode
    .byt 3

;--------------------------------------------------------------
#if 0
name=,Y
stack=( -- )
tags=vocabulary,ext
vocab=1
!!!Assembler mode
Indexed Y addressing mode
#endif
#include "align.i65"
asmindexy
    jsr _doasmmode
    .byt 4

;--------------------------------------------------------------
#if 0
name=X)
stack=( -- )
tags=vocabulary,ext
vocab=1
!!!Assembler mode
Indirect X addressing mode
#endif
#include "align.i65"
asmindirx
    jsr _doasmmode
    .byt 5

;--------------------------------------------------------------
#if 0
name=)Y
stack=( -- )
tags=vocabulary,ext
vocab=1
!!!Assembler mode
Indirect-Y addressing mode
#endif
#include "align.i65"
asmindiry
    jsr _doasmmode
    .byt 6

;--------------------------------------------------------------
#if 0
name=)
stack=( -- )
tags=vocabulary,ext
vocab=1
!!!Assembler mode
Indirect addressing mode
#endif
#include "align.i65"
asmindir
    jsr _doasmmode
    .byt $0f

;--------------------------------------------------------------
#if 0
name=BRK,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a BRK opcode
#endif
#include "align.i65"
ibrk
    jsr _docpu
    .byt $00

;--------------------------------------------------------------
#if 0
name=CLC,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a CLC opcode
#endif
#include "align.i65"
iclc
    jsr _docpu
    .byt $18

;--------------------------------------------------------------
#if 0
name=CLD,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a CLD opcode
#endif
#include "align.i65"
icld
    jsr _docpu
    .byt $d8

;--------------------------------------------------------------
#if 0
name=CLI,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a CLI opcode
#endif
#include "align.i65"
icli
    jsr _docpu
    .byt $58

;--------------------------------------------------------------
#if 0
name=CLV,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a CLV opcode
#endif
#include "align.i65"
iclv
    jsr _docpu
    .byt $b8

;--------------------------------------------------------------
#if 0
name=DEX,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a DEX opcode
#endif
#include "align.i65"
idex
    jsr _docpu
    .byt $ca

;--------------------------------------------------------------
#if 0
name=DEY,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a DEY opcode
#endif
#include "align.i65"
idey
    jsr _docpu
    .byt $88

;--------------------------------------------------------------
#if 0
name=INX,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a INX opcode
#endif
#include "align.i65"
iinx
    jsr _docpu
    .byt $e8

;--------------------------------------------------------------
#if 0
name=INY,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a INY opcode
#endif
#include "align.i65"
iiny
    jsr _docpu
    .byt $c8

;--------------------------------------------------------------
#if 0
name=NOP,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a NOP opcode
#endif
#include "align.i65"
inop
    jsr _docpu
    .byt $ea

;--------------------------------------------------------------
#if 0
name=PHA,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a PHA opcode
#endif
#include "align.i65"
ipha
    jsr _docpu
    .byt $48

;--------------------------------------------------------------
#if 0
name=PHP,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a PHP opcode
#endif
#include "align.i65"
iphp
    jsr _docpu
    .byt $08

;--------------------------------------------------------------
#if 0
name=PLA,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a PLA opcode
#endif
#include "align.i65"
ipla
    jsr _docpu
    .byt $68

;--------------------------------------------------------------
#if 0
name=PLP,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a PLP opcode
#endif
#include "align.i65"
iplp
    jsr _docpu
    .byt $28

;--------------------------------------------------------------
#if 0
name=RTI,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a RTI opcode
#endif
#include "align.i65"
irti
    jsr _docpu
    .byt $40

;--------------------------------------------------------------
#if 0
name=RTS,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a RTS opcode
#endif
#include "align.i65"
irts
    jsr _docpu
    .byt $60

;--------------------------------------------------------------
#if 0
name=SEC,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a SEC opcode
#endif
#include "align.i65"
isec
    jsr _docpu
    .byt $38

;--------------------------------------------------------------
#if 0
name=SED,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a SED opcode
#endif
#include "align.i65"
ised
    jsr _docpu
    .byt $f8

;--------------------------------------------------------------
#if 0
name=SEI,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a SEI opcode
#endif
#include "align.i65"
isei
    jsr _docpu
    .byt $78

;--------------------------------------------------------------
#if 0
name=TAX,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a TAX opcode
#endif
#include "align.i65"
itax
    jsr _docpu
    .byt $aa

;--------------------------------------------------------------
#if 0
name=TAY,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a TAY opcode
#endif
#include "align.i65"
itay
    jsr _docpu
    .byt $a8

;--------------------------------------------------------------
#if 0
name=TSX,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a TSX opcode
#endif
#include "align.i65"
itsx
    jsr _docpu
    .byt $ba

;--------------------------------------------------------------
#if 0
name=TXA,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a TXA opcode
#endif
#include "align.i65"
itxa
    jsr _docpu
    .byt $8a

;--------------------------------------------------------------
#if 0
name=TXS,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a TXS opcode
#endif
#include "align.i65"
itxs
    jsr _docpu
    .byt $9a

;--------------------------------------------------------------
#if 0
name=TYA,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a TYA opcode
#endif
#include "align.i65"
itya
    jsr _docpu
    .byt $98

;--------------------------------------------------------------
#if 0
name=ADC,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a ADC opcode
#endif
#include "align.i65"
iadc
    jsr _domcpu
    .byt $60
    .word $1c6e

;--------------------------------------------------------------
#if 0
name=AND,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a AND opcode
#endif
#include "align.i65"
iand
    jsr _domcpu
    .byt $20
    .word $1c6e

;--------------------------------------------------------------
#if 0
name=CMP,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a CMP opcode
#endif
#include "align.i65"
icmp
    jsr _domcpu
    .byt $c0
    .word $1c6e

;--------------------------------------------------------------
#if 0
name=EOR,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a EOR opcode
#endif
#include "align.i65"
ieor
    jsr _domcpu
    .byt $40
    .word $1c6e

;--------------------------------------------------------------
#if 0
name=LDA,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a LDA opcode
#endif
#include "align.i65"
ilda
    jsr _domcpu
    .byt $a0
    .word $1c6e

;--------------------------------------------------------------
#if 0
name=ORA,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a ORA opcode
#endif
#include "align.i65"
iora
    jsr _domcpu
    .byt $00
    .word $1c6e

;--------------------------------------------------------------
#if 0
name=SBC,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a SBC opcode
#endif
#include "align.i65"
isbc
    jsr _domcpu
    .byt $e0
    .word $1c6e

;--------------------------------------------------------------
#if 0
name=STA,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a STA opcode
#endif
#include "align.i65"
ista
    jsr _domcpu
    .byt $80
    .word $1c6c

;--------------------------------------------------------------
#if 0
name=ASL,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a ASL opcode
#endif
#include "align.i65"
iasl
    jsr _domcpu
    .byt $01
    .word $0d0d

;--------------------------------------------------------------
#if 0
name=DEC,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a DEC opcode
#endif
#include "align.i65"
idec
    jsr _domcpu
    .byt $c1
    .word $0c0c

;--------------------------------------------------------------
#if 0
name=INC,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a INC opcode
#endif
#include "align.i65"
iinc
    jsr _domcpu
    .byt $e1
    .word $0c0c

;--------------------------------------------------------------
#if 0
name=LSR,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a LSR opcode
#endif
#include "align.i65"
ilsr
    jsr _domcpu
    .byt $41
    .word $0d0d

;--------------------------------------------------------------
#if 0
name=ROL,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a ROL opcode
#endif
#include "align.i65"
irol
    jsr _domcpu
    .byt $21
    .word $0d0d

;--------------------------------------------------------------
#if 0
name=ROR,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a ROR opcode
#endif
#include "align.i65"
iror
    jsr _domcpu
    .byt $61
    .word $0d0d

;--------------------------------------------------------------
#if 0
name=STX,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a STX opcode
#endif
#include "align.i65"
istx
    jsr _domcpu
    .byt $81
    .word $0414

;--------------------------------------------------------------
#if 0
name=CPX,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a CPX opcode
#endif
#include "align.i65"
icpx
    jsr _domcpu
    .byt $e0
    .word $0414

;--------------------------------------------------------------
#if 0
name=CPY,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a CPY opcode
#endif
#include "align.i65"
icpy
    jsr _domcpu
    .byt $c0
    .word $0414

;--------------------------------------------------------------
#if 0
name=LDX,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a LDX opcode
#endif
#include "align.i65"
ildx
    jsr _domcpu
    .byt $a2
    .word $1496

;--------------------------------------------------------------
#if 0
name=LDY,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a LDY opcode
#endif
#include "align.i65"
ildy
    jsr _domcpu
    .byt $a0
    .word $0c8e

;--------------------------------------------------------------
#if 0
name=STY,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a STY opcode
#endif
#include "align.i65"
isty
    jsr _domcpu
    .byt $80
    .word $048c

;--------------------------------------------------------------
#if 0
name=JSR,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a JSR opcode
#endif
#include "align.i65"
ijsr
    jsr _domcpu
    .byt $14
    .word $0480

;--------------------------------------------------------------
#if 0
name=JMP,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a JMP opcode
#endif
#include "align.i65"
ijmp
    jsr _domcpu
    .byt $40
    .word $8480

;--------------------------------------------------------------
#if 0
name=BIT,
stack=( -- )
tags=assembler
vocab=1
!!!Assembler instruction
compiles a BIT opcode
#endif
#include "align.i65"
ibit
    jsr _domcpu
    .byt $20
    .word $0484


;" -----------------------
;"
;" : m/cpu  create c, , does>
;"     dup 1+ @ 80 and  if 10 mode +! then over
;"     ff00 and upmode upmode  if mem cr latest id.
;"     abort" has incorrect address mode" then c@ mode c@
;"     index + c@ + c,  mode c@ 7 and if mode x@
;"     0f and 7 < if c, else , then then mem ;
;"
;"   1c6e 60 m/cpu adc,  1c6e 20 m/cpu and,  1c6e c0 m/cpu cmp,
;"   1c6e 40 m/cpu eor,  1c6e a0 m/cpu lda,  1c6e 00 m/cpu ora,
;"   1c6e e0 m/cpu sbc,  1c6c 80 m/cpu sta,  0d0d 01 m/cpu asl,
;"   0c0c c1 m/cpu dec,  0c0c e1 m/cpu inc,  0d0d 41 m/cpu lsr,
;"   0d0d 21 m/cpu rol,  0d0d 61 m/cpu ror,  0414 81 m/cpu stx,
;"   0486 e0 m/cpu cpx,  0486 c0 m/cpu cpy,  1496 a2 m/cpu ldx,
;"   0c8e a0 m/cpu ldy,  048c 80 m/cpu sty,  0480 14 m/cpu jsr,
;"   8480 40 m/cpu jmp,  0484 20 m/cpu bit,
;"



;--------------------------------------------------------------
;" retyped from Blazin' Forth source screens 24-30, there may be some typos
;"
;" hex
;" vocabulary assembler
;" assembler definitions
;"  ( registers )
;" 8b constant xsave
;" 87 constant w
;" 89 constant up
;" 84 constant ip
;" 7c constant n
;"
;" (forth kernel locations )
;" 0957 constant pop
;" 0955 constant poptwo
;" 084c constant put
;" 084a constant push
;" 0851 constant next
;" 0879 constant setup
;"
;" -----------------------
;"
;" variable index -2 allot
;" 0909 , 1505 , 0115 , 8011 , 8009 , 1d0d , 8019 , 8080 ,
;" 0080 , 1404 , 8014 , 8080 , 8080 , 1c0c , 801c , 2c80 ,
;" variable mode  2 mode !
;" : .a  0 mode ! ; : #   1 mode ! ;  : mem 2 mode ! ;
;" : ,x  3 mode ! ; : ,y  4 mode ! ; : x)  5 mode ! ;
;" : )Y  6 mode ! ; : )   f mode ! ;
;"
;" : bot ,x 0 ;  ( address the bottom of the stack )
;" : sec ,x 2 ;  ( address the second item on data stack )
;" : rp) ,x 101 ;  ( address bottom of return stack )
;"
;" -----------------------
;"
;" : upmode  if  mode @ 8 and 0=  if 8 mode +!  then then
;"     1 mode @ 0f and  0 ?do dup + loop
;"     over 1+ @ and 0= ;
;" : cpu   create c, does> c@ c, mem ;
;"   00 cpu brk,  18 cpu clc,  d8 cpu cld,  58 cpu cli,
;"   b8 cpu clv,  ca cpu dex,  88 cpu dey,  e8 cpu inx,
;"   c8 cpu iny,  ea cpu nop,  48 cpu pha,  08 cpu php,
;"   68 cpu pla,  28 cpu plp,  40 cpu rti,  60 cpu rts,
;"   38 cpu sec,  f8 cpu sed,  78 cpu sei,  aa cpu tax,
;"   a8 cpu tay,  ba cpu tsx,  8a cpu txa,  9a cpu txs,
;"   98 cpu tya,
;"
;" -----------------------
;"
;" : m/cpu  create c, , does>
;"     dup 1+ @ 80 and  if 10 mode +! then over
;"     ff00 and upmode upmode  if mem cr latest id.
;"     abort" has incorrect address mode" then c@ mode c@
;"     index + c@ + c,  mode c@ 7 and if mode x@
;"     0f and 7 < if c, else , then then mem ;
;"
;"   1c6e 60 m/cpu adc,  1c6e 20 m/cpu and,  1c6e c0 m/cpu cmp,
;"   1c6e 40 m/cpu eor,  1c6e a0 m/cpu lda,  1c6e 00 m/cpu ora,
;"   1c6e e0 m/cpu sbc,  1c6c 80 m/cpu sta,  0d0d 01 m/cpu asl,
;"   0c0c c1 m/cpu dec,  0c0c e1 m/cpu inc,  0d0d 41 m/cpu lsr,
;"   0d0d 21 m/cpu rol,  0d0d 61 m/cpu ror,  0414 81 m/cpu stx,
;"   0486 e0 m/cpu cpx,  0486 c0 m/cpu cpy,  1496 a2 m/cpu ldx,
;"   0c8e a0 m/cpu ldy,  048c 80 m/cpu sty,  0480 14 m/cpu jsr,
;"   8480 40 m/cpu jmp,  0484 20 m/cpu bit,
;"
;" -----------------------
;"
;" : begin,   here 1 ; immediate
;" : until,   >r 1 ?pairs r> c, here 1+ - c, ; immediate
;" : if,   c, here 0 c, 3 ; immediate
;" : then,   abs 3 ?pairs here over c@
;"     if swap ! else over 1+ - swap c! then ; immediate
;" : else,   3 ?pairs here 1+   1 jmp,
;"     swap here over 1+ - swap c! -3 ; immediate
;"
;" -----------------------
;"
;" : again,   1 ?pairs jmp, ; immediate
;" : while,   >r dup 1 ?pairs r> [compile] if, 2+ ; immediate
;" : repeat,   >r >r 1 ?pairs jmp,
;"     r> r> 2- [compile] then, ; immediate
;" : not   20 + ;  ( reverse assembly test )
;" 90 constant cs ( assembler test for carry set )
;" d0 constant 0= ( assembler test for equal zero )
;" 10 constant 0< ( assembler test for less than or equal zero )
;" 90 constant >= ( assembler test for greater or equal zero )
;"                ( >= is only correct after sub, or cmp, )
;" 50 constant vs ( assembler test for overflow set )
;"
;" -----------------------
;"
;" forth definitions decimal
;" : end-code   current @ context ! ?csp smudge ;
;" : code   create smudge here dup 2- !
;"     [ assembler ] mem assembler !csp ;
;" : ;code   ?csp compile (;code)
;"     [compile] [ assembler !csp ; immediate
;" exit
;" : (;code)  r> latest name> ! ;
;" credit for the original form of this assemlber goes to William F. Ragsdale of FIG

;"  0 R0
;"  1 R1
;"  2 R2
;"  3 R3
;"  4 R4
;"  5 R5
;"  6 R6
;"  7 R7
;"  8 R8
;"  9 R9
;" 10 R10
;" 11 R11
;" 12 R12
;" 13 R13
;" 14 R14
;" 15 R15
;"
;"  0 ACC
;"  1 TOS
;"  2 N0
;"  3 N1
;"  4 N2
;"  5 N3
;"  6 N4
;"  7 N5
;"  8 N6
;"  9 N7
;" 0a N8
;"  0 R0L
;" R0L 1+ R0H
;" R0L 1c + R14L
;" R0L 1d + R14H
;" R0L 1e + R15L
;" R0L 1f + R15H
;"
;"
;"
;" 00 rtn,  01 bp,   02 bm,   03 bz,
;" 04 bnz,  05 bm1,  06 bnm1, 07 nxt,
;" 08 push, 09 pull, 0a br,   0b ext,
;" 0c bs,   0d rs,   0e bc,   0f bnc,
;" 10 set,  20 ld,   30 st,   40 ldi,
;" 50 sti,  60 ldd,  70 std,  80 pop,
;" 90 stpx, a0 add,  b0 sub,  c0 popd,
;" d0 cpr,  eo inr,  f0 dcr,
