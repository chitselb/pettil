@                         уSING THE фORTH аSSEMBLERвHAT THIS FILE IS:   а LOT OF THE MAIL и HAVE BEEN GETTING ABOUT бLAZIN' фORTH CONCERNS THEUSE OF цоде AND ;цоде DEFINITIONS, AND COMBINING ASSEMBLY LANGUAGE WITHфORTH.  иT RECENTLY OCCURRED TO ME THAT A LOT OF PEOPLE DON'T KNOW HOW TOUSE THE фORTH ASSEMBLER - AND ARE THEREFORE MISSING OUT ON A CONSIDERABLEAMOUNT OF THE POWER OF THE фORTH LANGUAGE. сO THIS IS AN ATTEMPT AT ATUTORIAL IN USING аSSEMBLER IN фORTH, AND IN USING IT IN THE бфц INPARTICULAR.  мUCH OF WHAT и SAY HERE SHOULD BE APPLICABLE TO OTHER 6502фORTH IMPLEMENTATIONS - BUT NOT NECESSARILY ALL. цONSIDER YOURSELF WARNED.вHAT THIS FILE IS NOT:   тHIS IS *NOT* A COURSE IN MACHINE LANGUAGE PROGRAMMING.  иF YOU NEEDINFORMATION ON THE BASICS OF USING ASSEMBLY LANGUAGE, THEN CONSULT A GOODTEXT - MY PERSONAL FAVORITES ARE THE ONES BY лANCE лEVENTHAL, BUT THERE AREMANY GOOD ONES AROUND.гENERAL цONSIDERATIONS:   уSING цоде AND ;цоде WORDS ARE FROWNED UPON IN PROGRAMS WHICH ATTEMPT TOBE PORTABLE.  иN FACT, THE QUICKEST WAY TO INSURE THAT YOUR PROGRAMS ARE NOT83 сTANDARD IS TO USE THE WORD цоде IN THEM.   хAVING SAID THIS HOWEVER, THERE IS MUCH TO BE SAID FOR INCORPORATING AFEW CODE DEFINITIONS IN фORTH PROGRAMS.  тYPICALLY, A PROGRAM WILL SPENDMOST OF ITS TIME IN ONE OR TWO WORDS - BY RECODING THESE WORDS IN ASSEMBLER,THE OVERALL SPEED OF THE PROGRAM CAN BE INCREASED MANYFOLD - 50% INCREASESOR MORE ARE NOT UNUSUAL, AND FOR VERY LITTLE WORK.   аLSO, THE INCOMPATIBILITY IS NOT AS GREAT AS IT WOULD APPEAR AT FIRST.иT IS PROBABLY SAFE TO SAY THAT THE MOST POPULAR 8-BIT PERSONAL COMPUTERSUSE THE 6502 цпу (аPPLE ии, ц64 ц128, аTARI LINE ETC.). аS LONG AS YOUR цодеDEFINITIONS ARE NOT ACCESSING SPECIAL HARDWARE FEATURES (SUCH AS THE сидCHIP IN THE ц64) MOST CODE DEFINITIONS WILL WORK ON ALL COMPUTERS USING THESAME цпу. и HAVE SHARED цоде DEFINITIONS WITH FRIENDS WHO HAVE аPPLES ANDаTARIS RUNNING фORTH, AND и HAVE NEVER YET HAD TO MODIFY ONE.   фINALLY, фORTH IS THE EASIEST LANGUAGE THERE IS TO COMBINE WITH MACHINELANGUAGE.  мANY OF THE HASSLES AND PROBLEMS ORDINARILY ASSOCIATED WITHCOMBINING HIGH LEVEL LANGUAGES AND ASSEMBLER SIMPLY DO NOT OCCUR IN фORTH.иN OTHER LANGUAGES, THE TYPICAL PROCESS IS THIS:   1: вRITE THE HIGH LEVEL PROGRAM, AND DEBUG.   2: фIGURE OUT WHERE YOU NEED TO SPEED THINGS UP.   3: фIRE UP AN EDITOR, AND WRITE SOME ASSEMBLY CODE.   4: аSSEMBLE THE FILE AND - USUALLY - RUN A LOADER PROGRAM ON THAT OUTPUT.   5: лOAD THE еDITOR, AND MODIFY YOUR HIGHER LEVEL SOURCE.   6: цOMPILE YOUR HIGHER LEVEL SOURCE.   7: лINK THE COMPILED PROGRAM AND THE LOADED ASSEMBLY LANGUAGE PROGRAM.   8: вHEN IT DOESN'T WORK (WHICH IT WON'T, AT FIRST). гO BACK TO STEP 3.   тHERE ARE ALSO INEVITABLE PROBLEMS IN PASSING PARAMETERS TO AND FROM THEHIGHER LEVEL CODE, AND THE INEVITABLE PROBLEM OF WHERE TO PUT THE MACHINELANGUAGE. иF YOU HAVE EVER DONE MUCH OF THIS SORT OF THING, YOU KNOW WHAT AHEADACHE THESE PROBLEMS CAN BE.   тHESE LAST TWO PROBLEMS ARE USUALLY THE MOST DIFFICULT, AND, YOU WILL BESURPRISED, AND POSSIBLY RELIEVED TO HEAR THAT THEY DON'T OCCUR IN фORTH. аTALL. еVER.   цOMBINE THAT WITH A RESIDENT ASSEMBLER AND A RESIDENT EDITOR AND ARESIDENT COMPILER, WRITING аSSEMBLY LANGUAGE IN фORTH BECOMES ALMOSTRIDICULOUSLY EASY.а яUICK еXAMPLE:   сINCE и HAVE TAKEN UP SO MUCH OF YOUR TIME WITH THE ABOVE ADVERTISEMENT,YOU WOULD PROBABLY LIKE ME TO PUT MY MONEY WHERE MY MOUTH IS. хERE IS AQUICK EXAMPLE OF WHAT и WAS TALKING ABOUT ABOVE.  и HOPE IT'S NOT TOOTRIVIAL, BUT THE IDEA и WANT TO GET ACROSS HERE IS THE EASE OF COMBININGаSSEMBLER WITH фORTH. фIRST, A HIGH LEVEL фORTH пROGRAM:: схифтлефт ( -- н2 н1 ) // SHIFT н2 LEFT н1 TIMES      0 ?до  2* лооп ;: схифт-4 ( йUST SHOW WHAT A LEFT SHIFT IS )      100 0 до  и 4 схифтлефт .  лооп ;мULTIPLE LEFT SHIFTS ARE FAIRLY COMMON, AND SO схифтлефт IS LIKELY TO BE AHANDY WORD IN CERTAIN APPLICATIONS.  аS IT IS, IT WILL RUN PRETTY QUICKLY.бUT PERHAPS, FOR CERTAIN SPEED DEMONS, NOT QUICKLY ENOUGH, SO YOU DECIDE TORECODE THE схифтлефт PRIMITIVE IN аSSEMBLER:цоде схифтлефт ( -- н2 н1 )  // SHIFT н2 LEFT н1 TIMES   бот лда, таы, бегин, 0 # цпы, 0= нот  вхиле,      сец асл, сец 1+ рол, деы, репеат,   поп ймп, енд-цодеиF YOU ARE USED TO CONVENTIONAL ASSEMBLERS, THIS PROBABLY LOOKS PRETTYWEIRD.  тHE IMPORTANT THING TO NOTICE HERE IS THAT *ONLY* схифтлефт HASCHANGED - схифт-4 (OR ANY OTHER WORD WHICH USES схифтлефт) WILL WORK JUST ASIT DID BEFORE, WITH THE ONLY CHANGE BEING THE OVERALL INCREASE OF SPEEDWHICH MACHINE LANGUAGE NATURALLY BRINGS TO ANY SITUATION.  нOTICE ALSO THATWE DIDN'T HAVE TO WORRY ABOUT WHERE TO PUT THE CODE - IT GOES IN THE SAMESPOT OUR HIGHER LEVEL схифтлефт WENT. ыOU WILL ALSO DISCOVER, IF YOU TYPETHIS EXAMPLE IN, THAT YOU DON'T HAVE TO CALL THE ASSEMBLER. тHIS IS ALLTAKEN CARE OF FOR YOU.  аS FAR AS YOU, ANOTHER USER, OR OTHER PROCEDURESWHICH USE схифтлефт ARE CONCERNED, THERE IS NO DIFFERENCE BETWEEN USING THEHI-LEVEL схифтлефт AND THE цоде схифтлефт.тHE сTRUCTURE OF A цоде DEFINITION:   иT'S PRETTY STRAIGHTFORWARD. тHEY ALL LOOK THE SAME:цоде [NAME] [ASSEMBLER MNEMONICS] енд-цоденOTE THE SIMILARITY TO A COLON DEFINITION:: [NAME]    [FORTH WORDS]         ;хOW TO еXIT A цODE дEFINITION:   оNE THING YOU MUST REMEMBER IS THAT YOU HAVE TO EXPLICITLY LEAVE A цодеDEFINITION BY DOING A ймп, TO ANOTHER CODE LEVEL ROUTINE.  тHIS IS PROBABLYTHE SINGLE MOST COMMON ERROR MADE BY NEWCOMERS.  пOSSIBLY IT IS CAUSED BYMAKING A FALSE ANALOGY BETWEEN THE HIGHER LEVEL ; AND THE CODE LEVELенд-цоде. вHILE THE фORTH WORD ; DOES IN FACT GET YOU BACK TO WHERE YOU CAMEFROM, енд-цоде DOES NOT. иN FACT, енд-цоде DOES NOTHING AT ALL AT RUN-TIME.ыOU CAN EXIT A цоде DEFINITION BY DOING A ймп, TO ANY OF THE FOLLOWING:неьт поп поптво пусх OR пут .  тHESE ARE DESCRIBED BELOW:неьт   неьт IS COMMONLY CALLED THE ADDRESS INTERPRETER. иT IS THE WORD THAT ISRESPONSIBLE FOR THE EXECUTION OF ALL фORTH WORDS.  алл WORDS IN фORTHULTIMATELY END UP HERE.  дOING A неьт ймп, WILL CAUSE THE CURRENT CODEDEFINITION TO STOP AND RETURN TO THE WORD THAT CALLED IT.  аLL OF THEFOLLOWING EXIT POINTS END WITH A JUMP TO неьт .  иN WHAT FOLLOWS, REMEMBERTHAT A "STACK ELEMENT" REFERS TO A 16 BIT QUANTITY -- I.E. TWO BYTES.поп   поп FIRST DROPS THE FIRST ELEMENT OF THE STACK, AND THEN JUMPS TO неьт.сAME AS дроп IN HI-LEVEL FORTH.поптво   поптво DROPS THE TOP TWO ELEMENTS FROM THE STACK, AND THEN JUMPS TO неьт.сAME AS 2дроп IN HI-LEVEL.пусх   пусх LETS YOU LEAVE A RESULT ON THE TOP OF THE STACK.  пусх EXPECTS THELOW BYTE OF THE NEW TOP OF STACK TO BE ON THE RETURN STACK, AND THE HIGHIN THE ACCUMULATOR. пусх WILL LEAVE THESE AS THE NEW TOP OF THE PARAMETERSTACK (THE FORMER TOP WILL THEN BE THE SECOND ELEMENT). пусх THEN CALLSнеьт. сINCE THIS ROUTINE IS SOMEWHAT MORE COMPLICATED THAN THE OTHERS HEREIS A TYPICAL SEQUENCE:      пха, ( PUSH LOW BYTE TO RETURN STACK )      тыа, ( ASSUME HIGH BYTE IS SAVED IN ы REGISTER, MOVE IT TO THE а REG)      пусх ймп, енд-цоде ( PARAMETERS SET, SO JUMP TO пусх)пут   пут REPLACES THE TOP OF THE STACK WITH A NEW VALUE.  ыOU SETUP пут INTHE SAME WAY AS YOU SETUP FOR пусх - THE NEW LOBYTE IS PUSHED TO THE RETURNSTACK, AND THE NEW HIBYTE IS IN THE ACCUMULATOR BEFORE THE CALL TO пут. тHEONLY DIFFERENCE BETWEEN THE TWO IS THAT пут REPLACES THE PRESENT TOP OF THESTACK, WHILE пусх CREATES A NEW TOP OF STACK. рEGISTER уSAGE:   сINCE фORTH USES TWO STACKS, AND THE 6502 цпу ONLY IMPLEMENTS ONEHARDWARE STACK, THE PARAMETER STACK MUST BE "ARTIFICIALLY" MAINTAINED. иNTHIS IMPLEMENTATION (AS IN MOST) IT IS LOCATED IN THE ZERO PAGE, AND THE ьREGISTER IS USED AS THE PARAMETER STACK POINTER. тHE MACHINE STACK ISфORTH'S RETURN STACK. тHEREFORE INSTRUCTIONS WHICH AFFECT THE ь REGISTER ORTHE MACHINE STACK SHOULD BE USED WITH CARE.  аT ENTRY TO A цоде DEFINTION,THE ь REGISTER POINTS TO THE TOP BYTE OF THE PARAMETER STACK.  тHIS STACKGROWS DOWNWARD IN MEMORY, SO DECREMENTING THE ь REGISTER WILL MAKE ROOMFOR ANOTHER ELEMENT ON THE STACK, AND INCREMENTING THE STACK POINTER WILLREMOVE AN ELEMENT FROM THE STACK. хERE IS A DIAGRAM WHICH SHOWS THESITUATION WHEN TWO ELEMENTS ARE ON THE STACK:         хI мEMORY      **************      *   HIBYTE2  *      *   LOBYTE2  *      **************      *   HIBYTE1  *ь --> *   LOBYTE1  * тOP OF сTACK      **************нOTICE THAT THE TWO BYTES WHICH MAKE UP ONE STACK ENTRY ARE STORED IN THEUSUAL 6502 ORDER, WITH THE LOBYTE LOWER IN MEMORY. тO REMOVE THE TOP ELEMENTOF THE STACK, WE CAN DEFINE THE CODE WORD дроп:цоде дроп ( н -- )  инь, инь, неьт ймп, енд-цодевHICH IN FACT, IS EXACTLY THE THE WAY дроп IS DEFINED IN THE бфц. аFTER дропHAS BEEN EXECUTED, THE STACK LOOKS LIKE THIS:        хI мEMORY      *************      *  HIBYTE2  *ь --> *  LOBYTE2  * нEW TOP OF сTACK      *************вE WILL RETURN TO THIS TOPIC LATER, WHEN WE TALK ABOUT ACCESSING THEPARAMETER STACK IN MORE DETAIL.  фOR NOW, THE MAIN POINT IS TO REMEMBER THATWHEN фORTH STARTS EXECUTING YOUR CODE DEFINITION, THE ь REGISTER WILLCONTAIN A POINTER TO THE TOP OF THE STACK. ыOU CAN USE THE ь REGISTER TOACCESS THE STACK, OR TO REMOVE ELEMENTS FROM THE STACK, BUT WHEN YOUR CODEDEFINITION IS FINISHED, OTHER фORTH WORDS, AND THE фORTH SYSTEM ITSELF ISGOING TO EXPECT THE ь REGISTER TO CONTAIN A VALID STACK POINTER, SO DON'TCHANGE IT WANTONLY. ыOU SHOULD ALSO REMEMBER THAT SINCE EACH STACK ENTRY ISTWO BYTES, ONLY EVEN MULTIPLES OF THE инь, OR деь, INSTRUCTION MAKE SENSE.(и.е. инь, инь, инь, инь, NOT инь, инь, инь, - THE FIRST WILL DROP TWO STACKELEMENTS, WHILE THE SECOND WILL DROP 1 AND 1/2 STACK ELEMENTS - AND CAUSETHE фORTH SYSTEM TO BEHAVE ODDLY.)бOTH THE аCCUMULATOR (а REG) AND THE ы REGISTER MAY BE FREELY USED. тHE аREGISTER WILL CONTAIN GARBAGE, AND MUST BE INITIALIZED, BUT THE ы REGISTERIS GUARANTEED TO BE 0 ON ENTRY TO YOUR CODE, AND YOU MAY TAKE ADVANTAGE OFTHIS FACT OR NOT, AS YOU WISH.  хERE IS A SHORT CODE DEFINITION THAT WILLLEAVE THE VALUE OF -1 (фORTH'S CANONICAL труе FLAG) ON THE STACK. иT USESTHE пусх ROUTINE DESCRIBED EARLIER.цоде труе ( -- -1 )   деы, ( ы рег NOW HOLDS $FF)                      тыа, пха, пусх ймп, енд-цодехERE IS AN EVEN SHORTER DEFINITION WHICH WILL LEAVE A 0 ON THE PARAMETERSTACK:цоде фалсе ( -- 0 )  тыа, ( SET а REGISTER TO 0 )                     пха, ( SET UP FOR пусх )                     пусх ймп, енд-цоделIFE BEING WHAT IT IS, YOU WILL OFTEN WISH YOU COULD USE THE ь REGISTER.тHERE IS A WAY.  ыOU CAN USE THE SYSTEM STORAGE LOCATION ьсаже, TOTEMPORARILY SAVE THE VALUE OF THE ь REGISTER WHILE YOU ARE DOING OTHERTHINGS. ыOU MUST REMEMBER TO RESTORE THE ь REGISTER BEFORE EXITING, HOWEVER.а TYPICAL SEQUENCE IS:  ьсаже сть, ( STUFF THAT CHANGES X ) ьсаже лдь, неьт ймп, енд-цодевHY IT LOOKS SO STRANGE....   тHE MAIN REASON THE фORTH аSSEMBLER LOOKS SO STRANGE IS THAT IT ISREVERSE POLISH, LIKE ALL OF фORTH. оPERANDS *PRECEED* THE OPERATORS. хEREARE SOME EXAMPLES THAT SHOULD MAKE IT CLEAR:цONVENTIONAL аSSEMBLER           фORTH'S аSSEMBLER=====================            ================   лда # 0                          0 # лда,   рол а                            .а  рол,   ста аддресс,ь                    аддресс ,ь ста,   ста (аддресс,ь)                  аддресс ь) ста,   лда (аддресс),ы                  аддресс )ы лда,   ймп (индирецт)                   индирецт ) ймп,   ймп аддресс                      аддресс  ймп,   лда аддресс                      аддресс  лда,вHILE ADMITTEDLY UNUSUAL, IT DOES MAKE THE BEST USE OF THE STACK AT ASSEMBLYTIME.тHE OTHER MAJOR DIFFERENCE IS THAT THE фORTH аSSEMBLER DOES NOT USE LABELS.тHERE ARE NO BRANCH INSTRUCTIONS - THE фORTH аSSEMBLER USES A STRUCTUREDCODE APPROACH TO CONTROL FLOW. иT DOES THIS BY USING ANALOGUES OF THEHI-LEVEL иф тхен елсе ETC. TO CONTROL THE FLOW OF YOUR цоде DEFINITION. тOTAKE ADVANTAGE OF THIS, YOU MUST SPECIFY THE CONDITION CODE YOU WANT TESTED.ыOU SPECIFY THIS CONDITION CODE BY USING ANY OF THE FOLLOWING WORDS:   цс  TEST IF CARRY SET   0<  TEST IF NEGATIVE FLAG SET   0=  TEST IF ZERO FLAG SET   жс  TEST IF OVERFLOW FLAG SET   ыOU CAN FOLLOW THESE CONDITION CODE SPECIFIERS WITH NOT, TO TEST FOR THEOPPOSITE CONDITION:   цс нот TEST IF CARRY CLEAR   0< нот TEST IF NEGATIVE CLEAR   0= нот TEST IF ZERO FLAG CLEAR   жс нот TEST IF OVERFLOW FLAG CLEARбELOW IS AN EXAMPLE OF A POSSIBLE DEFINITION OF 0= , WHICH LEAVES TRUE IFTHE TOP OF THE STACK IS 0, AND FALSE (0) IF IT IS ANYTHING ELSE:цоде 0= ( н -- флаг ) бот лда, бот 1+ ора, 0= иф, 255 # лда, елсе, 0 # лда,тхен, пха, пут ймп, енд-цодеиN THE ABOVE CODE, WE FIRST TEST FOR 0 BY орING THE TWO BYTES WHICH MAKE UPTHE TOP OF THE STACK TOGETHER. тHE RESULT WILL BE ZERO ONLY IF BOTH AREZERO. вE THEN TEST THE ZERO FLAG (WITH 0=). иF THE BYTE IS 0, WE лда WITH255, OTHERWISE, WE лда WITH 0, AND REPLACE THE TOP OF THE STACK WITH THEFLAG BY JUMPING TO THE пут EXIT ROUTINE. нOTE THAT WE COULD MAKE THISDEFINITION MUCH SHORTER BY TAKING ADVANTAGE OF THE FACT THAT THE ы REGISTERIS ZERO AT ENTRY:цоде 0= ( н -- флаг ) бот лда, бот 1+ ора, 0= иф, деы, тхен, тыа, пха, путймп, енд-цодеыOU CAN USE THE SAME TYPE OF TESTS TO DO CONDITIONAL LOOPS. хERE IS A DONOTHING EXAMPLE THAT SIMPLY WASTES SOME TIME IN A LOOP:цоде ваит ( -- ) бегин, деы, 0= унтил, неьт ймп, енд-цодетHIS SIMPLY DECREMENTS THE ы REGISTER UNTIL IT BECOMES ZERO.  иN THEORIGINAL фORTH ASSEMBLER FOR 6502 MACHINES, THE бегин, унтил, STRUCTURE WASTHE ONLY ONE AVAILABLE. тHE бфц HAS EXTENDED THIS TO INCLUDE бегин, вхиле,репеат, AND бегин, агаин, . тHE бегин, агаин, LOOP IS INFINITE - YOU MUSTйумп OUT OF IT IN THE MIDDLE SOMEWHERE.аCCESSING THE сTACKS.   тYPICALLY, MOST ROUTINES ONLY NEED TO ACCESS THE TOP TWO ELEMENTS OF THEPARAMETER STACK. сINCE THIS IS SO COMMON, SPECIAL WORDS HAVE BEEN PROVIDEDTO MAKE LIFE EASIER HERE. бот REFERENCES THE TOP OF THE STACK (WHICH ISLOWER IN MEMORY, AND SO THE ботTOM OF THE STACK). сец REFERENCES THE сецONDELEMENT OF THE STACK. иT'S IMPORTANT TO REMEMBER THAT A фORTH STACK ENTRY IS16 BITS, OR TWO BYTES, SO TO OBTAIN THE WHOLE STACK ELEMENT, YOU NEED TO DOTWO FETCHES OR STORES. хERE IS A SAMPLE IMPLEMENTATION OF дуп:цоде дуп   ( н -- н н ) бот лда, пха, бот 1+ лда, пусх ймп, енд-цодефIRST WE FETCH THE LOW BYTE OF THE TOP OF THE STACK WITH бот лда, . тHIS ISPUSHED ONTO THE RETURN STACK, AS REQUIRED BY THE EXIT ROUTINE пусх . нEXT WEGET THE HIGH BYTE WITH бот 1+ лда, . тHAT'S ALL THERE IS TO IT. аS ANOTHERILLUSTRATION, HERE IS AN IMPLEMENTATION OF ожер:цоде ожер ( а б -- а б а ) сец лда, пха, сец 1+ лда, пусх ймп, енд-цодетHE ACTUAL ADDRESSING MODE BEING USED HERE IS "ZERO-PAGE X". иNCONVENTIONAL ASSEMBLER, бот лда, WOULD BE WRITTEN лда 0,X WHILE бот 1+ лда,WOULD BE WRITTEN лда 1,ь . тO ACCESS DEEPER STACK ELEMENTS, YOU CAN KEEPADDING VALUES TO бот OR сец , OR YOU CAN USE THE ADDRESSING MODE EXPLICITLY:бот 4 + лдаOR4 ,ь лдавHILE NOT USED OFTEN, IT IS ALSO POSSIBLE TO ADDRESS DIRECTLY INTO THERETURN STACK. тYPICALLY, YOU WOULD ACCESS THE RETURN STACK USING THE пла,INSTRUCTION. тHIS HAS THE SIDE EFFECT OF ALTERING THE STACK POINTER, AND YOUCAN ALSO ONLY ACCESS THE TOP OF THE RETURN STACK.  тO ACCESS ARBITRARYBYTES, YOU CAN USE рп) . тO DO THIS, YOU MUST FIRST SAVE THE ь-рEGISTER INьсаже AND THEN EXECUTE тсь, WHICH WILL MOVE THE STACK POINTER INTO THEь-рEGISTER. ыOU CAN THEN DO рп) лда, WHICH WILL FETCH THE CURRENT TOP OF THERETURN STACK. тO GET DEEPER INTO THE RETURN STACK, OFFSET рп). бELOW IS ANEXAMPLE WHICH NON-DESTRUCTIVELY MOVES THE ADDRESS ON THE RETURN STACK TO THETOP OF THE PARAMETER STACK:цоде гет-ретурн-аддресс  ьсаже сть,  тсь, рп) лда, пха, рп) 1+ лда, ьсажелдь, пусх ймп, енд-цодеоNE OF THE EASIEST AND QUICKEST WAYS TO CRASH ANY SYSTEM IS TO GARBAGE THERETURN STACK. иF YOU NEED TO ACCESS THE STACK, GO FOR IT, BUT USE CARE.сетуп AND н   иT IS OFTEN USEFUL TO BE ABLE TO ACCESS ABSOLUTE MEMORY LOCATIONS.  тOTHIS END, фORTH PROVIDES AN 8 BYTE TEMPORARY DATA AREA WHICH IS REFERRED TOAS THE н AREA. ыOU MAY INITIALIZE THIS AREA YOURSELF, OR YOU MAY CALL сетупTO MOVE STACK ELEMENTS TO THE н AREA. тO USE сетуп, YOU MUST LOAD THEACCUMULATOR WITH THE NUMBER OF STACK ELEMENTS YOU WANT TO MOVE (ноте: THENUMBER OF STACK ELEMENTS, нот THE NUMBER OF BYTES) AND THEN DO A йср TOсетуп. сетуп WILL POP THE ELEMENTS OFF OF THE STACK, AND MOVE THEM TO THE нAREA.  сINCE THERE ARE ONLY 8 BYTES IN THE н AREA, YOU HAVE ROOM FOR AT MOST4 STACK ELEMENTS. аS A SIMPLE EXAMPLE, THE FOLLOWING WILL POP THE TOP TWOELEMENTS OFF OF THE STACK, AND MOVE THEM TO THE н AREA:цоде може2  2 # лда, сетуп йср, енд-цодетHE PREVIOUS TOP OF STACK (бот AND бот 1+) WILL BE STORED AT н AND н 1+ ,WHILE THE SECOND ELEMENT (сец AND сец 1+) WILL BE AT н 2+ AND н 3 +. оNCETHEY HAVE BEEN MOVED THERE, YOU CAN CARRY OUT OPERATIONS ON THEM, OR USETHEM IN THE INDEXED INDIRECT ы ADDRESSING MODE. ( лда (н), ы IN CONVENTIONALASSEMBLER, OR н )ы лда, IN фORTH ASSEMBLER.)  бY FAR THE MOST COMMON ERRORIN USING сетуп IS TO FORGET THAT IT ALSO POPS THE ELEMENTS OF THE STACK ASIT MOVES THEM.;цодеиF цоде IS THE аSSEMBLERS EQUIVALENT TO THE HI-LEVEL COLON, ;цоде IS THEASSEMBLERS EQUIVALENT TO доес>. аS AN EXAMPLE OF THE USE OF ;цоде, WE WILLWRITE OUR OWN VERSIONS OF цонстант - ONE IN HIGH LEVEL FORTH, USING доес>,AND ONE IN LOW LEVEL, USING ;цоде. фIRST THE HI-LEVEL DEFINITION:: цонстант  цреате , доес> @ ;аS A QUICK REVIEW, REMEMBER THAT цреате (OR A WORD THAT USES цреате) CREATESA DICTIONARY ENTRY FOR THE NEXT WORD IN THE INPUT STREAM. вORDS CREATED INTHIS WAY ALL HAVE THE SAME RUN-TIME BEHAVIOUR - THEY LEAVE THE ADDRESS OFTHEIR PARAMETER FIELD ON THE STACK. нOTE THAT цреате BY ITSELF DOES NOTALLOCATE ANY PARAMETER FIELD SPACE IN THE DICTIONARY, YOU MUST DO THISYOURSELF BY USING ц, , OR аллот . тHE доес> WORD ALLOWS YOU TO MANIPULATETHE VALUES IN THE PARAMETER FIELD, ESSENTIALLY ALLOWING YOU TO DEFINE ASPECIAL SET OF RELATED WORDS WHICH SHARE THE SAME RUN-TIME BEHAVIOUR. лETSWALK THROUGH THE PROCESS:10 цонстант тенвHEN фORTH EXECUTES THE ABOVE LINE, THE NUMBER 10 WILL BE LEFT ON THE STACK,AND цонстант WILL BE EXECUTED. тHE FIRST WORD IN цонстант IS цреате, WHICHWILL TAKE THE FIRST WORD IT FINDS IN THE INPUT STREAM (тен IN THIS CASE) ANDCREATE A HEADER FOR IT IN THE DICTIONARY, WITH ITS ASSOCIATED LINK FIELD,NAME FIELD AND CODE FIELD. тHE CODE FIELD WRITTEN BY цреате WILL CAUSE THEADDRESS OF THE FIRST BYTE OF THE PARAMETER FIELD TO BE LEFT ON THE STACKWHEN тен (THE WORD DEFINED BY цонстант) IS EXECUTED. нEXT , IS EXECUTED,WHICH TAKES THE TOP OF THE STACK, AND COMPILES THIS NUMBER IN THEDICTIONARY. доес> DOES SOMETHING MYSTERIOUS (MORE ON THIS LATER) WHICHCAUSES THE WORDS FOLLOWING доес> TO BE EXECUTED AT RUN-TIME. тHIS IS THECOMPILE TIME BEHAVIOUR OF цонстант. нOW, WHEN тен IS EXECUTED, THE RUN-TIMEBEHAVIOUR OF цонстант WILL OCCUR. тHE PARAMETER FIELDS ADDRESS IS PUSHEDONTO THE STACK, AND THEN THE WORDS AFTER доес> ARE EXECUTED. иN THIS CASE,THE SINGLE WORD @ WILL BE EXECUTED, WHICH REPLACES THE ADDRESS ON THE TOP OFTHE STACK WITH THE VALUE AT THAT ADDRESS.тен . 10 окнOW FOR THE ;цоде VERSION:: цонстант  цреате , ;цоде  2 # лды, в )ы лда, пха, ины, в )ы лда, пусх ймп,енд-цоденOTICE, BY THE WAY, THAT NO CONCLUDING SEMI-COLON IS REQUIRED WHEN YOU USE;цоде.вHEN ;цоде IS EXECUTED (FOR EXAMPLE, BY TYPING 10 цонстант тен), IT WILLреврите тхе цоде фиелд оф тхе ворд беинг дефинед! тHIS IS EXTREMELYIMPORTANT TO REMEMBER.  аLL фORTH WORDS HAVE CODE FIELDS THAT DEFINE THEIRRUN TIME BEHAVIOUR, WITH COLON DEFINITIONS ALL SHARING THE SAME CODE FIELD,VARIABLES SHARING THE SAME CODE FIELD (DIFFERENT, OF COURSE, FROM THAT OFCOLON DEFINITIONS AND CONSTANTS) AND SO ON. вHEN цреате EXECUTES IN OURцонстант DEFINITION, IT CREATES A CODE FIELD THAT CONTAINS THE ADDRESS OF AROUTINE WHICH WILL PUSH THE ADDRESS OF THE WORD BEING DEFINED TO THE STACK.вHEN ;цоде EXECUTES IN OUR цонстант DEFINITION, IT WILL SEARCH OUT THIS CODEFIELD, AND RE-WRITE IT WITH THE ADDRESS OF THE MACHINE LANGUAGE ROUTINEWHICH IMMEDIATELY FOLLOWS ;цоде. тHIS MEANS THAT THE ONLY RUN TIME BEHAVIOUROF A WORD WHICH CONTAINS A ;цоде TERMINATION IS DETERMINED BY YOU. еVENTHOUGH THERE IS A цреате IN THE LO-LEVEL DEFINITION OF цонстант, IT WILL NOTDEPOSIT THE ADDRESS OF THE PARAMETER FIELD ON THE STACK, BECAUSE ;цоде HASCHANGED THE CODE FIELD TO POINT TO OUR MACHINE LANGUAGE ROUTINE. аNILLUSTRATION MAY MAKE THIS CLEARER:хEADER CREATED BY цреате:*************** лINK фIELD **************** тен        *  нAME FIELD - STORES асции CHARACTERS OF DEFINED NAME.***************  $0900     *  $0900 = ADDRESS OF ROUTINE TO PUSH PARAMETER FIELD ON STACK*************** 10         *  пARAMETER FIELD - STORES VALUE OF CONSTANT**************нOTE THAT $0900 IS JUST AN EXAMPLE ADDRESS - DON'T TRY JUMPING TO IT IN YOUROWN CODE.вHEN A WORD DEFINED BY цреате IS EXECUTED, THE MACHINE LANGUAGE ROUTINE AT$0900 (THE ADDRESS IN THE CODE FIELD OF THE WORD) WILL BE EXECUTED. тHISROUTINE IS WHAT CAUSES THE RUN-TIME BEHAVIOUR OF цреате DEFINED WORDS - ITPUSHES THE ADDRESS OF THE PARAMETER FIELD TO THE STACK. тHE ABOVEILLUSTRATION SHOWS THE STATE OF THE DICTIONARY AFTER THE цреате AND , PARTOF цонстант HAVE BEEN EXECUTED. нOW, SUPPOSE THAT THE ADDRESS OF THE FIRSTINSTRUCTION FOLLOWING ;цоде IN цонстант ( THE 2 # лды, ) IS AT $8000 . вHEN;цоде EXECUTES IN THE COURSE OF DEFINING A NEW CONSTANT, THE HEADER WILLLOOK LIKE THIS:хEADER AFTER ;цоде HAS BEEN EXECUTED.*************** лINK фIELD **************** тен        *  нAME FIELD - STORES асции CHARACTERS OF DEFINED NAME.*************** $8000      *  $8000 = ADDRESS OF YOUR MACHINE LANGUAGE ROUTINE*************** 10         *  пARAMETER FIELD - STORES VALUE OF CONSTANT**************сO, AS ALWAYS, WHEN фORTH EXECUTES тен, THE FIRST THING TO BE EXECUTED ISTHE ADDRESS OF THE ROUTINE IN THE CODE FIELD, WHICH NO LONGER POINTS TO THEцреате RUN TIME CODE, BUT TO YOUR MACHINE LANGUAGE CODE.хOPE THAT IS ALL CLEAR ENOUGH. нOW, TO THE PARTICULARS OF THE ;цоде PART OFOUR LOW LEVEL цонстант DEFINITION (NOTE THAT THE FOLLOWING IS IMPLEMENTATIONDEPENDENT. мOST PRESENT DAY фORTHS USE AN IMPLEMENTATION ALONG THESE LINES,BUT NOT ALL.)фORTH DEPENDS ON TWO REGISTERS FOR ITS PERFORMANCE, THE ип AND THE вREGISTER. вHEN фORTH IS IMPLEMENTED ON PROCESSORS WITH MORE REGISTERS,TYPICALLY A PROCESSOR REGISTER WILL BE USED FOR THESE фORTH SYSTEMREGISTERS. хOWEVER, THERE ARE NOT ENOUGH ON THE 6502, SO ZERO PAGE LOCATIONSHAVE BEEN USED INSTEAD.  в WILL CONTAIN THE ADDRESS OF THE CODE FIELD OF THEWORD CURRENTLY BEING EXECUTED. фOR EXAMPLE, IF THE CODE FIELD OF тен ISLOCATED AT $9000, THE в REGISTER WILL CONTAIN $9000, OR THE ADDRESS OF THEADDRESS OF THE ROUTINE TO BE EXECUTED. тHE ;цоде PART OF цонстант USES THISFACT TO ACCESS THE PARAMETER FIELD OF THE CURRENT WORD. сINCE THE CODE FIELDOF AN ADDRESS, IS ALWAYS TWO BYTES LONG, THE FIRST BYTE OF THE PARAMETERFIELD IS LOCATED AT $9002. гIVEN THIS INFORMATION, IT BECOMES A SIMPLEMATTER OF INDIRECTLY INDEXING FROM в. лOADING THE ы REGISTER WITH 2, ANDTHEN PERFORMING в )ы лда, (лда (в),ы IN CONVENTIONAL ASSEMBLER) WILL GET THEFIRST BYTE OF THE CONSTANTS VALUE. тHE NEXT BYTE IS AT $9003, SO WE SIMPLYINCREMENT ы, AND INDIRECTLY INDEX AGAIN TO GET THE NEXT BYTE. тHE REST OFTHE DEFINITION CONSISTS OF SETTING UP FOR пусх, WHICH WAS COVERED EARLIER.пHEW! хOPE THAT WAS CLEAR ENOUGH. и THINK YOU CAN SEE THAT INDEXING FROM вCAN GET YOU ANY BYTE IN A DEFINITIONS PARAMETER FIELD. в 1- CONTAINS ANINDIRECT ймп INSTRUCTION, SO YOU CAN ALSO VECTOR CONTROL TO OTHER ROUTINESBY STORING THE ADDRESS OF THE ADDRESS OF THE ROUTINE IN в, AND THEN DOING Aв 1- ймп, . тHIS TECHNIQUE IS RARELY USED, HOWEVER.тHERE IS AN INTIMATE RELATIONSHIP BETWEEN THE ип REGISTER AND THE вREGISTER, AND AN EFFECTIVE USE OF THESE REGISTERS DEPENDS ON A CLEARUNDERSTANDING OF HOW THEY WORK IN THE фORTH SYSTEM AS A WHOLE.  бOTH OF THEMARE CHANGED BY неьт. вHEN неьт EXECUTES, THE ип WILL POINT TO AN ADDRESSWHICH CONTAINS THE CODE FIELD ADDRESS OF THE NEXT WORD TO BE EXECUTED BYфORTH. неьт FETCHES THIS ADDRESS, AND STORES IT IN в. иT THEN BUMPS THE ип(WHICH STANDS FOR иNTERPRETIVE пOINTER) BY TWO, SO THE NEXT TIME AROUND ITWILL BE POINTING TO THE NEXT WORD TO BE EXECUTED. фINALLY, неьт DOES A ймпTO в 1-, WHICH CAUSES AN INDIRECT JUMP TO THE ADDRESS POINTED TO BY в.тHE ип IS MOST USEFUL FOR ACCESSING THINGS LIKE INLINE DATA STRUCTURES,(CHARACTER STRINGS, AND THE LIKE.) сINCE THE ип IS INCREMENTED BY неьт, THECODE FRAGMENT:    ип )ы лда, пха, ины, ип )ы лда, пусх ймп,вILL PUSH THE ADDRESS WHICH CONTAINS THE ADDRESS OF THE NEXT фORTH WORD TOBE EXECUTED TO THE PARAMETER STACK. (тHIS WILL BE THE THIRD AND FOURTH BYTESPAST THE ADDRESS OF THE CURRENT WORD BEING INTERPRETED.) оBVIOUSLY, BYSTORING NEW VALUES IN THE ип, AND THEN JUMPING TO неьт , YOU CAN ALSO FORCETHE EXECUTION OF A PARTICULAR DEFINITION.  тHIS TECHNIQUE IS ALSO RARELYUSED. тYPICAL USES FOR THE ип ARE MAINLY ACCESSING INLINE DATA.аCCESSING жARIABLES FROM цODE DEFINITIONS.   сINCE VARIABLES LEAVE THE ADDRESS OF THEIR PARAMETER FIELDS ON THE STACK,IT IS A SIMPLE MATTER TO ACCESS THESE VARIABLES FROM цоде LEVEL DEFINITIONS.хERE IS AN EXAMPLE:жариабле фооцоде фоо+1   фоо лда, цлц, 1 # адц, фоо ста, цс иф, фоо 1+ инц, тхененд-цодетHIS IS A COMMON WAY TO INCREMENT THE VALUE AT A MEMORY LOCATION.  тHEASSEMBLER ALSO PROVIDES A WAY TO ACCESS усер VARIABLES, USING THE уп (USERPOINTER CONSTANT). уSER VARIABLES MUST BE ACCESSED USING AN OFFSET, SO THE)ы ADDRESSING MODE  IS RECOMMENDED. ыOU WILL NEED TO KNOW THE OFFSET OF THEUSER VARIABLE YOU NEED TO ACCESS IN ADVANCE, OF COURSE.мисц.   сINCE THE аSSEMBLER IS CO-RESIDENT WITH THE фортх SYSTEM, ALL THE POWER OFфортх IS AVAILABLE TO YOU WHEN USING THE аSSEMBLER. аS ONE EXAMPLE:   фоо @ 2 3 */ # лда,WILL INITIALIZE THE ACCUMULATOR TO TWO THIRDS OF THE VALUE STORED IN THEVARIABLE фоо. (оF COURSE, THIS MUST BE 255 OR LESS.) оCCASIONAL CONFLICTSMAY ARISE, HOWEVER. иN PARTICULAR, A COMMON ERROR IS TO CONFUSE THEASSEMBLERS 0= AND 0< WORDS WITH фORTHS - THEY ARE NOT THE SAME. иF YOU WISHTO USE THE фORTH VERSIONS WHILE ASSEMBLING, YOU MUST EXPLICITLY ENTER THEфортх VOCABULARY, DO YOUR фORTH THING, AND THEN RE-ENTER THE ASSEMBLERVOCABULARY. сUCH CONFLICTS ARE RARE, AND USUALLY EASILY RECOGNIZED.тHE фORTH ASSEMBLER USES THE STANDARD мос MNEMONICS FOR THE 6502 OP-CODES,BUT EACH MNEMONIC HAS A ',' ATTACHED. тHUS, IN FORTH, WE WRITE лда, брк, ORймп, NOT лда брк AND ймп. аLSO, THE аSSEMBLER CONDITIONALS USE THE SAMECONVENTION - иф, елсе, тхен, AND NOT иф елсе тхен . а COMMON ERROR IS TOOMIT THE COMMA FROM ONE OR MORE OF THESE CONDITIONALS.  и AM PERSONALLY NOTWILD ABOUT THIS CONVENTION, BUT THE FIRST фORTH ASSEMBLERS USED THEM, ANDNOW WE ARE STUCK WITH IT.ыOU MAY HAVE NOTICED THAT и HAVE NOT USED THE йср, ртс, INSTRUCTIONS. тHISIS BECAUSE TYPICALLY, цоде DEFINITIONS ARE CALLED FROM HIGHER LEVEL WORDS,AND MUST END WITH A ймп, TO неьт OR THE EQUIVALENT ROUTINE. иT IS POSSIBLETO WRITE PROGRAMS WHICH ARE STRUCTURED IN THIS WAY. тYPICALLY, THESUBROUTINES ARE GIVEN NAMES WITH цреате, AND THEN CALLED FROM A HIGHER LEVELCODE DEFINITION. хERE IS AN EXAMPLE:цреате блетцх  ассемблер  ноп, ноп, ртс,нOTE THAT WHEN WE DO THIS, WE MUST INVOKE THE аSSEMBLER VOCABULARYEXPLICITLY. блетцх WOULD BE TYPICALLY CALLED FROM A HIGHER LEVEL цодеDEFINITION:цоде тхе-греат-ртс-хацк  блетцх йср, неьт ймп, енд-цодетHIS IS ONLY OCCASIONALLY NECESSARY HOWEVER - USUALLY WHEN WRITING CODE THATIS EXTREMELY TIME CRITICAL, SUCH AS GRAPHICS CODE.фINALLY, IT IS POSSIBLE TO EXIT A CODE DEFINITION BY JUMPING TO YET ANOTHERCODE ROUTINE. ыOU MUST REMEMBER TO RESTORE THE ь REGISTER (IF YOU HAVEALTERED IT) AND IT IS ALSO WISE TO RESET THE ы REGISTER TO 0, SINCE MANYCODE LEVEL DEFINITIONS WILL ASSUME THAT THIS IS THE CASE. аS A SIMPLEEXAMPLE, HERE IS A WORD THAT SIMPLY SIMPLY DOES A ймп, TO фORTH'S кеыROUTINE:цоде цалл-кеы  ' кеы @ ймп, енд-цодетHE TICK (') GETS THE ADDRESS OF кеы'S CODE FIELD, AND THE @ FETCHES THEADDRESS OF THE ROUTINE WHICH IS STORED IN кеы'S CODE FIELD. тHIS IS THERECOMMENDED TECHNIQUE. иT IS MORE PORTABLE, AND ALSO SAFER THAN OTHERS WHICHONE SEES.  нOTE THAT YOU CANNOT CALL HI-LEVEL фORTH WORDS USING THISTECHNIQUE - ONLY CODE LEVEL DEFINITIONS MAY BE CALLED IN THIS WAY. иF YOUTHINK YOU WANT TO EXIT A цоде DEFINITION WITH A CALL TO A HIGHER LEVEL фORTHWORD, THINK AGAIN. иF YOU STILL NEED TO DO IT, THEN START TINKERING WITH THEип AND в REGISTERS.и THINK THAT ABOUT COVERS IT. и HAVE TRIED TO COVER ALL OF THE BASICS, ANDMANY OF THE MORE ADVANCED TECHNIQUES IN COMBINING ASSEMBLY LANGUAGE ANDфORTH. иF SOME OF IT SEEMS OBSCURE, IT IS PROBABLY MY EXPLANATION, SINCEHACKING IN цоде IS REALLY NO MORE DIFFICULT THAN HACKING IN ANY LANGUAGE -IT JUST RUNS FASTER.гOOD лUCKаNDхAPPY хACKING!сдб