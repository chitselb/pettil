; core-extra.a65
#echo .       core-extra.a65            Extra stuff

;--------------------------------------------------------------
#if 0
name=MSB
stack=( u -- c )
tags=extra
Returns the high byte of a cell
#endif
msb
    lda tos+1
    ldy #0
    jmp put

;--------------------------------------------------------------
#if 0
name=LSB
stack=( u -- c )
tags=extra
Returns the low byte of a cell
#endif
lsb
    lda #0
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=VIDRAM
stack=( -- $8000 )
tags=i/o,const
Constant, address of PET video memory $8000
#endif
vidram
    jsr doconst
    .word VIDRAM

;--------------------------------------------------------------
#if 0
name=MON
stack=( -- )
tags=system,ext
Restores BASIC zero page and exits to the TIM monitor
#endif
mon
    jsr aloha      ; restore BASIC zpage
    brk
    jsr aloha      ; restore BASIC zpage

;--------------------------------------------------------------
#if 0
name=xyzzy
stack=( -- )
tags=nosymbol
Forth breakpoint, used for debugging in VICE

usage:

```

: someword
   begin
       dup .
       1-
       dup bar 0=

       xyzzy    \ insert a breakpoint

    until drop ;
```
#endif
xyzzy
    jmp next        ; used as a VICE monitor breakpoint

;--------------------------------------------------------------
#if 0
name=JIFFY@
stack=( -- d )
tags=device,system,ext
The number of jiffies since powerup or midnight as a double
#endif
#include "align.i65"
_jiffyfetch
    jsr enter
#include "page.i65"
    .word notirq                ; don't let IRQ interrupt the copy
#include "page.i65"
    .word clit
    .byt TIME
#include "page.i65"
    .word threecfetch
#include "page.i65"
    .word notirq                ; reenable
#include "page.i65"
    .word exit  ; [14]

;--------------------------------------------------------------
#if 0
name=CMDOFF
tags=i/o,kernel
stack=( -- )
Restore default I/O channels
#endif
cmdoff
    stx xsave
    jsr CLRCHN
    ldx xsave
    jmp next

;--------------------------------------------------------------
#if 0
name=@SWAP!
stack=( var1 var2 -- )
tags=extra
Exchanges the contents of two variables.

```
: @swap!   ( a b -- )
2dup 2>r
( a b ; b a )
@ swap @
( @b @a ; b a )
r> ! r> ! ;
```
#endif
#include "align.i65"
_fetchswapstore
    jsr enter
#include "page.i65"
    .word twodup
#include "page.i65"
    .word twotor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PAUSE
stack=( flag -- )
tags=nucleus,ext
Waits for a keypress from the user before exiting

```
: pause   ( flag -- ) 
    if
        ." \nPRESS ANY KEY\n"
    then
    key drop ;
```
#endif
#include "align.i65"
_pause
    jsr enter
#include "page.i65"
    .word qbranch
    .byt <(pause01-*+1)
#include "pad.i65"
    .word pdq
    .byt <(pause01-*-1)
    .asc CR,"PRESS ANY KEY",CR
pause01
#include "pad.i65"
    .word key
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=40/MOD
stack=( u -- u%40 u/40 )
tags=math
[[Routine courtesy of Mike B.|http://forum.6502.org/viewtopic.php?f=2&t=3051#p34802]]  Thank you sir!

Perform a divide by 40 and a modulo 40, useful for screen positioning and
[[Radix50|http://en.wikipedia.org/wiki/DEC_Radix-50]]
#endif
xlmod40
        jsr slip
        lda #0
        ldy #16
xlmod40b
        cmp #20
        bcc xlmod40c
        sbc #20
xlmod40c
        rol tos
        rol tos+1
        rol
        dey
        bne xlmod40b
        sta stackl,x
        sty stackh,x
        jmp next

;--------------------------------------------------------------
#if 0
name=DORINGBUFFER
stack=( -- addr )
tags=compiler,nosymbol

#endif
doringbuffer
    jsr dodoes
#include "page.i65"
    .word four
#include "page.i65"
    .word plus
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NEW-EVENTS
stack=( -- addr )
tags=compiler
This is a [[RINGBUFFER]] of five 3-byte elements, used by the 
event IRQ routine.  New events are added like this:

* erase the next 3 bytes in the buffer
* increment the tail by +3
* [[C!]] the timeout byte
* [[!]] the CFA word

The [[!]] operation writes the most significant (high) byte
last, and no code field exists on the zero page.  When both the
timeout byte and the MSB of the CFA are non-zero, an event is
said to be latched, and the IRQ will add it to the [[EVENTS]] list
(and remove it from [[NEW-EVENTS]])

#endif
newevents
    jsr doringbuffer
    .byt 15                 ; size
    .byt 0                  ; wrap
    .byt 0                  ; head
    .byt 0                  ; tail
    .dsb 15,0

;--------------------------------------------------------------
#if 0
name=TASKS
stack=( -- addr )
tags=compiler
This is a [[RINGBUFFER]] of ten 2-byte elements, used by the 
event IRQ routine.  It will contain a list of CFAs to be executed
in order by the mainline code.  Mainline code should not add
elements to this queue, but can remove them by first zeroing 
the CFA then adding +2 to the head pointer

#endif
tasks
    jsr doringbuffer
    .byt 20                 ; size
    .byt 0                  ; wrap
    .byt 0                  ; head
    .byt 0                  ; tail
    .dsb 20,0

;--------------------------------------------------------------
#if 0
name=(RINGBUF+)
stack=( ringbuffer -- addr )
tags=compiler,subroutine,nosymbol
This subroutine is reentrant.  It is called by the interrupt
service routine and the mainline routine, so it can't use any
memory as it might interrupt itself.  The IRQ service routine
will push its own ringbuffers on the stack

|register|input|output|
|^''A''|^Offset to add to head or tail||
|^''X''|unused|unused|
|^''Y''||~|
|^''C''|''0''<br/>''1''|move the head (read)<br/>move the tail (write)|

Increments the `head` (-2) or `tail` (-1) by `offset` 
within a [[RINGBUFFER]] structure.  The pointer wraps
back to the start of the buffer when it reaches `size`.

Returns the address pointed to by the adjusted pointer.

Use an offset of 0 to read the pointer location.
#endif
pringbufplus
    php                     ; keep a copy of carry flag 0=head 1=tail
    dec tos+1               ; back up to prev page
    ldy #$fe                ; head
    bcc pringbufplus01
    iny                     ; no tail
    clc
pringbufplus01
    ;clc
    adc (tos),y             ; [head|tail] += offset
    sta (tos),y
    ldy #$fc
    cmp (tos),y             ; compare to size
    bcc pringbufplus03      ; inside the lines?
    iny                     ; $fd wrap counter
    lda (tos),y
    adc #0
    sta (tos),y             ; increment wrap counter
    iny                     ; head
    plp                     ; check copy of C flag
    bcc pringbufplus02
    iny
pringbufplus02
    lda #0
    sta (tos),y             ; zero head|tail pointer
    inc tos+1               ; move back to current page
    rts
pringbufplus03
    ;clc                    ; TOS += new position
    adc tos
    sta tos
    lda tos+1
    adc #1
    sta tos+1
    pla                     ; discard carry flag
    rts

;--------------------------------------------------------------
#if 0
name=RINGBUF+
stack=( offset -1|-2 ringbuf -- addr )
tags=compiler
Increments the `head` (-2) or `tail` (-1) by `offset` 
within a [[RINGBUFFER]] structure.  The pointer wraps
back to the start of the buffer when it reaches `size`.

Returns the address pointed to by the adjusted pointer.

Use an offset of 0 to read the pointer location.
#endif
ringbufplus
    lsr stackl,x            ; Carry bit is true for -1, false for -2
    lda stackl+1,x          ; offset, 0 for read
    jsr pringbufplus
    inx
    inx
    jmp next

;--------------------------------------------------------------
#if 0
name=MAINIRQ
stack=( -- )
tags=events
#endif
cmainirq
    jsr doconst
    .word MAINIRQ

;--------------------------------------------------------------
#if 0
name=EVENTIRQ
stack=( -- )
tags=events
IRQ service routine used by event handler.  There are three 
FIFO queues, two of them accessible to the application 
programmer: [[EVENTS]] and [[TASKS]].  The third queue is 
internal to this IRQ service routine and is not thread-safe 
for read or write by mainline code.

* check for events
* decrement all timers
* remove expired events
* add expired event CFAs to the [[TASKS]] queue
* add [[EVENTS]] from the [[NEW-EVENTS]] queue
* chain the ROM IRQ service routine
#endif
eventirq
    jsr slide               ; we may need two bytes of zero page
    ldx evcounters+2        ; tail
    dex
    jmp eventirq02
eventirq01
    dec eventtimers,x
    bne eventirq02
    ; expired? add it to [[TASKS]]
    lda #<(tasks+7)
    sta tos
    lda #>(tasks+7)
    sta tos+1
    clc                     ; the head
    lda #0
    jsr pringbufplus        ; get the head
    ldy #0
    lda eventcfalo,x
    sta (tos),y
    iny
    lda eventcfahi,x
    sta (tos),y
    clc                     ; the head
    lda #2
    jsr pringbufplus        ; increment the head
    ; remove the event here
eventirq02
    inx
    txa
    and #7                  ; for 8 events
    ; and #15               ; for 16 events
    tax
    bne eventirq03
    inc evcounters          ; bump wrap
eventirq03
    cpx evcounters+1        ; compare to head
    bne eventirq01          ; we've got something
    lda evcounters          ; wrap
    lsr
    bcs eventirq01          ; parity bit odd? queue is full
eventirq04
    ; add new events here
    jsr slip                ; restore the data stack
    jmp MAINIRQ

    lda #<(newevents+7)
    sta tos
    lda #>(newevents+7)
    sta tos+1
    sec                 ; the tail
    lda #0
    jsr pringbufplus
    ldy #0
    lda (tos),y
    beq eventirq01
    inc VIDRAM
    clc
    sbc #0
    sta (tos),y

;--------------------------------------------------------------
#if 0
name=EVENTS
stack=( -- )
tags=events
#endif
evcounters
;    .byt 8                 ; size is implicit, either 8 or 16
    .byt 0                  ; wrap
    .byt 0                  ; head
    .byt 0                  ; tail
eventtimers
    .dsb 8,0
eventcfalo
    .dsb 8,0
eventcfahi
    .dsb 8,0
