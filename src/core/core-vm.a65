; core-vm.a65
;#echo .       core-vm.a65               Virtual Memory

;--------------------------------------------------------------
#if 0
name=B/BUF
stack=( -- 1024 )
tags=const,forth-83
!!!Constant
bytes per buffer = 1024
#endif
bperbuf
    jsr doconst
    .word BPERBUF

;--------------------------------------------------------------
#if 0
name=B/SCR
stack=( -- 1000 )
tags=const,vm
!!!Constant
bytes per screen.  Not what it usually means in other Forths,

 |model|b/scr|h
 |PET|1000|
 |PET 8032|2000|
 |VIC-20|512|
 |C=64|1000|
 |C128|1000|
 |Plus/4|1000|

#endif
bperscr
    jsr doconst
    .word BPERSCR

;--------------------------------------------------------------
#if 0
name=CAS1BUF
stack=( -- $027A )
tags=const,vm
!!!Constant
Address of the first tape buffer (device #1)
#endif
cas1buf
    jsr doconst
    .word CAS1BUF

;--------------------------------------------------------------
#if 0
name=CAS2BUF
stack=( -- $033A )
tags=const,vm
!!!Constant
Address of the second tape buffer (device #2)
base address of cassette buffer #2, used (for now) as a line buffer
to unpack screens and blocks into lines
#endif
cas2buf
    jsr doconst
#ifdef IS_PET
    .word CAS2BUF
#else
    .word CAS1BUF
#endif

;--------------------------------------------------------------
#if 0
name=BLKBUF
stack=( -- addr )
tags=vm
Returns the address of the 1K virtual memory block buffer.

There is only a single 1K fixed block buffer on the system, and
all data and screen packets are retrieved from the packet buffer
through it.

Copying a block to a different block can be achieved by using [[PAD]] as
temporary storage.  When [[REHASH]] rebuilds the symbol
table, it performs [[automatic memory allocation|AUTOMEM]]
and may move `BLKBUF` (and its contents) to a new location.

!!! pronounced: "b-l-k-buff"

```
: blkbuf   ( -- addr )
    symtab @  ?: symtab limit  @ b/buf - ;
```
#endif
#include "align.i65"
blkbuf
    lda usersymtab+1            ; always a page boundary
    bne blkbuf02                ; or 0 if `symtab` is off
    lda zpbuf+MEMSIZ+1             ; okay  in core mode use `limit` from our zeropage copy
blkbuf02
    sec
    sbc #4
    tay
    lda #0
    jmp pushya
;[17] -1 20191019cah

;--------------------------------------------------------------
#if 0
name=EDITING?
stack=( -- flag )
tags=vm,ext,nosymbol
Retrieves the EDITING user variable

```
: editing?
    editing @ ;
```
#endif
editingq
    lda userediting+1
    jmp uncompressedq01

;--------------------------------------------------------------
#if 0
name=ISSCR?
stack=( -- flag )
tags=vm,ext,nosymbol
Returns a `flag`, `true` when `pkt` type is screen
`false` when the `pkt` type is data

```
: isscr?   ( -- flag )
    <n8 @ $4000 and ;
```
#endif
isscrq
    sec
    .byt $29                    ; AND imm
    ;fall through
;--------------------------------------------------------------
#if 0
name=UNCOMPRESSED?
stack=( -- flag )
tags=vm,ext,nosymbol
Returns a `flag`, `true` when the packet is simply stored by `cmove` or
`false` when the packet is runlength-encoded

```
: uncompressed?   ( -- flag )
    blk @ >pkt @ $4000 and ;
```
#endif
uncompressedq
    clc
    ;
    ldy #1
    lda (R0L+2*N8),y            ; packet header msb
    bcs uncompressedq01
    asl
uncompressedq01
    asl                         ; normalize `flag`
    jmp xpushc

;--------------------------------------------------------------
#if 0
name=CASBUF
stack=( -- 027a|033a )
tags=vm,kernel
Returns the tape buffer address for most recently accessed
device `FA ($d4)`

#endif
casbuf
    brk
    .byt ext
    .word SETCASBUF
    .byt set | N0
    .word TAPE1
    .byt ldd | N0
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=RLENCODE
stack=( from to size -- size uncompressed? )
tags=vm,sweet16
squeeze repeated characters out of a buffer by replacing them with [char][char][count]

`from to howmany` stack signature is like `cmove`

encode [size] bytes from source address [from] to
target address [to].

|PETTIL/Sweet16 Registers|<|<|<|<|<|<|<|h
|^ACC|^TOS|^N0|^N1|^N2|^N3|^N4|^N5|h
|^x|^x|^x|^x|^x|^x|^x|^x|
|^N6|^N7|^N8|^EXT|^SP|^CPR|^RSLT|^PC|h
|^x|^x|^x|^x|^x|^x|^x|^x|

* `uncompressed?` is false when RLE compression is used, true when data is copied as-is


#endif
rlencode
    ; n0    src (in)
    ; n1    size (in)
    ; n2    targ (out)
    ; n3    size (out)
    ; n4    repeat
    ; n5    prev
    ; n6    $100
    ; n7    targ (pristine)
    ; r11   size (pristine)
    brk
    .byt ld | TOS               ; size
    .byt st | N1                ; size (in)
    .byt st | N3                ; size (out)
    .byt st | R11               ; size (pristine)
    .byt pull                   ; to
    .byt st | N2                ; targ (out)
    .byt st | N7                ; targ (pristine)
    .byt pull                   ; from -- TOS = src (pristine)
    .byt st | N0                ; src (pristine)
    .byt set | N6               ; constant to initialize repeat counter
    .word $100
rlencode01
    .byt ld | N6                ; also unfindable character
rlencode02
    .byt st | N5                ; prev character
    .byt ld | N3
    .byt bm , <(rlencode07-*-2) ; is RL encoding no size benefit?
    .byt ld | N1
    .byt bz , <(rlencode06-*-2) ; done with input?
    .byt ldi | N0               ; read input stream
    .byt dcr | N1
    .byt sti | N2               ; write output stream
    .byt dcr | N3
    .byt cpr | N5               ; compare to prev
    .byt bnz , <(rlencode02-*-2) ; different? go get more
    .byt ld | N6
    .byt st | N4                ; count backwards from 256
    .byt dcr | N4               ; count the one already in output stream
rlencode03
    .byt dcr | N4
    .byt bz , <(rlencode04-*-2) ; overflow?
    .byt ld | N1
    .byt bz , <(rlencode04-*-2) ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | N1
    .byt cpr | N5
    .byt bz , <(rlencode03-*-2) ; same char? loop

    .byt dcr | N0               ; different char?
    .byt inr | N1               ; un-get from input stream
rlencode04                      ; overflow/end of input
    .byt ld | N6
    .byt sub | N4
    .byt sti | N2               ; write count to output stream
    .byt dcr | N3
    .byt br , <(rlencode01-*-2)

rlencode06                      ; win
    .byt sub | ACC              ; 0 = not uncompressed? (so, hopefully compressed then!)
    .byt bs, <(rlencode08-*-2)
    .byt nxt
;( uncompressed?        ; floor  pkt )

rlencode08
    .byt st | TOS
    .byt ld | N2
    .byt sub | N7
    .byt push
    .byt rs

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0                ; keep pristine TOS
    .byt ld | R11               ; return original `size`
    .byt add | N7               ; +pristine targ
    .byt st | N2                ; `update` uses `n2-n7` to get new size
    .byt set | ACC              ; `uncompressed?` is true
    .word $4000
    .byt bs, <(rlencode08-*-2)

    .byt ld | N0                ; from
    .byt push
    .byt ld | N7                ; to
    .byt push
    .byt ld | R11               ; howmany
    .byt push
    .byt rtn
    jmp cmove

;--------------------------------------------------------------
#if 0
name=RLDECODE
stack=( from to size -- )
tags=vm,sweet16
decode length {srclen} bytes beginning at source address
{srcaddr} to the target address (targaddr).

~todo: Forth only version is smaller/faster than Sweet16

```
: rldecode   ( from to size -- )
\ input stream follows each pair of matching adjacent characters with [count]
  begin
    1- rot c@+ >r
    c@+ r@ =
    if
      2-under c@+ >r rot
      2r> 0 ?do
        dup>r c!+ r>
      loop drop
    else
      1- rot r> c!+
    then rot
    dup 0=
  until  3drop ;
```
#endif
rldecode
    jsr harvests4
    brk
    .byt set | N4
    .word $100
rldecode01
    .byt ld | N4
    .byt st | N2                ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; read source stream
    .byt sti | N1               ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2) ; different? go get more
rldecode03
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | N4
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1               ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull                   ; drop srclen
    .byt nxt

;--------------------------------------------------------------
#if 0
name=PKT.SIZE
stack=( pkt -- pkt size )
tags=vm,ext,nosymbol
Return unaltered `pkt` and `size` of this packet

```
: pkt.size    ( pkt -- pkt size )
    dup @ psize ;
```
#endif
#include "align.i65"
_pktsize
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word psize
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT.THIS
stack=( -- pkt size )
tags=vm,ext
Return header address and size for current packet in `n8`

```
: pkt.this    ( -- pkt size )
    <n8 pkt.size ;
```
#endif
#include "align.i65"
_pktthis
    jsr enter
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N8
#include "pad.i65"
    .word _pktsize
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT.WRAP
stack=( -- addr )
tags=vm,ext,nosymbol
Return `addr` of 3-byte linewrap bits for current screen `pkt` in `vmbuf`

```
: pkt.wrap   ( -- addr )
    <n8 3- ;
```
#endif
#include "align.i65"
_pktwrap
    jsr enter
#include "parm.i65"
   .word zpfrom
   .byt R0L+2*N8
#include "pad.i65"
   .word threeminus
#include "past.i65"
   .word exit

;--------------------------------------------------------------
#if 0
name=PKT.NXT
stack=( pkt -- pkt' )
tags=vm,ext,nosymbol
Return next

```
: pkt.next    ( pkt -- pkt' )
    pkt.size - ;
```
#endif
#include "align.i65"
_pktnxt
    jsr enter
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word minus
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PSIZE
stack=( header -- addr )
tags=vm,ext,nosymbol
Return size of this packet header

```
: psize   ( header -- size )
    $7FF and ;
```
#endif
psize
    lda #7
psize01                                 ; useful entry point for xxFF AND
    and tos+1
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=>PKT
stack=( n -- )
tags=vm,ext
Set `n8` to `pkt` address of block `n`

```
: >pkt
    blkbuf 2-
    begin
        over
    while
        1-under
        @+ psize - 2-
        dup @ psize -
    repeat
    n8 ! ;
```
#endif
#include "align.i65"
_topkt
    jsr enter
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
topktb01
#include "page.i65"
    .word over
#include "parm.i65"
    .word qbranch
    .byt <(topktb02-*+1)
#include "pad.i65"
    .word oneminusunder
#include "page.i65"
    .word _pktnxt
#include "parm.i65"
    .word branch
    .byt <(topktb01-*+1)
#include "pad.i65"
topktb02
    .word nip
#include "parm.i65"
    .word blit
    .byt R0L+2*N8
#include "pad.i65"
    .word store
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=3C@
stack=( addr -- d )
tags=nucleus

 fetches three bytes as a double.  Useful for retrieving screen
 linewrap bits from the beginning of the block buffer or the jiffy
 clock

|msb|addr+0|
|2sb|addr+1|
|lsb|addr+2|

```
: 3c@   ( addr -- d )
     dup 1+ @ swap c@ ;
     c@+ swap @ ;
     @+ swap c@ ;

threecfetch
    jsr slip
    ldy #2
    jsr fetchunders
    jmp cfetch
;[11]

fetchunders
    lda (tos),y         ; msb
    sta stackl,x
    dey
    lda (tos),y
    sta stackh,x
    rts
```
#endif
#include "align.i65"
_threecfetch
    jsr enter
#include "page.i65"
    .word cfetchplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word cswap
#include "page.i65"
    .word swap
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=3C!
stack=( d addr -- )
tags=nucleus
 store low 3 bytes of d at addr in jiffy clock order

|msb|addr|
|2sb|addr+1|
|lsb|addr+2|

Order inverted to write timer last for EVENTS, and to find the bits from
left to right for linewrap masks

```
: 3c!    ( lo hi addr -- )
    1+ rot cswap !+ 3- c! ;
```
#endif
#include "align.i65"
_threecstore
    jsr enter
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word rot
#include "page.i65"
    .word cswap
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word cstore                ; low word
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-@
stack=( nfa -- cfa )
tags=extra
decrement `tos` and fetch the value

#endif
minusfetch
;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

```
: name>   ( nfa -- cfa )
    2- @ ;
```
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=WRAPZAP12
stack=( -- )
tags=editor,subroutine,nosymbol
Zero R0..R5 (12 bytes)

!!!pronounced: "wrap zap twelve"
#endif
wrapzap12
    jsr slip                    ; dup, so this won't overwrite `tos`
    lda #12                     ; default # of bytes to clear
    ;fall through
;--------------------------------------------------------------
#if 0
name=WRAPZAPS
stack=( x -- 0 )
tags=editor,subroutine,nosymbol
|pass:|A|# of bytes to clear|
|return:|A|0|
||Z|stack|

!!!pronounced: "wrap zap"
#endif
wrapzaps
    stx z                       ; preserve Forth data stack pointer
    tax
    lda #0
wrapzap01
    dex
    sta 0,x
    bne wrapzap01
    ldx z
    rts

;--------------------------------------------------------------
#if 0
name=WRAPROLLS
stack=( -- )
tags=vm,subroutine,nosymbol


pass `c` bit to append
    `x` lsb address of 32-bit wrapd

appends linewrap bit to a zeropage double beginning at `x`

!!!pronounced: "wrap rolls"
#endif
wraprolls
    rol 0,x
    rol 1,x
    rol 2,x
    rol 3,x
    rts
;[9]

;--------------------------------------------------------------
#if 0
name=WRAPUMAX
stack=( -- )
tags=editor,subroutine,nosymbol
Iteratively double a 32-bit `wrapd` until it is left-aligned (as close to
`umax` as possible without going over)

!!!pronounced: "wrap umax"
#endif
wrapumax
    sec                         ; return the `1` bit for line 0
    lda 3,x
    bmi wrapumax02
wrapumax01
    jsr wraprolls
    bpl wrapumax01
wrapumax02
    rts

;--------------------------------------------------------------
#if 0
name=WRAP@
stack=( -- wrapd  )
tags=primitive
Retrieve the 25-bit linewrap table at `$E0..F8` as a double

#endif
wrapfetch
    jsr wrapzap12               ; ~wut? ~C=64 issue?
    ;stx z
    ldy #$FF
    ldx #tos                    ; put it in `tos(hi) n0(lo)`
wrapfetch01
    iny
    lda LDTB1,y
    asl
    jsr wraprolls
    beq wrapfetch01
    ldx z
    ldy R0L+2*N0+1
    lda R0L+2*N0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=WRAP!
stack=( wrapd -- )
tags=primitive

Updates the linewrap table at $E1-F8 to reflect the low 24 bits
in double `wrapd`.  Since line 0 ($E0) is always $80 (never a
continuation line, it is not updated.  Only 24 bits need to be
written ($E1-$F8), not 25.  The  msb of `wrapd` is typically $01,
a framing bit used when loading the wrap double (see `wrap@`).

#endif
wrapstore
    jsr swaps
    jsr harvests2
    stx z
    ldx #tos
    jsr wrapumax
    ldx #<(-25)
wrapstore01
    txa
    asl <(LDTB1+25),x
    ldx #tos
    jsr wraprolls
    tax
    ror <(LDTB1+25),x
    inx
    bne wrapstore01
    ldx z
    jmp drop

;--------------------------------------------------------------
#if 0
name=DIRTYBUF
stack=( -- )
tags=vm,nosymbol
Mark `blkbuf` dirty to force `block` to reload from `vmbuf`

```
: dirtybuf   ( -- )
    prev on ;
```
#endif
#include "align.i65"
_dirtybuf
    jsr enter
#include "page.i65"
    .word prev
#include "page.i65"
    .word on
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#BLK!
stack=( -- )
tags=vm,extra
Reset `vmbuf` pointer and `#blk` by running through all packets

```
: #blk!   ( -- )
    #blk off  blkbuf 2-
    begin
        pkt.size ?dup
    while
        #blk 1+!
        -
    repeat
    vmbuf ! ;

: #blk!   ( -- )
    #blk 8 erase  dirtybuf
    blkbuf 2-
    begin
        dup pkt.nxt tuck <>
    while
        #blk 1+!
    repeat
    vmbuf ! ;
```
#endif
#include "align.i65"
_numblkstore
    jsr enter
#include "page.i65"
    .word numblk
#include "page.i65"
    .word eight
#include "page.i65"
    .word erase
#include "page.i65"
    .word _dirtybuf
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
numblkstore01
    .word _pktsize
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word qbranch
    .byt <(numblkstore02-*+1)
#include "pad.i65"
    .word numblk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word minus
#include "parm.i65"
    .word branch
    .byt <(numblkstore01-*+1)
#include "pad.i65"
numblkstore02
    .word vmbuf
#include "page.i65"
    .word store
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MKSCR
stack=( -- addr )
tags=compiler,nosymbol

#endif
mkscr
    jsr docreate
    .byt 5, $FF, $FF, $FF, $05, $80

;--------------------------------------------------------------
#if 0
name=MKDATA
stack=( -- addr )
tags=compiler,nosymbol

#endif
mkdata
    jsr docreate
    .byt 2, $02, $40

;--------------------------------------------------------------
#if 0
name=(PKT+)
stack=( size -- size floor #blk )
tags=compiler,nosymbol

#endif
ppktplus
    brk
    .byt set | N0
    .word usernumblk
    .byt popd | N0              ; `vmbuf`
    .byt st | N8                ; `pkt`
    .byt sub | TOS              ; `pkt` - `size`
    .byt std | N0               ; set `vmbuf`
    .byt push
    .byt sub | ACC
    .byt std | TOS              ; `vmbuf off`
    .byt ld | N0                ; #blk
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=PKT+
stack=( -- )
tags=compiler,nosymbol
Append a new data or screen packet (per `editing`) to `vmbuf` tail

```
: pkt+   ( -- )
    editing? ?: mkscr mkdata
    count (pkt+)
    1+! swap cmove ;
```
#endif
#include "align.i65"
_pktplus
    jsr enter
#include "page.i65"
    .word editingq
#include "parm.i65"
    .word pquerycolon
    .word mkscr
    .word mkdata
#include "pad.i65"
    .word count
#include "page.i65"
    .word ppktplus
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCREDIDX
stack=( -- index )
tags=vm,ext,nosymbol
return `index`:
0 interpret data
2 interpret isscr?
4 editing? data
6 editing? isscr?

    ldy #1
    bit userediting
    lda (R0L+2*N8),y
    php
    pla
    rol
    rol
    rol
    and #3
    jmp push0a

    ldy #1
    lda (R0L+2*N8),y            ; pkt header msb
    asl                         ; isscr? bit to carry flag
    tya
    and userediting
    rol
    asl                         ; 00|02|04|06
    jmp push0a

    editing? 2* isscr? xor 2+ 2*

~wut unused code [14]
#endif
scredidx
    ldy #1
    lda (R0L+2*N8),y            ; pkt header msb
    asl                         ; isscr? bit to carry flag
    tya
    and userediting
    rol
    asl                         ; 00|02|04|06
    jmp push0a
;[14]

;--------------------------------------------------------------
#if 0
name=DWRAP@
stack=( -- wrapd  )
tags=vm,ext,nosymbol

```
: dwrap@   ( -- wrapd )
    3c@ benjamin or ;
```
#endif
#include "align.i65"
_dwrapfetch
    jsr enter
#include "page.i65"
   .word _threecfetch
#include "page.i65"
   .word benjamin
#include "page.i65"
   .word orx                    ; the Cars guy
#include "past.i65"
   .word exit

;--------------------------------------------------------------
#if 0
name=BUF.WRAP
stack=( -- addr )
tags=vm,ext,nosymbol
Return `addr` of 3-byte linewrap bits in `blkbuf`

```
: buf.wrap   ( -- addr )
    blkbuf b/scr + ;
```
#endif
#include "align.i65"
_bufwrap
    jsr enter
#include "page.i65"
   .word blkbuf
#include "page.i65"
   .word bperscr
#include "page.i65"
   .word plus
#include "past.i65"
   .word exit

;--------------------------------------------------------------
#if 0
name=BUF.WRAP@
stack=( wrapd -- )
tags=vm,ext,nosymbol


```
: buf.wrap@   ( -- wrapd  )
    buf.wrap dwrap@ ;
```
#endif
#include "align.i65"
_bufwrapfetch
    jsr enter
#include "page.i65"
    .word _bufwrap
#include "page.i65"
   .word _dwrapfetch
#include "past.i65"
   .word exit

;--------------------------------------------------------------
#if 0
name=BUF.WRAP!
stack=( wrapd -- )
tags=vm,ext,nosymbol
Store 24-bit `wrapd` in `blkbuf` just beyond the screen image (+`b/scr`)

```
: buf.wrap!   ( wrapd -- )
    buf.wrap 3c! ;
```
#endif
#include "align.i65"
_bufwrapstore
    jsr enter
#include "page.i65"
    .word _bufwrap
#include "page.i65"
   .word _threecstore
#include "parm.i65"
    .word blit
    .byt $80
#include "pad.i65"
    .word _bufwrap
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word cstore
#include "past.i65"
   .word exit

;--------------------------------------------------------------
#if 0
name=PKT.CUR
stack=( -- )
tags=secondary,i/o,vm,nosymbol
Traverse the packet chain from top to button until we reach packet `scr` or packet `prev` (depending on the value of `editing?`).  Sets `n8`, used by
`update`, `block` and `copy`.

```
: pkt.cur   ( -- )
    scr.prev? @ >pkt ;
```
#endif
#include "align.i65"
_pktcur
    jsr enter
#include "page.i65"
   .word editingq
#include "parm.i65"
    .word pquerycolon
    .word scr
    .word prev
#include "pad.i65"
    .word fetch
#include "page.i65"
    .word _topkt
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EMPTY-BUFFERS
stack=( -- )
tags=i/o,forth-83
Unassign all virtual memory.  UPDATEed blocks are not written
to mass storage.

```
: empty-buffers   ( -- )
    blkbuf 2-  dup vmbuf !  off  blk off  scr off  #blk! ;
```
#endif
#include "align.i65"
_emptybuffers
    jsr enter
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word off
#include "page.i65"
    .word _numblkstore
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?MKPKTS
stack=( u -- u )
tags=vm,nosymbol

```
: ?mkpkts   ( u -- u )
    begin                       \ make packets loop
        #blk @ over 1+ <
     while
        pkt+
    repeat
    >pkt ;                 \ sets `n8`

#endif
#include "align.i65"
_qmkpkts
    jsr enter
#include "page.i65"
qmkpkts01
    .word numblk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word lt
#include "parm.i65"
    .word qbranch
    .byt <(qmkpkts02-*+1)
#include "pad.i65"
    .word _pktplus
#include "parm.i65"
    .word branch
    .byt <(qmkpkts01-*+1)
#include "past.i65"
qmkpkts02
    .word exit

;--------------------------------------------------------------
#if 0
name=BLOCK
stack=( blk -- buf )
tags=vm,fig,forth-79,forth-83
Unpack a screen or data packet from `vmbuf` to `blkbuf` or `vidram`

```

: block   ( u -- addr )
    ?mkpkts curbuf              ( addr )
    prev 2@ =
    editing? 0= and  ?exit      \ block already loaded?
    blk @ prev !                \ inhibit redundant reloading
    dup b/buf  isscr?
    ?: blank erase              \ wipe the buffer
    dup pkt.size tuck -
    isscr?
    if
        3-under <n8 3- dwrap@
        editing?  ?: wrap! bufwrap!
    then
    -rot uncompressed?
    ?: cmove rldecode ;

: curpkt   ( -- )
    editing? ?: scr prev
    >pkt drop ;

: update   ( -- )
    curpkt

    bufwrap dwrap!

: block   ( u -- buf )
    ?mkpkts
    scr.prev? buf? over @
    2swap under !
    <> editing? or
    if
        pkt.cur
        dup b/buf
        isscr? ?: blank erase
        pkt.this 2- dup>r - over r>
        isscr?
        if
            3- pkt.wrap dwrap@
            editing? ?: wrap! buf.wrap!
        then
        uncompressed? ?: cmove rldecode
    then ;
```
#endif
#include "align.i65"
_block
    jsr enter
#include "page.i65"
    .word _qmkpkts
#include "page.i65"
   .word editingq
#include "parm.i65"
    .word pquerycolon
    .word scr
    .word prev
#include "pad.i65"
    .word editingq
#include "parm.i65"
    .word pquerycolon
    .word vidram
    .word blkbuf
#include "pad.i65"
    .word over
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoswap
#include "page.i65"
    .word under
#include "page.i65"
    .word store
#include "page.i65"
    .word ne
#include "page.i65"
    .word editingq
#include "page.i65"
    .word orx
#include "parm.i65"
    .word qbranch
    .byt <(blk03-*+1)
#include "pad.i65"
    .word _pktcur
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word isscrq
#include "parm.i65"
    .word pquerycolon
    .word blank
    .word erase
#include "pad.i65"
    .word _pktthis              ; buf -- buf pkt size
#include "page.i65"
    .word twominus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word minus                 ; buf -- buf floor
#include "page.i65"
    .word over
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word isscrq
#include "parm.i65"
    .word qbranch
    .byt <(blk02-*+1)
#include "pad.i65"
    .word threeminus            ; don't decode 24-bit linewrap to buffer
#include "page.i65"
    .word _pktwrap              ; <n8 3-
#include "page.i65"
    .word _dwrapfetch
#include "page.i65"
    .word editingq
#include "parm.i65"
    .word pquerycolon
    .word wrapstore
    .word _bufwrapstore
#include "pad.i65"
blk02
    .word uncompressedq
#include "parm.i65"
    .word pquerycolon
    .word cmove
    .word rldecode              ; ~ in a world with poor packet data, could
#include "past.i65"             ; ~ overwrite linewrap bits at blkbuf+1000
blk03
    .word exit

;--------------------------------------------------------------
#if 0
name=UPDATE
stack=( -- )
tags=fig,forth-79,forth-83,vm
Copies and compresses from either the `vidram` or `blkbuf` into a
[[virtual memory packet buffer|PETTIL system memory map]].  `update`
is the antonym of `block` (which retrieves from `vmbuf`).

tests:
 block 0
 nonzero block numbers
 empty block
 blank block
 screen 1000+3 in blkbuf
 for all combinations of `isscr?` and `editing?`
 for both packet types
 with and without compression
 fill blkbuf half with $DEADBEEF
 fill blkbuf all with $DEADBEEF
 fill blkbuf half with '!'
 fill blkbuf all with '!'
 fill screen with 80-column uncompressable ($555555 wrap)
 fill screen with normal source code
 fill screen half with '!'
 fill blkbuf all with '!'
 fill blkbuf all with '!'

#endif
#include "align.i65"
_update
    jsr enter
#include "page.i65"
    .word _pktcur
#include "page.i65"
    .word editingq
#include "page.i65"
    .word isscrq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word minus
#include "page.i65"
    .word editingq
#include "parm.i65"
    .word pquerycolon
    .word vidram
    .word blkbuf
#include "pad.i65"
    .word tuck
#include "page.i65"
    .word isscrq
#include "parm.i65"
    .word pquerycolon
    .word bperscr
    .word bperbuf
#include "pad.i65"
    .word isscrq
#include "parm.i65"
    .word pquerycolon
    .word dashtrailing
    .word dashnulls
#include "pad.i65"
    .word nip
#include "page.i65"
    .word rlencode              ; ( uncompressed? size )
#include "page.i65"
    .word isscrq
#include "parm.i65"
    .word qbranch
    .byt <(update02-*+1)
#include "pad.i65"
    .word vidram
#include "page.i65"
    .word plusunder             ; set `isscr?` bit in new header
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N2               ; before `wrap@` erases it!
#include "pad.i65"
    .word editingq
#include "parm.i65"
    .word pquerycolon
    .word wrapfetch
    .word _bufwrapfetch
#include "pad.i65"
    .word rot
#include "page.i65"
    .word _threecstore
#include "page.i65"
    .word threeplus             ; add 3 to `size`
#include "page.i65"
update02
    .word twoplus               ; ( flags size.new )
#include "page.i65"
    .word _pktthis              ;( flags size.new pkt size )
#include "page.i65"
    .word twoover               ;( flags size.new pkt size.old flags size.new )
#include "page.i65"
    .word orx                   ;( flags size.new pkt size.old hdr.new )
#include "page.i65"
    .word updomojodojo
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word _plusmove
#include "page.i65"
    .word cmove                 ;( flags size.new )
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N8
#include "pad.i65"
    .word store
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UPDOMOJODOJO
stack=( hdr -- hdr  from to howmany  bottom top delta )
tags=vm,nosymbol
test area for update

|PETTIL/Sweet16 Registers|<|<|<|<|<|<|<|h
|^ACC|^TOS|^N0|^N1|^N2|^N3|^N4|^N5|h
|^|^hdr|^|^size.new|^|^size.old|^|^|
|^N6|^N7|^N8|^EXT|^SP|^CPR|^RSLT|^PC|h
|^|^targ0|^pkt|^|^|^|^|^|
|^9OS|^8OS|^7OS|^6OS|^5OS|^4OS|^3OS|^2OS|h
|^|^|^|^|^flags.new|^size.new|^pkt|^size.old|

>5600 41 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 4a 4a 4b 4b 4c 4c 4d 4d 4e 4e 4f 4f 50 50 51 51 52 52 53 53 54 54

#endif
updomojodojo
    jsr harvests8
    brk
    .byt ld | N3
    .byt sub | N1
    .byt st | N0                ; delta
    .byt add | N7
    .byt push                   ; `from`
    .byt ld | N8
    .byt sub | N1
    .byt inr | ACC
    .byt inr | ACC
    .byt push                   ; `to`
    .byt ld | N1
    .byt push                   ; `howmany`
    .byt ld | N7                ;targ0
    .byt push                   ; 1st param for +move
    .byt ld | N8
    .byt sub | N3
    .byt inr | ACC
    .byt inr | ACC              ;pkt.floor
    .byt push                   ; 2nd param for +move
    .byt ld | N0
    .byt push                   ; `delta`
    .byt push                   ; second copy for `vmbuf +!`
    .byt nxt

;--------------------------------------------------------------
#if 0
name=COPY
stack=( from-block to-block -- )
tags=secondary,extra

```
: copy   ( from to -- )
    editing dup @ editing off
    rot block drop
    ?: on off
    blk ! update ;

: copy   ( from to -- )
    swap block drop blk ! pkt.cur update ;
```
#endif
#include "align.i65"
_copy
    jsr enter
#include "page.i65"
    .word swap
#include "page.i65"
    .word _block
#include "page.i65"
    .word drop
#include "page.i65"
    .word blk
#include "page.i65"
    .word store
#include "page.i65"
    .word _pktcur
#include "page.i65"
    .word _update
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(READHEAD)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preadhead
    jsr doiooper
    .word READHEAD

;--------------------------------------------------------------
#if 0
name=(READDATA)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preaddata
    jsr doiooper
    .word READDATA

;--------------------------------------------------------------
#if 0
name=CURRNAME
stack=( -- addr )
tags=vm,i/o
filename

todo: All parameter and no code, maybe a string variable?
#endif
currname
    jsr docreate
    .byt (currname01-*-1)
    .asc "PETTILPACKETS",
currname01
    .asc              "           "
        ;"@0:full16characters,s,w "
        ; 123456789.123456789.1234

;--------------------------------------------------------------
#if 0
name=FILE
stack=( filename device secondary -- )
tags=vm,i/o
Set up parameters for file i/o

```
: file
    sa# ! drv# ! filename ! ;
```
#endif
#include "align.i65"
_file
    jsr enter
#include "page.i65"
    .word sanum
#include "page.i65"
    .word store
#include "page.i65"
    .word drvnum
#include "page.i65"
    .word store
#include "page.i65"
    .word filename
#include "page.i65"
    .word store
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(SAVE-BUFFERS)
stack=( blkbuf 'vmbuf+2 staleal -- )
tags=primitive,i/o,const,nosymbol

( blkbuf vmbuf staleal 4 )
    n0    n1    n2    tos

>C:0000  03 58 04 00  8a 06 00 51  90 06 38 04  05 00 00 00   cXd@.f@Q.f8de@@@
>C:0010  00 02 22 00  03 00 34 d5  00 01 0d d0  0a ff 74 6a   @b"@c@4U@amPj.tj

#endif
psavebuffers
    jsr harvests10
    brk
    .byt ldd | N4               ;get filename
    .byt st | N5
    .byt ldi | N5               ;get filename length
    .byt std | N2               ;store that in D1, D2 off
    .byt ld | N5                ;set filename pointer
    .byt std | N1               ;DA
    .byt ldd | N4               ;`sa#`
    .byt sti | N2               ;`sa#` to D3
    .byt ldd | N4               ;`drv#`
    .byt sti | N2               ;`drv#` to D4
    .byt ldd | N4               ;`vmbuf`
    .byt st | N4                ;start address
    .byt std | N3               ;to zpimage+28
    .byt sub | N0               ;negated `vmbuf` size
    .byt std | N4               ; -vmbuf.size replaces [00 00] tail marker
    .byt ld | N0                ;`blkbuf`
    .byt std | N3               ;to zpimage+2A
    .byt nxt

;--------------------------------------------------------------
#if 0
name=>IOOPER
stack=( -- )
tags=vm,i/o,kernel,nosymbol
switches out PETTIL and performs an I/O subroutine, inline

#endif
doiooper
    jsr topfas
    jsr parmpush
    txa
    pha
    jsr seeya
    lda #2                      ; set direct mode in CHRGET routine
    sta $78                     ; so we get prompts during i/o
    jsr doiooper906
    jsr qaloha
    pla
    tax
    jmp next

doiooper906
    jmp (zpbuf+tos)

;--------------------------------------------------------------
#if 0
name=SAVE-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
save those buffers

subtract `vmbuf` from `blkbuf` to get file size
store this at `vmbuf`, replacing the null-null tail
finally save everything between `vmbuf` and `blkbuf`, patterned after TIM

D4       device number
28-2B    bottom and top address in zpimage
(DA)     pointer to name
D1       length of name
D3       secondary address

```
: save-buffers   ( -- )
    4 staleal 2dup m>r          ( 4 staleal )
    vmbuf @ blkbuf 2dup -       ( 4 staleal vmbuf blkbuf -size  )
    third !                     ( 4 staleal vmbuf blkbuf )
    third 2!
( -size vmbuf ) !
( a a b b -- b b a a b b )
    vmbuf @ dup>r               ( 4 staleal vmbuf )
    blkbuf tuck -               ( 4 staleal blkbuf vmbuf -size )

    (prgfile)
    vmbuf @ dup>r blkbuf - r@ ! 'next =r
    blkbuf 2>r 'SETEALSTAL

```
#endif
#include "align.i65"
_savebuffers
    jsr enter
#include "page.i65"
    .word blkbuf
#include "parm.i65"
    .word plits
    .byt 5
    .word FNADR
    .word FNLEN
    .word zpbuf+TXTTAB
    .word userfilename
    .word 4
#include "pad.i65"
    .word psavebuffers
#include "parm.i65"
    .word doiooper
    .word SAVEPRG
#include "pad.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word off
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(LOADVERIFY)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Load or compare a batch of packets from tape to [[VMBUF]]

```
: (loadverify)   ( flag -- )
    [ VERCK ] literal c!
    (prg-file) (readhead)
    blkbuf dup (casbuf) 1+ dup>r
    2@ - - r> 2! ;
```
#endif
#include "align.i65"
_ploadverify
    jsr enter
#include "parm.i65"
    .word blit
    .byt VERCK
#include "pad.i65"
    .word cstore
#include "page.i65"
;    .word _pprgfile
#include "page.i65"
    .word preadhead
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word casbuf
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twostore
#include "page.i65"
    .word preaddata
#include "page.i65"
    .word _numblkstore
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CALCADDR
stack=( -- )
tags=vm,i/o,subroutine,nosymbol

#endif
calcaddr
/*

*/
    brk
    .byt rtn
    rts

;--------------------------------------------------------------
#if 0
name=TAPELOADVERIFY
stack=( -- )
tags=vm,i/o,kernel,nosymbol

_savebuffers
    jsr enter
    .word blkbuf
    .word plits
    .byt 5
    .word FNADR
    .word FNLEN
    .word zpbuf+TXTTAB
    .word userfilename
    .word 4
    .word psavebuffers
    .word doiooper
    .word SAVEPRG
    .word vmbuf
    .word fetch
    .word off
    .word exit
.C:f3c6  A5 FB       LDA $FB
.C:f3c8  85 C9       STA $C9
.C:f3ca  A5 FC       LDA $FC
.C:f3cc  85 CA       STA $CA
.C:f3ce  20 AE F1    JSR $F1AE
.C:f3d1  4C 2F F7    JMP $F72F
.C:f3d4  20 95 F6    JSR $F695
.C:f3d7  20 57 F8    JSR $F857
.C:f3da  20 49 F4    JSR $F449
.C:f3dd  A5 D1       LDA $D1
.C:f3df  F0 08       BEQ $F3E9
.C:f3e1  20 D3 F4    JSR $F4D3
.C:f3e4  D0 08       BNE $F3EE
.C:f3e6  4C AD F5    JMP $F5AD
.C:f3e9  20 E5 F5    JSR $F5E5
.C:f3ec  F0 F8       BEQ $F3E6
.C:f3ee  E0 01       CPX #$01
.C:f3f0  D0 EB       BNE $F3DD
.C:f3f2  A5 96       LDA $96
.C:f3f4  29 10       AND #$10
.C:f3f6  D0 74       BNE $F46C
.C:f3f8  20 7B F6    JSR $F67B
.C:f3fb  20 6D F4    JSR $F46D
.C:f3fe  4C A3 F8    JMP $F8A3
.C:f401  A9 00       LDA #$00
.C:f403  85 9D       STA $9D
.C:f405  20 7D F4    JSR $F47D
.C:f408  20 CC F6    JSR $F6CC
.C:f40b  A9 FF       LDA #$FF
.C:f40d  C5 9B       CMP $9B
.C:f40f  D0 FC       BNE $F40D
.C:f411  C5 9B       CMP $9B
.C:f413  D0 F8       BNE $F40D
.C:f415  20 56 F3    JSR $F356
.C:f418  A5 9D       LDA $9D
.C:f41a  D0 50       BNE $F46C
.C:f41c  20 2B F9    JSR $F92B
.C:f41f  A5 96       LDA $96
.C:f421  29 10       AND #$10
.C:f423  F0 09       BEQ $F42E
.C:f425  A0 00       LDY #$00
.C:f427  84 9E       STY $9E
.C:f429  A0 60       LDY #$60
.C:f42b  4C AF F5    JMP $F5AF
.C:f42e  A0 AE       LDY #$AE
.C:f430  20 49 F3    JSR $F349
.C:f433  20 51 F3    JSR $F351
.C:f436  D0 0B       BNE $F443
.C:f438  A5 CA       LDA $CA
.C:f43a  85 2B       STA $2B
.C:f43c  A5 C9       LDA $C9
.C:f43e  85 2A       STA $2A
.C:f440  4C AD B4    JMP $B4AD
.C:f443  20 22 B6    JSR $B622
.C:f446  4C 0B B6    JMP $B60B
.C:f449  20 51 F3    JSR $F351
.C:f44c  D0 1E       BNE $F46C
.C:f44e  A0 32       LDY #$32
.C:f450  20 85 F1    JSR $F185
.C:f453  A5 D1       LDA $D1
.C:f455  F0 15       BEQ $F46C
.C:f457  A0 3D       LDY #$3D
.C:f459  20 85 F1    JSR $F185
.C:f45c  A4 D1       LDY $D1
.C:f45e  F0 0C       BEQ $F46C
.C:f460  A0 00       LDY #$00
.C:f462  B1 DA       LDA ($DA),Y
.C:f464  20 66 F2    JSR $F266
.C:f467  C8          INY
.C:f468  C4 D1       CPY $D1
.C:f46a  D0 F6       BNE $F462
.C:f46c  60          RTS
.C:f46d  A0 5F       LDY #$5F
.C:f46f  A5 9D       LDA $9D
.C:f471  F0 02       BEQ $F475
.C:f473  A0 6D       LDY #$6D
.C:f475  20 49 F3    JSR $F349
.C:f478  A0 39       LDY #$39
.C:f47a  4C 49 F3    JMP $F349
.C:f47d  A2 00       LDX #$00
.C:f47f  86 96       STX $96
.C:f481  86 D1       STX $D1
.C:f483  86 D3       STX $D3
.C:f485  E8          INX
.C:f486  86 D4       STX $D4
.C:f488  20 4D F5    JSR $F54D
.C:f48b  20 3C F5    JSR $F53C
.C:f48e  20 4D F5    JSR $F54D
.C:f491  20 9F F4    JSR $F49F
.C:f494  86 D4       STX $D4
.C:f496  20 4D F5    JSR $F54D
.C:f499  20 9F F4    JSR $F49F
.C:f49c  86 D3       STX $D3
.C:f49e  60          RTS
.C:f49f  20 55 F5    JSR $F555
.C:f4a2  4C D4 C8    JMP $C8D4
.C:f4a5  A5 D3       LDA $D3
.C:f4a7  30 F5       BMI $F49E
.C:f4a9  A4 D1       LDY $D1
.C:f4ab  F0 F1       BEQ $F49E
.C:f4ad  20 D5 F0    JSR $F0D5
.C:f4b0  A5 D3       LDA $D3
.C:f4b2  09 F0       ORA #$F0
.C:f4b4  20 43 F1    JSR $F143
.C:f4b7  A5 96       LDA $96
.C:f4b9  10 05       BPL $F4C0
.C:f4bb  A0 74       LDY #$74
.C:f4bd  4C AF F5    JMP $F5AF
.C:f4c0  A5 D1       LDA $D1
.C:f4c2  F0 0C       BEQ $F4D0
.C:f4c4  A0 00       LDY #$00
.C:f4c6  B1 DA       LDA ($DA),Y
.C:f4c8  20 9E F1    JSR $F19E
.C:f4cb  C8          INY
.C:f4cc  C4 D1       CPY $D1
.C:f4ce  D0 F6       BNE $F4C6
.C:f4d0  4C B9 F1    JMP $F1B9
.C:f4d3  20 E5 F5    JSR $F5E5
.C:f4d6  F0 1D       BEQ $F4F5
.C:f4d8  A0 05       LDY #$05
.C:f4da  84 B5       STY $B5
.C:f4dc  A0 00       LDY #$00
.C:f4de  84 B4       STY $B4
.C:f4e0  C4 D1       CPY $D1
.C:f4e2  F0 10       BEQ $F4F4
.C:f4e4  B1 DA       LDA ($DA),Y
.C:f4e6  A4 B5       LDY $B5
.C:f4e8  D1 D6       CMP ($D6),Y
.C:f4ea  D0 E7       BNE $F4D3
.C:f4ec  E6 B4       INC $B4
.C:f4ee  E6 B5       INC $B5
.C:f4f0  A4 B4       LDY $B4
.C:f4f2  D0 EC       BNE $F4E0
.C:f4f4  98          TYA
.C:f4f5  60          RTS
.C:f4f6  A9 01       LDA #$01
.C:f4f8  85 9D       STA $9D
.C:f4fa  20 05 F4    JSR $F405
.C:f4fd  A5 96       LDA $96
.C:f4ff  29 10       AND #$10
(C:$f501)


#endif
#include "align.i65"
_tapeloadverify
    jsr enter
#include "page.i65"
    .word xyzzy
;    .word _pprgfile
#include "parm.i65"
    .word plits
    .byt 10
    .word 0
    .word plugh-1
    .word READHEAD-1
;    .word restoreforth-1
    .word plugh-1
    .word calcaddr-1
;    .word stashforth-1
    .word READDATA-1
;    .word restoreforth-1
    .word exit-1
#include "pad.i65"
tloadver01
    .word qdup
#include "parm.i65"
    .word qbranch
    .byt <(tloadver02-*+1)
#include "pad.i65"
    .word tor
#include "parm.i65"
    .word branch
    .byt <(tloadver01-*+1)
#include "past.i65"
tloadver02
;    .word stashforth

;--------------------------------------------------------------
#if 0
name=DISKLOADVERIFY
stack=( -- )
tags=vm,i/o,kernel,nosymbol

#endif
#include "align.i65"
_diskloadverify
    jsr enter
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(LOADVERIFY)
stack=( -- )
tags=vm,i/o,kernel,nosymbol

#endif
#include "align.i65"
ploadverify
    jsr enter
#include "past.i65"
    .word exit


;--------------------------------------------------------------
#if 0
name=>LOADVERIFY
stack=( -- )
tags=vm,i/o,kernel,nosymbol
`does>` part of `load-buffers` (0) and `verify-buffers` (1)

Load or compare a batch of packets from tape to `vmbuf`

```
\ does> >loadverify
    jsr dodoes
    c@+ &VERCK c!
    drv# @
    @+
    >storageio
    [ VERCK ] literal c!
    (prg-file) (readhead)
    blkbuf dup (casbuf) 1+ dup>r
    2@ - - r> 2! ;
```
#endif
#include "align.i65"
doloadverify
    jsr dodoes
#include "page.i65"
    .word cfetch
#include "parm.i65"
    .word blit
    .byt  VERCK
#include "pad.i65"
    .word cstore
#include "page.i65"
    .word sanum
#include "page.i65"
    .word off
#include "page.i65"
    .word drvnum
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word three
#include "page.i65"
    .word lt
#include "parm.i65"
    .word pquerycolon
    .word _tapeloadverify
    .word _diskloadverify
#include "pad.i65"
#include "page.i65"
;    .word _pprgfile
#include "page.i65"
    .word preadhead
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word casbuf
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twostore
#include "page.i65"
    .word preaddata
#include "page.i65"
    .word _numblkstore
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
Load a packets PRG file from tape or disk to `vmbuf`

called by STOP-L in the editor

```
: load-buffers   ( -- )
    0 (loadverify) ;
```

#endif
#include "align.i65"
_loadbuffers
    jsr doloadverify
    .byt 0

;--------------------------------------------------------------
#if 0
name=VERIFY-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
verify a packets PRG file from tape or disk vs. `vmbuf`

called by `STOP-V` in the editor

```
: verify-buffers   ( -- )
    1 (loadverify)
    ST c@  if  ." error"  then ;
```
#endif
#include "align.i65"
_verifybuffers
    jsr enter
#include "page.i65"
    .word pverifybuffers
#include "parm.i65"
    .word blit
    .byt STATUS
#include "pad.i65"
    .word cfetch
#include "parm.i65"
    .word qbranch
    .byt <(verifybuffers05-*+1)
#include "past.i65"
    .word _pdq
    .byt (verifybuffers06-*-1)
    .asc "ERROR"
verifybuffers06
#include "past.i65"
verifybuffers05
    .word exit

pverifybuffers
    jsr doloadverify
    .byt 1

;--------------------------------------------------------------
#if 0
name=SAVE-FORTH
stack=( -- )
tags=vm
Saves the core from $0401 to `here` as a turnkey application to the current device and secondary address, with the current filename.  A `verify` of the saved file should be possible, because Nothing Verifies  Bad Data In Z-80 Computers!

Before calling `save-forth`, it's a good idea to `' myapp startup !` as there will not be an interactive development environment
```
: save-forth   ( -- )
    basic here
    filename
    device sa
    0 (loadverify)
    ST c@  if  ." error"  then ;
```
~ write this
#endif
#include "align.i65"
_saveforth
;    jsr enter
;#include "past.i65"
;    .word exit
