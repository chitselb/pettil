; pettil-tdd.a65
;#echo .       pettil-tdd.a65
;#echo .       PETTIL test-driven development harness

;--------------------------------------------------------------
#if 0
name=TDD
stack=( -- )
tags=system,startup,secondary,tdd

#endif
#include "align.i65"
_tdd
    jsr enter
#include "page.i65"
    .word _info                     ; some entertainment
#include "page.i65"
    .word cr
#include "page.i65"
    .word _tdd05
#include "page.i65"
    .word _tdd06
#include "page.i65"
    .word _tdd01
#include "page.i65"
    .word _tdd04
#include "page.i65"
;    .word pseequewrapper
#include "page.i65"
;    .word xyzzy
#include "page.i65"
;    .word _tddresult
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=TDDRESULT
stack=( f -- )
tags=system,startup,secondary,tdd
Display the test result

#endif
#include "align.i65"
_tddresult
    jsr enter
#include "parm.i65"
    .word dotup
#include "parm.i65"
    .word cr
#include "parm.i65"
    .word qbranch
    .byt <(tddresult05-*+1)
#include "parm.i65"
    .word _pdq
    .byt (tddresult01-*-1)
    .asc CIRCLEFILL, SPACE, RVSON,"PASS", RVSOFF, SPACE
tddresult01
#include "parm.i65"
    .word branch
    .byt <(tddresult07-*+1)
#include "past.i65"
tddresult05
#include "parm.i65"
    .word _pdq
    .byt (tddresult02-*-1)
    .asc CIRCLEEMPTY, SPACE, RVSON,"FAIL", RVSOFF, SPACE
tddresult02
#include "pad.i65"
tddresult07
    .word cr
#include "past.i65"
    .word exit

;--------------------------------------------------------------
tddata
    .asc 2,"0="

;--------------------------------------------------------------
#if 0
name=TDD01
stack=( -- )
tags=system,startup,secondary,tdd

#endif
#include "align.i65"
_tdd01
    jsr enter
#include "parm.i65"
    .word _pdq
    .byt (tdd01msg-*-1)
    .asc "       FIND 0= IN CORE"
tdd01msg
#include "parm.i65"
    .word plits
    .byt 3
    .word zeq
    .word -1
    .word tddata
#include "pad.i65"
    .word forth
#include "pad.i65"
    .word pseekcontext
#include "page.i65"
;    .word _deq
#include "page.i65"
    .word _tddresult
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=TDD02
stack=( -- )
tags=system,startup,secondary,tdd

#endif
#include "align.i65"
_tdd02
    jsr enter
#include "page.i65"
    .word assembler
#include "parm.i65"
    .word dlit
    .word tddata
    .word 1
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=TDD03
stack=( -- )
tags=system,startup,secondary,tdd

#endif
#include "align.i65"
_tdd03
    jsr enter
#include "page.i65"
    .word assembler
#include "parm.i65"
    .word dlit
    .word tddata
    .word $FFFF
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=TDD08
stack=( -- )
tags=system,startup,secondary,tdd

#endif
#include "align.i65"
_tdd08
    jsr enter
#include "page.i65"
    .word forth
#include "parm.i65"
    .word dlit
    .word tddata
    .word $FFFF
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=TDD04
stack=( -- )
tags=system,startup,secondary,tdd

#endif
#include "align.i65"
_tdd04
    jsr enter
#include "parm.i65"
    .word _pdq
    .byt (tdd04msg-*-1)
    .asc "       TIMESES"
tdd04msg
#include "parm.i65"
    .word plits
    .byt 3
    .word 42
    .word 6
    .word 7
#include "pad.i65"
    .word _star
#include "page.i65"
    .word eq
#include "page.i65"
    .word _tddresult
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=TDD05
stack=( -- )
tags=system,startup,secondary,tdd

#endif
#include "align.i65"
_tdd05
    jsr enter
#include "parm.i65"
    .word _pdq
    .byt (tdd05msg-*-1)
    .asc "       SIMPLE ADDITION"
tdd05msg
#include "parm.i65"

#include "page.i65"
    .word forth
#include "parm.i65"
    .word plits
    .byt 3
    .word 263
    .word 34
    .word 229
#include "pad.i65"
    .word plus
#include "page.i65"
    .word eq
#include "page.i65"
    .word _tddresult
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=TDD06
stack=( -- )
tags=system,startup,secondary,tdd

#endif
#include "align.i65"
_tdd06
    jsr enter
#include "parm.i65"
    .word _pdq
    .byt (tdd06msg-*-1)
    .asc "       MULTIPLY"
tdd06msg
#include "parm.i65"
    .word plits
    .byt 3
    .word 42
    .word 6
    .word 7
#include "pad.i65"
    .word _star
#include "page.i65"
    .word eq
#include "page.i65"
    .word _tddresult
#include "past.i65"
    .word exit

;--------------------------------------------------------------

/*

2os             seek.name
tos             -1 | 0 | +1  mode
n0
n1
n2
n3
n4
n5
n6
n7
n8

2os             -1 | 0 | +1  mode
tos             seek.name
n0
n1
n2
n3
n4
n5
n6
n7
n8

harvests2

mode
| label | current | vocabs |

unsorted
only
          +current
           sorted
           only
                   +each
                    vocabid
                    until 0
                    (core)

code r1+
    txa,  tsx,  $0101 ,x inc,
    tax,  'next jmp,

tos         n0          n1          n2          n3         |
here-3      symtail+2   newest


code >create   ( r; pfa-1 -- ; -- pfa-1 )
    'slip jsr,  pla,  tos sta,   pla,  tos 1+ sta,
    \ fall through
code 1+
    'next 1- csplit  # lda,  pha,  # lda,  pha,
    \ fall through
code inctos
    tos inc,
    0= if,  tos 1+ inc,  then,
    rts,



code create00
  brk  'harvests4 ext,
\ tos         n0          n1
\ here-3      symtail+2   newest
  n0 popd,  n2 st,  tos ld,  n2 std,
  n2 ld,  n1 std,  acc inr,  n4 add,
  tos st,  n4 ld,  n5 st,  n1 ldi,
  0= not if,
    $20 acc set,  n5 add,  n5 st,
  then,
  tos ld,  n0 std,  n5 ld,  n2 sti,
  n2 ld,  tos st,  n4 ld,  push,  nxt,

: (create)   ( "name" ; cfa -- )
    eol?  4 ?error      \ MISSING NAME
    lbuf in @ + swap    ( 'stream cfa )
    redefined off   exists?          if
        <n3 redefined !
        <n7 .rvs $.
        ." [OFF] EXISTS"           then
    cfa,  bloomfilter cbit!
    bloom ( symtail 2+ ) newest  here 3-
    create00  cmove ;

: create   ( "name" ; -- )
   '>create (create) ;



load n4 with seek.len

tos             seek.name
n2
n3
n4
n5
n6
n7
n8

load n4 with seek.len

tos             seek.name
n2
n3
n4              seek.len
n5
n6
n7
n8

=n3 symlen




```
code (seek)
    brk,  acc sub,  n5 st,  n5 dcr,
    'plugh ext,  nxt,
```

*/
pseek
    jmp true

/*

*/
pseekcontext
    brk
    .byt sub | ACC
    .byt st  | N5
    .byt dcr | N5
;    .byt ext
;    .word plugh
;    .byt ext
;    .word pseeque
    .byt nxt

/*

*/
pseekcurrent
    jmp true

pseequewrapper
    brk
    .byt ld  | TOS
    .byt st  | N5
    .byt pull
;    .byt ext
;    .word plugh
    .byt ext
    .word pseeque
    .byt nxt

/*

    brk
    .byt set | N6
    .word uservocabs+1                  ; first vocab
pseequewrap01
    .byt ldd | N6
    .byt st  | N5                       ; get vocabid
    .byt set | N3
    .word usersymnew
    .byt ldd | N3
    .byt st  | N3
    .byt ext
    .word pseeque
    .byt bc  , <(pseequewrap86-*-2)          ; early exit if it was found
    .byt ld  | N7                       ; let's have a look at the sorted list then
    .byt st  | N3
pseequewrap86

*/
