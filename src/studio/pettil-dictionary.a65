/* pettil-dictionary.a65
tags: source nosymbol

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
*/

/* SYMTAB!
tags: nosymbol

*/
symtabset
    dex
    lda stackh+2,x
    clc
    sbc tos+1
    sta stackh,x
    sta usersymtab+1
    lda #32
    sta stackl,x
symtabset99
    jmp next

/* SYM0
tags: nosymbol

*/
sym0
    lda #34
    sta R0L+2*N3
    lda usersymtab+1
    sta R0L+2*N3+1
    bne symtabset99             ; next

/* SYM.LEN
tags: nosymbol

*/
symlen
    lda #>(pushya-1)
    pha
    lda #<(pushya-1)
    pha
symlen_s
    ldy #0              ;{2 {=23}}
    lda R0L+2*N3+1                      ; length = 0 if `n3` is 0
    beq symlen_s01
    lda (R0L+2*N3),y    ;{5}            ; length/flags
symlen_s01
    pha                 ;{3}            ; not using tay/tya preserves Y=0
    asl                 ;{2}
    asl                 ;{2}            ; Vocab bit to C flag
    pla                 ;{4}
symlen_s02
    and #$1F            ;{2}            ; length
    sta R0L+2*N8,y      ;{5}            ; N8L = visible length (omit vocab +1)
    rts

/* SYM.STRAND
tags: nosymbol

*/
symstrand
    jsr symlen_s
    iny
    lda (R0L+2*N3),y
    asl 				; 2* symtab + --> strand
    bne symlen_s02 			; bra

/* SYM.COPY
tags: nosymbol

*/
symcopy
    lda #>(next-1)
    pha
    lda #<(next-1)
    pha
symcopys
    jsr symlen_s
    adc #0
    tay
symcopy01
    lda (R0L+2*N3),y
    sta (R0L+2*N7),y
    dey
    bpl symcopy01
    rts

/* SYM+
tags: nosymbol

*/
symplus
    lda #>(next-1)
    pha
    lda #<(next-1)
    pha
    ; fall through
sympluss
    jsr symlen_s
    adc #3
    adc R0L+2*N3
    sta R0L+2*N3
    bcc symplus01
    inc R0L+2*N3+1
symplus01
    rts

/* (!SYMTAB)
tags: nosymbol

*/
psamtab
    brk
    .byt ld | N3
    .byt std | TOS              ; set `symnew`
    .byt popd | N3              ; 2-
    .byt ld | N3
    .byt std | TOS              ; set `symtail`
    .byt sub | ACC
    .byt std | N3               ; force cfa = 0
    .byt nxt

/* !SYMTAB
tags: nosymbol

stack=( start end -- size addr )
*/
#include "align.i65"
_setsymtab
    jsr enter
#include "page.i65"
    .word bloom
#include "page.i65"
    .word eight
#include "page.i65"
    .word erase                 ; reset the Bloom filter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "page.i65"
samtab01
    .word symlen
#include "page.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(samtab02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word _storeplus
#include "page.i65"
samtab02
    .word _bloomfilter
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symlen
#include "page.i65"
    .word symplus
#include "page.i65"
    .word symlen
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qbranch
    .byt <(samtab01-*+1)
#include "pad.i65"
    .word symnew
#include "page.i65"
    .word psamtab               ; handle `symtab` tail
#include "page.i65"
    .word threedrop
#include "past.i65"
    .word exit

/* BLOOM#
tags: nosymbol

stack=( -- n )

The Bloom filter tries to answer the question, 'is this word a number?'

The string under consideration is pointed to by (N3) with a length of N8.

Generate a hash of a string, in the range 0..63, used as an index into the
sparsely populated `bloom` 8-byte bitfield.

A `true` bloom filter bit means, this word might be in the dictionary
A `false` bit means, this word is not present

`create` turns on the `bloom` bit for each new name
`forget` completely rebuilds the `bloom` filter
*/
bloomhash
    ldy R0L+2*N8                ; length
    lda #0
    sta z
bloomhash01
    lda (R0L+2*N3),y
    eor #$30
    cmp #9
    bcs bloomhash02
    adc z
    sta z
bloomhash02
    dey
    bne bloomhash01
    lda z
    and #$3F                    ; width of the filter is 64 bits
    jmp pushya

/* BLOOMFILTER
tags: nosymbol

stack=( -- mask addr )
*/
#include "align.i65"
_bloomfilter
    jsr enter
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word bloom
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit

/* UNSMUDGE
tags: nosymbol

stack=( nfa -- )
*/
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
/*  SMUDGE
tags: nosymbol

stack=( nfa -- )
*/
smudge
    sec
    ;
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop

/* (>NAME)
tags: nosymbol

stack=( cfa -- nfa|0 )
*/
ptoname
    ldy #$FE
ptoname02
    dec R0L+2*N3+1
    lda (R0L+2*N3),y
    inc R0L+2*N3+1
    eor tos-$FE,y
    bne ptoname05
    iny
    bne ptoname02
    lda R0L+2*N3
    ldy R0L+2*N3+1
ptoname04
    jmp put
ptoname05
    ldy #0
    lda (R0L+2*N3),y
    beq ptoname04
    jsr sympluss                ; next!
    bne ptoname                 ; bra

;--------------------------------------------------------------
#if 0
name=>NAME
tags=interpreter

#endif
#include "align.i65"
_toname
/* >NAME
tags: forth-83

* search the dictionary for a given `cfa` and
* return the `nfa` if found, else `0`
* honors the smudge bit

```
: >name   ( cfa -- nfa|0 )
    sym0
    begin
        name> over <>
        sym.len and
    while
        3 sym+
    repeat
    name> nip ;
```
*/
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word ptoname
#include "past.i65"
    .word exit

/* (SEEK)
tags: nosymbol

stack=( thread -- flag )
*/
pseek
    brk
    .byt ldd | TOS
    .byt st | N3                ; `n3` is start of thread
    .byt rtn
pseekb
    lda R0L+2*N4+1              ; toggle sorted/unsorted flag in `n4h`
    eor #$FF
    sta R0L+2*N4+1              ; sorted = 0; unsorted = $FF
pseek00
    jsr symlen_s
    beq pseek08                 ; reached `symtail`? not found!
    eor R0L+2*N4
    beq pseekok1                ; same length? consider further...
    bit R0L+2*N4+1
    bmi pseek01                 ; unsorted list? next!
    lda R0L+2*N8
    cmp R0L+2*N4                ; length.current > length.seeking?
    bcs pseek08                 ; not found on sorted list!
pseek01
    jsr sympluss                ; next!
    bne pseek00                 ; bra
pseekok1
    ;ldy #0                     ; thanks, symlen
    lda (R0L+2*N3),y
    bmi pseek01                 ; smudged? next!
    ldy R0L+2*N4
    iny
    lda R0L+2*N5                ; compare vocabularies
    bcc pseek04b
    .byt $2C
pseekok2
    lda (R0L+2*N7),y            ; `n7` name we are looking for
pseek04
    eor (R0L+2*N3),y            ; `n3` current name under consideration
pseek04b
    bne pseek01                 ; different symbol? next!
pseek05
    dey
    bne pseekok2
pseek07
    clc                         ; found, false (inverted flag)
    .byt $29                    ; AND imm opcode
pseek08
    sec                         ; not found, true
pseek09
    ;
    jmp putc

tostrand
/* name=>STRAND
tags: nosymbol

code >strand   ( -- thread )

*/
    lda R0L+2*N8+1
    ldy usersymtab+1
    jmp put

/* name=>STRAND
tags: nosymbol

code >strand   ( -- thread )

*/
tothread
    ldy #1
    lda (R0L+2*N7),y            ; use `nfa` in `n7`, get first character
    and #$0F                    ; simplified replacement for Pearson hash
    asl                         ; *2
    sta tos                     ; `symtab` always at a page boundary
    jmp next


immedornot
/* IMMEDORNOT
tags: nosymbol

Return +1 if the immediate bit is set on current `nfa`, otherwise returns -1

code immedornot   ( true -- -1|+1 )

*/
    ldy #0
    lda (R0L+2*N3),y            ; length/flags of curr `nfa`
    and #$20                    ; immediate?
    lsr
    lsr
    lsr
    lsr                         ; divide by 16, $02 when immediate
    jmp nplus                   ; add 0 or 2 to tos

nextvocabq
/* NEXTVOCAB?
tags: nosymbol

Return `true` if there is a next vocabulary

```
code next.vocab?   ( -- flag )
    brk,  n5 ld,  push,
    n6 ld@,  n5 st,  nxt,
```
*/
    brk
    .byt ld | N5
    .byt push
    .byt ldi | N6
    .byt st | N5
    .byt nxt

pfoundq
/* (FOUND?)
tags: nosymbol

stack=( name vocabs -- )
*/
    brk
    .byt ld | N8                ; `n4` `n8` len
    .byt st | N4
    .byt ld | TOS
    .byt st | N6                ; vocabs
    .byt inr | N6
    .byt ldi | N6
    .byt st | N5                ; first vocab
    .byt pull
    .byt st | N7                ; name
    .byt st | N3                ; name
    .byt pull
    .byt nxt

#include "align.i65"
_foundq
/* FOUND?
tags: nosymbol

stack=( nfa -- xfa flag )
*/
    jsr enter
#include "page.i65"
    .word vocabs
#include "page.i65"
    .word pfoundq
#include "page.i65"
    .word _bloomfilter          ; sum of decimal digits in name % 64
#include "page.i65"
    .word cbitfetch
#include "parm.i65"
    .word qbranch               ; if
    .byt <(found04-*+1)
#include "pad.i65"
foundq01                        ;     begin (loop through vocabs)
    .word symnew
#include "page.i65"
    .word pseek                 ; returns inverted found? flag
#include "parm.i65"
    .word qbranch               ;     while (branches if found)
    .byt <(foundq03-*+1)
#include "pad.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word tothread
#include "page.i65"
;    .word tostrand
#include "page.i65"
    .word pseek
#include "parm.i65"
    .word qbranch               ; inverted flag, so branch if found
    .byt <(foundq03-*+1)
#include "pad.i65"
    .word nextvocabq
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qbranch               ; loop if more vocabs
    .byt <(foundq01-*+1)
#include "parm.i65"
found04                         ; then
    .word zpfrom
    .byt R0L+2*N7               ; original `nfa`
#include "pad.i65"
    .word false                 ; and nope, this name was not found
#include "past.i65"
    .word exit

#include "parm.i65"
foundq03                        ; found it
    .word zpfrom
    .byt R0L+2*N3               ; the CFA
#include "pad.i65"
    .word namefrom
#include "page.i65"
    .word true                  ; assume it's a normie -1
#include "page.i65"
    .word immedornot            ; maybe add 2 if it's immediate
#include "past.i65"
    .word exit


;--------------------------------------------------------------
#if 0
name=EXISTS?
tags=vocabulary

#endif
#include "align.i65"
_existsq
/* EXISTS?
tags: vocabulary

search the dictionary for a name

```
: exists?   ( "name" ; -- cfa|0 )
  bl name ?dup  ?: found? false  and ;
```
*/
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word pquerycolon
    .word _foundq
    .word false
#include "pad.i65"
    .word andx
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name='
tags=forth-83

#endif
#include "align.i65"
_tick
/* '
tags: forth-83

stack=( -- cfa )
*/
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qerror
    .byt 3                      ; NOT FOUND
#include "past.i65"
    .word exit

#include "align.i65"
_pcreate
/* (CREATE)
tags: nosymbol

stack=( cfa -- )
Create a new symbol in the symbol table
*/
    jsr enter
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qerror
    .byt 4                      ; MISSING NAME
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word off
#include "page.i65"
    .word _existsq
#include "parm.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word store
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N7
#include "pad.i65"
    .word dotrvs
#include "page.i65"
    .word _stringdot
#include "parm.i65"
    .word _pdq
    .byt <(pcreate01-*-1)
    .asc RVSOFF," EXISTS"
pcreate01
#include "pad.i65"
pcreate02
    .word bloom                         ; aka `symtail` +2
#include "page.i65"
    .word current
#include "page.i65"
    .word rot
#include "page.i65"
    .word _qalign
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word newest
#include "past.i65"
    .word *+2
    jsr harvests6
    brk
    .byt popd | N0               ; symtail @
    .byt st | N3
    .byt ld | N2                ; cfa'
    .byt std | N3               ; write CFA to symtab, +2 N5 pointer
    .byt ld | N3
    .byt std | TOS              ; populate `newest`
    .byt ld | N7
    .byt st | N3
    .byt popd | TOS
    .byt st | N7
    .byt ext
    .word symcopys              ; copy the symbol/length
    .byt ldi | N1
    .byt bz , <(ppcreate01-*-2)
    .byt set | ACC
    .word $40
ppcreate01
    .byt st | TOS               ; TOS = $00 or $40 if vocab
    .byt inr | N7
    .byt pop | N7
    .byt st | N5
    .byt add | TOS
    .byt sti | N7               ; symbol length with a proper vocab bit
    .byt ld | N7
    .byt add | N5
    .byt st | N7
    .byt pop | N1
    .byt bz , <(ppcreate02-*-2)
    .byt sti | N7
ppcreate02
    .byt ld | N7
    .byt std | N0               ; update symtail
    .byt sub | ACC
    .byt sti | N7
    .byt std | N7
    .byt pull
    .byt rtn
    jmp exit

#include "align.i65"
_pfnord
/* (FNORD)
tags: nosymbol

```
: (fnord)   ( cfa -- )
    sym0 pad
    robblerobble
```
plover
*/
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word _pad
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word robblerobble
#include "past.i65"
    .word exit

robblerobble
    jmp next

;--------------------------------------------------------------
#if 0
name=FORGET
tags=interpreter,fig,forth-79,forth-83

#endif
#include "align.i65"
_forget
/* FORGET

```
: forget   ( "name" ; -- )  '           \ next token from input stream
  dup fence @ u<  7 ?error              \ can't forget below fence
  (fnord) ;
```
*/
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "parm.i65"
    .word qerror
    .byt 7                      ; CAN'T FORGET BELOW FENCE
#include "pad.i65"
    .word _pfnord
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEFINITIONS
tags=forth-83

#endif
definitions
/* DEFINITIONS
tags: forth-83

Set `current` vocabulary for new words

```
code definitions   ( -- )
  vocabs 1+ lda,  current sta,
  next jmp,
```
*/
    lda uservocabs+1
    sta usercurrent
    jmp next

;--------------------------------------------------------------
#if 0
name=REHASH
tags=interpreter

#endif
#include "align.i65"
_rehash
/* REHASH
tags: pettil

```
: rehash   ( -- )
  here (fnord) ;
```
*/
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _pfnord
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORTH
tags=vocabulary,forth-83

#endif
#include "align.i65"
_forth
/* FORTH
tags: vocabulary

use only the core forth vocabulary

```
: forth   ( -- )
  vocabs count erase ;
```
*/
    jsr enter
#include "page.i65"
    .word vocabs
#include "page.i65"
    .word count
#include "page.i65"
    .word erase
#include "past.i65"
    .word exit
