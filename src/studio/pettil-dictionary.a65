/* pettil-dictionary.a65
tags: source

Dictionary

```
Symbol table

+---------------+
|    CFA[low]   |  -2
|    CFA[high]  |  LFA     Code field address
+-+-+-+-+-+-+-+-+
|     [   len   ]  NFA     Length bits
[S]             |          Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?  vocab id     ?  +len+1  Vocabulary ID (if V bit set)
+---------------+

~todo: implement labels, a temporary symbol
symbols must have a code field address, pointing to executable 6502 code
    labels are like symbols, but may have any arbitrary 2-byte value
    labels do not survive `rehash` all are dropped
    label redefinition overwrites the value, and is not a duplicate label
    labels are immediate by default  (?what is a non-immediate label useful for?)
    dawdle -- antonym of immediate

!!!label %smudge, %vocab %immed bits are always true
    * alabel has a value, stored in link field
    * alabel is a member of vocabid '00' (?what would labels by vocabulary be useful for?)
    * :alabel defines one
    * 'alabel the address of alabel
    * all flags TRUE
    * `label` `is` and `at`
    * (%smudge on %vocab on vocabid 0)

|             | compiled | execution |<|h
|alabel       | constant | [']       |a label has no code. `alabel` has a value.   |
|label alabel |          | (create)  |`( avalue ) label alabel` creates alabel     |
|is alabel    | !        | !         |`( avalue ) is alabel` updates alabel     |
|:alabel      | ?error   | (create)  |`:-prefix` with a value of `here`            |
|'alabel      | constant | (seek)    |`'-prefix` 'alabel gives us alabel's address |

```
|label  |2 bytes |value                    |
|~      |1 byte  |%smudge                  |
|~      |~       |%vocab        true       |
|~      |~       |%immed                   |
|~      |~       |len                      |
|       |len     |`label`                  |
|~      |1 byte  |vocabid       00         |
|~      |~       |~                        |
|symbol |2 bytes |Code Field Address (CFA) |
|~      |1 byte  |%smudge                  |
|~      |~       |%vocab                   |
|~      |~       |%immed                   |
|~      |~       |len                      |
|       |len     |`symbol`                 |

|symbol |2 bytes|code field address |1 byte|%smudge %vocab %immed length |length bytes|

* `rehash` causes all labels to vanish
* labels may be reassigned with the syntax: ( value ) IS label
!!symbol

** although labels associate to a value which is usually an address, no similar constraint that the value must be a code field address exists with labels

*/

/* !SYMDEX
tags: secondary nosymbol

Resize and rebuild symbol table

* establish new location of `symtab`
* establish `bloom` filter 64-bit
* establish `symdex` 16 strand pointers

Given a start address and size of a list of symbols, move them to a page
boundary lower than `studio - size` and let this be the new `symtab`.

This word performs several tasks, all related to creating a symbol table for
`interpret` to use for name lookups.  The symbol table connects the common,
pronounceable name of a word to it's code field.  Invoking `words` will show
only symbols in the active vocabularies, or show all the symbols in core when
no vocabulary is active.

The symbol table is located below the `studio` region and grows upward as new
words are added to the dictionary.  If it overwrites `studio`, well, you know
what will happen.  When it gets close, `rehash` will rebuild the symbol table.

inputs:
studio                          uservar, address of `studio` dictionary
start                           start of region containing sorted symbols
size                            size of region, in bytes

outputs:
symtab                          studio - size pages, an extra page, and keep the change
symtail                         address where new symbols are appended
symnew                          address of first unsorted symbol
bloom                           helps PETTIL (hopefully) search less often for numbers
[symtab..symtail]               symbols, terminated by three nulls

```
: !symdex   ( start size -- )
    studio @  over -                    \ calculate memory requirements
    $ff00 and benjamin -                \ (studio - size) & $FF00  - $100
( start size symtab )
    dup symtab !  bl +                  \ set symtab
( start size symtab+32 )
    2dup + dup 3coff                    \ set tail = 00 00 00
    dup symtail !                       \ set symtail
    2+ symnew !                         \ set symnew
( start size symtab+32 )
    swap cmove>                         \ copy names from start to symtab+32
( -- )
    bloom 8 erase  sym0                 \ set bloom filter & strands
    symtab @  bl
( symtab 32 )
    begin
        sym.len <
        if
           n3> !+
        then
        bloomfilter cbit!
        sym+
        sym.len 0=
    until ;

    etc ...

    ;
```

    bloom 8 erase  sym0
    symtab @ bl
```
*/
#include "align.i65"
_setsymdex
    jsr enter
#include "page.i65"
    .word bloom
#include "page.i65"
    .word eight
#include "page.i65"
    .word erase
#include "page.i65"
    .word sym0
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "past.i65"
    .word exit

/* SYMTAB!
tags: nosymbol

Using the formula: (size + 2 pages + keep the change),
reallocate memory during `rehash` or `(cold)`.

|        |in          |out       |<|h
|symtab  |.           |symtab    |<|
|tos     |size        |.         |<|
|2os     |+           |symtab+32 |inserted value |
|3os     |start       |.         |pad|

Calculate `symtab` memory requirements, given a size

```
\ determine size of new symbol table
noname code symtab!
( studio start size -- studio start symtab+32 size )
tiny
  1 harvests jsr,  brk,

  1 plants ext,  nxt,
fast
  dex,  stackh 1+ ,x lda,
  clc,  tos 1+ sbc,  stackh ,x sta,
  symtab 1+ sta,  #32 # lda,
  stackl ,x sta,
label symtabset99
    next jmp,  end-code
```
*/
symtabset
    dex
    lda stackh+2,x
    clc
    sbc tos+1
    sta stackh,x
    sta usersymtab+1
    lda #32
    sta stackl,x
symtabset99
    jmp next

/* SYM0

|       |in          |out    |<|h
|symtab |addr        |len    |<|
|y      |.           |0      |<|
|c      |.           |vocab? |<|
|z      |.           |tail?  |true when symtail is reached |
|tos    |+           |len    |<|
|n3     |nfa         |.      |<|
|n8l    |.           |len    |<|

```
noname code sym0   ( -- nfa )
    symtab 1+ ldy,  #34 # lda,
    n3 1+ sty,  n3 sta,
    symtabset99 bne, \ bra
```
*/
sym0
    lda #34
    sta R0L+2*N3
    lda usersymtab+1
    sta R0L+2*N3+1
    bne symtabset99             ; next

/* SYM.LEN

|change  |in          |out    |<|h
|a       |.           |len    |<|
|y       |.           |0      |<|
|c       |.           |vocab? |<|
|z       |.           |tail?  |true when symtail is reached |
|tos     |+           |len    |<|
|n3      |nfa         |.      |<|
|n8l     |.           |len    |<|

```
noname code sym.len   ( -- len )        \ nfa length (@n3)
  'pushya csplit
  # lda, pha,  #lda, pha,
noname code symlens
  0 # ldy,  n3 1+ lda,
  0= not if,  n3 )y lda,  then,         \ until reaching '00' at end of symtab
  pha,  asl, asl,  pla,  $1f # and,
  n8 sta,  rts,
```

*/
symlen
    lda #>(pushya-1)
    pha
    lda #<(pushya-1)
    pha
symlens
    ldy #0              ;{2 {=23}}
    lda R0L+2*N3+1                      ; length = 0 if `n3` is 0
    beq symlens01
    lda (R0L+2*N3),y    ;{5}            ; length/flags
symlens01
    pha                 ;{3}            ; not using tay/tya preserves Y=0
    asl                 ;{2}
    asl                 ;{2}            ; Vocab bit to C flag
    pla                 ;{4}
symlens02
    and #$1F            ;{2}            ; length
    sta R0L+2*N8,y      ;{5}            ; N8L = visible length (omit vocab +1)
    rts

symstrand
    jsr symlens
    iny
    lda (R0L+2*N3),y
    asl 				; 2* symtab + --> strand
    bne symlens02 			; bra

/* SYM.COPY
tags: primitive nosymbol

Copy current LFA and name from (N3-2..N3+length+%vocab) source to (N5) target

```
noname code sym.copy   ( -- )
  'pushya csplit
  # lda, pha,  #lda, pha,
noname code symlens
  0 # ldy,  n3 1+ lda,
  0= not if,  n3 )y lda,  then,         \ until reaching '00' at end of symtab
  pha,  asl, asl,  pla,  $1f # and,
  n8 sta,  rts,
```
*/
symcopy
    lda #>(next-1)
    pha
    lda #<(next-1)
    pha
symcopys
    jsr symlens
    adc #0
    tay
symcopy01
    lda (R0L+2*N3),y
    sta (R0L+2*N7),y
    dey
    bpl symcopy01
    rts

;--------------------------------------------------------------
#if 0
name=SYM+
stack=( -- )
tags=primitive,nfa,nosymbol
registers=Z:false
* move N3 to the next symbol
compiled with an inline value following the CFA
to specify a constant per-symbol offset

#endif
symplus
    jsr sympluss
    jmp next

sympluss
    jsr symlens
    adc #3
    adc R0L+2*N3
    sta R0L+2*N3
    bcc symplus01
    inc R0L+2*N3+1
symplus01
    rts

;--------------------------------------------------------------
#if 0
name=(!SYMTAB)
stack=( len addr -- )
tags=system,startup,nosymbol
nip nip
set 'symnew' once per (rehash) to the third null
set 'symtail' = symnew-2
write '0000' word at symtail

#endif
psamtab
    brk
    .byt ld | N3
    .byt std | TOS              ; set `symnew`
    .byt popd | N3              ; 2-
    .byt ld | N3
    .byt std | TOS              ; set `symtail`
    .byt sub | ACC
    .byt std | N3               ; force cfa = 0
    .byt nxt

;--------------------------------------------------------------
#if 0
name=!SYMTAB
stack=( start end -- size addr )
tags=system,startup,nosymbol
Scan `symtab`

: !symtab   ( -- )
    bloom 8 erase  sym.rewind
    symtab @ bl
    begin
        sym.len <
        if
            n3> !+
        then
        bloomfilter cbit!
        sym.len
        3 sym+
        sym.len 0=
    until (!symtab) ;


#endif
#include "align.i65"
_setsymtab
    jsr enter
#include "page.i65"
    .word bloom
#include "page.i65"
    .word eight
#include "page.i65"
    .word erase                 ; reset the Bloom filter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "page.i65"
samtab01
    .word symlen
#include "page.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(samtab02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word _storeplus
#include "page.i65"
samtab02
    .word _bloomfilter
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symlen
#include "page.i65"
    .word symplus
#include "page.i65"
    .word symlen
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qbranch
    .byt <(samtab01-*+1)
#include "pad.i65"
    .word symnew
#include "page.i65"
    .word psamtab               ; handle `symtab` tail
#include "page.i65"
    .word threedrop
#include "past.i65"
    .word exit

#if 0
name=BLOOM#
stack=( -- n )
tags=nosymbol
The Bloom filter tries to answer the question, 'is this word a number?'

The string under consideration is pointed to by (N3) with a length of N8.

Generate a hash of a string, in the range 0..63, used as an index into the
sparsely populated `bloom` 8-byte bitfield.

A `true` bloom filter bit means, this word might be in the dictionary
A `false` bit means, this word is not present

`create` turns on the `bloom` bit for each new name
`forget` completely rebuilds the `bloom` filter

#endif
bloomhash
    ldy R0L+2*N8                ; length
    lda #0
    sta z
bloomhash01
    lda (R0L+2*N3),y
    eor #$30
    cmp #9
    bcs bloomhash02
    adc z
    sta z
bloomhash02
    dey
    bne bloomhash01
    lda z
    and #$3F                    ; width of the filter is 64 bits
    jmp pushya

;--------------------------------------------------------------
#if 0
name=BLOOMFILTER
stack=( -- mask addr )
tags=nfa,dictionary,nosymbol

Returns a `mask`/`addr` pair suitable for `cbit!` or `cbit@`

```
: bloom!   ( -- mask addr )
    bloom# bloom >bit ;
```
#endif
#include "align.i65"
_bloomfilter
    jsr enter
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word bloom
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UNSMUDGE
stack=( nfa -- )
tags=compiler,nosymbol
Turn off the smudge bit so it can be found by [[FIND]].  In
PETTIL, the smudge bit does double duty, also deactivating any
words that have been [[REDEFINED]].

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
#endif
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler,nosymbol
Turn on the smudge bit.  Smudged names won't be found by FIND.
In PETTIL, the smudge bit does double duty, also marking as
inactive any names that have been [[REDEFINED]].
#endif
smudge
    sec
    ;
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=(>NAME)
stack=( cfa -- nfa|0 )
tags=compiler,nosymbol

~todo: code is giant, and rarely called
~ deprecate
#endif
ptoname
    ldy #$FE
ptoname02
    dec R0L+2*N3+1
    lda (R0L+2*N3),y
    inc R0L+2*N3+1
    eor tos-$FE,y
    bne ptoname05
    iny
    bne ptoname02
    lda R0L+2*N3
    ldy R0L+2*N3+1
ptoname04
    jmp put
ptoname05
    ldy #0
    lda (R0L+2*N3),y
    beq ptoname04
    jsr sympluss                ; next!
    bne ptoname                 ; bra

;--------------------------------------------------------------
#if 0
name=>NAME
stack=( cfa -- nfa|0 )
tags=compiler
* search the dictionary for a given `cfa` and
* return the `nfa` if found, else `0`
* honors the smudge bit

```
: >name   ( cfa -- nfa|0 )
    sym0
    begin
        name> over <>
        sym.len and
    while
        3 sym+
    repeat
    name> nip ;
```
#endif
#include "align.i65"
_toname
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word ptoname
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(SEEK)
stack=( thread -- flag )
tags=interpreter,primitive,nosymbol
Search a segment of the dictionary

end of list
    nfa 0 true
found
    cfa -1|1 true
not found
    vocabs+ false


#endif
pseek
    brk
    .byt ldd | TOS
    .byt st | N3                ; `n3` is start of thread
    .byt rtn
pseekb
    lda R0L+2*N4+1              ; toggle sorted/unsorted flag in `n4h`
    eor #$FF
    sta R0L+2*N4+1              ; sorted = 0; unsorted = $FF
pseek00
    jsr symlens
    beq pseek08                 ; reached `symtail`? not found!
    eor R0L+2*N4
    beq pseekok1                ; same length? consider further...
    bit R0L+2*N4+1
    bmi pseek01                 ; unsorted list? next!
    lda R0L+2*N8
    cmp R0L+2*N4                ; length.current > length.seeking?
    bcs pseek08                 ; not found on sorted list!
pseek01
    jsr sympluss                ; next!
    bne pseek00                 ; bra
pseekok1
    ;ldy #0                     ; thanks, symlens
    lda (R0L+2*N3),y
    bmi pseek01                 ; smudged? next!
    ldy R0L+2*N4
    iny
    lda R0L+2*N5                ; compare vocabularies
    bcc pseek04b
    .byt $2C
pseekok2
    lda (R0L+2*N7),y            ; `n7` name we are looking for
pseek04
    eor (R0L+2*N3),y            ; `n3` current name under consideration
pseek04b
    bne pseek01                 ; different symbol? next!
pseek05
    dey
    bne pseekok2
pseek07
    clc                         ; found, false (inverted flag)
    .byt $29                    ; AND imm opcode
pseek08
    sec                         ; not found, true
pseek09
    ;
    jmp putc

/* name=>STRAND
tags: nosymbol

code >strand   ( -- thread )

*/
tostrand
    lda R0L+2*N8+1
    ldy usersymtab+1
    jmp put

tothread
    ldy #1
    lda (R0L+2*N7),y            ; use `nfa` in `n7`, get first character
    and #$0F                    ; simplified replacement for Pearson hash
    asl                         ; *2
    sta tos                     ; `symtab` always at a page boundary
    jmp next


/* IMMEDORNOT
code immedornot   ( true -- -1|+1 )
tags: nosymbol

Return +1 if the immediate bit is set on current `nfa`

Otherwise returns -1

*/
immedornot
    ldy #0
    lda (R0L+2*N3),y            ; length/flags of curr `nfa`
    and #$20                    ; immediate?
    lsr
    lsr
    lsr
    lsr                         ; divide by 16, $02 when immediate
    jmp nplus                   ; add 0 or 2 to tos

/* NEXTVOCAB?
tags: nosymbol

Return `true` if there is a next vocabulary

```
code next.vocab?   ( -- flag )
    brk,  n5 ld,  push,
    n6 ld@,  n5 st,  nxt,
```
*/
nextvocabq
    brk
    .byt ld | N5
    .byt push
    .byt ldi | N6
    .byt st | N5
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(FOUND?)
stack=( name vocabs -- )
tags=interpreter,forth-83,nosymbol
set up Sweet16 registers for `found?`


|register|contents|h
|n3|name|
|n4|len|
|n5|vocabid|
|n6|vocabs|
|n7|name|
|n8|len|
#endif
pfoundq
    brk
    .byt ld | N8                ; `n4` `n8` len
    .byt st | N4
    .byt ld | TOS
    .byt st | N6                ; vocabs
    .byt inr | N6
    .byt ldi | N6
    .byt st | N5                ; first vocab
    .byt pull
    .byt st | N7                ; name
    .byt st | N3                ; name
    .byt pull
    .byt nxt

;--------------------------------------------------------------
#if 0
name=FOUND?
stack=( nfa -- xfa flag )
tags=interpreter,forth-83,nosymbol
This replaces the Forth-83 standard word `find`, idea from Albert van der Horst
in comp.lang.forth

starting with the most recently added to `vocabs`
for each vocabulary
    try searches in this order
        word+trialvocabid `symnew`
        word+trialvocabid `symtab`
until vocabulary was (0)forth
if still not found, 0

* search order
** begin
** each vocab
** symnew .. symtail, unsized
** while not found
** symtab thread, sized
** while not found
** until vocab was 0
** exit

|^`nfa`|^the `name` we are looking for<br/>(e.g. counted string in `tib` buffer)|<|
|^`xfa`|^`flag`|<|
|nfa|0|not found|
|cfa|-1|found normal word|
|cfa|+1|found immediate word|

|^`forth editor assembler`<br/>`vocabulary tools`<br/>`tools definitions`<br/>|<|<|<|
|>|Search order example|<|<|h
|1|`tools` vocabulary|`symtail`|unsorted|
|2|`tools` vocabulary|`thread`|sorted|
|3|`assembler` vocabulary|`symtail`|unsorted|
|4|`assembler` vocabulary|`thread`|sorted|
|5|`editor` vocabulary|`symtail`|unsorted|
|6|`editor` vocabulary|`thread`|sorted|
|7|`core` vocabulary|`symtail`|unsorted|
|8|`core` vocabulary|`thread`|sorted|
|9|not found|<|<|

`core` is always the last vocabulary searched.  A name/vocabulary combination
is `unique` meaning it has at most one active symbol.  Prior copies of
redefined symbols remain in the symbol table, smudged. Smudged words are
ignored (not a match) by `found?`

```
: found?   ( name -- xfa flag )
    vocabs (found?) bloomfilter cbit@
    if
        symnew (seek)
        if
            symtab @ >thread (seek)

```
#endif
#include "align.i65"
_foundq
    jsr enter
#include "page.i65"
    .word vocabs
#include "page.i65"
    .word pfoundq
#include "page.i65"
    .word _bloomfilter          ; sum of decimal digits in name % 64
#include "page.i65"
    .word cbitfetch
#include "parm.i65"
    .word qbranch               ; if
    .byt <(found04-*+1)
#include "pad.i65"
foundq01                        ;     begin (loop through vocabs)
    .word symnew
#include "page.i65"
    .word pseek                 ; returns inverted found? flag
#include "parm.i65"
    .word qbranch               ;     while (branches if found)
    .byt <(foundq03-*+1)
#include "pad.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word tothread
#include "page.i65"
;    .word tostrand
#include "page.i65"
    .word pseek
#include "parm.i65"
    .word qbranch               ; inverted flag, so branch if found
    .byt <(foundq03-*+1)
#include "pad.i65"
    .word nextvocabq
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qbranch               ; loop if more vocabs
    .byt <(foundq01-*+1)
#include "parm.i65"
found04                         ; then
    .word zpfrom
    .byt R0L+2*N7               ; original `nfa`
#include "pad.i65"
    .word false                 ; and nope, this name was not found
#include "past.i65"
    .word exit

#include "parm.i65"
foundq03                        ; found it
    .word zpfrom
    .byt R0L+2*N3               ; the CFA
#include "pad.i65"
    .word namefrom
#include "page.i65"
    .word true                  ; assume it's a normie -1
#include "page.i65"
    .word immedornot            ; maybe add 2 if it's immediate
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EXISTS?
stack=( -- addr flag )
tags=interpreter,ext
parses the next token in the input stream.  Returns either the
address of the (unfound) token at HERE and a 0, or the code
field address of the word and -1 for normal, +1 for immediate
words

```
: exists?
   bl word ?dup ?: found? 0 and ;
```
#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word pquerycolon
    .word _foundq
    .word zero
#include "pad.i65"
    .word andx
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name='
stack=( -- cfa )
tags=forth-83
Parse the next token in the input stream and search for it,
returning the CFA if successful.  Otherwise aborts with the
message "NOT FOUND"

```
: '   ( "name" -- cfa )
    exists? dup 0=  3 ?error ;
```
#endif
#include "align.i65"
_tick
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qerror
    .byt 3                      ; NOT FOUND
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CREATE)
stack=( cfa -- )
tags=compiler,nosymbol
Create a new symbol in the symbol table

```
: (create)   ( cfa -- )
    eol? 4 ?error                       \ "MISSING NAME"
    redefined off                       \ no need to set the bloom bit first
    exists? ?dup
    if                                  ( cfa )
        <n7 dup redefined !
        .rvs  $. ."  [OFF]exists "
    then                                ( cfa )
    bloom                               ( symtail 2+ )
    current
    2swap over cfa,
    sym0 here 3- ((create))
    3coff dup smudge newest !
    false (seekb)
    if
        unsmudge
    else
        <n3 dup redefined !
        RVSON emit
        id. ." exists{OFF}"
    then ;
```
#endif
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qerror
    .byt 4                      ; MISSING NAME
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word off
#include "page.i65"
    .word _existsq
#include "parm.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word store
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N7
#include "pad.i65"
    .word dotrvs
#include "page.i65"
    .word _stringdot
#include "parm.i65"
    .word _pdq
    .byt <(pcreate01-*-1)
    .asc RVSOFF," EXISTS"
pcreate01
#include "pad.i65"
pcreate02
    .word bloom                         ; aka `symtail` +2
#include "page.i65"
    .word current
#include "page.i65"
    .word rot
#include "page.i65"
    .word _qalign
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word newest
// CFA may move up one byte if $EA was enclosed (for paging)
//
#include "past.i65"
    .word *+2
    jsr harvests6
// tos=newest n0=symtail+2 n1=current n2=here
// * copy symbol @n7 to symtail
// * enclose 'here' as new CFA
// * current nonzero?
//      - set vocabulary bit
//      - append `current` at symtail
// * drop out a 00 00 00    symtail `3coff`
// * update symtail
// * set newest
    brk
    .byt popd | N0               ; symtail @
// N0 = usersymtail ACC = symtail
    .byt st | N3
    .byt ld | N2                ; cfa'
    .byt std | N3               ; write CFA to symtab, +2 N5 pointer
    .byt ld | N3
    .byt std | TOS              ; populate `newest`

    .byt ld | N7
    .byt st | N3
    .byt popd | TOS
    .byt st | N7
;    .byt ext
;    .word swap73s

    .byt ext
    .word symcopys              ; copy the symbol/length
    .byt ldi | N1
    .byt bz , <(ppcreate01-*-2)
    .byt set | ACC
    .word $40
ppcreate01
    .byt st | TOS               ; TOS = $00 or $40 if vocab
    .byt inr | N7
    .byt pop | N7
    .byt st | N5
    .byt add | TOS
    .byt sti | N7               ; symbol length with a proper vocab bit
    .byt ld | N7
    .byt add | N5
    .byt st | N7
    .byt pop | N1
    .byt bz , <(ppcreate02-*-2)
    .byt sti | N7
ppcreate02
    .byt ld | N7
    .byt std | N0               ; update symtail
    .byt sub | ACC
    .byt sti | N7
    .byt std | N7
    .byt pull
    .byt rtn
    jmp exit

;--------------------------------------------------------------
#if 0
name=?VMMOVE
stack=( newsymtab -- )
tags=nosymbol
* if `#blk` nonzero, move `vmbuf` area

```
: ?vmmove   ( newsymtab -- )
    #blk @
    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
     vmbuf !
    symtab ! ;
```
    jsr harvests4               ; grab just b/buf & vmbuf, leave newsymtab next
    brk
    .byt ldd | TOS              ; #blk@
    .byt st | TOS               ; if we leave abruptly, don't +MOVE anything
    .byt bz , <(qvmmovemagic01-*-2)
    .byt pull                   ; newsymtab
    .byt st | N2                ; put it somewhere safe, for now
    .byt sub | N6               ; old `symtab`

    ;~wut? more to do here, to support moving `vmbuf`

                                ; no blocks in VM buffer to worry about here
                                ; not much to do either, really
qvmmovemagic01
    .byt rtn
plant4
    ldy #4
    jmp plant






```
: ?vmmove   ( newsymtab -- )
    #blk @
    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
     vmbuf !
    symtab ! ;


: ?vmmove   ( newsymtab -- )
    vmbuf
    b/buf
    #blk
    (?vmmove).magic             ( newsymtab newvmbuf from to delta flag )
    ?: +move 3drop
    vmbuf !
    symtab ! ;

;(?vmmove).magic   ( newsymtab vmbuf b/buf #blk -- newvmbuf newsymtab )
qvmmovemagic
    jsr locals4                 ; grab just b/buf & vmbuf, leave newsymtab next
    brk
    .byt ldd | TOS              ; #blk@
    .byt st | TOS               ; in case must leave abruptly, don't +MOVE anything
    .byt bz , <(qvmmovemagic01-*-2)
    .byt pull                   ; newsymtab
    .byt st | N2                ; put it somewhere safe, for now
    .byt sub | N6               ; old `symtab`


                                ; no blocks in VM buffer to worry about here
                                ; not much to do either, really
qvmmovemagic01
    .byt rtn
    ldy #4
    jsr restack
    jmp next



    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
```
#endif
#include "align.i65"
_qvmmove
    jsr enter
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(AUTOMEM)
stack=( ~wut? )
tags=nosymbol
Figure out where the new symbol table will be located, runs in between
PASS1 and PASS2 of (FORGET)
( start actualsize -- start actualsize studio-newsize )
~wut? If VMBUF has buffers loaded, they are moved by (AUTOMEM)

: (automem)
    user0studio @ over - $FF00 and benjamin - ;



Automatically move symbol table and vmbuf to someplace that

pad pass1end -                  negative size of symbol table
studio +                        new `symtab` is `size` bytes below studio
ff00 and                        include remainder of the page
256 -                           include one more page
--------------
'some room'                     `symtab`


`n7` points to the null at the end of the sorted-by-size symbol
table copy at `pad`
* calculate `n7` - `pad`
** pass1 symbol table size
** 1 byte larger per entry because PEARSON#

```
: (automem)   ( pad+3 -- pad+3 symtab )
    (automem).init              \ set `dp`, calculate new `symtab`
    dup 32 +under
    symtab #blk @
    if ?movevmbuf then
    ! (automem).phase2 ;

(automem)
studio
inline ; brk ; ldd tos ; st n5
pull ; sub n7 ; add n5 ; push
sub acc ; std n7 ; sti n7 ; rtn
lda #0 ; sta tos
dec tos+1 ; jsr toforth
>n5 dup bl +under symtab
#blk @ if ?vmmove then
! ;


: (automem)
    user0studio @ over - $FF00 and benjamin - ;
```
#endif
#include "align.i65"
_automem
    jsr enter
#include "page.i65"
    .word studio
#include "page.i65"
    .word *+2                   ; `[ assembler here 2+ xt,  brk, tos ldd, ...`
    brk                         ;( 16 0 pad+3 studio )
    .byt ldd | TOS              ;( 16 0 pad+3 studio+2 )
    .byt st | N5
    .byt pull
    .byt sub | N7               ; negated size of interim symtab
    .byt add | N5               ; new size subtracted from studio, will round
    .byt push                   ; down to $FF00 AND
    .byt sub | ACC
    .byt std | N7               ; append end-of-symbols marker
    .byt sti | N7
    .byt rtn
    lda #0
    sta tos                     ; &= $FF00
    dec tos+1                   ; <-- ~#resizestudio startup code area here
;    dec tos+1                   ; -= $0200 leave 'some room'
#include "align.i65"
    jsr toforth                 ; `>forth jsr, forth ] >n5 dup ...`
#include "parm.i65"
    .word tozp
    .byt R0L+2*N5
#include "pad.i65"
    .word dup
#include "page.i65"
    .word bl                    ; 32
#include "page.i65"
    .word plusunder             ;( 16 0 pad+3 $5920 $5900 )
#include "page.i65"
    .word symtab
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch                 ;( 16 0 pad+3 $5920 $5900 symtab #blk )
#include "parm.i65"
    .word qbranch
    .byt <(automem01-*+1)
#include "pad.i65"
    .word _qvmmove              ; need to move vm buffer before symtab !
#include "page.i65"
automem01
    .word store                 ; set symtab
#include "past.i65"
    .word exit

/* (FNORD)
tags: secondary nosymbol

code (fnord)   ( cfa -- )

Merge new symbols into 16 dictionary strands and set new memory allocation

`forget forget` is a synonym for `rehash`

most recent definition (highest address) is the only unsmudged one

: goat 1 ;                              \ cfa1  S|4 goat
        2 constant goal                 \ cfan  S|4 goal
: goat 3 ;                              \ cfa2  S|4 goat
: goat 4 ;                              \ cfa3  S|4 goat  sorted   b. this becomes "U"
        5 constant goal                 \ cfao  S|4 goal
rehash
        6 constant goal                 \ cfap  S|4 goal      unsorted
        7 constant goal                 \ cfaq  S|4 goal           a. this becomes "U"
                                        \ <--- dp following `forget goal`
        8 constant goal                 \ cfar  U|4 goal
: goat 9 ;                              \ cfa4  S|4 goat
: goat 10 ;                             \ cfa5  S|4 goat
: goat 11 ;                             \ cfa6  S|4 goat
: goat 12 ;                             \ cfa7  U|4 goat
forget goal
goat . goal . 4 7 ok

```
: (fnord)   ( cfa -- )
    pad symtab ;code
    brk,   harvests4 ext,
    tos ldd,  n3 st,
    $f000 n4 set,
\ n4h for each strand...
\ n4l ... for each length...



    sym0
    begin
        n8 n4 =
        if
            ?keepacopy
        else

            <n3 <n8
            symnew @ n3 !
            begin
                n8
            while
                sym.strand ( set both n8l, n8h )
                n8 n4 =
                if
                    ?keepacopy
                then
                sym+
            repeat
            n8 ! n3 !
        then
        sym+
        n3 symnew @ =   ( -- flag )
    until

\ bump length/strand
\     until 16/32 --> done
\ copy the sorted ones until (n8)strand/length <> (n4)strand/length --> merge_seq
\     or until (n3 = symnew)? --> done
\ :merge_seq
\   <n8 n4 !              pick up where we left off
\   scan symnew for all (n8)strand/length == (n4)strand/length
\   ... until n4 = n6, that saved copy of (n8) from the break
<---- repeat

    (automem) symtab! ;

```
plover
*/
#include "align.i65"
_pfnord
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word _pad
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word robblerobble
#include "past.i65"
    .word exit

robblerobble
    jmp next

;--------------------------------------------------------------
#if 0
name=FORGET
stack=( "name" -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, sorts symbol table, keeping only words below the CFA of the named word

```
: forget   ( "name" -- )
    '  dup  fence @  u<  7 ?error
    (fnord) ;
```
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "parm.i65"
    .word qerror
    .byt 7                      ; CAN'T FORGET BELOW FENCE
#include "pad.i65"
    .word _pfnord
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REHASH
stack=( -- )
tags=interpreter,extension
Rebuild the [[dictionary]].  This may be necessary during long code builds
as the dictionary eventually overgrows the region of memory between `symnew`
and `studio`

Since `symtab` always aligns on a page boundary, after `rehash` completes,
there will be one page plus whatever space is available on the final page
of the rebuilt symbol table.  This dictionary expansion space is less generous
than the initial helping after `cold` start, before another `rehash` is
required.

* these are synonymous:
** `rehash`
** `forget forget`
** `forget :` (or any word with a CFA in the `studio` region)
** `here (fnord)`

```
: rehash  ( -- )
    here (fnord) ;   \ effectively a `forget nothing` command
```
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _pfnord
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORTH
stack=( -- )
tags=vocabulary,forth-83
Reset the vocabulary search order to just CORE.  Equivalent to
`ONLY FORTH` in ANS Forth

```
: forth   ( -- )
    vocabs 12 erase ;
```
#endif
#include "align.i65"
_forth
    jsr enter
#include "page.i65"
    .word vocabs
#include "page.i65"
    .word count
#include "page.i65"
    .word erase
#include "past.i65"
    .word exit

#if 0
name=DEFINITIONS
stack=( -- )
tags=forth-83

Sets the `current` vocabulary of new definitions

#endif
definitions
    lda uservocabs+1
    sta usercurrent
    jmp next
