;------------------------------------------------------------------------------
/*
title: pettil-dictionary.a65
tags: source nosymbol

SYMTAB!     SYM0        SYM.LEN     SYM.STRANDS
SYM.COPY    (!SYMTAB)   !SYMTAB     STRAND
IMMEDORNOT  (FOUND?)    FOUND?      STRAND+
(FNORD)     >STRAND     NEXTVOCAB?  :WILLITBLEND?
FNORDITUDE  :SOSORTED   :SOSCRAMBLED

>NAME       EXISTS?     '           FORGET
DEFINITIONS REHASH      FORTH

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [  length ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+

symbol
    lfa     contains the
    cfa     points to 6502 code
 %smudge    is smudged
 %vocab     has vocabid
 %immed     is immediate
 length     1..31, 0 = end of list
vocabid     present if %vocab is true, 0 = is label
```
*/
;------------------------------------------------------------------------------
/*
title: SYMTAB!
tags: nosymbol

code symtab!   ( -- )
*/
symtabset
    lda stackh+1,x
    clc
    sbc tos+1
    dex
    sta stackh,x
    sta usersymtab+1
    lda #32
    sta stackl,x
symtabset99
    jmp next
;------------------------------------------------------------------------------
/*
title: SYM0
tags: nosymbol

```
code sym0   ( -- )
  symtab 1+ lda,  n3 1+ sta,
  #34  # lda,  n3 sta,
  'symtabset99 bne,  \ next
```
*/
sym0
    lda usersymtab+1
    sta R0L+2*N3+1
    lda #34
    sta R0L+2*N3
    bne symtabset99                     ; bra next
;------------------------------------------------------------------------------
/*
title: SYM.LEN
tags: primitive nosymbol

Calculate length of a name

|^N3  |^ |^length |
|^N8l |^ |^length |
|^C  |^ |^%vocab |

```
code sym.len   ( ; n3=nfa -- len ; n8l=len )
  'pushya 1- csplit
  # lda, pha,  # lda, pha,
:sym.lens
  0 # ldy,  n3 1+ lda,
  0= not if,
    n3 )y lda,
  then,
  pha, asl, asl, pla,
:symlen_s02
  $1F # and,  n8 ,y sta,  rts,
```
*/
symlen
    lda #>(pushya-1)
    pha
    lda #<(pushya-1)
    pha
symlens
    ldy #0
;~?    lda R0L+2*N3+1                      ; length = 0 if `n3` is 0
;~?    beq symlen_s01
    lda (R0L+2*N3),y                    ; length/flags
symlen_s01
    pha                                 ; not using tay/tya preserves Y=0
    asl
    asl                                 ; Vocab bit to C flag
    pla
symlen_s02
    and #$1F                            ; length
    sty R0L+2*N8+1
    sta R0L+2*N8                        ; N8L = visible length (omit vocab +1)
    rts
;------------------------------------------------------------------------------
/*
title: SYM.COPY
tags: nosymbol subroutine

|^`sym.copy` |<|<|h
|^stack |^( target -- target  )|<|
|^N3 |^nfa.source |^ . |
|^N8 |^source.length |^ . |
|reg |entry |exit |f


code symcopy   ( -- )

*/
symcopy
    jsr symlens
    adc #0
    tay
symcopy01
    lda (R0L+2*N3),y
    sta (R0L+2*N7),y
    dey
    bpl symcopy01
    rts
;------------------------------------------------------------------------------
/* SYM+
tags: nosymbol subroutine

|Z | |false |

*/
symplus
    jsr symlens
    adc #3
    adc R0L+2*N3
    sta R0L+2*N3
    bcc symplus01
    inc R0L+2*N3+1
symplus01
    rts                                 ; Z flag is always nonzero
;------------------------------------------------------------------------------
/*
title: (!SYMTAB)
tags: nosymbol

*/
psamtab
    brk
    .byt ld | N3
    .byt std | TOS              ; set `symnew`
    .byt popd | N3              ; 2-
    .byt ld | N3
    .byt std | TOS              ; set `symtail`
    .byt sub | ACC
    .byt std | N3               ; force cfa = 0
    .byt nxt
;------------------------------------------------------------------------------
/*
title: !SYMTAB
tags: nosymbol secondary

```
: !symtab   ( start end -- size addr )
    bloom 8 erase sym0 symtab @ bl
    begin
        sym.len >  if  <n3 !+ then
        bloomfilter cbit!
        sym.len  call sym+  sym.len 0=
    until (!symtab) 3drop ;
```
*/
#include "align.i65"
_setsymtab
    jsr enter
#include "page.i65"
    .word bloom
#include "page.i65"
    .word eight
#include "page.i65"
    .word erase                 ; reset the Bloom filter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "page.i65"
samtab01
    .word symlen
#include "page.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(samtab02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word _storeplus
#include "page.i65"
samtab02
    .word _bloomfilter
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symlen
#include "parm.i65"
    .word callz                         ; ~todo tidy up here
    .word symplus
#include "pad.i65"
    .word symlen
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qbranch
    .byt <(samtab01-*+1)
#include "pad.i65"
    .word symnew
#include "page.i65"
    .word psamtab               ; handle `symtab` tail
#include "page.i65"
    .word threedrop
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* BLOOM#
tags: nosymbol

stack=( -- n )

The Bloom filter tries to answer the question, 'is this word a number?'

The string under consideration is pointed to by (N3) with a length of N8.

Generate a hash of a string, in the range 0..63, used as an index into the
sparsely populated `bloom` 8-byte bitfield.

A `true` bloom filter bit means, this word might be in the dictionary
A `false` bit means, this word is not present

`create` turns on the `bloom` bit for each new name
`forget` completely rebuilds the `bloom` filter

|reg |entry |exit |h
|^stack |^( nfa -- bloom# )|<|
|^N3 |^ |^nfa |
|^N8l |^ |^length |
|^N8h |^ |^0 |

code bloom#   ( nfa -- bloom# )

*/
bloomhash
    ldy R0L+2*N8                        ; length
    lda #0
    sta z
bloomhash01
    lda (R0L+2*N3),y
    eor #$30
    cmp #9
    bcs bloomhash02
    adc z
    sta z
bloomhash02
    dey
    bne bloomhash01
    lda z
    and #$3F                            ; width of the filter is 64 bits
    jmp pushya
;------------------------------------------------------------------------------
/* BLOOMFILTER
tags: nosymbol

stack=( -- mask addr )
*/
#include "align.i65"
_bloomfilter
    jsr enter
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word bloom
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: UNSMUDGE
tags: primitive

stack=( nfa -- )
*/
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
/*
title: SMUDGE
tags: primitive forth-79

stack=( nfa -- )
*/
smudge
    sec
    ;
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop
;------------------------------------------------------------------------------
/*
title: (>NAME)
tags: nosymbol

stack=( cfa -- nfa|0 )
*/
ptoname
    ldy #$FE
ptoname02
    dec R0L+2*N3+1
    lda (R0L+2*N3),y
    inc R0L+2*N3+1
    eor tos-$FE,y
    bne ptoname05
    iny
    bne ptoname02
    lda R0L+2*N3
    ldy R0L+2*N3+1
ptoname04
    jmp put
ptoname05
    ldy #0
    lda (R0L+2*N3),y
    beq ptoname04
    jsr symplus                 ; next!
    bne ptoname                 ; bra
;------------------------------------------------------------------------------
#if 0
name=>NAME
tags=interpreter

#endif
#include "align.i65"
_toname
/*
title: >NAME
tags: forth-83

* search the dictionary for a given `cfa` and
* return the `nfa` if found, else `0`
* honors the smudge bit

```
: >name   ( cfa -- nfa|0 )
    sym0
    begin
        name> over <>
        sym.len and
    while
        3 sym+
    repeat
    name> nip ;
```
*/
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word ptoname
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: (SEEK)
tags: nosymbol

|^stack |^( nfa.seek -- xfa flag )|<|h
|^N3 |^sym0             |^nfa.result    |
|^N4 |^seek.length      |^ .            |
|^N5 |^                 |^vocabid       |
|^N6 |^                 |^vocabs        |
|^N7 |^nfa.strand[0]    |^ .            |
|^N8 |^                 |^result.length |
|reg |entry             |exit           |f

0000  00 AA FF 01  60 6B B6 05  A6 17 D8 64  06 60 00 00
0010  B7 06 20 00  03 00 6A 6C  00 01 0D D0  16 83 C1 6C

0040  AA AA AA 08  88 6C 1E 90  7E 09 08 B6  00 80 FF 01
0070  BB BB BB 00  06 06 00 06  06 00 00 06  00 00 01 10

0080  00 00 00 00  74 06 E6 8B  E6 8B 6C DE  6C
                                                00 08 50
0090  55 E4 55 06  FF B3 00 1B  00 06 01 FF  00 00 00 00
00A0  00 03 00 14  03 00 1B 01  0A 20 00 00  00 00 00 00
00B0  03 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00C0  00 00 00 00  20 83 04 01  04 3C 45 00  00 00 00 00
00D0  00 00 00 00  00 27 00 00  14 0D 00 00  00 00 00 00
00E0  80 80 80 80  80 80 80 81  81 81 81 81  81 82 82 82
00F0  82 82 82 82  83 83 83 83  83 00 00 5D  46 FF FF 00

0100  20 33 31 37  34 33 00 30  30 30 30 00  00 00 00 00

01E0  FF FF FF FF  FF FF 35 75  34 03 09 57  03 4E 01 6C
01F0  6C 4B 06 68  06 DE 2F FF  30 B5 6C 33  6E 5C 6E 03

|^stack |^( nfa.seek -- xfa flag )|<|h
|^N3 |^sym0             |^nfa.result    |
|^N4 |^seek.length      |^ .            |
|^N5 |^                 |^vocabid       |
|^N6 |^                 |^vocabs        |
|^N7 |^nfa.strand[0]    |^ .            |
|^N8 |^                 |^result.length |
|reg |entry             |exit           |f

* n8 n4 > sorted and ?exit

code pseek   ( nfa -- xfa flag )

    1stchar  = (n3),1 $0F & 2*
    %smudge = (n3),0 $80 & 0<>
    %vocab  = (n3),0 $40 & 0<>
    %immed  = (n3),0 $20 & 0<>
    (n3),0 = 0                          symtail                     not found
    %vocab &

*/
pseeko
    jsr plugh
    inc R0L+2*N8+1                      ; odd for unsorted, even for sorted
                                        ; this toggles on subsequent (seek) calls
    bne pseek
pnext
    jsr symplus
pseek
    jsr symlens
    beq unfounded                       ; exit if we reach symtail
    tay                                 ; length
    lda R0L+2*N8+1
    lsr
    bcc unfounded

    lda R0L+2*N5                        ; seek vocab
    beq pseek0v
    bcc nextsymbol              ;mismatch?
    .byt $2C
pseek0v
    bcs nextsymbol              ; mismatch
    ;
    bcc pseechrplus
    iny
    iny
pseechr                                 ; char.each
    dey
    beq goteem
pseechrplus
    lda (tos),y                         ; check next char
    eor (R0L+2*N3),y                    ; vocabid
    beq pseechr
nextsymbol
    jsr symplus
    bne pseek                           ; bra

goteem
    inc R0L+2*R14+1                     ; sec
unfounded
    rts

/*
    bpl pseek



psee01
    jsr symplus                 ; next!
    bne pseek                   ; bra
pseeok1
    ;ldy #0                     ; thanks, symlen
    lda (R0L+2*N3),y
    bmi psee01                 ; smudged? next!
    ldy R0L+2*N4
    iny
    lda R0L+2*N5                ; compare vocabularies
    bcc psee04b
    .byt $2C
*/
;------------------------------------------------------------------------------
/*
title: IMMEDORNOT
tags: nosymbol

Return +1 if the immediate bit is set on current `nfa`, otherwise returns -1

code immedornot   ( true -- -1|+1 )

*/
immedornot
    ldy #0
    lda (R0L+2*N3),y            ; length/flags of curr `nfa`
    and #$20                    ; immediate?
    lsr
    lsr
    lsr
    lsr                         ; divide by 16, $02 when immediate
    jmp nplus                   ; add 0 or 2 to tos
;------------------------------------------------------------------------------
/*
title: (FOUND?)
tags: nosymbol


~ use N4 to hold either:
~    length.seek (as set by >strand )
~    length.32 (to prevent ever reaching it)

calculate n7=strand
for each vocabulary
	n3=symnew+2
    check unsorted (symnew...)
	n3=n7
    check sorted (>strand...)


```
code (found?)   ( nfa -- xfa flag )
    brk,  vocabs 1+ n6 set,             \ first vocab
:found1
    n6 ldd@,  n5 st,                    \ get vocabid
:found2
    symnew n3 set,  n3 ldd@,
    n3 st,  n3 ldd@,  '(seek) ext,
    '>strand ext,  '(seek) ext,
```


#include "parm.i65"
    .word tozp
    .byt R0L+2*N3
#include "pad.i65"
    .word symlen
#include "page.i65"
    .word drop



code >strand   ( nfa -- nfa ; n3=strand )
  'symlens jsr,  n4 sta,  iny,
  tos )y lda,  $0f # and,  asl,  n7 sta,
  symtab 1+ lda,  n7 1+ sta,
  rts,  end-code

code (found?)   ( nfa -- xfa flag )
    brk,  vocabs 1+ n6 set,             \ first vocab
:pfoundq01
    n6 ldd@, n5 st,                     \ get vocabid
    symnew tos set,
    (seek) ext,                         \ check unsorted
    >strand tos set,
    (seek) ext,                         \ check sorted
    n6 ld@, 'pfoundq01 bnz,
    nxt,
```
code found00
    'symlens jsr,  n4 sta,  iny,
    n3 )y lda,  $0F # and,  asl,
    n7 sta,  symtab 1+ lda,  n7 1+ sta,
    next jmp,  end-code

    n3 !  callz symlen
*/
pfoundq
    brk
    .byt set | N6
    .word uservocabs+1                  ; first vocab
pfoundq01
    .byt ldd | N6
    .byt st  | N5                       ; get vocabid
    .byt set | N3
    .word usersymnew
    .byt ldd | N3
    .byt st  | N3
    .byt ext
    .word pseeko
    .byt bc  , <(pfound99-*-2)
    .byt ld  | N7
    .byt st  | N3
    .byt ext                            ; if we're still here, we haven't exited
    .word pseek                         ; search sorted until 0= or len>seeklen(n4)
    .byt bc  , <(pfound99-*-2)
;---
    .byt ld  | N5                       ; get vocabid
    .byt bnz  , <(pfoundq01-*-2)        ; until last vocab
pfound99
    .byt ld  | N3                       ; tell 'em what happened
    .byt push                           ;
    .byt nxt                            ; ( nfa 0 )

;------------------------------------------------------------------------------
/*
title: FOUND?
tags: nosymbol secondary

Search the dictionary for a name

| flag | meaning | 2os |h
| -1 | found | cfa |
|  0 | not found | nfa |
| +1 | immediate word | cfa |

```
: found?   ( nfa -- xfa flag )
  >n3 found00                           ( nfa ; n3=nfa n4=n8=seek.length )
  bloomfilter cbit@                     ( nfa flag )
  ?: (found?) false ;
```
*/
#include "align.i65"
_foundq
    jsr enter
#include "parm.i65"
    .word tozp
    .byt R0L+2*N3
#include "page.i65"
    .word found00
#include "page.i65"
    .word _bloomfilter          ; in sought name, sum of digits ['0-9'+1] modulo 64
#include "page.i65"             ; e.g. `dup` = 0, and `3.1459` = 27
    .word cbitfetch
#include "parm.i65"
    .word pquerycolon
    .word pfoundq
    .word false
#include "past.i65"
    .word exit
found00
    jsr symlens
    iny
    lda (R0L+2*N3),y                    ; 1st character of name
    and #$0F                            ; low 4-bits only
    asl                                 ; *2
    sta R0L+2*N7                        ; sym0 (sorted)
    lda usersymtab+1
    sta R0L+2*N7+1
    brk
    .byt ldd | N7
    .byt st  | N7                       ; j'adoube
    .byt ld  | N8
    .byt st  | N4                       ; seek.length
    .byt nxt
;------------------------------------------------------------------------------
/*
title: EXISTS?
tags: secondary vocabulary

search the dictionary for a name
bill had a billboard he also had a board bill the board bill bored bill so bill sold
the billboard to pay the board bill so the board bill no longer bored bill

```
: exists?   ( "name" ; -- cfa|0 )
  bl name ?dup  ?: found? false  and ;
```
*/
#if 0
name=EXISTS?
tags=vocabulary

#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word pquerycolon
    .word _foundq
    .word false
#include "pad.i65"
    .word andx
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: `'`
tags: forth-83

stack=( -- cfa )
*/
#if 0
name='
tags=forth-83

#endif
#include "align.i65"
_tick
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qerror
    .byt 3                      ; NOT FOUND
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: (CREATE)
tags: nosymbol

stack=( cfa -- )
Create a new symbol in the symbol table
*/
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qerror
    .byt 4                      ; MISSING NAME
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word off
#include "page.i65"
    .word _existsq
#include "parm.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word store
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N7
#include "pad.i65"
    .word dotrvs
#include "page.i65"
    .word _stringdot
#include "parm.i65"
    .word _pdq
    .byt <(pcreate01-*-1)
    .asc RVSOFF," EXISTS"
pcreate01
#include "pad.i65"
pcreate02
    .word bloom                         ; aka `symtail` +2
#include "page.i65"
    .word current
#include "page.i65"
    .word rot
#include "page.i65"
    .word _qalign
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word newest
#include "past.i65"
    .word *+2
    jsr harvests6
    brk
    .byt popd | N0               ; symtail @
    .byt st | N3
    .byt ld | N2                ; cfa'
    .byt std | N3               ; write CFA to symtab, +2 N5 pointer
    .byt ld | N3
    .byt std | TOS              ; populate `newest`
    .byt ld | N7
    .byt st | N3
    .byt popd | TOS
    .byt st | N7
    .byt ext
    .word symcopy               ; copy the symbol/length
    .byt ldi | N1
    .byt bz , <(ppcreate01-*-2)
    .byt set | ACC
    .word $40
ppcreate01
    .byt st | TOS               ; TOS = $00 or $40 if vocab
    .byt inr | N7
    .byt pop | N7
    .byt st | N5
    .byt add | TOS
    .byt sti | N7                       ; symbol length with a proper vocab bit
    .byt ld | N7
    .byt add | N5
    .byt st | N7
    .byt pop | N1
    .byt bz , <(ppcreate02-*-2)
    .byt sti | N7
ppcreate02
    .byt ld | N7
    .byt std | N0                       ; update symtail
    .byt sub | ACC
    .byt sti | N7
    .byt std | N7
    .byt pull
    .byt rtn
    jmp exit
;------------------------------------------------------------------------------
/*
title: STRAND+
tags: nosymbol

increment the length byte (N4l) until it
reaches 32, then increment strand (N4h)

code strand+   ( -- )
  n4 inc,  32 # lda,  n4 eor,
  0<> if,  n4 sta,  n4 1+ inc,  then,
  rts,
*/
strandplus
    inc R0L+2*N4
    lda #32
    eor R0L+2*N4
    bne straplu01
    sta R0L+2*N4
    inc R0L+2*N4+1
straplu01
    rts

;------------------------------------------------------------------------------
/*
title: :WILLITBLEND?
tags: nosymbol sweet16

Evaluate (and maybe retain) a name
|tos|symnew             |symnew             |
|n0 |cfa(n3)            |cfa(n3)            |
|n2 |studio             |studio             |
|n3 |nfa                |nfa+               |
|n4 |                   |stepper len/strand |
|n5 |                   |output to pad      |
|n6 |                   |cutoff             |

:willitblend?
    'sym.strand ext,
    n4 ld,  n8 cpr,  'wiblend02 bnz,    \ len/strand must match exactly
    n3 ld,  n0 st,
    n0 popd,  n6 cpr,  'wiblend01 bp,   \ and cfa must be in bounds
    n2 cpr,  'wiblend02 bp,
:wiblend01
    'sym.copy ext,
:wiblend02
    'sym+ ext,  rs,
*/
willitblendq
    .byt ext
    .byt ld  | N4
    .byt cpr | N8                       ; shall I compare n4 to a summer's day?
    .byt bnz , <(wiblend02-*-2)         ; move over to unsorted list if they differ
    .byt popd | N3
    .byt ldd  | N3                      ; get cfa without disturbing n3
    .byt cpr | N2                       ; compare to studio
    .byt bp , <(wiblend01-*-2)
    .byt cpr | N6                       ; compare to cfa
    .byt bp , <(wiblend02-*-2)
wiblend01
    .byt ext
    .word symcopy
wiblend02
    .byt ext
    .word symplus
    .byt rs

;------------------------------------------------------------------------------
/*
title: (FNORD)
tags: nosymbol sweet16 tiny

```
code fnorditude   ( cfa pad 'studio -- pad size )
    brk, tos ldd, n2 st,  pull, n5 st,
    pull, n6 st,  acc sub, n4 st,       \ n2=studio n3=sym0 n4=0 n5=pad n6=cfa
    symnew tos set,  tos ldd,  tos st,  \ unsorted symbols
```
*/
pfnord
    brk
    .byt ldd | TOS
    .byt st  | N2                       ; n2=studio
    .byt pull
    .byt st  | N5                       ; n5=output buffer (pad)
    .byt pull
    .byt st  | N6                       ; n6=cfa copy
    .byt sub | ACC
    .byt st  | N4                       ; n4=current len/strand off
    ; fall through
;------------------------------------------------------------------------------
/*
title: :SOSORTED
tags: nosymbol

```
:sosorted
    'willitblend? bs, 'sosorted bz,     \ copy sorted names for len/strand=n4
    n3 ld,  tos cpr,  'fnordout bp,     \ while  n3 < symnew
    tos ld,  n0 st,
    n3 ld, push,  n8 ld, push,          \ TOS is next sorted len/strand
```
*/
sosorted
    .byt bs , <(willitblendq-*-2)
    .byt bz , <(sosorted-*-2)
    .byt ld  | N3
    .byt cpr | TOS
    .byt bp , <(fnordout-*-2)
    .byt ld  | TOS
    .byt st  | N0
    .byt ld  | N3
    .byt push,
    .byt ld  | N8
    .byt push,
    ; fall through
;------------------------------------------------------------------------------
/*
title: :SOSCRAMBLED
tags: nosymbol

:soscrambled
    n0 ld,  n3 st,                      \ n3=symnew
:howaboutthis
    'willitblend? bs,
    n3 ldd, :howaboutthis bnz,
    'strand+ ext,
       <n4 tos =
    'soscrambled bnz,
    tos ld, n8 st, pull, n3 st,
    n0 ld, tos st,
    'sosorted br,               \ repeat
:fnordout
    nxt,
```
*/
soscrambled
    .byt ld | N0
    .byt st | N3
howaboutthis
    .byt bs , <(willitblendq-*-2)
    .byt ldd | N3
    .byt bnz , <(howaboutthis-*-2)
    .byt ext
    .word strandplus
    .byt ld | N4
    .byt cpr | TOS
    .byt bnz , <(soscrambled-*-2)
    .byt ld | TOS
    .byt st | N8
    .byt pull,
    .byt st | N3
    .byt ld | N0
    .byt st | TOS
    .byt br ,  <(sosorted-*-2)
fnordout
    .byt nxt
;------------------------------------------------------------------------------
/*
title: FNORD
tags: nosymbol secondary

code strand.len+
    lda n4
    and #31
    bne +
    sta n4
    inc n4+1
    lda n4+1
    and #15
    beq seeyabye
seeyabye
    rts
+
end-code

```
: fnord   ( cfa -- )
    sym0  pad studio                    ( cfa pad 'studio )
    fnorditude !symtab ;
```
*/
#include "align.i65"
_fnord
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word _pad
#include "page.i65"
    .word studio
#include "page.i65"                     ; ~goto symtab! to end (fnord)
    .word pfnord
#include "page.i65"
    .word _setsymtab
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: FORGET
tags: secondary dictionary fig forth-79 forth-83

```
: forget   ( "name" ; -- )  '           \ next token from input stream
  dup fence @ u<  7 ?error              \ can't forget below fence
  (fnord) ;
```
*/
#if 0
name=FORGET
tags=fnord
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word under
#include "page.i65"
    .word ult
#include "parm.i65"
    .word qerror
    .byt 7                      ; CAN'T FORGET BELOW FENCE
#include "pad.i65"
    .word _fnord
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: DEFINITIONS
tags: forth-83

Set `current` vocabulary for `create`

```
code definitions   ( -- )
  vocabs 1+ lda,  current sta,
  next jmp,
```
*/
#if 0
name=DEFINITIONS
tags=fnord
#endif
definitions
    lda uservocabs+1
    sta usercurrent
    jmp next
;------------------------------------------------------------------------------
/*
title: REHASH
tags: secondary pettil dictionary

Sort/merge a fresh dictionary

```
: rehash   ( -- )
  here (fnord) ;
```
*/
#if 0
name=REHASH
tags=fnord
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _fnord
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: FORTH
tags: vocabulary forth-83

Search only the main forth vocabulary

```
\ must be first vocabulary defined
#voc on  vocabulary forth
```
~~~code golf~~~
[-7 bytes] chitselb 2020-05-11
*/
#if 0
name=FORTH
tags=fnord
#endif
#include "align.i65"
_forth
    jsr dovocab
    .byt 0                              ; vocabulary identifier
