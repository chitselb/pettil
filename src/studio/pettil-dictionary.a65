;------------------------------------------------------------------------------
/*
title: pettil-dictionary.a65
tags: source nosymbol

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
*/
;------------------------------------------------------------------------------
/*
title: SYMTAB!
tags: nosymbol

*/
symtabset
    dex
    lda stackh+2,x
    clc
    sbc tos+1
    sta stackh,x
    sta usersymtab+1
    lda #32
    sta stackl,x
symtabset99
    jmp next
;------------------------------------------------------------------------------
/*
title: SYM0
tags: nosymbol

```
code sym0   ( -- )
  #34  # lda,  n3 sta,
  symtab 1+ lda,  n3 1+ sta,
  'symtabset99 bne,  \ next
```
*/
sym0
    lda #34
    sta R0L+2*N3
    lda usersymtab+1
    sta R0L+2*N3+1
    bne symtabset99             ; next
;------------------------------------------------------------------------------
/*
title: SYM.LEN
tags: primitive nosymbol

Calculate length of a name to N8, C flag

```
code sym.len   ( -- )
  'pushya 1- csplit
  # lda, pha,  # lda, pha,
:sym.len_s
  0 # ldy,  n3 1+ lda,
  0= not if,
    n3 )y lda,
  then,
  pha, asl, asl, pla,
:symlen_s02
  $1F # and,  n8 ,y sta,  rts,
```
*/
symlen
    lda #>(pushya-1)
    pha
    lda #<(pushya-1)
    pha
symlen_s
    ldy #0              ;{2 {=23}}
    lda R0L+2*N3+1                      ; length = 0 if `n3` is 0
    beq symlen_s01
    lda (R0L+2*N3),y    ;{5}            ; length/flags
symlen_s01
    pha                 ;{3}            ; not using tay/tya preserves Y=0
    asl                 ;{2}
    asl                 ;{2}            ; Vocab bit to C flag
    pla                 ;{4}
symlen_s02
    and #$1F            ;{2}            ; length
    sta R0L+2*N8,y      ;{5}            ; N8L = visible length (omit vocab +1)
    rts
;------------------------------------------------------------------------------
/*
title: SYM.STRAND
tags: nosymbol

```
code sym.strand
    'symlen_s jsr,  iny,  n3 ,y lda,
    asl,  'symlen_s02 bne, \ bra
```
*/
symstrand
    jsr symlen_s
    iny
    lda (R0L+2*N3),y
    asl
    bne symlen_s02 			; bra
;------------------------------------------------------------------------------
/*
title: SYM.COPY
tags: nosymbol subroutine

*/
symcopy
    jsr symlen_s
    adc #0
    tay
symcopy01
    lda (R0L+2*N3),y
    sta (R0L+2*N7),y
    dey
    bpl symcopy01
    rts
;------------------------------------------------------------------------------
/* SYM+
tags: nosymbol subroutine

*/
symplus
    jsr symlen_s
    adc #3
    adc R0L+2*N3
    sta R0L+2*N3
    bcc symplus01
    inc R0L+2*N3+1
symplus01
    rts
;------------------------------------------------------------------------------
/*
title: (!SYMTAB)
tags: nosymbol

*/
psamtab
    brk
    .byt ld | N3
    .byt std | TOS              ; set `symnew`
    .byt popd | N3              ; 2-
    .byt ld | N3
    .byt std | TOS              ; set `symtail`
    .byt sub | ACC
    .byt std | N3               ; force cfa = 0
    .byt nxt
;------------------------------------------------------------------------------
/*
title: !SYMTAB
tags: nosymbol secondary


```
: !symtab   ( start end -- size addr )
    bloom 8 erase sym0 symtab @ bl
    begin
        sym.len >  if  <n3 !+ then
        bloomfilter cbit!
        sym.len  call sym+  sym.len 0=
    until (!symtab) 3drop ;
```
*/
#include "align.i65"
_setsymtab
    jsr enter
#include "page.i65"
    .word bloom
#include "page.i65"
    .word eight
#include "page.i65"
    .word erase                 ; reset the Bloom filter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "page.i65"
samtab01
    .word symlen
#include "page.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(samtab02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word _storeplus
#include "page.i65"
samtab02
    .word _bloomfilter
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symlen
#include "parm.i65"
    .word callz                         ; ~todo tidy up here
    .word symplus
#include "pad.i65"
    .word symlen
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qbranch
    .byt <(samtab01-*+1)
#include "pad.i65"
    .word symnew
#include "page.i65"
    .word psamtab               ; handle `symtab` tail
#include "page.i65"
    .word threedrop
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* BLOOM#
tags: nosymbol

stack=( -- n )

The Bloom filter tries to answer the question, 'is this word a number?'

The string under consideration is pointed to by (N3) with a length of N8.

Generate a hash of a string, in the range 0..63, used as an index into the
sparsely populated `bloom` 8-byte bitfield.

A `true` bloom filter bit means, this word might be in the dictionary
A `false` bit means, this word is not present

`create` turns on the `bloom` bit for each new name
`forget` completely rebuilds the `bloom` filter
*/
bloomhash
    ldy R0L+2*N8                ; length
    lda #0
    sta z
bloomhash01
    lda (R0L+2*N3),y
    eor #$30
    cmp #9
    bcs bloomhash02
    adc z
    sta z
bloomhash02
    dey
    bne bloomhash01
    lda z
    and #$3F                    ; width of the filter is 64 bits
    jmp pushya
;------------------------------------------------------------------------------
/* BLOOMFILTER
tags: nosymbol

stack=( -- mask addr )
*/
#include "align.i65"
_bloomfilter
    jsr enter
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word bloom
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* UNSMUDGE
tags: nosymbol

stack=( nfa -- )
*/
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
/*  SMUDGE
tags: nosymbol

stack=( nfa -- )
*/
smudge
    sec
    ;
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop
;------------------------------------------------------------------------------
/* (>NAME)
tags: nosymbol

stack=( cfa -- nfa|0 )
*/
ptoname
    ldy #$FE
ptoname02
    dec R0L+2*N3+1
    lda (R0L+2*N3),y
    inc R0L+2*N3+1
    eor tos-$FE,y
    bne ptoname05
    iny
    bne ptoname02
    lda R0L+2*N3
    ldy R0L+2*N3+1
ptoname04
    jmp put
ptoname05
    ldy #0
    lda (R0L+2*N3),y
    beq ptoname04
    jsr symplus                 ; next!
    bne ptoname                 ; bra
;------------------------------------------------------------------------------
#if 0
name=>NAME
tags=interpreter

#endif
#include "align.i65"
_toname
/* >NAME
tags: forth-83

* search the dictionary for a given `cfa` and
* return the `nfa` if found, else `0`
* honors the smudge bit

```
: >name   ( cfa -- nfa|0 )
    sym0
    begin
        name> over <>
        sym.len and
    while
        3 sym+
    repeat
    name> nip ;
```
*/
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word ptoname
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* (SEEK)
tags: nosymbol

~todo: rewrite to no longer use N4 as sorted/unsorted so it may interoperate
    better with `(fnord)`

stack=( thread -- flag )
*/
pseek
    brk
    .byt ldd | TOS
    .byt st | N3                ; `n3` is start of thread
    .byt rtn
pseekb
    lda R0L+2*N4+1              ; toggle sorted/unsorted flag in `n4h`
    eor #$FF
    sta R0L+2*N4+1              ; sorted = 0; unsorted = $FF
pseek00
    jsr symlen_s
    beq pseek08                 ; reached `symtail`? not found!
    eor R0L+2*N4
    beq pseekok1                ; same length? consider further...
    bit R0L+2*N4+1
    bmi pseek01                 ; unsorted list? next!
    lda R0L+2*N8
    cmp R0L+2*N4                ; length.current > length.seeking?
    bcs pseek08                 ; not found on sorted list!
pseek01
    jsr symplus               ; next!
    bne pseek00                 ; bra
pseekok1
    ;ldy #0                     ; thanks, symlen
    lda (R0L+2*N3),y
    bmi pseek01                 ; smudged? next!
    ldy R0L+2*N4
    iny
    lda R0L+2*N5                ; compare vocabularies
    bcc pseek04b
    .byt $2C
pseekok2
    lda (R0L+2*N7),y            ; `n7` name we are looking for
pseek04
    eor (R0L+2*N3),y            ; `n3` current name under consideration
pseek04b
    bne pseek01                 ; different symbol? next!
pseek05
    dey
    bne pseekok2
pseek07
    clc                         ; found, false (inverted flag)
    .byt $29                    ; AND imm opcode
pseek08
    sec                         ; not found, true
pseek09
    ;
    jmp putc
;------------------------------------------------------------------------------
/*
title: STRAND
tags: nosymbol

```
code >strand   ( -- thread )
  n8 1+ lda,  symtab 1+ ldy,  put jmp,
```
*/
tostrand
    lda R0L+2*N8+1
    ldy usersymtab+1
    jmp put
;------------------------------------------------------------------------------
/*
title: >STRAND
tags: nosymbol

code >strand   ( -- thread )
  1 # ldy,  n7 )y lda,  $0F # and,  asl,
  tos sta,  next jmp,
*/
tothread
    ldy #1
    lda (R0L+2*N7),y            ; use `nfa` in `n7`, get first character
    and #$0F                    ; simplified replacement for Pearson hash
    asl                         ; *2
    sta tos                     ; `symtab` always at a page boundary
    jmp next
;------------------------------------------------------------------------------
/*
title: IMMEDORNOT
tags: nosymbol

Return +1 if the immediate bit is set on current `nfa`, otherwise returns -1

code immedornot   ( true -- -1|+1 )

*/
immedornot
    ldy #0
    lda (R0L+2*N3),y            ; length/flags of curr `nfa`
    and #$20                    ; immediate?
    lsr
    lsr
    lsr
    lsr                         ; divide by 16, $02 when immediate
    jmp nplus                   ; add 0 or 2 to tos
;------------------------------------------------------------------------------
/*
title: NEXTVOCAB?
tags: nosymbol

Return `true` if there is a next vocabulary

```
code next.vocab?   ( -- flag )  brk,
  n5 ld,  push,  n6 ld@,  n5 st,  nxt,
```
*/
nextvocabq
    brk
    .byt ld | N5
    .byt push
    .byt ldi | N6
    .byt st | N5
    .byt nxt
;------------------------------------------------------------------------------
/*
title: (FOUND?)
tags: nosymbol

```
code (found?)   (  name vocabs -- ) brk,
  n8 ld,  n4 st,  tos ld,  n6 st,
  n6 inr,  n6 ldi,  n5 st,  pull,
  n7 st,  n3 st,  pull,  nxt,
```
*/
pfoundq
    brk
    .byt ld | N8                ; `n4` `n8` len
    .byt st | N4
    .byt ld | TOS
    .byt st | N6                ; vocabs
    .byt inr | N6
    .byt ldi | N6
    .byt st | N5                ; first vocab
    .byt pull
    .byt st | N7                ; name
    .byt st | N3                ; name
    .byt pull
    .byt nxt
;------------------------------------------------------------------------------
/*
title: FOUND?
tags: nosymbol secondary

Search the dictionary for a name

: found?   ( nfa -- xfa flag )
  vocabs (found?)  bloomfilter cbit@
  if
    begin
      symnew (seek)
    while
      symtab @ >thread
*/
#include "align.i65"
_foundq
    jsr enter
#include "page.i65"
    .word vocabs
#include "page.i65"
    .word pfoundq
#include "page.i65"
    .word _bloomfilter          ; sum of decimal digits in name % 64
#include "page.i65"
    .word cbitfetch
#include "parm.i65"
    .word qbranch               ; if
    .byt <(found04-*+1)
#include "pad.i65"
foundq01                        ;     begin (loop through vocabs)
    .word symnew
#include "page.i65"
    .word pseek                 ; returns inverted found? flag
#include "parm.i65"
    .word qbranch               ;     while (branches if found)
    .byt <(foundq03-*+1)
#include "pad.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word tothread
#include "page.i65"
;    .word tostrand
#include "page.i65"
    .word pseek
#include "parm.i65"
    .word qbranch               ; inverted flag, so branch if found
    .byt <(foundq03-*+1)
#include "pad.i65"
    .word nextvocabq
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qbranch               ; loop if more vocabs
    .byt <(foundq01-*+1)
#include "parm.i65"
found04                         ; then
    .word zpfrom
    .byt R0L+2*N7               ; original `nfa`
#include "pad.i65"
    .word false                 ; and nope, this name was not found
#include "past.i65"
    .word exit

#include "parm.i65"
foundq03                        ; found it
    .word zpfrom
    .byt R0L+2*N3               ; the CFA
#include "pad.i65"
    .word namefrom
#include "page.i65"
    .word true                  ; assume it's a normie -1
#include "page.i65"
    .word immedornot            ; maybe add 2 if it's immediate
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* EXISTS?
tags: vocabulary

search the dictionary for a name

```
: exists?   ( "name" ; -- cfa|0 )
  bl name ?dup  ?: found? false  and ;
```
*/
#if 0
name=EXISTS?
tags=vocabulary

#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word pquerycolon
    .word _foundq
    .word false
#include "pad.i65"
    .word andx
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
#if 0
name='
tags=forth-83

#endif
#include "align.i65"
_tick
/* '
tags: forth-83

stack=( -- cfa )
*/
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qerror
    .byt 3                      ; NOT FOUND
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
#include "align.i65"
_pcreate
/* (CREATE)
tags: nosymbol

stack=( cfa -- )
Create a new symbol in the symbol table
*/
    jsr enter
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qerror
    .byt 4                      ; MISSING NAME
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word off
#include "page.i65"
    .word _existsq
#include "parm.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word store
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N7
#include "pad.i65"
    .word dotrvs
#include "page.i65"
    .word _stringdot
#include "parm.i65"
    .word _pdq
    .byt <(pcreate01-*-1)
    .asc RVSOFF," EXISTS"
pcreate01
#include "pad.i65"
pcreate02
    .word bloom                         ; aka `symtail` +2
#include "page.i65"
    .word current
#include "page.i65"
    .word rot
#include "page.i65"
    .word _qalign
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word newest
#include "past.i65"
    .word *+2
    jsr harvests6
    brk
    .byt popd | N0               ; symtail @
    .byt st | N3
    .byt ld | N2                ; cfa'
    .byt std | N3               ; write CFA to symtab, +2 N5 pointer
    .byt ld | N3
    .byt std | TOS              ; populate `newest`
    .byt ld | N7
    .byt st | N3
    .byt popd | TOS
    .byt st | N7
    .byt ext
    .word symcopy               ; copy the symbol/length
    .byt ldi | N1
    .byt bz , <(ppcreate01-*-2)
    .byt set | ACC
    .word $40
ppcreate01
    .byt st | TOS               ; TOS = $00 or $40 if vocab
    .byt inr | N7
    .byt pop | N7
    .byt st | N5
    .byt add | TOS
    .byt sti | N7               ; symbol length with a proper vocab bit
    .byt ld | N7
    .byt add | N5
    .byt st | N7
    .byt pop | N1
    .byt bz , <(ppcreate02-*-2)
    .byt sti | N7
ppcreate02
    .byt ld | N7
    .byt std | N0               ; update symtail
    .byt sub | ACC
    .byt sti | N7
    .byt std | N7
    .byt pull
    .byt rtn
    jmp exit
;------------------------------------------------------------------------------
/*
title: STRAND+
tags: nosymbol

increment the length byte (N4l) until it
reaches 32, then increment thread (N4h)

code strand+   ( -- )
  n4 inc,  32 # lda,  n4 eor,
  0<> if,  n4 sta,  n4 1+ inc,  then,
  rts,
*/
strandplus
    inc R0L+2*N4
    lda #32
    eor R0L+2*N4
    bne straplu01
    sta R0L+2*N4
    inc R0L+2*N4+1
straplu01
    rts
;------------------------------------------------------------------------------
willitblendq
/*
title: :WILLITBLEND?
tags: nosymbol sweet16

Evaluate (and maybe retain) a name

:willitblend?
    'sym.strand ext,
    n4 ld,  n8 cpr,  'wiblend02 bnz,
    n3 ld,  n0 st,
    n0 popd,  n6 cpr,  'wiblend01 bp,
    n2 cpr,  'wiblend02 bp,
:wiblend01
    'sym.copy ext,
:wiblend02
    'sym+ ext,  rs,
*/
    .byt ext
    .word symstrand
    .byt ld  | N4
    .byt cpr | N8                       ; shall I compare n4 to a summer's day?
// plover
    .byt bnz , <(wiblend02-*-2)
    .byt popd | N3
    .byt ldd  | N3                      ; get cfa without disturbing n3
    .byt cpr | N2                       ; compare to studio
    .byt bp , <(wiblend01-*-2)
    .byt cpr | N6                       ; compare to cfa
    .byt bp , <(wiblend02-*-2)
wiblend01
    .byt ext
    .word symcopy
wiblend02
    .byt ext
    .word symplus
    .byt rs
;------------------------------------------------------------------------------
/*
title: FNORDITUDE
tags: nosymbol sweet16 tiny

```
code fnorditude   ( cfa pad 'studio -- pad size )
    brk, tos ldd, n2 st,  pull, n5 st,
    pull, n6 st,  acc sub, n4 st,       \ n2=studio n3=sym0 n4=0 n5=pad n6=cfa
    symnew tos set,  tos ldd,  tos st,  \ unsorted symbols
```
*/
fnorditude
    brk
    .byt ldd | TOS
    .byt st  | N2                       ; n2=studio
    .byt pull
    .byt st  | N5                       ; n5=output buffer (pad)
    .byt pull
    .byt st  | N6                       ; n6=cfa copy
    .byt sub | ACC
    .byt st  | N4                       ; n4=current len/strand off
    ; fall through
;------------------------------------------------------------------------------
/*
title: :SOSORTED
tags: nosymbol

```
:sosorted
    'willitblend? bs,
    'sosorted bz,                       \ copy sorted names for len/strand=n4
    n3 ld,  tos cpr,  'fnordout bp,     \ while  n3 < symnew
    tos ld,  n0 st,
    n3 ld, push,  n8 ld, push,          \ TOS is next sorted len/strand
```
*/
sosorted
    .byt bs , <(willitblendq-*-2)
    .byt bz , <(sosorted-*-2)
    .byt ld  | N3
    .byt cpr | TOS
    .byt bp , <(fnordout-*-2)
    .byt ld  | TOS
    .byt st  | N0
    .byt ld  | N3
    .byt push,
    .byt ld  | N8
    .byt push,
;------------------------------------------------------------------------------
/*
title: :SOSCRAMBLED
tags: nosymbol

:soscrambled
    n0 ld,  n3 st,                      \ n3=symnew
:howaboutthis
    'willitblend? bs,
    n3 ldd, :howaboutthis bnz,
    'strand+ ext,
       <n4 tos =
    'soscrambled bnz,
    tos ld, n8 st, pull, n3 st,
    n0 ld, tos st,
    'sosorted br,               \ repeat
:fnordout
    nxt,
```
*/
soscrambled
    .byt ld | N0
    .byt st | N3
howaboutthis
    .byt bs , <(willitblendq-*-2)
    .byt ldd | N3
    .byt bnz , <(howaboutthis-*-2)
    .byt ext
    .word strandplus
    .byt ld | N4
    .byt cpr | TOS
    .byt bnz , <(soscrambled-*-2)
    .byt ld | TOS
    .byt st | N8
    .byt pull,
    .byt st | N3
    .byt ld | N0
    .byt st | TOS
    .byt br ,  <(sosorted-*-2)

fnordout
    .byt nxt
;------------------------------------------------------------------------------
/*
title: (FNORD)
tags: nosymbol secondary

Internals of `forget` and `rehash`

```
: (fnord)   ( cfa -- )
    sym0  pad studio                    ( cfa pad 'studio )
    fnorditude !symtab ;
```
*/
#include "align.i65"
_pfnord
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word _pad
#include "page.i65"
    .word studio
#include "page.i65"
    .word xyzzy
#include "page.i65"
    .word fnorditude
#include "page.i65"
    .word _setsymtab
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: FORGET
tags: secondary dictionary fig forth-79 forth-83

```
: forget   ( "name" ; -- )  '           \ next token from input stream
  dup fence @ u<  7 ?error              \ can't forget below fence
  (fnord) ;
```
*/
#if 0
name=FORGET
tags=fnord
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "parm.i65"
    .word qerror
    .byt 7                      ; CAN'T FORGET BELOW FENCE
#include "pad.i65"
    .word _pfnord
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: DEFINITIONS
tags: forth-83

Set `current` vocabulary for `create`

```
code definitions   ( -- )
  vocabs 1+ lda,  current sta,
  next jmp,
```
*/
#if 0
name=DEFINITIONS
tags=fnord
#endif
definitions
    lda uservocabs+1
    sta usercurrent
    jmp next
;------------------------------------------------------------------------------
/*
title: REHASH
tags: secondary pettil dictionary

Sort/merge a fresh dictionary

```
: rehash   ( -- )
  here (fnord) ;
```
*/
#if 0
name=REHASH
tags=fnord
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _pfnord
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: FORTH
tags: vocabulary forth-83

Search only the main forth vocabulary

```
#voc on  vocabulary forth
```
~~~code golf~~~
[-7 bytes] chitselb 2020-05-11
*/
#if 0
name=FORTH
tags=fnord
#endif
#include "align.i65"
_forth
    jsr dovocab
    .byt 0                              ; vocabulary identifier
