;------------------------------------------------------------------------------
/*
title: pettil-dictionary.a65
tags: source nosymbol

```
SYMTAB!     SYM0        SYM.LEN     SYM.STRANDS
SYM.COPY    (!SYMTAB)   !SYMTAB     STRAND
IMMEDORNOT  (FOUND?)    FOUND?      STRAND+
(FNORD)     >STRAND     NEXTVOCAB?  :WILLITBLEND?
FNORDITUDE  :SOSORTED   :SOSCRAMBLED

>NAME       EXISTS?     '           FORGET
DEFINITIONS REHASH      FORTH

 SYMBOL
+---------------+
|   CFA[low]    | <-- LFA      Link Field Address
+---------------+              (2 bytes)
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]     %smudge | <-- NFA      Name Field Address
| [I]   %immed  |              (1 byte)
|   [V] %vocab  |
|     [  length ]
+-+-+-+-+-+-+-+-+
|   name[1]     |     NFA+1    text of the name
|               |              (`length` bytes)
|      .        |
|               |
|      .        |
|               |
|      .        |
|   name[len]   |
?---?---?---?---?
?   vocabid     ?     NFA+length+1
?---?---?---?---?         01 = assembler; 02 = editor; 03 = user's first vocab
                               (1 byte, present iff %vocab is true)

symbol
    lfa     contains the
    cfa     points to 6502 code
 %smudge    is smudged
 %vocab     has vocabid
 %immed     is immediate
 length     1..31, 0 = end of list
vocabid     present if %vocab is true, 0 = is label
```
*/
;------------------------------------------------------------------------------
/*
title: SYMTAB!
tags: nosymbol

code symtab!   ( -- )
*/
symtabset
    lda stackh+1,x
    clc
    sbc tos+1
    dex
    sta stackh,x
    sta usersymtab+1
    lda #32
    sta stackl,x
symtabset99
    jmp next
;------------------------------------------------------------------------------
/*
title: SYM0
tags: nosymbol

```
code sym0   ( -- )
  symtab 1+ lda,  n3 1+ sta,
  #34  # lda,  n3 sta,
  'symtabset99 bne,  \ next
```
*/
sym0
    lda usersymtab+1
    sta R0L+2*N3+1
    lda #34
    sta R0L+2*N3
    bne symtabset99                     ; bra next
;------------------------------------------------------------------------------
/*
title: SYM.LEN
tags: primitive nosymbol

Calculate length of a name

|^N3  |^ |^length |
|^N8l |^ |^length |
|^N8h |^ |^`(seek)` toggle sorted/unsorted |
|^C  |^ |^%vocab |

```
code sym.len   ( ; n3=nfa -- len ; n8l=len )
  'pushya 1- csplit
  # lda, pha,  # lda, pha,
:sym.lens
  0 # ldy,  n3 )y lda,  n2 sta,
  'sym+ bit, \ check the $20 bit %vocab
  clc,  0= not if,  sec,  then,
  $1f # lda,  n2 bit, \ %smudge %immed
  php,  n2 and,  plp,
  n8 sta,  rts,
```
*/
symlen
    lda #>(pushya-1)
    pha
    lda #<(pushya-1)
    pha
symlens
    ldy #0
    lda (R0L+2*N3),y
    sta R0L+2*N2
    bit symplus                 ; any Tubman will do
    clc
    beq symlens99
    sec                         ; C %vocab $20
symlens99
    lda #$1F
    bit R0L+2*N2                ; N %smudge $80  V %immed $40
    php
    and R0L+2*N2
    plp
    sta R0L+2*N8
    rts
;------------------------------------------------------------------------------
/*
title: SYM.COPY
tags: nosymbol subroutine

symcopy
    jsr symzzens
    adc #0
    tay
symcopy01
    lda (R0L+2*N3),y
    sta (R0L+2*N7),y        ; ~~ change to TOS
    dey
    bpl symcopy01
    rts

*/
;------------------------------------------------------------------------------
/* SYM+
tags: nosymbol subroutine

|Z  |    |0    |
|N3 |nfa |nfa+ |

*/
symplus
    jsr symlens                         ; this $20 opcode is used by `symlens`
    adc #3
    adc R0L+2*N3
    sta R0L+2*N3
    bcc symplus01
    inc R0L+2*N3+1
symplus01
    rts                                 ; Z flag is always nonzero
;------------------------------------------------------------------------------
/*
title: (!SYMTAB)
tags: nosymbol

*/
psamtab
    brk
    .byt ld | N3
    .byt std | TOS              ; set `symnew`
    .byt popd | N3              ; 2-
    .byt ld | N3
    .byt std | TOS              ; set `symtail`
    .byt sub | ACC
    .byt std | N3               ; force cfa = 0
    .byt nxt
;------------------------------------------------------------------------------
/*
title: !SYMTAB
tags: nosymbol secondary

```
: !symtab   ( start end -- size addr )
    bloom 8 erase sym0 symtab @ bl
    begin
        sym.len >  if  <n3 !+ then
        bloomfilter cbit!
        sym.len  call sym+  sym.len 0=
    until (!symtab) 3drop ;
```
*/
#include "align.i65"
_setsymtab
    jsr enter
#include "page.i65"
    .word bloom
#include "page.i65"
    .word eight
#include "page.i65"
    .word erase                 ; reset the Bloom filter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "page.i65"
samtab01
    .word symlen
#include "page.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(samtab02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word _storeplus
#include "page.i65"
samtab02
    .word _bloomfilter
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symlen
#include "parm.i65"
    .word callz                         ; ~todo tidy up here
    .word symplus
#include "pad.i65"
    .word symlen
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qbranch
    .byt <(samtab01-*+1)
#include "pad.i65"
    .word symnew
#include "page.i65"
    .word psamtab               ; handle `symtab` tail
#include "page.i65"
    .word threedrop
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* BLOOM#
tags: nosymbol

stack=( -- n )

The Bloom filter tries to answer the question, 'is this word a number?'

The string under consideration is pointed to by (N3) with a length of N8.

Generate a hash of a string, in the range 0..63, used as an index into the
sparsely populated `bloom` 8-byte bitfield.

A `true` bloom filter bit means, this word might be in the dictionary
A `false` bit means, this word is not present

`create` turns on the `bloom` bit for each new name
`forget` completely rebuilds the `bloom` filter

|reg |entry |exit |h
|^stack |^( nfa -- bloom# )|<|
|^N3 |^ |^nfa |
|^N8l |^ |^length |
|^N8h |^ |^0 |

code bloom#   ( nfa -- bloom# )

*/
bloomhash
    ldy R0L+2*N8                        ; length
    lda #0
    sta z
bloomhash01
    lda (R0L+2*N3),y
    eor #$30
    cmp #9
    bcs bloomhash02
    adc z
    sta z
bloomhash02
    dey
    bne bloomhash01
    lda z
    and #$3F                            ; width of the filter is 64 bits
    jmp pushya
;------------------------------------------------------------------------------
/* BLOOMFILTER
tags: nosymbol

stack=( -- mask addr )
*/
#include "align.i65"
_bloomfilter
    jsr enter
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word bloom
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: UNSMUDGE
tags: primitive

stack=( nfa -- )
*/
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
/*
title: SMUDGE
tags: primitive forth-79

stack=( nfa -- )
*/
smudge
    sec
    ;
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop
;------------------------------------------------------------------------------
/*
title: (>NAME)
tags: nosymbol

stack=( cfa -- nfa|0 )
*/
ptoname
    ldy #$FE
ptoname02
    dec R0L+2*N3+1
    lda (R0L+2*N3),y
    inc R0L+2*N3+1
    eor tos-$FE,y
    bne ptoname05
    iny
    bne ptoname02
    lda R0L+2*N3
    ldy R0L+2*N3+1
ptoname04
    jmp put
ptoname05
    ldy #0
    lda (R0L+2*N3),y
    beq ptoname04
    jsr symplus                 ; next!
    bne ptoname                 ; bra
;------------------------------------------------------------------------------
/*
title: >NAME
tags: forth-83

* search the dictionary for a given `cfa` and
* return the `nfa` if found, else `0`
* honors the smudge bit

```
: >name   ( cfa -- nfa|0 )
    sym0
    begin
        name> over <>
        sym.len and
    while
        3 sym+
    repeat
    name> nip ;
```
*/
#if 0
name=>NAME
tags=interpreter

#endif
#include "align.i65"
_toname
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word ptoname
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: (SEEK)
tags: nosymbol

|^stack |^( nfa.seek -- xfa flag )|<|h
|^N2 |^                 |^flags,len,og  |
|^N3 |^sym0             |^nfa.result    |
|^N4 |^seek.length      |^ .            |
|^N5 |^                 |^vocabid       |
|^N6 |^                 |^vocabs        |
|^N7 |^nfa.strand[0]    |^ .            |
|^N8L|^                 |^result.length |
|^N8H|^                 |^toggle sorted/unsorted |
|reg |entry             |exit           |f

code  (seek)   ( nfa -- xfa flag )
  r14 1+ asl,  n8 1+ inc,
  '(seek100) bne,
:(seek10)
  n8 1+ lda,  lsr,  '(seek20) bcc,
  '(seek86) bne,  iny,
:(seek200)
  dey,  '(seek42) beq,  tos )y lda,
  n3 )y eor,  '(seek200) beq,
:(seek20)
  'sym+ jsr,
:(seek100)
  'sym.lens jsr,  '(seek86) beq,
  n2 bit,  '(seek10) bmi,  tay,
  '(seek10) bvc,
  n5 lda,  '(seek10) beq,
  iny,  iny,  '(seek10) bne,
:(seek42)
  r14 1+ inc,
:(seek86)
  rts,  end-code
*/
pseek
    asl R0L+2*R14+1                     ; presume not found
    inc R0L+2*N8+1                      ; toggle sorted/unsorted flag
    bne pseek100                        ; bra, do first symbol
pseek10                                 ; "next symbol"
    lda R0L+2*N8+1                      ; sorted vs unsorted bit
    lsr                                 ; 0 = unsorted; 1 = sorted
    bcs pseek20                         ; unsorted? next sym+
    lda R0L+2*N8                        ; list is sorted; get nfa.length
    cmp R0L+2*N4                        ;                 vs seek.length
    bcc pseek20                         ; are we there yet? next sym+
    bne pseek86                         ; we passed the length
    iny
pseek200
    dey
    beq pseek42
    lda (tos),y                         ; check next char
    eor (R0L+2*N3),y                    ; vocabid
    beq pseek200
                                        ; length is a match, so string compare
                                        ;        len > seek len      C set
                                        ;        len = seek len      C set
                                        ;        len < seek len      C clear
pseek20
    jsr symplus                         ; move to the next symbol
pseek100
    jsr symlens
    beq pseek86                         ; exit if we reach symtail
    bit R0L+2*N2                        ; N=smudge; V=vocab from symlen.og copy
    bmi pseek10                         ; %smudged? next!
    tay                                 ; length 1..31; Z=false; N=false
    bvc pseek10                         ; !(%vocab)?  "is core"
    ; expect C to be set here also, mirroring V
    lda R0L+2*N5                        ; seek vocabid
    beq pseek10                         ; if this word is in core, ignore. next!
    iny
    iny
    bne pseek10                         ; bra
pseek42
    inc R0L+2*R14+1                     ; goteem!
pseek86
    rts
;------------------------------------------------------------------------------
/*
title: IMMEDORNOT
tags: nosymbol

Return +1 if the immediate bit is set on current `nfa`, otherwise returns -1

code immedornot   ( true -- -1|+1 )

*/
immedornot
    ldy #0
    lda (R0L+2*N3),y            ; length/flags of curr `nfa`
    and #$20                    ; immediate?
    lsr
    lsr
    lsr
    lsr                         ; divide by 16, $02 when immediate
    jmp nplus                   ; add 0 or 2 to tos
;------------------------------------------------------------------------------
/*
title: (FOUND?)
tags: nosymbol


~ use N4 to hold either:
~    length.seek (as set by >strand )
~    length.32 (to prevent ever reaching it)

calculate n7=strand
for each vocabulary
    n3=symnew+2
    check unsorted (symnew...)
    n3=n7
    check sorted (>strand...)


```
code (found?)   ( nfa -- xfa flag )
    brk,  vocabs 1+ n6 set,             \ first vocab
:found1
    n6 ldd@,  n5 st,                    \ get vocabid
:found2
    symnew n3 set,  n3 ldd@,
    n3 st,  n3 ldd@,  '(seek) ext,
    '>strand ext,  '(seek) ext,
```


#include "parm.i65"
    .word tozp
    .byt R0L+2*N3
#include "pad.i65"
    .word symlen
#include "page.i65"
    .word drop



code >strand   ( nfa -- nfa ; n3=strand )
  'symlens jsr,  n4 sta,  iny,
  tos )y lda,  $0f # and,  asl,  n7 sta,
  symtab 1+ lda,  n7 1+ sta,
  rts,  end-code

code (found?)   ( nfa -- xfa flag )
    brk,  vocabs 1+ n6 set,             \ first vocab
:pfoundq01
    n6 ldd@, n5 st,                     \ get vocabid
    symnew tos set,
    (seek) ext,                         \ check unsorted
    >strand tos set,
    (seek) ext,                         \ check sorted
    n6 ld@, 'pfoundq01 bnz,
    nxt,
```
code found00
    'symlens jsr,  n4 sta,  iny,
    n3 )y lda,  $0F # and,  asl,
    n7 sta,  symtab 1+ lda,  n7 1+ sta,
    next jmp,  end-code

    n3 !  callz symlen
*/
pfoundq
    brk
    .byt set | N6
    .word uservocabs+1                  ; first vocab
pfoundq01
    .byt ldd | N6
    .byt st  | N5                       ; get vocabid
    .byt set | N3
    .word usersymnew
    .byt ldd | N3
    .byt st  | N3
    .byt ext
    .word pseek
    .byt bc  , <(pfound99-*-2)          ; early exit if it was found
    .byt ld  | N7                       ; let's have a look at the sorted list then
    .byt st  | N3
    .byt ext                            ; if we're still here, we haven't exited
    .word pseek                         ; search sorted until 0= or len>seeklen(n4)
    .byt bc  , <(pfound99-*-2)
    .byt ld  | N5                       ; get vocabid
    .byt bnz  , <(pfoundq01-*-2)        ; until last vocab
    .byt rtn
    jmp false
pfound99
    .byt popd | N3                       ; tell 'em what happened
    .byt st   | TOS
    .byt rtn
    lda #$20
    bit R0L+2*N2
    beq pfoundnormal
    jmp one
pfoundnormal
    jmp minusone
;------------------------------------------------------------------------------
/*
title: FOUND?
tags: nosymbol secondary

Search the dictionary for a name

| flag | meaning | 2os |h
| -1 | found | cfa |
|  0 | not found | nfa |
| +1 | immediate word | cfa |

```
: found?   ( nfa -- xfa flag )
  >n3 found00                           ( nfa ; n3=nfa n4=n8=seek.length )
  bloomfilter cbit@                     ( nfa flag )
  ?: (found?) false ;
```
*/
#include "align.i65"
_foundq
    jsr enter
#include "parm.i65"
    .word tozp
    .byt R0L+2*N3
#include "page.i65"
    .word found00
#include "page.i65"
    .word _bloomfilter          ; in sought name, sum of digits ['0-9'+1] modulo 64
#include "page.i65"             ; e.g. `dup` = 0, and `3.1459` = 27
    .word cbitfetch
#include "parm.i65"
    .word pquerycolon
    .word pfoundq
    .word false
#include "past.i65"
    .word exit
found00
    jsr symlens
    sty R0L+2*N8+1                      ; reset the sorted/unsorted toggle
    iny
    lda (R0L+2*N3),y                    ; 1st character of name
    and #$0F                            ; low 4-bits only
    asl                                 ; *2
    sta R0L+2*N7                        ; sym0 (sorted)
    lda usersymtab+1
    sta R0L+2*N7+1
    brk
    .byt ldd | N7
    .byt st  | N7                       ; j'adoube
    .byt ld  | N8                       ; seek.length
    .byt st  | N4                       ; N4H = even/odd sorted/unsorted flag
    .byt nxt
;------------------------------------------------------------------------------
/*
title: EXISTS?
tags: secondary vocabulary

search the dictionary for a name
bill had a billboard he also had a board bill the board bill bored bill so bill sold
the billboard to pay the board bill so the board bill no longer bored bill

```
: exists?   ( "name" ; -- cfa|0 )
  bl name ?dup  ?: found? false  and ;
```
*/
#if 0
name=EXISTS?
tags=vocabulary

#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word pquerycolon
    .word _foundq
    .word false
#include "pad.i65"
    .word andx
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: `'`
tags: forth-83

stack=( -- cfa )
*/
#if 0
name='
tags=forth-83

#endif
#include "align.i65"
_tick
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qerror
    .byt 3                      ; NOT FOUND
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: (CREATE)
tags: nosymbol

stack=( cfa -- )
Create a new symbol in the symbol table


|^ |^pass |^exit |h
|^redefined |^ |^ |
|^redefined |^ |^here ~+3 |
|^dp        |^ |^enclose `JSR cfa`<br/>page crossing<br/>dp += 2 |
|^symtail   |^points to `0` |^enclose `dp` +3 ~ -3<br/>set `flags/length` byte<br/>append `vocabid` if needed<br/>`cmove`  symbol name |

* check for "MISSING NAME"
* look up the name
* found?
** ( NFA ) redefined !
** "[RVS] " nfa $. "[OFF] EXISTS"
* bloom  symtail+2 current  rot
* ?align cfa,  here 3-  newest
** enclose nop byte, if needed
** enclose jsr cfa,
** 3 dp +!
** set newest to jsr opcode's address

|tos|^          |^ |^ |
|n0 |^symtail   |^ |^ |
|n1 |^          |^ |^ |
|n2 |^cfa       |^ |^ |
|n3 |^symtail   |^ |^ |

* create00
code create00
  brk,  harvests6 ext,  n0 popd@,
  n3 st,  n2 ld,  n3 std@,  n3 ld,
  tos std@,  n7 ld ,  n3 st,  tos popd@,
  tos st,  symcopy ext,  n1 ld@,
  'create01 bz,  $40 acc set,
:create01
  tos st,  n7 inr,  n7 pop,  n5 st,
  tos add,  n7 st@,  n7 ld,  n5 add,
  n7 st,  n1 pop, 'create02 bz,
  n7 st@,
:create02
  n7 ld,  n0 std@,  acc sub,  n7 st@,
  n7 std@,  pull,  rtn,  exit jmp,

|^N2 |^                 |^flags,len,og  |
|^N4 |^seek.length      |^ .            |
|^N5 |^                 |^vocabid       |
|^N6 |^                 |^vocabs        |
|^N7 |^nfa.strand[0]    |^ .            |
|^N8L|^                 |^result.length |
|^N8H|^                 |^toggle sorted/unsorted |

|^stack |^( cfa -- )|<|h
|^N0 |^                 |^              |
|^N1 |^                 |^              |
|^N2 |^                 |^nfa.flags.length |
|^N3 |^ .               |^nfa.result    |
|^N4 |^ .               |^seek.length |
|^N5 |^ .               |^              |
|^N6 |^ .               |^              |
|^N7 |^ .               |^              |
|^N8 |^                 |^nfa.length    |
|^N9 |^                 |^              |
|^redefined |^          |^true iff name already existed |
|reg |entry             |exit           |f



*/
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qerror
    .byt 4                      ; MISSING NAME
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word off
#include "page.i65"
    .word _existsq
#include "parm.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "parm.i65"
    .word zpfrom                        ; ~~ code path appears broken
    .byt R0L+2*N3
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word store
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N7                       ; ~~ eschew n7
#include "pad.i65"
    .word dotrvs
#include "page.i65"
    .word _stringdot
#include "parm.i65"
    .word _pdq
    .byt <(pcreate01-*-1)
    .asc RVSOFF," EXISTS"
pcreate01
#include "pad.i65"
pcreate02
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word create00                      ; ( from to howmany )
#include "page.i65"
    .word cmove                         ; drop the text into place
#include "past.i65"
    .word exit

/*
>C:0000  00 00 a5 1a  7e 07 b6 05  05 17 11 62  04 00 00 00
>C:0010  b7 06 4d 61  05 02 a5 04  00 01 0d d0  04 34 45 6b
>C:0040  aa aa aa 08  88 6c 1e 90  7e 09 08 00  80 01 02 01
>C:0070  bb bb bb 00  06 06 00 06  06 00 00 00  00 00 00 10
>C:0080  00 00 00 00  74 06 e6 8b  e6 8b 6c 3b  6b 00 02 90

>C:01e0  00 ed cd 4c  31 9f 30 6e  57 03 00 ef  2e 00 05 68
>C:01f0  06 1a 2f a5  31 43 6b 7c  6d 19 6c 3b  6c 5c 6c 06

>C:0660  01 88 84 1f  85 1e 20 c5  04 4c 66 06  0a 00 5c 17
>C:0670  00 00 00 00  31 00 fe 01  00 00 78 d4  00 00 32 66
>C:0680  f5 6b a8 1a  a5 1a 00 55  0a 00 5c 17  00 00 00 00
>C:0690  fe 50 00 00  00 00 ff ff  00 00 0c 00  0b 00 01 00
>C:06a0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 65
>C:06b0  a6 7b 02 00  09 00 00 00  00 00 00 00  00 00 00 00
>C:06c0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 d1 62
>C:06d0  cf 62 ff 80  00 00 00 00  00 00 cc cc  cc cc cc cc
>C:06e0  01 a0 0a 2c  a0 08 2c a0  06 2c a0 04  2c a0 02 b5

>C:1a80  a9 39 48 4c  86 00 4e e0  06 ee e0 06  b0 16 20 43
>C:1a90  1a 86 ff a2  8d b5 ff bc  0f 04 94 ff  9d 0f 04 ca
>C:1aa0  d0 f3 a6 ff  60 20 d4 0d  02 de 65 02  c0 de 65 02

>C:6280  4d 4f 44 81  09 04 3f 44  55 50 93 18  04 3f 4b 45
>C:6290  59 3f 09 04  4f 56 45 52  3d 76 24 4f  52 41 2c 01
>C:62a0  7e 10 05 3f  45 58 49 54  3a 0e 06 3f  50 41 55 53
>C:62b0  45 99 10 06  3f 53 54 41  43 4b 8a 70  46 3f 4c 45
>C:62c0  41 56 45 3b  0a 09 3f 54  45 52 4d 49  4e 41 4c 00
>C:62d0  00 00 aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa

>C:0200  43 52 45 41  54 45 04 4e  4f 4f 42 42  2d 56 2e 30   CREATEdNOOBB-V.0

.C:064c  8A          TXA            - A:2F X:2F Y:01 SP:ee ..-B.... 4156707450
*/
create00
    brk
    .byt ext
    .word plugh
    .byt ld   | N0
    .byt popd | N0               ; symtail @
    .byt st | N3
    .byt ld | N2                ; cfa'
    .byt std | N3               ; write CFA to symtab
    .byt ld | N3
    .byt std | TOS              ; populate `newest`
    .byt ld | N7
    .byt st | N3
    .byt popd | TOS
    .byt st | TOS
;    .byt ext
;    .word symcopy               ; copy the symbol/length
    .byt ldi | N1
    .byt bz , <(ppcreate01-*-2)
    .byt set | ACC
    .word $40
ppcreate01
    .byt st | TOS               ; TOS = $00 or $40 if vocab
    .byt inr | N7
    .byt pop | N7
    .byt st | N5
    .byt add | TOS
    .byt sti | N7                       ; symbol length with a proper vocab bit
    .byt ld | N7
    .byt add | N5
    .byt st | N7
    .byt pop | N1
    .byt bz , <(ppcreate02-*-2)
    .byt sti | N7
ppcreate02
    .byt ld | N7
    .byt std | N0                       ; update symtail
    .byt sub | ACC
    .byt sti | N7
    .byt std | N7
    .byt pull
    .byt nxt

    .word bloom                         ; aka `symtail` +2
#include "page.i65"
    .word current
#include "page.i65"
    .word rot
#include "page.i65"

;------------------------------------------------------------------------------
/*
title: STRAND+
tags: nosymbol

increment the length byte (N4l) until it
reaches 32, then increment strand (N4h)

code strand+   ( -- )
  n4 inc,  32 # lda,  n4 eor,
  0<> if,  n4 sta,  n4 1+ inc,  then,
  rts,
*/
strandplus
    inc R0L+2*N4
    lda #32
    eor R0L+2*N4
    bne straplu01
    sta R0L+2*N4
    inc R0L+2*N4+1
straplu01
    rts

;------------------------------------------------------------------------------
/*
title: :WILLITBLEND?
tags: nosymbol sweet16

Evaluate (and maybe retain) a name
|tos|symnew             |symnew             |
|n0 |cfa(n3)            |cfa(n3)            |
|n2 |studio             |studio             |
|n3 |nfa                |nfa+               |
|n4 |                   |stepper len/strand |
|n5 |                   |output to pad      |
|n6 |                   |cutoff             |

:willitblend?
    'sym.strand ext,
    n4 ld,  n8 cpr,  'wiblend02 bnz,    \ len/strand must match exactly
    n3 ld,  n0 st,
    n0 popd,  n6 cpr,  'wiblend01 bp,   \ and cfa must be in bounds
    n2 cpr,  'wiblend02 bp,
:wiblend01
    'sym.copy ext,
:wiblend02
    'sym+ ext,  rs,
*/
willitblendq
    .byt ext
    .byt ld  | N4
    .byt cpr | N8                       ; shall I compare n4 to a summer's day?
    .byt bnz , <(wiblend02-*-2)         ; move over to unsorted list if they differ
    .byt popd | N3
    .byt ldd  | N3                      ; get cfa without disturbing n3
    .byt cpr | N2                       ; compare to studio
    .byt bp , <(wiblend01-*-2)
    .byt cpr | N6                       ; compare to cfa
    .byt bp , <(wiblend02-*-2)
wiblend01
;    .byt ext
;    .word symcopy
wiblend02
    .byt ext
    .word symplus
    .byt rs

;------------------------------------------------------------------------------
/*
title: (FNORD)
tags: nosymbol sweet16 tiny

```
code fnorditude   ( cfa pad 'studio -- pad size )
    brk, tos ldd, n2 st,  pull, n5 st,
    pull, n6 st,  acc sub, n4 st,       \ n2=studio n3=sym0 n4=0 n5=pad n6=cfa
    symnew tos set,  tos ldd,  tos st,  \ unsorted symbols
```
*/
pfnord
    brk
    .byt ldd | TOS
    .byt st  | N2                       ; n2=studio
    .byt pull
    .byt st  | N5                       ; n5=output buffer (pad)
    .byt pull
    .byt st  | N6                       ; n6=cfa copy
    .byt sub | ACC
    .byt st  | N4                       ; n4=current len/strand off
    ; fall through
;------------------------------------------------------------------------------
/*
title: :SOSORTED
tags: nosymbol

```
:sosorted
    'willitblend? bs, 'sosorted bz,     \ copy sorted names for len/strand=n4
    n3 ld,  tos cpr,  'fnordout bp,     \ while  n3 < symnew
    tos ld,  n0 st,
    n3 ld, push,  n8 ld, push,          \ TOS is next sorted len/strand
```
*/
sosorted
    .byt bs , <(willitblendq-*-2)
    .byt bz , <(sosorted-*-2)
    .byt ld  | N3
    .byt cpr | TOS
    .byt bp , <(fnordout-*-2)
    .byt ld  | TOS
    .byt st  | N0
    .byt ld  | N3
    .byt push,
    .byt ld  | N8
    .byt push,
    ; fall through
;------------------------------------------------------------------------------
/*
title: :SOSCRAMBLED
tags: nosymbol

:soscrambled
    n0 ld,  n3 st,                      \ n3=symnew
:howaboutthis
    'willitblend? bs,
    n3 ldd, :howaboutthis bnz,
    'strand+ ext,
       <n4 tos =
    'soscrambled bnz,
    tos ld, n8 st, pull, n3 st,
    n0 ld, tos st,
    'sosorted br,               \ repeat
:fnordout
    nxt,
```
*/
soscrambled
    .byt ld | N0
    .byt st | N3
howaboutthis
    .byt bs , <(willitblendq-*-2)
    .byt ldd | N3
    .byt bnz , <(howaboutthis-*-2)
    .byt ext
    .word strandplus
    .byt ld | N4
    .byt cpr | TOS
    .byt bnz , <(soscrambled-*-2)
    .byt ld | TOS
    .byt st | N8
    .byt pull,
    .byt st | N3
    .byt ld | N0
    .byt st | TOS
    .byt br ,  <(sosorted-*-2)
fnordout
    .byt nxt
;------------------------------------------------------------------------------
/*
title: FNORD
tags: nosymbol secondary

code strand.len+
    lda n4
    and #31
    bne +
    sta n4
    inc n4+1
    lda n4+1
    and #15
    beq seeyabye
seeyabye
    rts
+
end-code

```
: fnord   ( cfa -- )
    sym0  pad studio                    ( cfa pad 'studio )
    fnorditude !symtab ;
```
*/
#include "align.i65"
_fnord
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word _pad
#include "page.i65"
    .word studio
#include "page.i65"                     ; ~goto symtab! to end (fnord)
    .word pfnord
#include "page.i65"
    .word _setsymtab
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: FORGET
tags: secondary dictionary fig forth-79 forth-83

```
: forget   ( "name" ; -- )  '           \ next token from input stream
  dup fence @ u<  7 ?error              \ can't forget below fence
  (fnord) ;
```
*/
#if 0
name=FORGET
tags=fnord
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word under
#include "page.i65"
    .word ult
#include "parm.i65"
    .word qerror
    .byt 7                      ; CAN'T FORGET BELOW FENCE
#include "pad.i65"
    .word _fnord
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: DEFINITIONS
tags: forth-83

Set `current` vocabulary for `create`

```
code definitions   ( -- )
  vocabs 1+ lda,  current sta,
  next jmp,
```
*/
#if 0
name=DEFINITIONS
tags=fnord
#endif
definitions
    lda uservocabs+1
    sta usercurrent
    jmp next
;------------------------------------------------------------------------------
/*
title: REHASH
tags: secondary pettil dictionary

Sort/merge a fresh dictionary

```
: rehash   ( -- )
  here (fnord) ;
```
*/
#if 0
name=REHASH
tags=fnord
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _fnord
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: FORTH
tags: vocabulary forth-83

Search only the main forth vocabulary

```
\ must be first vocabulary defined
#voc on  vocabulary forth
```
~~~code golf~~~
[-7 bytes] chitselb 2020-05-11
*/
#if 0
name=FORTH
tags=fnord
#endif
#include "align.i65"
_forth
    jsr dovocab
    .byt 0                              ; vocabulary identifier
