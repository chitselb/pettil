;------------------------------------------------------------------------------
/*
title: pettil-dictionary.a65
tags: source nosymbol

|^N3 |^nfa |^|
|^N4L |^seek.length |^|
|^N4H |^strand |^|
|^N5 |^vocabid |^|
|^N6 |^vocabs |^|
|^N7 |^seek nfa |^ ???? ~probably mean TOS~ |
|^N8L |^nfa.length |^|
|^N8H |^strand |^|

    SYMTAB!
    SYM0
    SYM.LEN
    SYM.STRANDS
    SYM.COPY
    (!SYMTAB)
    !SYMTAB
    STRAND
    IMMEDORNOT
    (FOUND?)
    FOUND?
    STRAND+
    (FNORD)
                title: >THREAD
                title: NEXTVOCAB?
                title: :WILLITBLEND?
                title: FNORDITUDE
                title: :SOSORTED
                title: :SOSCRAMBLED
>NAME
EXISTS?
'
FORGET
DEFINITIONS
REHASH
FORTH


```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
*/
;------------------------------------------------------------------------------
/*
title: SYMTAB!
tags: nosymbol

code symtab!   90
*/
symtabset
    lda stackh+1,x
    clc
    sbc tos+1
    dex
    sta stackh,x
    sta usersymtab+1
    lda #32
    sta stackl,x
symtabset99
    jmp next
;------------------------------------------------------------------------------
/*
title: SYM0
tags: nosymbol

```
code sym0   ( -- )
  symtab 1+ lda,  n3 1+ sta,
  #34  # lda,  n3 sta,
  'symtabset99 bne,  \ next
```
*/
sym0
    lda usersymtab+1
    sta R0L+2*N3+1
    lda #34
    sta R0L+2*N3
    bne symtabset99                     ; bra next
;------------------------------------------------------------------------------
/*
title: SYM.LEN
tags: primitive nosymbol

Calculate length of a name to N8, C flag

```
code sym.len   ( ; n3=nfa -- len ; n8l=len )
  'pushya 1- csplit
  # lda, pha,  # lda, pha,
:sym.lens
  0 # ldy,  n3 1+ lda,
  0= not if,
    n3 )y lda,
  then,
  pha, asl, asl, pla,
:symlen_s02
  $1F # and,  n8 ,y sta,  rts,
```
*/
symlen
    lda #>(pushya-1)
    pha
    lda #<(pushya-1)
    pha
symlens
    ldy #0              ;{2 {=23}}
    lda R0L+2*N3+1                      ; length = 0 if `n3` is 0
    beq symlen_s01
    lda (R0L+2*N3),y    ;{5}            ; length/flags
symlen_s01
    pha                 ;{3}            ; not using tay/tya preserves Y=0
    asl                 ;{2}
    asl                 ;{2}            ; Vocab bit to C flag
    pla                 ;{4}
symlen_s02
    and #$1F            ;{2}            ; length
    sta R0L+2*N8        ;{3}            ; N8L = visible length (omit vocab +1)
    rts
;------------------------------------------------------------------------------
/*
title: >STRAND
tags: nosymbol

read back
    STRAND   ([1]&$0F)*2 symtab

```
code >strand   ( nfa -- nfa ; n3=strand )
  1 # ldy,  tos )y lda,  $0f # and,  asl,
  symtab 1+ ldy,  n3 1+ sty,  n3 sta,
  rts,  end-code
```
*/
tostrand
    jsr symlens
    sta R0L+2*N4                        ; seek.length
    iny
    lda (tos),y
    and #$0F
    asl
    ldy usersymtab+1
    sty R0L+2*N3+1
    sta R0L+2*N3                        ; sym0 (sorted)
    rts
;------------------------------------------------------------------------------
/*
title: SYM.COPY
tags: nosymbol subroutine

*/
symcopy
    jsr symlens
    adc #0
    tay
symcopy01
    lda (R0L+2*N3),y
    sta (R0L+2*N7),y
    dey
    bpl symcopy01
    rts
;------------------------------------------------------------------------------
/* SYM+
tags: nosymbol subroutine

*/
symplus
    jsr symlens
    adc #3
    adc R0L+2*N3
    sta R0L+2*N3
    bcc symplus01
    inc R0L+2*N3+1
symplus01
    rts
;------------------------------------------------------------------------------
/*
title: (!SYMTAB)
tags: nosymbol

*/
psamtab
    brk
    .byt ld | N3
    .byt std | TOS              ; set `symnew`
    .byt popd | N3              ; 2-
    .byt ld | N3
    .byt std | TOS              ; set `symtail`
    .byt sub | ACC
    .byt std | N3               ; force cfa = 0
    .byt nxt
;------------------------------------------------------------------------------
/*
title: !SYMTAB
tags: nosymbol secondary

```
: !symtab   ( start end -- size addr )
    bloom 8 erase sym0 symtab @ bl
    begin
        sym.len >  if  <n3 !+ then
        bloomfilter cbit!
        sym.len  call sym+  sym.len 0=
    until (!symtab) 3drop ;
```
*/
#include "align.i65"
_setsymtab
    jsr enter
#include "page.i65"
    .word bloom
#include "page.i65"
    .word eight
#include "page.i65"
    .word erase                 ; reset the Bloom filter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "page.i65"
samtab01
    .word symlen
#include "page.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(samtab02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word _storeplus
#include "page.i65"
samtab02
    .word _bloomfilter
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symlen
#include "parm.i65"
    .word callz                         ; ~todo tidy up here
    .word symplus
#include "pad.i65"
    .word symlen
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qbranch
    .byt <(samtab01-*+1)
#include "pad.i65"
    .word symnew
#include "page.i65"
    .word psamtab               ; handle `symtab` tail
#include "page.i65"
    .word threedrop
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* BLOOM#
tags: nosymbol

stack=( -- n )

The Bloom filter tries to answer the question, 'is this word a number?'

The string under consideration is pointed to by (N3) with a length of N8.

Generate a hash of a string, in the range 0..63, used as an index into the
sparsely populated `bloom` 8-byte bitfield.

A `true` bloom filter bit means, this word might be in the dictionary
A `false` bit means, this word is not present

`create` turns on the `bloom` bit for each new name
`forget` completely rebuilds the `bloom` filter
*/
bloomhash
    ldy R0L+2*N8                ; length
    lda #0
    sta z
bloomhash01
    lda (R0L+2*N3),y
    eor #$30
    cmp #9
    bcs bloomhash02
    adc z
    sta z
bloomhash02
    dey
    bne bloomhash01
    lda z
    and #$3F                    ; width of the filter is 64 bits
    jmp pushya
;------------------------------------------------------------------------------
/* BLOOMFILTER
tags: nosymbol

stack=( -- mask addr )
*/
#include "align.i65"
_bloomfilter
    jsr enter
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word bloom
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* UNSMUDGE
tags: nosymbol

stack=( nfa -- )
*/
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
/*  SMUDGE
tags: nosymbol

stack=( nfa -- )
*/
smudge
    sec
    ;
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop
;------------------------------------------------------------------------------
/* (>NAME)
tags: nosymbol

stack=( cfa -- nfa|0 )
*/
ptoname
    ldy #$FE
ptoname02
    dec R0L+2*N3+1
    lda (R0L+2*N3),y
    inc R0L+2*N3+1
    eor tos-$FE,y
    bne ptoname05
    iny
    bne ptoname02
    lda R0L+2*N3
    ldy R0L+2*N3+1
ptoname04
    jmp put
ptoname05
    ldy #0
    lda (R0L+2*N3),y
    beq ptoname04
    jsr symplus                 ; next!
    bne ptoname                 ; bra
;------------------------------------------------------------------------------
#if 0
name=>NAME
tags=interpreter

#endif
#include "align.i65"
_toname
/* >NAME
tags: forth-83

* search the dictionary for a given `cfa` and
* return the `nfa` if found, else `0`
* honors the smudge bit

```
: >name   ( cfa -- nfa|0 )
    sym0
    begin
        name> over <>
        sym.len and
    while
        3 sym+
    repeat
    name> nip ;
```
*/
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word ptoname
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* (SEEK)
tags: nosymbol

    jsr symlens
    beq psee08                 ; reached `symtail`? not found!
    eor R0L+2*N4
    beq pseeok1                ; same length? consider further...
    bit R0L+2*N4+1
    bmi psee01                 ; unsorted list? next!
    lda R0L+2*N8
    cmp R0L+2*N4                ; length.current > length.sought?
    bcs psee08                 ; not found on sorted list!

*   sorted vs unsorted list - use N4h
*

|reg |entry |exit |h
|^tos |^seek nfa |^. |
|^n3 |^nfa |^. |
|^n4l |^seek.length |^. |
|^n4h |^sorted/unsorted |^. |
|^n5 |^vocabid |^. |
|^n6 |^vocabs |^. |
|^n7 |^ |^. |
|^n8 |^length |^. |

                                      nfa    seek  vocabid
                                             length
                   N0    N1     N2    N3     N4    N5
0000  FF 01 FF 01  65 6B B6 05  00 65 D8 64  03 00 00 00
0010  B7 06 20 00  03 00 A5 04  00 01 0D D0  16 83 60 6C
      N6    N7     N8
      vocabs       length


stack=( nfa.seek -- flag )
  n3=sym0 n4=seek.length ; n3=nfa.result

*/
pseek
    jsr plugh
psee00
    jsr symlens
; A=nfa.length
; end of list   A(len)=00?
;   cmp R0L+2*N4
; is A > or < N4?
; cmp n4 vs n8


    beq psee08                 ; reached `symtail`? not found!
    eor R0L+2*N4
    beq pseeok1                ; same length? consider further...
    bit R0L+2*N4+1
    bmi psee01                 ; unsorted list? next!
    lda R0L+2*N8
    cmp R0L+2*N4                ; length.current > length.sought?
    bcs psee08                 ; not found on sorted list!
psee01
    jsr symplus                 ; next!
    bne psee00                  ; bra
pseeok1
    ;ldy #0                     ; thanks, symlen
    lda (R0L+2*N3),y
    bmi psee01                 ; smudged? next!
    ldy R0L+2*N4
    iny
    lda R0L+2*N5                ; compare vocabularies
    bcc psee04b
    .byt $2C
pseeok2
    lda (R0L+2*N7),y            ; `n7` name we are looking for
psee04
    eor (R0L+2*N3),y            ; `n3` current name under consideration
psee04b
    bne psee01                 ; different symbol? next!
psee05
    dey
    bne pseeok2
psee07
    clc                         ; found, false (inverted flag)
    .byt $29                    ; AND imm opcode
psee08
    sec                         ; not found, true
psee09
    ;
    jmp putc
;------------------------------------------------------------------------------
/*
title: IMMEDORNOT
tags: nosymbol

Return +1 if the immediate bit is set on current `nfa`, otherwise returns -1

code immedornot   ( true -- -1|+1 )

*/
immedornot
    ldy #0
    lda (R0L+2*N3),y            ; length/flags of curr `nfa`
    and #$20                    ; immediate?
    lsr
    lsr
    lsr
    lsr                         ; divide by 16, $02 when immediate
    jmp nplus                   ; add 0 or 2 to tos
;------------------------------------------------------------------------------
/*
title: NEXTVOCAB?
tags: nosymbol

Return `true` if there is a next vocabulary

```
code next.vocab?   ( -- flag )  brk,
  n5 ld,  push,  n6 ld@,  n5 st,  nxt,
```
*/
nextvocabq
    brk
    .byt ld | N5
    .byt push
    .byt ldi | N6
    .byt st | N5
    .byt nxt
;------------------------------------------------------------------------------
/*
title: (FOUND?)
tags: nosymbol

```
code (found?)   ( nfa -- xfa flag )
    brk,  vocabs 1+ n6 set,             \ first vocab
:found1
    n6 ldd@,  n5 st,                    \ get vocabid
:found2
    symnew n3 set,  n3 ldd@,
    n3 st,  n3 ldd@,  '(seek) ext,
    '>strand ext,  '(seek) ext,
```
~ use N4 to hold either:
~    length.seek (as set by >strand )
~    length.32 (to prevent ever reaching it)

???
code (found?)   ( nfa -- xfa flag )
    brk,
    vocabs 1+ n6 set,
:flupe1
    n6 ldd@, n5 st,
    symnew tos set,
    tos ldd@,
    tos st,
    tos ldd@,                           \ ( nfa symnew+2 )
    (seek) ext,                         \ check unsorted
    >strand ext,
    (seek) ext,                         \ check unsorted

    >strand tos set,
    (seek) ext,                         \ check sorted
    n6 ld@, 'flupe1 bz,

    ' strands ext,
    n8 ld, n4 st,                       \ copy len/strand

    vocabs 1+ n6 set,
    n6 ldd@,  n5 st,                    \ for each vocab

    symnew (seek)                       \ search unsorted list
    >strand (seek)                      \ search sorted strand

code (seek)   ( nfa addr -- flag )

    .word qbranch               ;     while (branches if found)
    .byt <(foundq03-*+1)
    .word tostrand
    .word pseek
    .word qbranch               ; inverted flag, so branch if found
    .byt <(foundq03-*+1)
    .word nextvocabq
    .word zeq
    .word qbranch               ; loop if more vocabs
    .byt <(foundq01-*+1)
0= until
found04                         ; then
<n7 false ;

foundq03                        ; found it
<n3 name> true immedornot ;
```
: found?   ( nfa -- xfa flag )

foundq
    brk
    .byt ld | TOS
    .byt st | N7                        ; N7 = seek NFA
    .byt set | N6
    .word  uservocabs+1
    .byt ldd | N6
    .byt st  | N5                       ; N5 = current vocabid

```
code (found?)   (  name vocabs -- ) brk,
  n8 ld,  n4 st,  tos ld,  n6 st, \ obsolete code
  n6 inr,  n6 ldi,  n5 st,  pull, \ obsolete code
  n7 st,  n3 st,  pull,  nxt, \ obsolete code

code (found?)   ( nfa -- xfa flag )
    brk,
    vocabs 1+ n6 set,                   \ first vocab
:pfoundq01
    n6 ldd@, n5 st,                     \ get vocabid
    symnew tos set,
    (seek) ext,                         \ check unsorted
    >strand tos set,
    (seek) ext,                         \ check sorted
    n6 ld@, 'pfoundq01 bnz,
    nxt,
```

                        strand*2+symtab = sorted
        ; ~may as well get the start address of seek.sym0 in.... n7?



*/
pfoundq
    brk
    .byt set | N6
    .word uservocabs+1                  ; first vocab
pfoundq01
    .byt ldd | N6
    .byt st  | N5                       ; get vocabid
    .byt set | N3
    .word usersymnew
    .byt ldd | N3
    .byt st  | N3
    .byt ldd | N3                       ; N3=symnew+2  search unsorted until 0= or symtail
;---
    .byt ext
    .word pseek
    .byt ext            ; N3=symtab[strand] first of its kind and shortest in length
    .word tostrand
    .byt ext                            ; if we're still here, we haven't found and exited
    .word pseek                         ; search sorted until 0= or len>seeklen(n4)
;---
    .byt ld  | N5                       ; get vocabid
    .byt bnz  , <(pfoundq01-*-2)        ; until last vocab
    .byt push                           ; nay! denied! Dave's not here man. not found.
    .byt nxt                            ; ( nfa 0 )

;------------------------------------------------------------------------------
/*
title: FOUND?
tags: nosymbol secondary

Search the dictionary for a name

| flag | meaning | 2os |h
| -1 | found | cfa |
|  0 | not found | nfa |
| +1 | immediate word | cfa |

```
: found?   ( nfa -- xfa flag )
  >n3 symlen <n8 n4 !                   ( nfa ; n3=nfa n4=n8=seek.length )
  bloomfilter cbit@                     ( nfa flag )
  ?: (found?) false ;
```
*/
#include "align.i65"
_foundq
    jsr enter
#include "parm.i65"
    .word tozp
    .byt R0L+2*N3
#include "parm.i65"
    .word callz
    .word symstrand
#include "pad.i65"
    .word _bloomfilter          ; in sought name, sum of digits ['0-9'+1] modulo 64
#include "page.i65"             ; e.g. `dup` = 0, and `3.1459` = 27
    .word cbitfetch
#include "parm.i65"
    .word pquerycolon
    .word pfoundq
    .word false
#include "past.i65"
    .word exit

;------------------------------------------------------------------------------
/* EXISTS?
tags: vocabulary

search the dictionary for a name
bill had a billboard he also had a board bill the board bill bored bill so bill sold
the billboard to pay the board bill so the board bill no longer bored bill

```
: exists?   ( "name" ; -- cfa|0 )
  bl name ?dup  ?: found? false  and ;
```
*/
#if 0
name=EXISTS?
tags=vocabulary

#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word pquerycolon
    .word _foundq
    .word false
#include "pad.i65"
    .word andx
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* '
tags: forth-83

stack=( -- cfa )
*/
#if 0
name='
tags=forth-83

#endif
#include "align.i65"
_tick
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qerror
    .byt 3                      ; NOT FOUND
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* (CREATE)
tags: nosymbol

stack=( cfa -- )
Create a new symbol in the symbol table
*/
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qerror
    .byt 4                      ; MISSING NAME
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word off
#include "page.i65"
    .word _existsq
#include "parm.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word store
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N7
#include "pad.i65"
    .word dotrvs
#include "page.i65"
    .word _stringdot
#include "parm.i65"
    .word _pdq
    .byt <(pcreate01-*-1)
    .asc RVSOFF," EXISTS"
pcreate01
#include "pad.i65"
pcreate02
    .word bloom                         ; aka `symtail` +2
#include "page.i65"
    .word current
#include "page.i65"
    .word rot
#include "page.i65"
    .word _qalign
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word newest
#include "past.i65"
    .word *+2
    jsr harvests6
    brk
    .byt popd | N0               ; symtail @
    .byt st | N3
    .byt ld | N2                ; cfa'
    .byt std | N3               ; write CFA to symtab, +2 N5 pointer
    .byt ld | N3
    .byt std | TOS              ; populate `newest`
    .byt ld | N7
    .byt st | N3
    .byt popd | TOS
    .byt st | N7
    .byt ext
    .word symcopy               ; copy the symbol/length
    .byt ldi | N1
    .byt bz , <(ppcreate01-*-2)
    .byt set | ACC
    .word $40
ppcreate01
    .byt st | TOS               ; TOS = $00 or $40 if vocab
    .byt inr | N7
    .byt pop | N7
    .byt st | N5
    .byt add | TOS
    .byt sti | N7                       ; symbol length with a proper vocab bit
    .byt ld | N7
    .byt add | N5
    .byt st | N7
    .byt pop | N1
    .byt bz , <(ppcreate02-*-2)
    .byt sti | N7
ppcreate02
    .byt ld | N7
    .byt std | N0                       ; update symtail
    .byt sub | ACC
    .byt sti | N7
    .byt std | N7
    .byt pull
    .byt rtn
    jmp exit
;------------------------------------------------------------------------------
/*
title: STRAND+
tags: nosymbol

increment the length byte (N4l) until it
reaches 32, then increment thread (N4h)

code strand+   ( -- )
  n4 inc,  32 # lda,  n4 eor,
  0<> if,  n4 sta,  n4 1+ inc,  then,
  rts,
*/
strandplus
    inc R0L+2*N4
    lda #32
    eor R0L+2*N4
    bne straplu01
    sta R0L+2*N4
    inc R0L+2*N4+1
straplu01
    rts

;------------------------------------------------------------------------------
/*
title: :WILLITBLEND?
tags: nosymbol sweet16

Evaluate (and maybe retain) a name
|tos|symnew             |symnew             |
|n0 |cfa(n3)            |cfa(n3)            |
|n2 |studio             |studio             |
|n3 |nfa                |nfa+               |
|n4 |                   |stepper len/strand |
|n5 |                   |output to pad      |
|n6 |                   |cutoff             |

:willitblend?
    'sym.strand ext,
    n4 ld,  n8 cpr,  'wiblend02 bnz,    \ len/strand must match exactly
    n3 ld,  n0 st,
    n0 popd,  n6 cpr,  'wiblend01 bp,   \ and cfa must be in bounds
    n2 cpr,  'wiblend02 bp,
:wiblend01
    'sym.copy ext,
:wiblend02
    'sym+ ext,  rs,
*/
willitblendq
    .byt ext
    .byt ld  | N4
    .byt cpr | N8                       ; shall I compare n4 to a summer's day?
    .byt bnz , <(wiblend02-*-2)         ; move over to unsorted list if they differ
    .byt popd | N3
    .byt ldd  | N3                      ; get cfa without disturbing n3
    .byt cpr | N2                       ; compare to studio
    .byt bp , <(wiblend01-*-2)
    .byt cpr | N6                       ; compare to cfa
    .byt bp , <(wiblend02-*-2)
wiblend01
    .byt ext
    .word symcopy
wiblend02
    .byt ext
    .word symplus
    .byt rs

;------------------------------------------------------------------------------
/*
title: (FNORD)
tags: nosymbol sweet16 tiny

```
code fnorditude   ( cfa pad 'studio -- pad size )
    brk, tos ldd, n2 st,  pull, n5 st,
    pull, n6 st,  acc sub, n4 st,       \ n2=studio n3=sym0 n4=0 n5=pad n6=cfa
    symnew tos set,  tos ldd,  tos st,  \ unsorted symbols
```
*/
pfnord
    brk
    .byt ldd | TOS
    .byt st  | N2                       ; n2=studio
    .byt pull
    .byt st  | N5                       ; n5=output buffer (pad)
    .byt pull
    .byt st  | N6                       ; n6=cfa copy
    .byt sub | ACC
    .byt st  | N4                       ; n4=current len/strand off
    ; fall through
;------------------------------------------------------------------------------
/*
title: :SOSORTED
tags: nosymbol

```
:sosorted
    'willitblend? bs, 'sosorted bz,     \ copy sorted names for len/strand=n4
    n3 ld,  tos cpr,  'fnordout bp,     \ while  n3 < symnew
    tos ld,  n0 st,
    n3 ld, push,  n8 ld, push,          \ TOS is next sorted len/strand
```
*/
sosorted
    .byt bs , <(willitblendq-*-2)
    .byt bz , <(sosorted-*-2)
    .byt ld  | N3
    .byt cpr | TOS
    .byt bp , <(fnordout-*-2)
    .byt ld  | TOS
    .byt st  | N0
    .byt ld  | N3
    .byt push,
    .byt ld  | N8
    .byt push,
    ; fall through
;------------------------------------------------------------------------------
/*
title: :SOSCRAMBLED
tags: nosymbol

:soscrambled
    n0 ld,  n3 st,                      \ n3=symnew
:howaboutthis
    'willitblend? bs,
    n3 ldd, :howaboutthis bnz,
    'strand+ ext,
       <n4 tos =
    'soscrambled bnz,
    tos ld, n8 st, pull, n3 st,
    n0 ld, tos st,
    'sosorted br,               \ repeat
:fnordout
    nxt,
```
*/
soscrambled
    .byt ld | N0
    .byt st | N3
howaboutthis
    .byt bs , <(willitblendq-*-2)
    .byt ldd | N3
    .byt bnz , <(howaboutthis-*-2)
    .byt ext
    .word strandplus
    .byt ld | N4
    .byt cpr | TOS
    .byt bnz , <(soscrambled-*-2)
    .byt ld | TOS
    .byt st | N8
    .byt pull,
    .byt st | N3
    .byt ld | N0
    .byt st | TOS
    .byt br ,  <(sosorted-*-2)

fnordout
    .byt nxt

;------------------------------------------------------------------------------
/*
title: FNORD
tags: nosymbol secondary

code strand.len+
    lda n4
    and #31
    bne +
    sta n4
    inc n4+1
    lda n4+1
    and #15
    beq seeyabye

seeyabye
    rts

+
end-code

Internals of `forget` and `rehash`
    acc sub,
    n4 st,
begin,
    n4 inr,
    ' strand.len+ ext,
    inc n4
    bne +


    n3 = sym0
    n4 = 0
    begin
        n4.len 1+!         \ ratchet up n4 by thread.len
        32 =
        if
            n4.thread 1+!
            16 = ?exit
        then

        n8 = symlen

        n4 = n8?
    while
        n4 = n8?
    while
    repeat
    push n3
    push n8

```
: fnord   ( cfa -- )
    sym0  pad studio                    ( cfa pad 'studio )
    fnorditude !symtab ;
```
*/
#include "align.i65"
_fnord
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word _pad
#include "page.i65"
    .word studio
#include "page.i65"                     ; ~goto symtab! to end (fnord)
    .word pfnord
#include "page.i65"
    .word _setsymtab
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: FORGET
tags: secondary dictionary fig forth-79 forth-83

```
: forget   ( "name" ; -- )  '           \ next token from input stream
  dup fence @ u<  7 ?error              \ can't forget below fence
  (fnord) ;
```
*/
#if 0
name=FORGET
tags=fnord
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word under
#include "page.i65"
    .word ult
#include "parm.i65"
    .word qerror
    .byt 7                      ; CAN'T FORGET BELOW FENCE
#include "pad.i65"
    .word _fnord
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: DEFINITIONS
tags: forth-83

Set `current` vocabulary for `create`

```
code definitions   ( -- )
  vocabs 1+ lda,  current sta,
  next jmp,
```
*/
#if 0
name=DEFINITIONS
tags=fnord
#endif
definitions
    lda uservocabs+1
    sta usercurrent
    jmp next
;------------------------------------------------------------------------------
/*
title: REHASH
tags: secondary pettil dictionary

Sort/merge a fresh dictionary

```
: rehash   ( -- )
  here (fnord) ;
```
*/
#if 0
name=REHASH
tags=fnord
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _fnord
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: FORTH
tags: vocabulary forth-83

Search only the main forth vocabulary

```
\ must be first vocabulary defined
#voc on  vocabulary forth
```
~~~code golf~~~
[-7 bytes] chitselb 2020-05-11
*/
#if 0
name=FORTH
tags=fnord
#endif
#include "align.i65"
_forth
    jsr dovocab
    .byt 0                              ; vocabulary identifier
