; pettil-dictionary.a65
;#echo .       pettil-dictionary.a65     Dictionary

;--------------------------------------------------------------
#if 0
name=SYMTHREAD
stack=( n -- thread )
tags=interpreter,ext,nosymbol
Returns thread address for the given ersatz Pearson hash value

```
: symthread   ( n -- thread )
    dup 0<
    if
        drop
        symnew
    else
        2* symtab @ +
    then ;
```
#endif
#include "align.i65"
symthread
    ldy usersymtab+1
    asl tos
    bcc symthread09
    lda usersymnew
    sta tos
    ldy usersymnew+1
symthread09
    jmp puty

;--------------------------------------------------------------
#if 0
name=SYMLEN
stack=( -- len )
tags=nfa,nosymbol
Return length information about the `nfa`  `n3`

`visible length` means the length of the name when you type it.
The carry flag indicates whether a `vocabid` follows the `name`

C = vocabid?
A,N8L = visible length
Y = 0
#endif
symlen
    lda #>(pushya-1)
    pha
    lda #<(pushya-1)
    pha
;--------------------------------------------------------------
#if 0
name=SYMLENS
effects=A:len;Y:0;C:vocab?;Z:len
tags=subroutine,nfa,nosymbol
6502registers=A:symlen Y:0 C:vocab Z:symlen
Sweet16registers=N3:nfa N8:length
return the length of the current `nfa` stored in `n3`

input
(N3)                            nfa

outputs
N8L, A                          len
Y                               0
C                               vocab?
Z                               last?

#endif
symlens
    ldy #0
    lda (R0L+2*N3),y            ; length/flags
    asl
    asl                         ; Vocab bit to C flag
    lda (R0L+2*N3),y            ; length/flags
    and #$1F                    ; length
    sta R0L+2*N8                ; N8L = visible length (omit vocab +1)
    rts
;{27}

;--------------------------------------------------------------
#if 0
name=SYMCOPYS
stack=( target -- target )
tags=subroutine,nfa,nosymbol

* N3 (curr) symbol to tos (targ) symbol
* copy `name` text
* copy length/flags byte
* copy `vocabid` byte
* does not move N7, does not move N3 either
    ~maybe it should?

#endif
symcopys
    jsr symlens
    adc #0
    tay
symcopy01
    lda (R0L+2*N3),y
    sta (tos),y
    dey
    bpl symcopy01
    rts

;--------------------------------------------------------------
#if 0
name=SYM+S
stack=( -- )
tags=subroutine,ext,primitive,nfa,nosymbol
registers=Z:false
* move N3 to the next symbol
compiled with an inline value following the CFA
to specify a constant per-symbol offset

#endif
sympluss
    jsr symlens                 ; A=len C=vocab
    adc #3
    adc R0L+2*N3
    sta R0L+2*N3
    bcc sympluss01
    inc R0L+2*N3+1
sympluss01
    rts                         ; Z=0 or fail!

;--------------------------------------------------------------
#if 0
name=!SYMTAB
stack=( symtab -- )
tags=ext,nosymbol
runs in the middle of `(forget)` to decide how much to allocate for `symtab`
and possibly move `vmbuf`

* `symtab !`
* `symtab size + dup 3coff dup symtail ! 2+ symnew !
* ?vmmove
* ( to from ) gonorth

#endif
#include "align.i65"
_setsymtab
    jsr enter
#include "page.i65"
    .word symtab
#include "page.i65"
    .word store
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch
#include "parm.i65"
    .word pquerycolon
    .word _plusmove
    .word threedrop
#include "past.i65"
    .word exit

    .word tozp
    .byt R0L+2*N5
#include "pad.i65"
    .word dup
#include "page.i65"
    .word bl                    ; 32
#include "page.i65"
    .word plusunder             ;( 16 0 pad+3 $5920 $5900 )
#include "page.i65"
    .word symtab
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch                 ;( 16 0 pad+3 $5920 $5900 symtab #blk )
#include "parm.i65"
    .word qbranch
    .byt <(automem01-*+1)
#include "pad.i65"
    .word _qvmmove              ; need to move vm buffer before symtab !
#include "page.i65"
automem01
    .word store                 ; set symtab
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NEWSYMTAB
stack=( symtab.end symtab.start -- addr )
tags=ext,nosymbol
Given `studio` and the start/end addresses of `symtab`, return the page where
`symtab` should relocate, to make room for growth.

`cold` will take this return value and allocate an additional two pages of
memory (512 bytes) for `future` growth, but `rehash` is less generous, leaving
only one extra page, plus any leftover space on the last page of `symtab`

#endif
newsymtab
    jsr harvests2
    brk
    .byt ld | N0                ; `symtab.end`
    .byt sub | TOS              ; -`symtab.start`
    .byt st | N0                ; `symtab.size`
    .byt set | N1
    .word userstudio
    .byt ldd | N1               ; `studio`
    .byt sub | N0
    .byt st | TOS               ; symtab'
    .byt rtn
    dec tos+1
    jmp ff00and

;--------------------------------------------------------------
#if 0
name=-@
stack=( nfa -- cfa )
tags=extra
decrement `tos` and fetch the value

#endif
minusfetch
;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

```
: name>   ( nfa -- cfa )
    2- @ ;
```
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=BLOOM#
stack=( -- n )
tags=ext,nosymbol
The Bloom filter tries to answer the question, 'is this word a number?'

The string under consideration is pointed to by (N3) with a length of N8.

Generate a hash of a string, in the range 0..63, used as an index into the
sparsely populated `bloom` 8-byte bitfield.

A `true` bloom filter bit means, this word might be in the dictionary
A `false` bit means, this word is not present

`create` turns on the `bloom` bit for each new name
`forget` completely rebuilds the `bloom` filter

#endif
bloomhash
    ldy R0L+2*N8                ; length
    lda #0
    sta z
bloomhash01
    lda (R0L+2*N3),y
    eor #$30
    cmp #10
    bcs bloomhash02
    sec
    adc z
    sta z
bloomhash02
    dey
    bne bloomhash01
    lda z
    and #$3F                    ; width of the filter is 64 bits
    jmp pushya

;--------------------------------------------------------------
#if 0
name=BLOOMFILTER
stack=( -- mask addr )
tags=nfa,dictionary,nosymbol

Returns a `mask`/`addr` pair suitable for `cbit!` or `cbit@`

```
: bloomfilter   ( -- mask addr )
    bloom# bloom >bit ;
```
#endif
#include "align.i65"
_bloomfilter
    jsr enter
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word bloom
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PEARSON#
stack=( nfa -- pearsonhash nfa )
tags=ext,nfa,nosymbol
tuck the hash value for name field address at N3
`pearson#` is the 4-bit thread index (0..F)

This hash is used to divide the entire symbol table into
16 roughly equal-sized lists called "threads".  The Ruby
script `pearson.rb` is used to generate 8 initial values
from the base dictionary, so if you feel a need to come
up with your own numbers after adding to the common wordlist,
there's the tool.

the Pearson hash should return an evenly distributed
value between $00-$0F based on the values generated from
the core dictionary.  In other words, all 16 threads
are initially balanced with the same number of words,
to reduce searches to (on average) 1/16th of the
dictionary.

```
symbol table entry
+---------------+
|    CFA[low]   |  -2      Code field address
|    CFA[high]  |
+-+-+-+-+-+-+-+-+
|     [   len   ]  NFA     Length field
[S]             |          Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?  vocab id     ?  +len+1  Vocabulary ID (if V bit set)
+---------------+
```

2017-09-20 this is just AND #$0F, not Pearson hash anymore, so vestigial label.
#endif
pearsonhash
    ldy #1
    lda (R0L+2*N3),y    ; [5]
    and #$0F
    jmp push0a

;--------------------------------------------------------------
#if 0
name=UNSMUDGE
stack=( nfa -- )
tags=compiler,nosymbol
Turn off the smudge bit so it can be found by [[FIND]].  In
PETTIL, the smudge bit does double duty, also deactivating any
words that have been [[REDEFINED]].

#endif
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler,nosymbol
Turn on the smudge bit.  Smudged names won't be found by FIND.
In PETTIL, the smudge bit does double duty, also marking as
inactive any names that have been [[REDEFINED]].
#endif
smudge
    sec
    ;
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=(>NAME)
stack=( cfa -- nfa|0 )
tags=compiler,nosymbol

Compare the provided CFA(N4) vs. CFA of current NFA in (N3)

```
: (>name)   ( cfa -- nfa|0 )


ptoname
    ldy #$FE
    dec R0L+2*N3+1
ptoname02
    lda (R0L+2*N3),y
    eor tos-$FE,y
    bne ptoname05
    iny
    bne ptoname02               ; ~todo: blergh!
    inc R0L+2*N3+1
    lda R0L+2*N3
    ldy R0L+2*N3+1
ptoname04
    jmp put
ptoname05
    inc R0L+2*N3+1
    ldy #0
    lda (R0L+2*N3),y
    beq ptoname04
    jsr sympluss                ; next!
    jmp ptoname                 ; bra


```
#endif
#include "align.i65"
ptoname
    ldy #$FE
ptoname02
    dec R0L+2*N3+1
    lda (R0L+2*N3),y
    inc R0L+2*N3+1
    eor tos-$FE,y
    bne ptoname05
    iny
    bne ptoname02               ; ~todo  fix this blerghy code!
    lda R0L+2*N3
    ldy R0L+2*N3+1
ptoname04
    jmp put
ptoname05
    ldy #0
    lda (R0L+2*N3),y
    beq ptoname04
    jsr sympluss                ; next!
    jmp ptoname                 ; bra

;--------------------------------------------------------------
#if 0
name=>NAME
stack=( cfa -- nfa|0 )
tags=compiler
Returns the Name Field Address (`nfa`) of a given word, or 0
if the provided Code Field Address (`cfa`) wasn't found in the
symbol table.  This word honors the smudge bit

Populates `n3` with the current `nfa`

```
: >name   ( cfa -- nfa|0 )
    >syms >n3 drop
    begin
        name> over <>
        sym.len and
    while
        3 sym+
    repeat
    name> nip ;
```
#endif
#include "align.i65"
_toname
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word symthread
#include "parm.i65"
    .word blit
    .byt R0L+2*N3
#include "pad.i65"
    .word store
#include "page.i65"
    .word ptoname
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=IMMEDORNOT
stack=( true -- -1|+1 )
tags=interpreter,forth-83,nosymbol
Returns +1 if the immediate bit is set on current `nfa`
Otherwise returns -1
#endif
immedornot
    ldy #0
    lda (R0L+2*N3),y            ; length/flags of curr `nfa`
    and #$20                    ; immediate?
    lsr
    lsr
    lsr
    lsr                         ; divide by 16, $02 when immediate
    jmp nplus                   ; add 0 or 2 to tos

;--------------------------------------------------------------
#if 0
name=(SEEK)
stack=( nfa -- xfa )
tags=interpreter,primitive,nosymbol
search a segment of the dictionary
                                        n2
search exits when:
end of list
    reach `symtail` (symlen = 0)        false

    found                               -1|1
        also replace nfa with cfa

    not found
    searching sorted list AND mismatched thread.id
                                        false

`tos` seek nfa
`n3` current nfa
`n4l` seek length
`n4h` sorted thread flag:  sorted by size (0) or unsorted ($FF)
`n5` seek vocab
`n6` next vocab address
`n8l` current length

#endif
pseek
    lda R0L+2*N4+1              ; toggle sorted/unsorted flag in `n4h`
    eor #$FF
    sta R0L+2*N4+1              ; sorted = 0; unsorted = $FF
pseek00
    jsr symlens
    beq pseek09           ; reached `symtail`? not found!
    eor R0L+2*N4
    beq pseekok1                ; same length? consider further...
    bit R0L+2*N4+1
    bmi pseek01                 ; unsorted list? next!
    lda R0L+2*N8
    cmp R0L+2*N4                ; length.current > length.seeking?
    bcs pseek09                 ; not found on sorted list!
pseek01
    jsr sympluss                ; next!
    jmp pseek00                 ; bra
pseekok1
    ;ldy #0                     ; thanks, symlens
    lda (R0L+2*N3),y
    bmi pseek01                 ; smudged? next!
zeep
    bit _foundq                 ; has a $20 opcode here
    ldy R0L+2*N4
    iny
    lda R0L+2*N5
    bcs pseek04                 ; compare vocabularies
pseekok2
    dey
    beq pseek07
    lda (tos),y                 ; name we are looking for
pseek04
    eor (R0L+2*N3),y            ; `n3` current name under consideration
pseek04b
    bne pseek01                 ; different symbol? next!
    beq pseekok2

pseek07
    lda (R0L+2*N3),y            ; reget
    bit _toname                 ; any JSR opcode
    bne pseek08
    dey
    sty R0L+2*N2+1
    dey
pseek08
    iny
    sty R0L+2*N2
    brk
    .byt popd | N3              ; get CFA
    .byt st   | TOS
    .byt nxt
pseek09
    jmp next

;--------------------------------------------------------------
#if 0
name=(FOUND?)
stack=( name vocabs -- )
tags=interpreter,forth-83,nosymbol
set up Sweet16 registers for `found?`

|register|contents|h
|n3|name|
|n4|len|
|n5|vocabid|
|n6|vocabs|
|n7|name|
|n8|len|

#endif
pfoundq
    brk
    .byt ld | TOS
    .byt st | N6
    .byt inr | N6
    .byt pull
    .byt st | N3
;~    .byt st | N7
    .byt ext
    .word symlens
    .byt ld | N8                ; `n4` `n8` len
    .byt st | N4
    .byt sub | ACC
    .byt st | N2
    .byt nxt

;--------------------------------------------------------------
#if 0
name=NOT.IN.THREAD?
stack=( cfa -- nfa|0 )
tags=compiler

```
: not.in.thread?   ( nfa addr -- xfa flag )
    @ n3 !                      ( nfa )
    (seek) <n2 0= ;             ( xfa flag )
```
#endif
#include "align.i65"
_notinthreadq
    jsr enter
#include "page.i65"
    .word fetch
#include "parm.i65"
    .word blit
    .byt R0L+2*N3
#include "pad.i65"
    .word store
#include "page.i65"
    .word pseek
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N2
#include "pad.i65"
    .word zeq
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FOUND?
stack=( nfa -- xfa flag )
tags=interpreter,forth-83,nosymbol
This replaces the Forth-83 standard word `find`, idea from Albert van der Horst
in comp.lang.forth

starting with the most recently added to `vocabs`
for each vocabulary
    try searches in this order
        word+trialvocabid `symnew`
        word+trialvocabid `symtab`
until vocabulary was (0)forth
if still not found, 0

* search order
** begin
** each vocab
** symnew .. symtail, unsized
** while not found
** symtab thread, sized
** while not found
** until vocab was 0
** exit

|^`nfa`|^the `name` we are looking for<br/>(e.g. counted string in `tib` buffer)|<|
|^`xfa`|^`flag`|<|
|nfa|0|not found|
|cfa|-1|found normal word|
|cfa|+1|found immediate word|

|^`forth editor assembler`<br/>`vocabulary tools`<br/>`tools definitions`<br/>|<|<|<|
|>|Search order example|<|<|h
|1|`tools` vocabulary|`symtail`|unsorted|
|2|`tools` vocabulary|`thread`|sorted|
|3|`assembler` vocabulary|`symtail`|unsorted|
|4|`assembler` vocabulary|`thread`|sorted|
|5|`editor` vocabulary|`symtail`|unsorted|
|6|`editor` vocabulary|`thread`|sorted|
|7|`core` vocabulary|`symtail`|unsorted|
|8|`core` vocabulary|`thread`|sorted|
|9|not found|<|<|

`core` is always the last vocabulary searched.  A name/vocabulary combination
is `unique` meaning it has at most one active symbol.  Prior copies of
redefined symbols remain in the symbol table, smudged. Smudged words are
ignored (not a match) by `found?`

```
: found?   ( name -- xfa flag )
    vocabs (found?)
    begin
        <n6 c@+ >n5 drop n6 !
        ldi | N6
        st | N5
        nxt

: nextvocab   ( vocab nfa -- vocab' nfa )
    swap c@+ n5 ! swap ;

: nextvoc

: (found?)    ( nfa vocabs -- nfa )
    ;
code (found?)
    brk
    ldd | TOS
    st | N6
    inr | N6
    pull
    st | N3
    nxt


true = found
false = not found
: found?   ( name -- xfa flag )
    n2 off                      \ result
    vocabs @ 1+ n6 !  >n3       ( nfa )
    bloomfilter cbit@           ( nfa flag )
    if
        begin
            <n6 c@+ n5 2!       ( nfa ) \ next vocab
            symnew              ( nfa addr )
            not.in.thread?      ( xfa  flag )
        while
            =n3 pearson# 2* symtab @ +
            >r =n3 r>           ( nfa addr )
            not.in.thread?      ( xfa flag )
        while
            <n5 0=
        until
    then <n2 ;


```
: found?   ( nfa -- xfa flag )
    n2 off  >n3
    bloomfilter cbit@ dup 0= ?exit drop
    vocabs (found?)
    begin
        <n6 c@+ n5 2!
        symnew not.in.thread?
    while
        =n3 pearson# 2* symtab @ +
        >r =n3 r> not.in.thread?
    while
        <n5 0=
    until ;
pfoundq
    brk
    .byt ld | TOS
    .byt st | N6
    .byt inr | N6
    .byt pull
    .byt st | N3
;~    .byt st | N7
    .byt ext
    .word symlens
    .byt ld | N8                ; `n4` `n8` len
    .byt st | N4
    .byt sub | ACC
    .byt st | N2                ; n2 off
    .byt nxt

```
#endif
#include "align.i65"
_foundq
    jsr enter
#include "pad.i65"
    .word vocabs
#include "page.i65"
    .word pfoundq
#include "pad.i65"
    .word _bloomfilter          ; sum of decimal digits in name % 64
#include "page.i65"
    .word cbitfetch
#include "parm.i65"
    .word qbranch               ;     if
    .byt <(foundq03-*+1)
#include "parm.i65"
foundq01                        ;     begin (loop through vocabs)
    .word zpfrom
    .byt R0L+2*N6
#include "pad.i65"
    .word cfetchplus
#include "parm.i65"
    .word blit
    .byt R0L+2*N5
#include "pad.i65"
    .word twostore
#include "page.i65"
    .word symnew
#include "page.i65"
    .word _notinthreadq
#include "parm.i65"
    .word qbranch               ;     while
    .byt <(foundq03-*+1)
#include "parm.i65"
    .word zpex
    .byt R0L+2*N3
#include "pad.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "parm.i65"
    .word zpex
    .byt R0L+2*N3
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word _notinthreadq
#include "parm.i65"
    .word qbranch               ;     while
    .byt <(foundq03-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N5
#include "pad.i65"
    .word zeq
#include "parm.i65"
    .word qbranch               ;     until then
    .byt <(foundq01-*+1)
#include "parm.i65"
foundq03
    .word zpfrom
    .byt R0L+2*N2
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEFINITIONS
stack=( -- )
tags=forth-83
Sets the compilation vocabulary by copying the first vocabulary in
the [[VOCABS]] search order to [[CURRENT]].

#endif
#include "align.i65"
definitions
    lda uservocabs+1
    sta usercurrent
definitions99
    jmp next

;--------------------------------------------------------------
#if 0
name=FORTH
stack=( -- )
tags=vocabulary,forth-83
Reset the vocabulary search order to just CORE.  Equivalent to
`ONLY FORTH` in ANS Forth

```
: forth   ( -- )
    vocabs 12 erase ;
```
#endif
#include "align.i65"
_forth
    jsr enter
#include "page.i65"
    .word vocabs
#include "page.i65"
    .word count
#include "page.i65"
    .word erase
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EXISTS?
stack=( -- addr flag )
tags=interpreter,ext
parses the next token in the input stream.  Returns either the
address of the (unfound) token at HERE and a 0, or the code
field address of the word and -1 for normal, +1 for immediate
words

```
: exists?   ( -- addr flag )
   bl name ?dup ?: found? false  0<> and ;
```
#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word pquerycolon
    .word _foundq
    .word false
#include "pad.i65"
    .word zne
#include "page.i65"
    .word andx
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name='
stack=( -- cfa )
tags=forth-83
Parse the next token in the input stream and search for it,
returning the CFA if successful.  Otherwise aborts with the
message "NOT FOUND"

```
: '   ( "name" -- cfa )
    exists? dup 0=  3 ?error ;
```
#endif
#include "align.i65"
_tick
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qerror
    .byt 3                      ; NOT FOUND
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CREATE)
stack=( cfa -- )
tags=compiler,nosymbol
Create a new symbol in the symbol table

`(create)` should (and does!) smudge the previous definition's NFA, if found.
Pairs like `:` will need to unsmudge the prior word and smudge this newly
defined word.  Finally `;` will smudge the prior word and unsmudge this
new one

```
: (create)   ( cfa -- )
    eol? 4 ?error               \ "MISSING NAME"
    redefined off
    \ no need to set the bloom bit first
    exists? ?dup
    if                          ( cfa )
        <n7 dup redefined !
        .rvs  $. ."  [OFF]exists "
    then                        ( cfa )
    bloom                       ( symtail 2+ )
    current
    2swap over cfa,
    >syms here 3- ((create))
    3coff dup smudge newest !
    false (seekb)
    if
        unsmudge
    else
        <n3 dup redefined !
        RVSON emit
        id. ." exists{OFF}"
    then ;

: (create)   ( cfa -- )
    eol? [ 4 ] ?error \ MISSING NAME
    redefined off
    exists?
    if
        redefined ((redefine))
        .rvs $. ." [OFF]EXISTS"
    then
    bloom current rot ?align cfa,
    here 3- newest ((create)) ;


code ((create))
    jsr harvests6
    brk
    .byt popd | N0               ; symtail @
    .byt st | N3
    .byt ld | N2                ; cfa'
    .byt std | N3               ; write CFA to symtab, +2 N5 pointer
    .byt ld | N3
    .byt std | TOS              ; populate `newest`
    .byt ext
;    .word swap73s
    .byt ext
    .word symcopys              ; copy the symbol/length
    .byt ldi | N1
    .byt bz , <(ppcreate01-*-2)
    .byt set | ACC
    .word $40
ppcreate01
    .byt st | TOS               ; TOS = $00 or $40 if vocab
    .byt inr | N7
    .byt pop | N7
    .byt st | N5
    .byt add | TOS
    .byt sti | N7               ; symbol length with a proper vocab bit
    .byt ld | N7
    .byt add | N5
    .byt st | N7
    .byt pop | N1
    .byt bz , <(ppcreate02-*-2)
    .byt sti | N7
ppcreate02
    .byt ld | N7
    .byt std | N0               ; update symtail
    .byt sub | ACC
    .byt sti | N7
    .byt std | N7
    .byt pull
    .byt rtn
    jmp exit

: ((redefine))
    <n3 @ dup rot ! ;
\ [16]
code ((redefine))
    brk
    .byt ldd | N3
    .byt ld | N3
    .byt std | TOS
    .byt st | TOS
    .byt nxt
;[6]
```
#endif
#include "align.i65"
_pcreate
    jsr enter                   ; ( cfa )
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qerror
    .byt 4                      ; MISSING NAME
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word off
#include "pad.i65"
    .word _existsq              ; ( cfa|nfa )
#include "parm.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "pad.i65"
    .word dotrvs
#include "page.i65"
    .word redefined
#include "page.i65"
    .word ppredefine
#include "page.i65"
    .word dup
#include "page.i65"
    .word _stringdot
#include "page.i65"
    .word smudge
#include "parm.i65"
    .word _pdq
    .byt <(pcreate01-*-1)
    .asc RVSOFF," EXISTS"
pcreate01
#include "pad.i65"
pcreate02
    .word _qalign
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word bloom                 ; aka `symtail` +2
#include "page.i65"
    .word current
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus            ; first enclose, then rewind to cfa
#include "page.i65"
    .word newest                ; ( symtail+2 current cfa newest )
#include "page.i65"
    .word ppcreate
#include "past.i65"
    .word exit

/*
.C:6D86  00          BRK            - A:D4 X:2F Y:00 SP:F6 ..-B..Z.   93608252
$6D86) m 0 1f;m 40 4f;m 70 ff;m 130 17f;m 1e0 1ff;m 410 49f;m 660 6df

0000  03 00 C6 06  D4 06 C2 06  43 1A C9 5F  03 00 00 00
0010  B8 06 06 02  04 00 9C 6B  00 01 0D D0  08 0F 86 00
0040  AA AA AA AA  AA AA AA 08  8A 6C 1E 00  43 C2 D4 01
0070  BB BB BB BB  BB BB BB 00  06 06 00 00  1A 06 06 10
0080  00 00 00 00  74 06 E6 8B  E6 8B 6C 7F  6D 00 08 58
0090  55 E4 55 06  FF B3 00 1B  00 0E 01 FF  00 00 00 00
00A0  00 0A 00 14  0A 00 1B 01  08 20 00 00  00 00 00 00
00B0  03 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00C0  00 00 00 00  20 83 0B 01  04 E8 46 00  00 00 00 00
00D0  00 00 00 00  00 27 00 00  14 0D 00 00  00 00 00 00
00E0  80 80 80 80  80 80 80 81  81 81 81 81  81 82 82 82
00F0  82 82 82 82  83 83 83 83  83 00 00 09  48 FF FF 70
0130  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
0140  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
0150  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
0160  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
0170  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
01E0  57 35 99 66  57 C7 57 E4  03 C7 05 68  42 CE 26 12
01F0  84 04 70 1C  26 85 6D B2  70 58 6F 7A  6F 9B 6F 06
0200  43 52 45 41  54 45 03 46  4F 4F 56 2E  30 22 2C 39   CREATEcFOOV.0",9
0210  00 2C 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @,@@@@@@@@@@@@@@
0220  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
0230  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
0240  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF   ................
0250  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF   ................
0410  4C 73 C3 22  00 5B 00 00  00 04 00 64  00 00 00 00
0420  00 0D 04 16  13 00 08 12  B3 01 0D D0  02 FF 86 40
0430  B2 E9 CE AA  AA AA AA AA  01 04 E8 46  E8 46 E8 46
0440  00 80 AA AA  00 80 D1 07  AA AA 00 04  AA AA 00 04
0450  AA AA AA AA  24 AA AA 08  B6 FF 00 00  00 FB AB 00
0460  03 4C BB 00  BB BB BB BB  BB BB 00 00  00 00 8B 00
0470  00 04 0D 00  00 00 8B 80  C0 00 00 00  00 00 05 B3
0480  E6 77 D0 02  E6 78 AD 0A  04 C9 3A B0  0A C9 20 F0
0490  EF 38 E9 30  38 E9 D0 60  80 4F C7 52  7C 80 40 20
0660  01 88 84 1F  85 1E 20 C5  04 4C 66 06  0A 00 07 17
0670  00 00 01 00  31 00 FE 01  00 00 78 D4  00 00 00 00
0680  32 68 36 6F  46 1A 43 1A  00 57 0A 00  07 17 00 00
0690  01 00 FE 52  00 00 00 00  FF FF 00 00  0B 00 0A 00
06A0  01 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
06B0  00 67 80 7F  02 00 09 00  00 00 00 00  00 00 00 00
06C0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
06D0  ED 64 EB 64  FF E0 00 00  00 00 00 00  CC CC CC CC
1A00  90 00 99 78  06 78 68 99  90 00 68 99  91 00 58 60   .@.xfxh..@h..@X`
1A10  20 EE 10 19  1A ED 19 3D  11 86 FF A9  0F 48 A9 31    .pyz.y=q...oH.1
1A20  48 4C 86 00  4E E2 06 EE  E2 06 B0 16  20 E1 19 86   HL.@N.f..f.v .y.
1A30  FF A2 8D B5  FF BC 0F 04  94 FF 9D 0F  04 CA D0 F3   ......od...odJP.
1A40  A6 FF 60 20  CF 0D EF EF  DE AD BE EF  DE AD BE EF   ..` Om..........
1A50  DE AD BE EF  DE AD BE EF  DE AD BE EF  DE AD BE EF   ................
1A60  DE AD BE EF  DE AD BE EF  DE AD BE EF  DE AD BE EF   ................
1A70  DE AD BE EF  DE AD BE EF  DE AD BE EF  DE AD BE EF   ................
1A80  DE AD BE EF  DE AD BE EF  DE AD BE EF  DE AD BE EF   ................
64C0  41 55 53 45  67 10 06 3F  53 54 41 43  4B F1 70 26   AUSEgpf?STACK.p&
64D0  3F 45 52 52  4F 52 CE 73  26 3F 4C 45  41 56 45 33   ?ERRORNs&?LEAVE3
64E0  0A 09 3F 54  45 52 4D 49  4E 41 4C 00  00 00 AA AA   ji?TERMINAL@@@..
64F0  AA AA AA AA  AA AA AA AA  AA AA AA AA  AA AA AA AA   ................
6500  AA AA AA AA  AA AA AA AA  AA AA AA AA  AA AA AA AA   ................
6510  AA AA AA AA  AA AA AA AA  AA AA AA AA  AA AA AA AA   ................
6520  AA AA AA AA  AA AA AA AA  AA AA AA AA  AA AA AA AA   ................
6530  AA AA AA AA  AA AA AA AA  AA AA AA AA  AA AA AA AA   ................
6540  AA AA AA AA  AA AA AA AA  AA AA AA AA  AA AA AA AA   ................

0000  03 00 C6 06  D4 06 C2 06  43 1A C9 5F  03 00 00 00
0010  B8 06 06 02  04 00 9C 6B  00 01 0D D0  08 0F 86 00
0040  AA AA AA AA  AA AA AA 08  8A 6C 1E 00  43 C2 D4 01
0070  BB BB BB BB  BB BB BB 00  06 06 00 00  1A 06 06 10
0080  00 00 00 00  74 06 E6 8B  E6 8B 6C 7F  6D 00 08 58
0090  55 E4 55 06  FF B3 00 1B  00 0E 01 FF  00 00 00 00
00A0  00 0A 00 14  0A 00 1B 01  08 20 00 00  00 00 00 00
00B0  03 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
00C0  00 00 00 00  20 83 0B 01  04 E8 46 00  00 00 00 00
00D0  00 00 00 00  00 27 00 00  14 0D 00 00  00 00 00 00
00E0  80 80 80 80  80 80 80 81  81 81 81 81  81 82 82 82
00F0  82 82 82 82  83 83 83 83  83 00 00 09  48 FF FF 70
0130  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
0140  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
0150  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
0160  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
0170  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
01E0  57 35 99 66  57 C7 57 E4  03 C7 05 68  42 CE 26 12
01F0  84 04 70 1C  26 85 6D B2  70 58 6F 7A  6F 9B 6F 06
0200  43 52 45 41  54 45 03 46  4F 4F 56 2E  30 22 2C 39   CREATEcFOOV.0",9
0210  00 2C 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @,@@@@@@@@@@@@@@
0220  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
0230  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
0240  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF   ................
0250  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF   ................
0410  4C 73 C3 22  00 5B 00 00  00 04 00 64  00 00 00 00
0420  00 0D 04 16  13 00 08 12  B3 01 0D D0  02 FF 86 40
0430  B2 E9 CE AA  AA AA AA AA  01 04 E8 46  E8 46 E8 46
0440  00 80 AA AA  00 80 D1 07  AA AA 00 04  AA AA 00 04
0450  AA AA AA AA  24 AA AA 08  B6 FF 00 00  00 FB AB 00
0460  03 4C BB 00  BB BB BB BB  BB BB 00 00  00 00 8B 00
0470  00 04 0D 00  00 00 8B 80  C0 00 00 00  00 00 05 B3
0480  E6 77 D0 02  E6 78 AD 0A  04 C9 3A B0  0A C9 20 F0
0490  EF 38 E9 30  38 E9 D0 60  80 4F C7 52  7C 80 40 20
0660  01 88 84 1F  85 1E 20 C5  04 4C 66 06  0A 00 07 17
0670  00 00 01 00  31 00 FE 01  00 00 78 D4  00 00 00 00
0680  32 68 36 6F  46 1A 43 1A  00 57 0A 00  07 17 00 00
0690  01 00 FE 52  00 00 00 00  FF FF 00 00  0B 00 0A 00
06A0  01 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
06B0  00 67 80 7F  02 00 09 00  00 00 00 00  00 00 00 00
06C0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00
06D0  ED 64 EB 64  FF E0 00 00  00 00 00 00  CC CC CC CC
1A00  90 00 99 78  06 78 68 99  90 00 68 99  91 00 58 60   .@.xfxh..@h..@X`
1A10  20 EE 10 19  1A ED 19 3D  11 86 FF A9  0F 48 A9 31    .pyz.y=q...oH.1
1A20  48 4C 86 00  4E E2 06 EE  E2 06 B0 16  20 E1 19 86   HL.@N.f..f.v .y.
1A30  FF A2 8D B5  FF BC 0F 04  94 FF 9D 0F  04 CA D0 F3   ......od...odJP.
1A40  A6 FF 60 20  CF 0D EF EF  DE AD BE EF  DE AD BE EF   ..` Om..........
1A50  DE AD BE EF  DE AD BE EF  DE AD BE EF  DE AD BE EF   ................
1A60  DE AD BE EF  DE AD BE EF  DE AD BE EF  DE AD BE EF   ................
1A70  DE AD BE EF  DE AD BE EF  DE AD BE EF  DE AD BE EF   ................
1A80  DE AD BE EF  DE AD BE EF  DE AD BE EF  DE AD BE EF   ................
64C0  41 55 53 45  67 10 06 3F  53 54 41 43  4B F1 70 26   AUSEgpf?STACK.p&
64D0  3F 45 52 52  4F 52 CE 73  26 3F 4C 45  41 56 45 33   ?ERRORNs&?LEAVE3
64E0  0A 09 3F 54  45 52 4D 49  4E 41 4C 00  00 00 AA AA   ji?TERMINAL@@@..
64F0  AA AA AA AA  AA AA AA AA  AA AA AA AA  AA AA AA AA   ................
6500  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
6510  AA AA AA AA  AA AA AA AA  AA AA AA AA  AA AA AA AA   ................
6520  AA AA AA AA  AA AA AA AA  AA AA AA AA  AA AA AA AA   ................
6530  AA AA AA AA  AA AA AA AA  AA AA AA AA  AA AA AA AA   ................
6540  AA AA AA AA  AA AA AA AA  AA AA AA AA  AA AA AA AA   ................

>C:0000  00 00 50 00  00 02 c2 06  49 1a 1c 02  03 ff 03 00   @@P@@bBfIz\bc.c@
>C:0010  00 02 20 00  03 00 34 d5  00 01 0d d0  00 73 86 00   @b @c@4U@amP@s.@
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa aa 08  8a 6c 1e 69  85 00 00 01   .......h.l^i.@@a
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb bb 00  06 06 00 6d  6f 02 02 10   .......@ff@mobbp
>C:0080  00 00 00 00  74 06 e6 8b  e6 8b 6c bd  68 00 0d 9b   @@@@tf....l.h@m.
>C:0090  55 e4 55 06  ff b3 00 ff  00 75 01 ff  00 00 00 00   U.Uf..@.@ua.@@@@
>C:00a0  00 20 00 16  00 00 ff 00  05 20 01 00  00 00 00 00   @ @v@@.@e a@@@@@
>C:00b0  03 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   c@@@@@@@@@@@@@@@
>C:00c0  00 00 00 00  70 83 00 01  04 e8 46 00  00 00 00 00   @@@@p.@ad.F@@@@@
>C:00d0  00 00 00 00  00 27 00 00  16 0d 00 00  00 00 00 00   @@@@@'@@vm@@@@@@
>C:00e0  80 80 80 80  80 80 80 81  81 81 81 81  81 82 82 82   ................
>C:00f0  82 82 82 82  83 03 83 83  83 00 00 09  48 ff ff 69   .....c...@@iH..i
>C:0100  20 33 31 37  34 33 00 30  30 30 30 00  00 00 00 00    31743@0000@@@@@
>C:0110  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
>C:0120  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
>C:0130  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
>C:0140  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff   ................
>C:0150  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff   ................
>C:0160  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff   ................
>C:0170  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff   ................
>C:0180  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
>C:0190  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
>C:01a0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
>C:01b0  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
>C:01c0  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff   ................
>C:01d0  ff ff ff ff  ff ff ff ff  ff 34 99 66  57 34 99 66   .........4.fW4.f
>C:01e0  57 35 99 66  57 57 e4 c7  05 68 03 57  e4 00 2f 00   W5.fWW.GehcW.@/@
>C:01f0  23 bf e0 2f  00 5e 18 5e  69 79 69 6b  6f 9b 6f 06   #. /@^x^iyiko.of
>C:0200  43 52 45 41  54 45 03 46  4f 4f 06 43  52 45 41 54   CREATEcFOOfCREAT
>C:0210  45 03 46 4f  4f 06 43 52  45 41 54 45  03 46 4f 4f   EcFOOfCREATEcFOO
>C:0220  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
>C:0230  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   @@@@@@@@@@@@@@@@
>C:0240  ff ff ff ff  ff ff ff ff  ff ff ff ff  ff ff ff ff   ................
>C:0660  01 88 84 1f  85 1e 20 c5  04 4c 66 06  0a 00 07 17   a.._.^ EdLffj@gw
>C:0670  00 00 01 00  31 00 fe 01  00 00 78 d4  00 00 00 00   @@a@1@.a@@xT@@@@
>C:0680  32 68 36 6f  4c 1a 43 1a  00 57 0a 00  07 17 00 00   2h6oLzCz@Wj@gw@@
>C:0690  01 00 fe 52  00 00 00 00  ff ff 00 00  00 00 00 00   a@.R@@@@..@@@@@@
>C:06a0  02 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00   b@@@@@@@@@@@@@@@
>C:06b0  00 67 80 7f  02 00 09 00  00 00 00 00  00 00 00 00   @g..b@i@@@@@@@@@
>C:06c0  00 00 00 00  f3 64 f9 64  00 00 00 00  00 00 00 00   @@@@.d.d@@@@@@@@
>C:06d0  ed 64 fd 64  ff e0 00 00  00 00 00 00  cc cc cc cc   .d.d. @@@@@@LLLL
>C:1a00  90 00 99 78  06 78 68 99  90 00 68 99  91 00 58 60   .@.xfxh..@h..@X`
>C:1a10  20 ee 10 19  1a ed 19 3d  11 86 ff a9  0f 48 a9 31    .pyz.y=q...oH.1
>C:1a20  48 4c 86 00  4e e2 06 ee  e2 06 b0 16  20 e1 19 86   HL.@N.f..f.v .y.
>C:1a30  ff a2 8d b5  ff bc 0f 04  94 ff 9d 0f  04 ca d0 f3   ......od...odJP.
>C:1a40  a6 ff 60 20  cf 0d 20 cf  0d 20 cf 0d  de ad be ef   ..` Om Om Om....
>C:1a50  de ad be ef  de ad be ef  de ad be ef  de ad be ef   ................
>C:1a60  de ad be ef  de ad be ef  de ad be ef  de ad be ef   ................
>C:1a70  de ad be ef  de ad be ef  de ad be ef  de ad be ef   ................
>C:1a80  de ad be ef  de ad be ef  de ad be ef  de ad be ef   ................
>C:64c0  41 55 53 45  67 10 06 3f  53 54 41 43  4b f1 70 26   AUSEgpf?STACK.p&
>C:64d0  3f 45 52 52  4f 52 ce 73  26 3f 4c 45  41 56 45 33   ?ERRORNs&?LEAVE3
>C:64e0  0a 09 3f 54  45 52 4d 49  4e 41 4c 43  1a 83 46 4f   ji?TERMINALCz.FO
>C:64f0  4f 46 1a 83  46 4f 4f 49  1a 03 46 4f  4f 00 00 00   OFz.FOOIzcFOO@@@
>C:6500  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:6510  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:6520  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:6530  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:6540  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................

tos=newest n0=symtail+2 n1=current n2=here
((create))
    jsr harvests6
    brk
    .byt popd | N0               ; symtail @
// N0 = usersymtail ACC = symtail
    .byt st | N3
    .byt ld | N2                ; cfa'
    .byt std | N3               ; write CFA to symtab
    .byt ld | N3                ; nfa'
    .byt std | TOS              ; populate `newest`
    .byt ext
    .word pppcreate
;    .word swap73s
    .byt ext
    .word symcopys              ; copy the symbol/length

(((create)))
;    jsr swap73s
    jsr symcopys
    ldy #0
    lda R0L+2*N1                ; vocab

    .byt ldi | N1               ; vocab
    .byt bz , <(ppcreate01-*-2)
    .byt set | ACC
    .word $40
ppcreate01
    .byt st | TOS               ; TOS = $00 or $40 if vocab
    .byt inr | N7
    .byt pop | N7               ; reget length
    .byt st | N5
    .byt add | TOS              ; ora #$40 if vocab bit
    .byt sti | N7               ; output symbol length with a proper vocab bit

    .byt ld | N7
    .byt add | N5
    .byt st | N7
    .byt pop | N1
    .byt bz , <(ppcreate02-*-2)
    .byt sti | N7
ppcreate02
    .byt ld | N7
    .byt std | N0               ; symtail !
    .byt sub | ACC
    .byt sti | N7               ; write three nulls at symtail
    .byt std | N7
    .byt pull
    .byt nxt


* copy symbol @n7 to symtail
* enclose 'here' as new CFA
* current nonzero?
     - set vocabulary bit
     - append `current` at symtail
* drop out a 00 00 00    symtail `3coff`
* update symtail
* set newest

tos newest
n0  symtail+2
n1  current
n2  here
n3  symtail
n7

*/
ppcreate
    jsr harvests6
    brk
    .byt popd | N0               ; symtail @
// N0 = usersymtail ACC = symtail
    .byt st | N3
    .byt ld | N2                ; cfa'
    .byt std | N3               ; write CFA to symtab
    .byt ld | N3                ; nfa'
    .byt std | TOS              ; populate `newest`
    .byt ext
;    .word swap73s
    .byt ext
    .word symcopys              ; copy the symbol/length
    .byt ldi | N1               ; vocab
    .byt bz , <(ppcreate01-*-2)
    .byt set | ACC
    .word $40
ppcreate01
    .byt st | TOS               ; TOS = $00 or $40 if vocab
    .byt inr | N7
    .byt pop | N7
    .byt st | N5
    .byt add | TOS              ; ora #$40 if vocab bit
    .byt sti | N7               ; symbol length with a proper vocab bit
    .byt ld | N7
    .byt add | N5
    .byt st | N7
    .byt pop | N1
    .byt bz , <(ppcreate02-*-2)
    .byt sti | N7
ppcreate02
    .byt ld | N7
    .byt std | N0               ; symtail !
    .byt sub | ACC
    .byt sti | N7               ; write three nulls at symtail
    .byt std | N7
    .byt pull
    .byt nxt

/*
code ((redefine))   ( redefined -- nfa )
    brk,
    n3 ldd,
    n3 ld,
    tos std,
    tos st,
    nxt,
end-code

`redefined` = `nfa` of found word
return `nfa` of found word for `$.` to display

TOS                             redefined
N0
N1
N2
N3                              NFA

TOS                             nfa
N3                              NFA+2

*/
ppredefine
    brk
    .byt ldd | N3
    .byt ld | N3
    .byt std | TOS
    .byt st | TOS
    .byt nxt

;--------------------------------------------------------------
#if 0
name=?VMMOVE
stack=( newsymtab -- )
tags=ext,nosymbol
* if `#blk` nonzero, move `vmbuf` area

```
: ?vmmove   ( newsymtab -- )
    #blk @
    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
     vmbuf !
    symtab ! ;
```
    jsr harvests4               ; grab just b/buf & vmbuf, leave newsymtab next
    brk
    .byt ldd | TOS              ; #blk@
    .byt st | TOS               ; if we leave abruptly, don't +MOVE anything
    .byt bz , <(qvmmovemagic01-*-2)
    .byt pull                   ; newsymtab
    .byt st | N2                ; put it somewhere safe, for now
    .byt sub | N6               ; old `symtab`

    ;~wut? more to do here, to support moving `vmbuf`

                                ; no blocks in VM buffer to worry about here
                                ; not much to do either, really
qvmmovemagic01
    .byt rtn






```
: ?vmmove   ( newsymtab -- )
    #blk @
    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
     vmbuf !
    symtab ! ;


: ?vmmove   ( newsymtab -- )
    vmbuf
    b/buf
    #blk
    (?vmmove).magic             ( newsymtab newvmbuf from to delta flag )
    ?: +move 3drop
    vmbuf !
    symtab ! ;

;(?vmmove).magic   ( newsymtab vmbuf b/buf #blk -- newvmbuf newsymtab )
qvmmovemagic
    jsr locals4                 ; grab just b/buf & vmbuf, leave newsymtab next
    brk
    .byt ldd | TOS              ; #blk@
    .byt st | TOS               ; in case must leave abruptly, don't +MOVE anything
    .byt bz , <(qvmmovemagic01-*-2)
    .byt pull                   ; newsymtab
    .byt st | N2                ; put it somewhere safe, for now
    .byt sub | N6               ; old `symtab`


                                ; no blocks in VM buffer to worry about here
                                ; not much to do either, really
qvmmovemagic01
    .byt rtn
    ldy #4
    jsr restack
    jmp next



    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
```
#endif
#include "align.i65"
_qvmmove
    jsr enter
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(FORGET).KEEP
stack=( cfa -- flag )
tags=interpreter,nfa,nosymbol

#endif
#include "align.i65"
_pforgetkeep
    jsr enter
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N7
#include "pad.i65"
    .word store
#include "parm.i65"
    .word callz
    .word symcopys
#include "pad.i65"
;    .word swap73
#include "parm.i65"
    .word callz
    .word sympluss
#include "pad.i65"
;    .word swap73
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=!SYMTAIL
stack=( tail -- symnew )
tags=dictionary,nosymbol
* Append three nulls as an end marker to symbol table
* Set uservar `symtail`
* used by `(cold)`, `(forget)` and `(create)`

|n0|`symtail`|
|n1|`studio`|
|n2|`studio.size`|
|n3|temp addr|
|n4|`symtab`|
|stack|`sym.start sym.end from to howmany`|
#endif
#include "align.i65"
setsymtail
    brk
    .byt set | N0
    .word usersymtail
    .byt ld | TOS                       ; tail
    .byt std | N0                       ; `symtail !`
    .byt sub | ACC
    .byt std | TOS
    .byt sti | TOS                      ; put three nulls at tail
    .byt pop | TOS                      ; back up over the last one to reach `symnew`
    .byt nxt

;--------------------------------------------------------------
#if 0
name=SOUTHERLY
stack=( )
tags=interpreter,extension,nosymbol

: southerly

    <n1 ?exit
    <n8 passbits >bit cbit! ;

: pforgetpass1
    i
    .word qbranch
    .byt <(pforgetpass1b-*+1)
    .word i
    .word symlen
    .word eq
    .word qbranch
    .byt <(symnext01-*+1)       ; next!
;#refactor
    .word zpfrom                ; nfa
    .byt R0L+2*N3
    .word namefrom              ; nfa>cfa
    .word twodup
    .word studio
    .word fetch
    .word swap
    .word oneplus
    .word betweenq
pforgetpass1a
    .word pquerycolon
    .word drop
    .word _pforgetkeep
    .word branch
    .byt <(symnext01-*+1)       ; next!
pforgetpass1b                   ; pass 0 only, set passbits and bloomfilter
    .word symlen
    .word _passbitsstore         ; if ((i-1) = 0) set `passbits` for all lengths
    .word _bloomfilter          ; doing this here speeds things up slightly,
#include "page.i65"             ; with a low risk of setting (inconsequential)
    .word cbitstore             ; false positives in `bloom#` for forgotten words
    .word branch
    .byt <(symnext01-*+1)       ; next!


southerly
    jsr symlens
    iny
    lda (n3),y
    and #$0F
    eor n1
    bne nextsymbol

nextsymbol
    beq lastone
    lda n1
    bne

lastone
    inc n1                      ; counter

    lda R0L+2*N1                ; counter 0..31

    i



#endif
#include "align.i65"
_southerly
    jsr enter
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=GOSOUTH
stack=( cfa -- targetend )
tags=interpreter,extension,nosymbol
Copy names from `symtab` to `pad`
exclude names where:  tos <= CFA <= studio

tos                             0
n0                              cfa
n1                              src
n2                              dest
n3                              fence
n4                              studio

: gosouth   ( cfa -- addr )
    bloom 12 erase
    pad 0 thread 0
    fence
    (gosouth)
    begin
        southerly
    until

tos                             0
n0                              cfa
n1                              src
n2                              dest
n3                              fence
n4                              studio
code (gosouth)
    jsr harvests10




#endif
#include "align.i65"
_gosouth
    jsr enter
#include "page.i65"
    .word bloom                 ; cfa bloom )
#include "parm.i65"
    .word blit                 ; cfa bloom 12 )
    .byt <(userpassbits+4-userbloom)
#include "pad.i65"
    .word erase                 ; reset bloom filter, passbits
#include "page.i65"
    .word _pad
#include "page.i65"
;    .word tosyms
#include "page.i65"
    .word pgosouth
#include "page.i65"
gosouth01                       ; begin
    .word doextreg
#include "parm.i65"             ;  ( flag )
    .word qbranch               ; until
    .byt <(gosouth01-*+1)
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(GOSOUTH)
stack=( -- flag )
tags=interpreter,extension,nosymbol
6EBE   .pgosouth:
6EBE  20 EF 06    jsr .harvests4
6EC1  00          brk
0000  DC 64 22 57  4E 1A F2 1A  88 1A DC 64  05 FF 00 00
0000  DC 64 22 57  4E 1A 00.00  88 1A 22.57  05 FF 00 00

0010  B8 06 06 02  05 00 34 D5  00 01 1B 00  0A 93 67 6C
0010  B8 06 F2.1A  05 00 .cfa.  00 01 1B 00  0A 93 67 6C

0040  AA AA AA AA  AA AA AA FF  00 01 AD 00  0C F2 4E 01
0070  BB BB BB BB  BB BB BB FF  53 00 24 00  00 1A 1A 10
0080  00 00 00 00  74 06 E6 8B  E6 8B 6C B5  6E 00 2E 5C
0090  55 E4 55 06  FF B3 00 1B  00 32 00 FF  00 00 00 00
00A0  00 0C 00 18  0C 00 1B 01  0C 20 00 00  00 00 00 00
00B0  03 00 00 00  05 0A 00 08  00 00 00 00  00 00 00 00
00C0  00 00 80 47  C0 83 0D 00  84 00 53 FC  18 00 C0 00
00D0  00 05 00 00  01 27 7A 02  18 0D 0E 17  00 47 00 47
00E0  80 80 80 80  80 80 80 81  81 81 81 81  81 82 82 82
00F0  82 82 82 82  83 83 83 83  83 34 00 21  52 FF FF 6E
0130  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20
0140  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20
0150  20 20 20 20  20 20 20 20  FF FF FF FF  FF FF FF FF
0160  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
0170  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
01E0  57 57 E4 57  03 00 0E 00  22 CF 05 68  06 06 2F 0F
01F0  26 12 26 C0  6E 9F 6E F2  6E 2A 6F 4C  6F 6D 6F 06
0410  4C 73 C3 22  00 5B 00 00  00 04 00 64  00 00 00 00
0420  00 0D 04 16  13 00 08 12  B3 01 0D D0  02 FF 86 40
0430  B2 E9 CE AA  AA AA AA AA  FE 52 00 53  A5 46 A5 46
0440  00 80 AA AA  00 80 D1 07  AA AA 00 04  AA AA 00 04
0450  AA AA AA AA  24 AA AA 08  B6 FF 00 00  00 FB 7B 00
0460  03 4C BB 00  BB BB BB BB  BB BB 00 00  00 00 8B 00
0470  00 04 0D 00  00 00 8B 80  C0 00 00 00  00 00 05 B3
0480  E6 77 D0 02  E6 78 AD 0A  02 C9 3A B0  0A C9 20 F0
0490  EF 38 E9 30  38 E9 D0 60  80 4F C7 52  7B 80 40 20
0660  01 88 84 1F  85 1E 20 C5  04 4C 66 06  0A 00 0D 17
0670  00 00 01 00  31 00 FE 01  00 00 78 D4  00 00 00 00
0680  32 68 08 6F  A2 1A 4E 1A  00 57 0A 00  0D 17 00 00
0690  01 00 21 52  02 00 00 00  01 00 00 00  0D 00 0C 00
06A0  02 00 00 00  00 00 00 00  00 00 03 28  00 C0 56 28
06B0  00 67 46 7F  02 00 09 00  00 00 00 00  00 00 00 00
06C0  30 00 00 00  00 00 01 65  00 00 00 00  00 00 00 00
06D0  DC 64 06 65  00 00 00 00  00 00 00 00  00 00 00 00


#endif
pgosouth
    jsr harvests4
    brk
    .byt set | R11
    .word _southerly
    .byt ld | TOS
    .byt st | N3
    .byt ld | N1
    .byt st | N7
    .byt sub | ACC
    .byt st | N1
    .byt nxt

;--------------------------------------------------------------
#if 0
name=GONORTH
stack=( -- )
tags=interpreter,extension,nosymbol

#endif
#include "align.i65"
_gonorth
    jsr enter
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSBIT?
stack=( -- flag )
tags=dictionary,nosymbol

#endif
passbitq
    stx z
    ldx #3
    clc
passbitq01
    rol userpassbits,x
    dex
    bpl passbitq01
    ldx z
    jmp xpushc

;--------------------------------------------------------------
#if 0
name=(FORGET)
stack=( cfa -- )
tags=nfa,ext,nosymbol
(FORGET) rebuilds and reindexes the entire dictionary, balancing it
into 16 roughly equal-sized 'threads'.  (FORGET) merges symbols
created at SYMNEW since the last (FORGET) into their thread. Then
SYMNEW is set to SYMTAIL, emptying the 'noob' list

!!!Symbol table entry
|field| size| offset|h
|cfa| 2| -2|
|flags+length| 1| `NFA` 0|
|name| length| +1|
|voabcid| 1| +length+1|
A ''//clone//'' is a symbol which has the same name (and length) as well as
both belonging to the same vocabulary (or both [[FORTH]], no vocabulary).  The
distinction is that each `clone` has a different `cfa`.  When (CREATE) adds
a `clone`, this new definition replaces the original and smudges the lower,
earlier definition.  It is up to [[(FORGET)]] to reverse that process.

Smudge is set between ''[[:]]'' and ''[[;]]'' during a word's
creation. If there is an error during compilation, [[UNDEFINE]]
cleans up the partial (smudged) definition in the symbol table
and also moves [[DP]] back to where it started.  There should
only ever be one symbol at a time that is smudged during word
creation.

The other reason a word is smudged is when it is redefined.
When ''[[;]]'' closes the definition, if there is a previous
active definition ([[REDEFINED]] is non-zero) then it will be
smudged, and the new definition becomes active.  There should
only ever be one active `clone` (the most recent) at a time.

As [[FORGET]] sorts through the symbol table, when it finds a
smudged symbol, that is how it knows it found a `clone`.  Since
PASS1 processes Pearson-hashed symbols in [[SYMTAB]] first,
then [[SYMNEW]] symbols, the first clone found will also be
the original definition of the word.  This order corresponds
to the chronological order in which symbols are added.  At this
point, PASS1 collects all the other clones and smudges them.
When no more clones can be found, the last `clone` is unsmudged,
making it the active one.

[SYMTAB ... SYMTAIL] is also a long continuous chain of symbols, beginning at
SYMTAB+32 and ending at the triple null where SYMTAIL points.

    pad >syms
    migrate

code copy?
    doextreg
    jmp (R11)


: migrate   ( cfa to from -- )
    going up or down?
        vector R11 (for speed)
        going down?
            initial length=1
            stash cfa in a register
        going up?
            initial hash=0
    begin
        copy?
            this word's address is < cfa
            it is the correct length

        ?copy
copy them down
    filter anything >= `cfa`
    set bloom filter bit for each `bloom#`
    set pass bit for each length

automem
    `cfa` dp !
    three nulls at end of pad area
    calculate new symtab location
    symtab !
    calculate new symnew location
    symnew !
    calculate new symtail location
    symtail !
    write three nulls at new symtail location also

passbit 0 off
copy them all up
    set thread pointers


```
: (forget)   ( cfa -- )
    plits 6

    passbits
    $80
    bloom
    8
    erase !+ off
    pad >syms
    migrate
    !symtab                     ( -- symtab )
    ?vmmove
    pad 2+
    migrate

b a do rewind begin cfa execute while copy? repeat loop`

: (forget).keep
    (forget).postcfa
    symcopy swap73 1 sym+ swap73 ;

pforgetpostcfa
    brk
    .byt ld | TOS
    .byt std | N7
    .byt pull
    .byt nxt

erase bloom filter
    bloom
    00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
passbit 0 only (all lengths)
    passbits
    10000000 00000000 00000000 00000000

tos                             sym0
n0                              cfa
n1                              target
n2
n3
n7                              target
n8                              sym.len (visible, no vocab)

0000  DC 64 22 57  4E 1A 00.00  88 1A 22.57  05 FF 00 00
0010  B8 06 F2.1A  05 00 .cfa.  00 01 1B 00  0A 93 67 6C

: keeper?   ( -- flag )
    <n3 name> <n0 < ;


: southerly
    i symlen <> ?exit
    <
    keeper? if (forget).keep then
    sym+


: (forget)   ( cfa -- )
    n0 !   pad n7 !             ( )
    bloom 12 erase
    16 0 do
        symtab @ i 2* + @       ( thread )
        begin
            i symlen =
            if
                southerly
            then
        until
    loop
    !symtab ?vmmove
    32 1 do
        northerly
    loop ;


    (forget).pass1 (filter)!
    32 0  >syms pad
    (forget).looper             \ does `ext-until` 32x, completing pass1

    passbits on
    (forget).pass2 (filter)!
    16 0  pad 3+ (automem)
    (forget).looper             \ does `ext-until` 16x, completing pass2
```
#endif
#include "align.i65"
_pforget
    jsr enter
#include "page.i65"
    .word _gosouth
#include "page.i65"
    .word newsymtab
#include "page.i65"
    .word _setsymtab
#include "page.i65"
    .word _qvmmove
#include "page.i65"
    .word _gonorth
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REHASH
stack=( -- )
tags=interpreter,extension
Rebuilds the PETTIL [[symbol table ~]].

```
: rehash  ( -- )
    here (forget) ;   \ effectively a FORGET nil
```
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _pforget
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORGET
stack=( "name" -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, sorts symbol table, keeping only words below the CFA of the named word

```
: forget   ( "name" -- )
    '  dup  fence @  u<  7 ?error
    (forget) ;

~wut?  maybe new and improved 2017-09-04
: forget   ( "name" -- )
    '  dup  fence @ studio @ between 0=
    7 ?error (forget) ;
```
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "parm.i65"
    .word qerror
    .byt 7                      ; CAN'T FORGET BELOW FENCE
#include "pad.i65"
    .word _pforget
#include "past.i65"
    .word exit
