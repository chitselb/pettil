; pettil-dictionary.a65
;#echo .       pettil-dictionary.a65     Dictionary

/* dictionary conspiracy

n3      nfa                             sym0 !symdex (seek) >name (unremember) word-list
n4l     seek symlen
n4h     sorted/unsorted flag
n5l     seek vocabid
n5h
n6      vocab index
n7      seek nfa
n8l     symlen
n8h

*/

;--------------------------------------------------------------
#if 0
name=!SYMDEX
stack=( start size -- )
tags=system,startup,nosymbol

```
\ set up a fresh dictionary from a long string of symbols

inputs:                 studio
                        [start..(start+size)]

outputs:                symtab symtail symnew
                        bloom
                        [symtab..symtail]


get memory requirements                 symtab
    1 harvests

    symtab+32 >n0
    1 plants                            from to howmany
    <n0  2+ >n3




: !symdex   ( start size -- )
    studio @  over -                    \ calculate memory requirements
    $ff00 and benjamin -                \ (studio - size) & $FF00  - $100
( start size symtab )
    dup symtab !  bl +                  \ set symtab
( start size symtab+32 )
    2dup + dup 3coff                    \ set tail = 00 00 00
    dup symtail !                       \ set symtail
    2+ symnew !                         \ set symnew
( start size symtab+32 )
    swap cmove>                         \ copy names from start to symtab+32
( -- )
    bloom 8 erase  sym0                 \ set bloom filter & threads
    symtab @  bl
( symtab 32 )
    begin
        sym.len <
        if
           n3> !+
        then
        bloomfilter cbit!
        sym+
        sym.len 0=
    until ;

    etc ...

    ;
```

    bloom 8 erase  sym0
    symtab @ bl
```
#endif
#include "align.i65"
_setsymdex
    jsr enter
#include "page.i65"
    .word bloom
#include "page.i65"
    .word eight
#include "page.i65"
    .word erase
#include "page.i65"
    .word sym0
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SYMTAB!
stack=( studio start size -- studio start symtab size )
tags=system,startup,nosymbol
Calculate `symtab` memory requirements, given a size

#endif
symtabset
    dex
    lda stackh+2,x
    clc
    sbc tos+1
    sta stackh,x
    sta usersymtab+1
    lda #32
    sta stackl,x
symtabset99
    jmp next
;[18]

;--------------------------------------------------------------
#if 0
name=SYM0
stack=( -- nfa )
tags=interpreter,ext,nosymbol
Returns `nfa` of first symbol in the `symbol table`

#endif
sym0
    ldy usersymtab+1
    lda #34
    sty R0L+2*N3+1
    sta R0L+2*N3
    bne symtabset99             ; bra

;--------------------------------------------------------------
#if 0
name=SYM.LEN
stack=( -- len )
tags=nfa,nosymbol
Return length information about the `nfa`  `n3`

`visible length` means the length of the name when you type it.
The carry flag indicates whether a `vocabid` follows the `name`

C = vocabid?
A,N8L = visible length
Y = 0
#endif
symlen
    lda #>(pushya-1)
    pha
    lda #<(pushya-1)
    pha
;--------------------------------------------------------------
#if 0
name=SYMLENS
effects=A:len;Y:0;C:vocab?;Z:len
tags=nfa,nosymbol
6502registers=A:symlen Y:0 C:vocab
Sweet16registers=N3:nfa N8:length

#endif
symlens
    ldy #0              ;{2 {=23}}
    lda R0L+2*N3+1              ; length = 0 if `n3` is 0
    beq symlens01
    lda (R0L+2*N3),y    ;{5}    ; length/flags
symlens01
    pha                 ;{3}    ; not using tay/tya preserves Y=0
    asl                 ;{2}
    asl                 ;{2}    ; Vocab bit to C flag
    pla                 ;{4}
    and #$1F            ;{2}    ; length
    sta R0L+2*N8        ;{3}    ; N8L = visible length (omit vocab +1)
    rts

;--------------------------------------------------------------
#if 0
name=SYMCOPY
stack=( -- )
tags=ext,primitive,nfa,nosymbol

* N3 (curr) symbol to N7 (targ) symbol
* copy vocab byte
* copy text
* copy length/flags
* does not move N7, does not move N3 either

#endif
symcopy
    lda #>(next-1)
    pha
    lda #<(next-1)
    pha
symcopys
    jsr symlens
    adc #0
    tay
symcopy01
    lda (R0L+2*N3),y
    sta (R0L+2*N7),y
    dey
    bpl symcopy01
    rts

;--------------------------------------------------------------
#if 0
name=SYM+
stack=( -- )
tags=ext,primitive,nfa,nosymbol
registers=Z:false
* move N3 to the next symbol
compiled with an inline value following the CFA
to specify a constant per-symbol offset

#endif
symplus
    jsr sympluss
    jmp next

sympluss
    jsr symlens
    adc #3
    adc R0L+2*N3
    sta R0L+2*N3
    bcc symplus01
    inc R0L+2*N3+1
symplus01
    rts

;--------------------------------------------------------------
#if 0
name=BLOOM#
stack=( -- n )
tags=ext,nosymbol
The Bloom filter tries to answer the question, 'is this word a number?'

The string under consideration is pointed to by (N3) with a length of N8.

Generate a hash of a string, in the range 0..63, used as an index into the
sparsely populated `bloom` 8-byte bitfield.

A `true` bloom filter bit means, this word might be in the dictionary
A `false` bit means, this word is not present

`create` turns on the `bloom` bit for each new name
`forget` completely rebuilds the `bloom` filter

#endif
bloomhash
    ldy R0L+2*N8                ; length
    lda #0
    sta z
bloomhash01
    lda (R0L+2*N3),y
    eor #$30
    cmp #9
    bcs bloomhash02
    adc z
    sta z
bloomhash02
    dey
    bne bloomhash01
    lda z
    and #$3F                    ; width of the filter is 64 bits
    jmp pushya

;--------------------------------------------------------------
#if 0
name=BLOOMFILTER
stack=( -- mask addr )
tags=nfa,dictionary,nosymbol

Returns a `mask`/`addr` pair suitable for `cbit!` or `cbit@`

```
: bloom!   ( -- mask addr )
    bloom# bloom >bit ;
```
#endif
#include "align.i65"
_bloomfilter
    jsr enter
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word bloom
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PEARSON#
stack=( -- pearsonhash )
tags=ext,nfa,nosymbol
Return the hash value for name field address at N3
`pearson#` is the 4-bit thread index (0..F)

This hash is used to divide the entire symbol table into
16 roughly equal-sized lists called "threads".  The Ruby
script `pearson.rb` is used to generate 8 initial values
from the base dictionary, so if you feel a need to come
up with your own numbers after adding to the common wordlist,
there's the tool.

the Pearson hash should return an evenly distributed
value between $00-$0F based on the values generated from
the core dictionary.  In other words, all 16 threads
are initially balanced with the same number of words,
to reduce searches to (on average) 1/16th of the
dictionary.

```
symbol table entry
+---------------+
|    CFA[low]   |  -2      Code field address
|    CFA[high]  |
+-+-+-+-+-+-+-+-+
|     [   len   ]  NFA     Length field
[S]             |          Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?  vocab id     ?  +len+1  Vocabulary ID (if V bit set)
+---------------+
```

2017-09-20 this is just AND #$0F, not Pearson hash anymore, so vestigial label.
#endif
pearsonhash
    ldy #1
    lda (R0L+2*N3),y    ; [5]
    and #$0F
    jmp push0a

;--------------------------------------------------------------
#if 0
name=UNSMUDGE
stack=( nfa -- )
tags=compiler,nosymbol
Turn off the smudge bit so it can be found by [[FIND]].  In
PETTIL, the smudge bit does double duty, also deactivating any
words that have been [[REDEFINED]].

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
#endif
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler,nosymbol
Turn on the smudge bit.  Smudged names won't be found by FIND.
In PETTIL, the smudge bit does double duty, also marking as
inactive any names that have been [[REDEFINED]].
#endif
smudge
    sec
    ;
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=(>NAME)
stack=( cfa -- nfa|0 )
tags=compiler,nosymbol

~ deprecate
#endif
ptoname
    ldy #$FE
ptoname02
    dec R0L+2*N3+1
    lda (R0L+2*N3),y
    inc R0L+2*N3+1
    eor tos-$FE,y
    bne ptoname05
    iny
    bne ptoname02
    lda R0L+2*N3
    ldy R0L+2*N3+1
ptoname04
    jmp put
ptoname05
    ldy #0
    lda (R0L+2*N3),y
    beq ptoname04
    jsr sympluss                ; next!
    bne ptoname                 ; bra

;--------------------------------------------------------------
#if 0
name=>NAME
stack=( cfa -- nfa|0 )
tags=compiler
* search the dictionary for a given `cfa` and
* return the `nfa` if found, else `0`
* honors the smudge bit

```
: >name   ( cfa -- nfa|0 )
    sym0
    begin
        name> over <>
        sym.len and
    while
        3 sym+
    repeat
    name> nip ;
```
#endif
#include "align.i65"
_toname
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word ptoname
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(FILTER).REWIND
stack=( -- )
tags=interpreter,nfa,nosymbol
Rewinds to beginning of symbol table on each loop iteration

```
: (filter).rewind   ( -- )
    <n6 >n3 drop ;
    <n4 0=
    if  <n5 <n7 2+ !+ >n5 drop
    then ;
```


#endif
pfilterrewind
    brk
    .byt ld | N6                ; get `sym0`
    .byt st | N3                ; rewind the symbol list
    .byt ld | N4                ; contains either `newdp`(pass1) or `0`(pass2)
    .byt bnz , <(pfilterrewind02-*-2) ; check 'pass' flag
    .byt ld | N7
    .byt inr | ACC
    .byt inr | ACC              ; thread points to 1st NFA of each thread
    .byt std | N5               ; write thread start addresses on pass2
pfilterrewind02
    .byt nxt

;--------------------------------------------------------------
#if 0
name=SWAP.73
stack=( -- )
tags=interpreter,nfa,nosymbol

~deprecate
Switches contents of N7 <--> N3
#endif
#include "align.i65"
swap73
    lda #>(next-1)
    pha
    lda #<(next-1)
    pha
swap73s
    lda R0L+2*N7
    ldy R0L+2*N3
    sta R0L+2*N3
    sty R0L+2*N7
    lda R0L+2*N7+1
    ldy R0L+2*N3+1
    sta R0L+2*N3+1
    sty R0L+2*N7+1
    rts

;--------------------------------------------------------------
#if 0
name=EXT-UNTIL
stack=( -- )
tags=ext,immediate,compiler,nosymbol
This (poorly named) word wraps a BEGIN-UNTIL loop around a `cfa` called
via the `r11` register, like PETTIL Sweet16's `ext` instruction.  The
injected function needs a stack signature of ( -- flag ) that is
`true` when finished.

1. write your filter function to do what it needs to do to each of the things
2. set up registers the filter function needs
3. set R11 to point to your filter function
4. `ext-until`
5. profit!

#endif
#include "align.i65"
_extuntil
    jsr enter
#include "page.i65"
extuntil01                      ; begin
    .word doextreg
#include "parm.i65"             ;  ( flag )
    .word qbranch               ; until
    .byt <(extuntil01-*+1)
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(SEEK)
stack=( thread -- flag )
tags=interpreter,primitive,nosymbol
Search a segment of the dictionary

end of list
    nfa 0 true
found
    cfa -1|1 true
not found
    vocabs+ false


#endif
pseek
    brk
    .byt ldd | TOS
    .byt st | N3                ; `n3` is start of thread
    .byt rtn
pseekb
    lda R0L+2*N4+1              ; toggle sorted/unsorted flag in `n4h`
    eor #$FF
    sta R0L+2*N4+1              ; sorted = 0; unsorted = $FF
pseek00
    jsr symlens
    beq pseek08                 ; reached `symtail`? not found!
    eor R0L+2*N4
    beq pseekok1                ; same length? consider further...
    bit R0L+2*N4+1
    bmi pseek01                 ; unsorted list? next!
    lda R0L+2*N8
    cmp R0L+2*N4                ; length.current > length.seeking?
    bcs pseek08                 ; not found on sorted list!
pseek01
    jsr sympluss                ; next!
    bne pseek00                 ; bra
pseekok1
    ;ldy #0                     ; thanks, symlens
    lda (R0L+2*N3),y
    bmi pseek01                 ; smudged? next!
    ldy R0L+2*N4
    iny
    lda R0L+2*N5                ; compare vocabularies
    bcc pseek04b
    .byt $2C
pseekok2
    lda (R0L+2*N7),y            ; `n7` name we are looking for
pseek04
    eor (R0L+2*N3),y            ; `n3` current name under consideration
pseek04b
    bne pseek01                 ; different symbol? next!
pseek05
    dey
    bne pseekok2
pseek07
    clc                         ; found, false (inverted flag)
    .byt $29                    ; AND imm opcode
pseek08
    sec                         ; not found, true
pseek09
    ;
    jmp putc

;--------------------------------------------------------------
#if 0
name=>THREAD
stack=( symtab -- thread )
tags=interpreter,forth-83,nosymbol
Returns `true` if there is a next vocabulary
#endif
tothread
    ldy #1
    lda (R0L+2*N7),y            ; use `nfa` in `n7`, get first character
    and #$0F                    ; simplified replacement for Pearson hash
    asl                         ; *2
    sta tos                     ; `symtab` always at a page boundary
    jmp next

;--------------------------------------------------------------
#if 0
name=IMMEDORNOT
stack=( true -- -1|+1 )
tags=interpreter,forth-83,nosymbol
Returns +1 if the immediate bit is set on current `nfa`
Otherwise returns -1
#endif
immedornot
    ldy #0
    lda (R0L+2*N3),y            ; length/flags of curr `nfa`
    and #$20                    ; immediate?
    lsr
    lsr
    lsr
    lsr                         ; divide by 16, $02 when immediate
    jmp nplus                   ; add 0 or 2 to tos

;--------------------------------------------------------------
#if 0
name=NEXTVOCAB?
stack=( -- flag )
tags=interpreter,forth-83,nosymbol
Return `true` if there is a next vocabulary

#endif
nextvocabq
    brk
    .byt ld | N5
    .byt push
    .byt ldi | N6
    .byt st | N5
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(FOUND?)
stack=( name vocabs -- )
tags=interpreter,forth-83,nosymbol
set up Sweet16 registers for `found?`


|register|contents|h
|n3|name|
|n4|len|
|n5|vocabid|
|n6|vocabs|
|n7|name|
|n8|len|
#endif
pfoundq
    brk
    .byt ld | N8                ; `n4` `n8` len
    .byt st | N4
    .byt ld | TOS
    .byt st | N6                ; vocabs
    .byt inr | N6
    .byt ldi | N6
    .byt st | N5                ; first vocab
    .byt pull
    .byt st | N7                ; name
    .byt st | N3                ; name
    .byt pull
    .byt nxt

;--------------------------------------------------------------
#if 0
name=FOUND?
stack=( nfa -- xfa flag )
tags=interpreter,forth-83,nosymbol
This replaces the Forth-83 standard word `find`, idea from Albert van der Horst
in comp.lang.forth

starting with the most recently added to `vocabs`
for each vocabulary
    try searches in this order
        word+trialvocabid `symnew`
        word+trialvocabid `symtab`
until vocabulary was (0)forth
if still not found, 0

* search order
** begin
** each vocab
** symnew .. symtail, unsized
** while not found
** symtab thread, sized
** while not found
** until vocab was 0
** exit

|^`nfa`|^the `name` we are looking for<br/>(e.g. counted string in `tib` buffer)|<|
|^`xfa`|^`flag`|<|
|nfa|0|not found|
|cfa|-1|found normal word|
|cfa|+1|found immediate word|

|^`forth editor assembler`<br/>`vocabulary tools`<br/>`tools definitions`<br/>|<|<|<|
|>|Search order example|<|<|h
|1|`tools` vocabulary|`symtail`|unsorted|
|2|`tools` vocabulary|`thread`|sorted|
|3|`assembler` vocabulary|`symtail`|unsorted|
|4|`assembler` vocabulary|`thread`|sorted|
|5|`editor` vocabulary|`symtail`|unsorted|
|6|`editor` vocabulary|`thread`|sorted|
|7|`core` vocabulary|`symtail`|unsorted|
|8|`core` vocabulary|`thread`|sorted|
|9|not found|<|<|

`core` is always the last vocabulary searched.  A name/vocabulary combination
is `unique` meaning it has at most one active symbol.  Prior copies of
redefined symbols remain in the symbol table, smudged. Smudged words are
ignored (not a match) by `found?`

```
: found?   ( name -- xfa flag )


        for the nfa(n7) in `symnew` list (ordered by age)
    calculate pearson hash for word if it were in this vocabulary
    get thread start
    search for the nfa(n7) in `symtab` list (ordered by length)
    search for the nfa(n7) in `sym

: found?   ( nfa -- xfa flag )
    vocabs (found?) bloomfilter cbit@
    if
        symnew (seek)
        if
            symtab @ >thread (seek)
        if
            nextvocab
        repeat
        '(seek) init.411
    bloomfilter cbit@
    if  vocabs c@+ symnew @
        set.76 swap73
        ext-until ?exit
        1- c@+
: found?   ( name -- xfa flag )
    vocabs (found?) bloomfilter cbit@
    if
        symnew (seek)
        if
            symtab @ >thread (seek)

```
#endif
#include "align.i65"
_foundq
    jsr enter
#include "page.i65"
    .word vocabs
#include "page.i65"
    .word pfoundq
#include "page.i65"
    .word _bloomfilter          ; sum of decimal digits in name % 64
#include "page.i65"
    .word cbitfetch
#include "parm.i65"
    .word qbranch               ; if
    .byt <(found04-*+1)
#include "pad.i65"
foundq01                        ;     begin (loop through vocabs)
    .word symnew
#include "page.i65"
    .word pseek                 ; returns inverted found? flag
#include "parm.i65"
    .word qbranch               ;     while (branches if found)
    .byt <(foundq03-*+1)
#include "pad.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word tothread
#include "page.i65"
    .word pseek
#include "parm.i65"
    .word qbranch               ; inverted flag, so branch if found
    .byt <(foundq03-*+1)
#include "pad.i65"
    .word nextvocabq
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qbranch               ; loop if more vocabs
    .byt <(foundq01-*+1)
#include "parm.i65"
found04                         ; then
    .word zpfrom
    .byt R0L+2*N7               ; original `nfa`
#include "pad.i65"
    .word false                 ; and nope, this name was not found
#include "past.i65"
    .word exit

#include "parm.i65"
foundq03                        ; found it
    .word zpfrom
    .byt R0L+2*N3               ; the CFA
#include "pad.i65"
    .word namefrom
#include "page.i65"
    .word true                  ; assume it's a normie -1
#include "page.i65"
    .word immedornot            ; maybe add 2 if it's immediate
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EXISTS?
stack=( -- addr flag )
tags=interpreter,ext
parses the next token in the input stream.  Returns either the
address of the (unfound) token at HERE and a 0, or the code
field address of the word and -1 for normal, +1 for immediate
words

```
: exists?
   bl word ?dup ?: found? 0 and ;
```
#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word pquerycolon
    .word _foundq
    .word zero
#include "pad.i65"
    .word andx
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name='
stack=( -- cfa )
tags=forth-83
Parse the next token in the input stream and search for it,
returning the CFA if successful.  Otherwise aborts with the
message "NOT FOUND"

```
: '   ( "name" -- cfa )
    exists? dup 0=  3 ?error ;
```
#endif
#include "align.i65"
_tick
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qerror
    .byt 3                      ; NOT FOUND
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CREATE)
stack=( cfa -- )
tags=compiler,nosymbol
Create a new symbol in the symbol table

```
: (create)   ( cfa -- )
    eol? 4 ?error                       \ "MISSING NAME"
    redefined off                       \ no need to set the bloom bit first
    exists? ?dup
    if                                  ( cfa )
        <n7 dup redefined !
        .rvs  $. ."  [OFF]exists "
    then                                ( cfa )
    bloom                               ( symtail 2+ )
    current
    2swap over cfa,
    sym0 here 3- ((create))
    3coff dup smudge newest !
    false (seekb)
    if
        unsmudge
    else
        <n3 dup redefined !
        RVSON emit
        id. ." exists{OFF}"
    then ;
```
#endif
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qerror
    .byt 4                      ; MISSING NAME
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word off
#include "page.i65"
    .word _existsq
#include "parm.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word store
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N7
#include "pad.i65"
    .word dotrvs
#include "page.i65"
    .word _stringdot
#include "parm.i65"
    .word _pdq
    .byt <(pcreate01-*-1)
    .asc RVSOFF," EXISTS"
pcreate01
#include "pad.i65"
pcreate02
    .word bloom                         ; aka `symtail` +2
#include "page.i65"
    .word current
#include "page.i65"
    .word rot
#include "page.i65"
    .word _qalign
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word newest
// CFA may move up one byte if $EA was enclosed (for paging)
//
#include "past.i65"
    .word *+2
    jsr harvests6
// tos=newest n0=symtail+2 n1=current n2=here
// * copy symbol @n7 to symtail
// * enclose 'here' as new CFA
// * current nonzero?
//      - set vocabulary bit
//      - append `current` at symtail
// * drop out a 00 00 00    symtail `3coff`
// * update symtail
// * set newest
    brk
    .byt popd | N0               ; symtail @
// N0 = usersymtail ACC = symtail
    .byt st | N3
    .byt ld | N2                ; cfa'
    .byt std | N3               ; write CFA to symtab, +2 N5 pointer
    .byt ld | N3
    .byt std | TOS              ; populate `newest`
    .byt ext
    .word swap73s
    .byt ext
    .word symcopys              ; copy the symbol/length
    .byt ldi | N1
    .byt bz , <(ppcreate01-*-2)
    .byt set | ACC
    .word $40
ppcreate01
    .byt st | TOS               ; TOS = $00 or $40 if vocab
    .byt inr | N7
    .byt pop | N7
    .byt st | N5
    .byt add | TOS
    .byt sti | N7               ; symbol length with a proper vocab bit
    .byt ld | N7
    .byt add | N5
    .byt st | N7
    .byt pop | N1
    .byt bz , <(ppcreate02-*-2)
    .byt sti | N7
ppcreate02
    .byt ld | N7
    .byt std | N0               ; update symtail
    .byt sub | ACC
    .byt sti | N7
    .byt std | N7
    .byt pull
    .byt rtn
    jmp exit

;--------------------------------------------------------------
#if 0
name=?VMMOVE
stack=( newsymtab -- )
tags=ext,nosymbol
* if `#blk` nonzero, move `vmbuf` area

```
: ?vmmove   ( newsymtab -- )
    #blk @
    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
     vmbuf !
    symtab ! ;
```
    jsr harvests4               ; grab just b/buf & vmbuf, leave newsymtab next
    brk
    .byt ldd | TOS              ; #blk@
    .byt st | TOS               ; if we leave abruptly, don't +MOVE anything
    .byt bz , <(qvmmovemagic01-*-2)
    .byt pull                   ; newsymtab
    .byt st | N2                ; put it somewhere safe, for now
    .byt sub | N6               ; old `symtab`

    ;~wut? more to do here, to support moving `vmbuf`

                                ; no blocks in VM buffer to worry about here
                                ; not much to do either, really
qvmmovemagic01
    .byt rtn
plant4
    ldy #4
    jmp plant






```
: ?vmmove   ( newsymtab -- )
    #blk @
    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
     vmbuf !
    symtab ! ;


: ?vmmove   ( newsymtab -- )
    vmbuf
    b/buf
    #blk
    (?vmmove).magic             ( newsymtab newvmbuf from to delta flag )
    ?: +move 3drop
    vmbuf !
    symtab ! ;

;(?vmmove).magic   ( newsymtab vmbuf b/buf #blk -- newvmbuf newsymtab )
qvmmovemagic
    jsr locals4                 ; grab just b/buf & vmbuf, leave newsymtab next
    brk
    .byt ldd | TOS              ; #blk@
    .byt st | TOS               ; in case must leave abruptly, don't +MOVE anything
    .byt bz , <(qvmmovemagic01-*-2)
    .byt pull                   ; newsymtab
    .byt st | N2                ; put it somewhere safe, for now
    .byt sub | N6               ; old `symtab`


                                ; no blocks in VM buffer to worry about here
                                ; not much to do either, really
qvmmovemagic01
    .byt rtn
    ldy #4
    jsr restack
    jmp next



    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
```
#endif
#include "align.i65"
_qvmmove
    jsr enter
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(AUTOMEM)
stack=( ~wut? )
tags=ext,nosymbol
Figure out where the new symbol table will be located, runs in between
PASS1 and PASS2 of (FORGET)
( start actualsize -- start actualsize studio-newsize )
~wut? If VMBUF has buffers loaded, they are moved by (AUTOMEM)

: (automem)
    user0studio @ over - $FF00 and benjamin - ;



Automatically move symbol table and vmbuf to someplace that

pad pass1end -                  negative size of symbol table
studio +                        new `symtab` is `size` bytes below studio
ff00 and                        include remainder of the page
256 -                           include one more page
--------------
'some room'                     `symtab`


`n7` points to the null at the end of the sorted-by-size symbol
table copy at `pad`
* calculate `n7` - `pad`
** pass1 symbol table size
** 1 byte larger per entry because PEARSON#

```
: (automem)   ( pad+3 -- pad+3 symtab )
    (automem).init              \ set `dp`, calculate new `symtab`
    dup 32 +under
    symtab #blk @
    if ?movevmbuf then
    ! (automem).phase2 ;

(automem)
studio
inline ; brk ; ldd tos ; st n5
pull ; sub n7 ; add n5 ; push
sub acc ; std n7 ; sti n7 ; rtn
lda #0 ; sta tos
dec tos+1 ; jsr toforth
>n5 dup bl +under symtab
#blk @ if ?vmmove then
! ;


: (automem)
    user0studio @ over - $FF00 and benjamin - ;
```
#endif
#include "align.i65"
_automem
    jsr enter
#include "page.i65"
    .word studio
#include "page.i65"
    .word *+2                   ; `[ assembler here 2+ xt,  brk, tos ldd, ...`
    brk                         ;( 16 0 pad+3 studio )
    .byt ldd | TOS              ;( 16 0 pad+3 studio+2 )
    .byt st | N5
    .byt pull
    .byt sub | N7               ; negated size of interim symtab
    .byt add | N5               ; new size subtracted from studio, will round
    .byt push                   ; down to $FF00 AND
    .byt sub | ACC
    .byt std | N7               ; append end-of-symbols marker
    .byt sti | N7
    .byt rtn
    lda #0
    sta tos                     ; &= $FF00
    dec tos+1                   ; <-- ~#resizestudio startup code area here
;    dec tos+1                   ; -= $0200 leave 'some room'
#include "align.i65"
    jsr toforth                 ; `>forth jsr, forth ] >n5 dup ...`
#include "parm.i65"
    .word tozp
    .byt R0L+2*N5
#include "pad.i65"
    .word dup
#include "page.i65"
    .word bl                    ; 32
#include "page.i65"
    .word plusunder             ;( 16 0 pad+3 $5920 $5900 )
#include "page.i65"
    .word symtab
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch                 ;( 16 0 pad+3 $5920 $5900 symtab #blk )
#include "parm.i65"
    .word qbranch
    .byt <(automem01-*+1)
#include "pad.i65"
    .word _qvmmove              ; need to move vm buffer before symtab !
#include "page.i65"
automem01
    .word store                 ; set symtab
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=>PASSBIT
stack=( index -- flag )
tags=interpreter,nfa,nosymbol

```
: >passbit   ( index -- addr mask )
    passbits >bit ;
```
#endif
#include "align.i65"
_topassbit
    jsr enter
#include "page.i65"
    .word passbits
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSBITS?
stack=( index -- flag )
tags=interpreter,nfa,nosymbol

```
: passbits?   ( index -- flag )
    passbits >bit cbit@ ;
```
#endif
#include "align.i65"
_passbitsq
    jsr enter
#include "page.i65"
    .word _topassbit
#include "page.i65"
    .word cbitfetch
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSBITS!
stack=( index -- )
tags=interpreter,nfa,nosymbol

```
: passbits?   ( index -- flag )
    passbits >bit cbit@ ;
```
#endif
#include "align.i65"
_passbitsstore
    jsr enter
#include "page.i65"
    .word _topassbit
#include "page.i65"
    .word cbitstore
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(UNREMEMBER)
stack=( cfa -- )
tags=nfa,ext,nosymbol


sym0
for j = 0 to F                          \ thread
    for i = 1 to 31                     \ length
    begin                               \ copy all sorted symbols: thread,length
        symlen i =                      \ get length @(n3)
    while                               \ is (length = i) ?
      ??? ???                   \ copy the symbol from @n3
        sym+                            \ next sorted symbol
    repeat
    save n3
    save what is the length now?
    n3 = symnew
    begin                               \ append unsorted symbols: thread,length
        is the length the same?
        if
            is the thread the same?
            if
                copy the symbol
            then
        then
        sym+
        are we at the symtail?
    until


symtab @ 34 +
 0 symthread is pointer2sorted
for j = 0 to F                          \ thread
    for length=1 to 31                  \ length
        begin
            length(pointer2sorted) = i?
        while
            check CFA and copy it
            advance pointer2sorted
        repeat
        symnew is pointer2unsorted
        begin
            length(pointer2unsorted) = i?
        while
            thread(pointer2unsorted) = j?
        while
            check CFA and copy it
            end of list?
        until
    next length
next thread
calculate size



: southerly ( cfa -- cfa )
    sym0
                                        ( cfa )
    \ symbols are copied to pad, sort
    \ by thread 0..F,  by length 1..31
    16 0 do
        31 1 do
            i j ?gosouth?

            newdp @ studio @  <n3 name> between?  0=


            symnew @ =n3

            check-symnew
        loop
    loop

            if keepit then

            \ cfa < studio?  no: keep it
            <n3 name> studio @ <  0=
            \ cfa < newdp?  yes: keep it
            <n3 name> newdp @ <
* rebuild and reindex the entire dictionary
* rebalance it into 16 roughly equal-sized threads
** thread key is the low four bits of the first character in the name.
* Merge in newly created names from `symnew .. symtail`
** that have been defined since startup
** or the last `(unremember)`.
* `bloom` filter will be repopulated
!!!!PASS1
* initialize output pointer to `pad`
* for each of 16 threads:
*   for each of 31 lengths:
*     copy from `j symthread` to output until `i <> symlen`
*
* scan & copy
* for each word < `cfa` stack parameter
* copy smudged words too
* Words with a CFA >= `cfa` stack parameter are discarded
** when a word is discarded, if a predecessor (with the smudge bit set) exists:
** AND the CFA of the predecessor is < `cfa` stack parameter
*** unsmudge it
!!!!PASS2

A new `symtab`
address will be calculated at halftime.  After the second phase, the `symnew`
 list will be empty once again.


;    .word bloom                 ; cfa bloom )
;    .word eight                 ; cfa bloom 8 )
;    .word erase                 ; reset the Bloom filter
;    .word passbits              ; cfa passbits )
;    .word blit                  ; cfa passbits %1000_0000 )
;    .byt $80
;    .word _storeplus            ; cfa passbits+2 )
;    .word off                   ; passbits = %1000 0000 0000 0000
;    .word dlit
;    .word $FFFF
;    .word _pforgetpass1         ; >r11
;    .word init411


```
: (unremember)   ( cfa -- )
    sym0 bl 0 pad

    bloom 8 erase

    passbits $80 !+ off
    (forget).pass1 (filter)!
    32 0  sym0 pad
    (forget).looper             \ does `ext-until` 32x, completing pass1

    passbits on
    (forget).pass2 (filter)!
    16 0  pad 3+ (automem)
    (forget).looper             \ does `ext-until` 16x, completing pass2
```
#endif
#include "align.i65"
_punremember
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word bl                    ; 32 )
#include "page.i65"
    .word zero                 ; 32 0 ) \ factored into `(forget).looper`
#include "page.i65"
    .word _pad
#include "page.i65"
;    .word pforgetlooper         ; this is it. performs all of pass1
#include "page.i65"
    .word passbits
#include "page.i65"
    .word on                    ; passbits = %1111 1111 1111 1111
#include "parm.i65"
    .word dlit
    .word 0                     ; pass2 flag
;    .word _pforgetpass2         ; >r11
;#include "pad.i65"
;    .word init411
#include "parm.i65"
    .word blit
    .byt 16
;#include "pad.i65"
;    .word zero
#include "page.i65"
    .word _pad                  ; the new sym0
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word _automem              ; does things, returns the new targ
#include "page.i65"
;    .word pforgetlooper         ;( do eet! again! )
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
;    .word symtail
#include "page.i65"
;    .word symtailstore
#include "page.i65"
;    .word symnew
#include "page.i65"
;    .word symtailstore
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UNREMEMBER
stack=( "name" -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, sorts symbol table, keeping only words below the CFA of the named word

```
: forget   ( "name" -- )
    '  dup  fence @  u<  7 ?error
    (unremember) ;
```
#endif
#include "align.i65"
_unremember
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "parm.i65"
    .word qerror
    .byt 7                      ; CAN'T FORGET BELOW FENCE
#include "pad.i65"
    .word _punremember
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REHASH
stack=( -- )
tags=interpreter,extension
Rebuild the [[dictionary]].  This may be necessary during long code builds
as the dictionary eventually overgrows the region of memory between `symnew`
and `studio`

Since `symtab` always aligns on a page boundary, after `rehash` completes,
there will be one page plus whatever space is available on the final page
of the rebuilt symbol table.  This dictionary expansion space is less generous
than the initial helping after `cold` start, before another `rehash` is
required.

* these are synonymous:
** `rehash`
** `forget forget`
** `forget :` (or any word with a CFA in the `studio` region)
** `here (unremember)`

```
: rehash  ( -- )
    here (unremember) ;   \ effectively a `forget nothing` command
```
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _punremember
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORTH
stack=( -- )
tags=vocabulary,forth-83
Reset the vocabulary search order to just CORE.  Equivalent to
`ONLY FORTH` in ANS Forth

```
: forth   ( -- )
    vocabs 12 erase ;
```
#endif
#include "align.i65"
_forth
    jsr enter
#include "page.i65"
    .word vocabs
#include "page.i65"
    .word count
#include "page.i65"
    .word erase
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEFINITIONS
stack=( -- )
tags=forth-83
Sets the compilation vocabulary by copying the first vocabulary in
the [[VOCABS]] search order to [[CURRENT]].

#endif
#include "align.i65"
definitions
    lda uservocabs+1
    sta usercurrent
    jmp next
