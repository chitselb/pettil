; pettil-dictionary.a65
;#echo .       pettil-dictionary.a65     Dictionary

;--------------------------------------------------------------
#if 0
name=SYMTAB!
stack=( studio start size -- studio start symtab size )
tags=system,startup,nosymbol
Calculate `symtab` memory requirements, given a size

#endif
symtabset
    dex
    lda stackh+2,x
    clc
    sbc tos+1
    sta stackh,x
    sta usersymtab+1
    lda #32
    sta stackl,x
symtabset99
    jmp next

;--------------------------------------------------------------
#if 0
name=>SYMS
stack=( -- nfa )
tags=interpreter,ext,nosymbol
Returns `nfa` of first symbol in the `symbol table`

#endif
#include "align.i65"
tosyms
    lda #34
    ldy usersymtab+1
    jmp pushya

;--------------------------------------------------------------
#if 0
name=-@
stack=( nfa -- cfa )
tags=extra
decrement `tos` and fetch the value

#endif
minusfetch
;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

```
: name>   ( nfa -- cfa )
    2- @ ;
```
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=SYM.REWIND
stack=( -- )
tags=nfa,nosymbol
set `n3` to the first symbol in the (sequential) `symtab`

#endif
#include "align.i65"
symrewind
    lda usersymtab+1
    sta R0L+2*N3+1
    lda #34
    sta R0L+2*N3
    bne symtabset99

;--------------------------------------------------------------
#if 0
name=SYM.LEN
stack=( -- len )
tags=nfa,nosymbol
Return length information about the `nfa`  `n3`

`visible length` means the length of the name when you type it.
The carry flag indicates whether a `vocabid` follows the `name`

C = vocabid?
A,N8L = visible length
Y = 0
#endif
symlen
    lda #>(pushya-1)
    pha
    lda #<(pushya-1)
    pha
;--------------------------------------------------------------
#if 0
name=SYMLENS
effects=A:len;Y:0;C:vocab?;Z:len
tags=nfa,nosymbol
6502registers=A:symlen Y:0 C:vocab Z:symlen
Sweet16registers=N3:nfa N8:length
return the length of the current `nfa` stored in `n3`

#endif
symlens
    ldy #0              ;{2 {=23}}
    lda R0L+2*N3+1              ; length = 0 if `n3` is 0
    beq symlens01
    lda (R0L+2*N3),y    ;{5}    ; length/flags
symlens01
    pha                 ;{3}    ; not using tay/tya preserves Y=0
    asl                 ;{2}
    asl                 ;{2}    ; Vocab bit to C flag
    pla                 ;{4}
    and #$1F            ;{2}    ; length
    sta R0L+2*N8        ;{3}    ; N8L = visible length (omit vocab +1)
    rts

;--------------------------------------------------------------
#if 0
name=SYMCOPY
stack=( -- )
tags=ext,primitive,nfa,nosymbol

* N3 (curr) symbol to N7 (targ) symbol
* copy vocab byte
* copy text
* copy length/flags
* does not move N7, does not move N3 either

~evaluate
#endif
symcopy
    lda #>(next-1)
    pha
    lda #<(next-1)
    pha
symcopys
    jsr symlens
    adc #0
    tay
symcopy01
    lda (R0L+2*N3),y
    sta (R0L+2*N7),y
    dey
    bpl symcopy01
    rts

;--------------------------------------------------------------
#if 0
name=SYM+
stack=( -- )
tags=ext,primitive,nfa,nosymbol
registers=Z:false
* move N3 to the next symbol
compiled with an inline value following the CFA
to specify a constant per-symbol offset

#endif
symplus
    jsr topfas
    jsr sympluss
    jmp pad0

sympluss
    sta R0L+2*ACC
    jsr symlens                 ; A=len C=vocab
    adc R0L+2*ACC
    adc R0L+2*N3
    sta R0L+2*N3
    bcc symplus01               ; always nonzero
    inc R0L+2*N3+1              ; always nonzero
symplus01
    rts                         ; Z=0 or fail!

;--------------------------------------------------------------
#if 0
name=BLOOM#
stack=( -- n )
tags=ext,nosymbol
The Bloom filter tries to answer the question, 'is this word a number?'

The string under consideration is pointed to by (N3) with a length of N8.

Generate a hash of a string, in the range 0..63, used as an index into the
sparsely populated `bloom` 8-byte bitfield.

A `true` bloom filter bit means, this word might be in the dictionary
A `false` bit means, this word is not present

`create` turns on the `bloom` bit for each new name
`forget` completely rebuilds the `bloom` filter

#endif
bloomhash
    ldy R0L+2*N8                ; length
    lda #0
    sta z
bloomhash01
    lda (R0L+2*N3),y
    eor #$30
    cmp #10
    bcs bloomhash02
    sec
    adc z
    sta z
bloomhash02
    dey
    bne bloomhash01
    lda z
    and #$3F                    ; width of the filter is 64 bits
    jmp pushya

;--------------------------------------------------------------
#if 0
name=BLOOMFILTER
stack=( -- mask addr )
tags=nfa,dictionary,nosymbol

Returns a `mask`/`addr` pair suitable for `cbit!` or `cbit@`

```
: bloomfilter   ( -- mask addr )
    bloom# bloom >bit ;
```
#endif
#include "align.i65"
_bloomfilter
    jsr enter
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word bloom
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PEARSON#
stack=( nfa -- pearsonhash nfa )
tags=ext,nfa,nosymbol
tuck the hash value for name field address at N3
`pearson#` is the 4-bit thread index (0..F)

This hash is used to divide the entire symbol table into
16 roughly equal-sized lists called "threads".  The Ruby
script `pearson.rb` is used to generate 8 initial values
from the base dictionary, so if you feel a need to come
up with your own numbers after adding to the common wordlist,
there's the tool.

the Pearson hash should return an evenly distributed
value between $00-$0F based on the values generated from
the core dictionary.  In other words, all 16 threads
are initially balanced with the same number of words,
to reduce searches to (on average) 1/16th of the
dictionary.

```
symbol table entry
+---------------+
|    CFA[low]   |  -2      Code field address
|    CFA[high]  |
+-+-+-+-+-+-+-+-+
|     [   len   ]  NFA     Length field
[S]             |          Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?  vocab id     ?  +len+1  Vocabulary ID (if V bit set)
+---------------+
```

2017-09-20 this is just AND #$0F, not Pearson hash anymore, so vestigial label.
#endif
pearsonhash
    ldy #1
    lda (R0L+2*N3),y    ; [5]
    and #$0F
    jmp push0a

;--------------------------------------------------------------
#if 0
name=UNSMUDGE
stack=( nfa -- )
tags=compiler,nosymbol
Turn off the smudge bit so it can be found by [[FIND]].  In
PETTIL, the smudge bit does double duty, also deactivating any
words that have been [[REDEFINED]].

```
symbol table entry
+---------------+
|   CFA[low]    |  -2      Code field address
|   CFA[high]   |
+-+-+-+-+-+-+-+-+
[S]             |  NFA     Smudge bit
| [V]           |          Vocabulary bit
|   [I]         |          Immediate bit
|     [   len   ]          Length field
+-+-+-+-+-+-+-+-+
|   name[1]     |  +1      Name field
|           ... |
|   name[len]   |  +len
+---------------+
?   vocabid     ?  +len+1  Vocabulary token (if Vocab bit set)
+---------------+
```
#endif
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
;--------------------------------------------------------------
#if 0
name=SMUDGE
stack=( nfa -- )
tags=compiler,nosymbol
Turn on the smudge bit.  Smudged names won't be found by FIND.
In PETTIL, the smudge bit does double duty, also marking as
inactive any names that have been [[REDEFINED]].
#endif
smudge
    sec
    ;
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop

;--------------------------------------------------------------
#if 0
name=(>NAME)
stack=( cfa -- nfa|0 )
tags=compiler,nosymbol

Compare the provided CFA(N4) vs. CFA of current NFA in (N3)

```
: (>name)   ( cfa -- nfa|0 )

```
#endif
#include "align.i65"
ptoname
    ldy #$FE
ptoname02
    dec R0L+2*N3+1
    lda (R0L+2*N3),y
    inc R0L+2*N3+1
    eor tos-$FE,y
    bne ptoname05
    iny
    bne ptoname02
    lda R0L+2*N3
    ldy R0L+2*N3+1
ptoname04
    jmp put
ptoname05
    ldy #0
    lda (R0L+2*N3),y
    beq ptoname04
    lda #3
    jsr sympluss                ; next!
    bne ptoname                 ; bra

;--------------------------------------------------------------
#if 0
name=>NAME
stack=( cfa -- nfa|0 )
tags=compiler
Returns the Name Field Address (`nfa`) of a given word, or 0
if the provided Code Field Address (`cfa`) wasn't found in the
symbol table.  This word honors the smudge bit

Populates `n3` with the current `nfa`

```
: >name   ( cfa -- nfa|0 )
    >syms >n3 drop
    begin
        name> over <>
        sym.len and
    while
        3 sym+
    repeat
    name> nip ;
```
#endif
#include "align.i65"
_toname
    jsr enter
#include "page.i65"
    .word symrewind
#include "page.i65"
    .word ptoname
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SWAP.73
stack=( -- )
tags=interpreter,nfa,nosymbol
Switches contents of N7 <--> N3
#endif
#include "align.i65"
swap73
    lda #>(next-1)
    pha
    lda #<(next-1)
    pha
swap73s
    lda R0L+2*N7
    ldy R0L+2*N3
    sta R0L+2*N3
    sty R0L+2*N7
    lda R0L+2*N7+1
    ldy R0L+2*N3+1
    sta R0L+2*N3+1
    sty R0L+2*N7+1
    rts

;--------------------------------------------------------------
#if 0
name=(SEEK)
stack=( nfa -- xfa )
tags=interpreter,primitive,nosymbol
search a segment of the dictionary
                                        n2
search exits when:
end of list
    reach `symtail` (symlen = 0)        false

    found                               -1|1
        also replace nfa with cfa

    not found
    searching sorted list AND mismatched thread.id
                                        false

`n3` current nfa
`n4l` seek length
`n4h` sorted thread flag:  sorted by size (0) or unsorted ($FF)
`n5` seek vocab
`n6` next vocab address
`n7` seek nfa
`n8l` current length

#endif
pseek
    lda R0L+2*N4+1              ; toggle sorted/unsorted flag in `n4h`
    eor #$FF
    sta R0L+2*N4+1              ; sorted = 0; unsorted = $FF
pseek00
    jsr symlens
    beq pseek09                 ; reached `symtail`? not found!
    eor R0L+2*N4
    beq pseekok1                ; same length? consider further...
    bit R0L+2*N4+1
    bmi pseek01                 ; unsorted list? next!
    lda R0L+2*N8
    cmp R0L+2*N4                ; length.current > length.seeking?
    bcs pseek09                 ; not found on sorted list!
pseek01
    lda #3
    jsr sympluss                ; next!
    bne pseek00                 ; bra
pseekok1
    ;ldy #0                     ; thanks, symlens
    lda (R0L+2*N3),y
    bmi pseek01                 ; smudged? next!
    ldy R0L+2*N4
    iny
    lda R0L+2*N5
    bcs pseek04                 ; compare vocabularies
pseekok2
    dey
    beq pseek07
    lda (tos),y                 ; name we are looking for
pseek04
    eor (R0L+2*N3),y            ; `n3` current name under consideration
pseek04b
    bne pseek01                 ; different symbol? next!
    beq pseekok2
pseek07
    lda (R0L+2*N3),y            ; reget
    and #$20                    ; IMMEDIATE bit
    lsr
    lsr
    lsr
    lsr
    sta R0L+2*N2
    brk
    .byt popd | N3
    .byt st   | TOS
    .byt dcr  | N2
    .byt nxt
pseek09
    jmp next

;--------------------------------------------------------------
#if 0
name=IMMEDORNOT
stack=( true -- -1|+1 )
tags=interpreter,forth-83,nosymbol
Returns +1 if the immediate bit is set on current `nfa`
Otherwise returns -1
#endif
immedornot
    ldy #0
    lda (R0L+2*N3),y            ; length/flags of curr `nfa`
    and #$20                    ; immediate?
    lsr
    lsr
    lsr
    lsr                         ; divide by 16, $02 when immediate
    jmp nplus                   ; add 0 or 2 to tos

;--------------------------------------------------------------
#if 0
name=NEXTVOCAB?
stack=( -- flag )
tags=interpreter,forth-83,nosymbol
Return `true` if there is a next vocabulary

#endif
nextvocabq
    brk
    .byt ld | N5
    .byt push
    .byt ldi | N6
    .byt st | N5
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(FOUND?)
stack=( name vocabs -- )
tags=interpreter,forth-83,nosymbol
set up Sweet16 registers for `found?`


|register|contents|h
|n3|name|
|n4|len|
|n5|vocabid|
|n6|vocabs|
|n7|name|
|n8|len|
#endif
pfoundq
    brk
    .byt ld | TOS
    .byt st | N6
    .byt inr | N6
    .byt pull
    .byt st | N3
    .byt st | N7
    .byt ext
    .word symlens
    .byt ld | N8                ; `n4` `n8` len
    .byt st | N4
    .byt sub | ACC
    .byt st | N2
    .byt nxt

;--------------------------------------------------------------
#if 0
name=NOT.IN.THREAD?
stack=( cfa -- nfa|0 )
tags=compiler

```
: not.in.thread?   ( nfa addr -- xfa flag )
    @ n3 !                      ( nfa )
    (seek) <n2 0= ;             ( xfa flag )
```
#endif
#include "align.i65"
_notinthreadq
    jsr enter
#include "page.i65"
    .word fetch
#include "parm.i65"
    .word blit
    .byt R0L+2*N3
#include "pad.i65"
    .word store
#include "page.i65"
    .word pseek
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N2
#include "pad.i65"
    .word zeq
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FOUND?
stack=( nfa -- xfa flag )
tags=interpreter,forth-83,nosymbol
This replaces the Forth-83 standard word `find`, idea from Albert van der Horst
in comp.lang.forth

starting with the most recently added to `vocabs`
for each vocabulary
    try searches in this order
        word+trialvocabid `symnew`
        word+trialvocabid `symtab`
until vocabulary was (0)forth
if still not found, 0

* search order
** begin
** each vocab
** symnew .. symtail, unsized
** while not found
** symtab thread, sized
** while not found
** until vocab was 0
** exit

|^`nfa`|^the `name` we are looking for<br/>(e.g. counted string in `tib` buffer)|<|
|^`xfa`|^`flag`|<|
|nfa|0|not found|
|cfa|-1|found normal word|
|cfa|+1|found immediate word|

|^`forth editor assembler`<br/>`vocabulary tools`<br/>`tools definitions`<br/>|<|<|<|
|>|Search order example|<|<|h
|1|`tools` vocabulary|`symtail`|unsorted|
|2|`tools` vocabulary|`thread`|sorted|
|3|`assembler` vocabulary|`symtail`|unsorted|
|4|`assembler` vocabulary|`thread`|sorted|
|5|`editor` vocabulary|`symtail`|unsorted|
|6|`editor` vocabulary|`thread`|sorted|
|7|`core` vocabulary|`symtail`|unsorted|
|8|`core` vocabulary|`thread`|sorted|
|9|not found|<|<|

`core` is always the last vocabulary searched.  A name/vocabulary combination
is `unique` meaning it has at most one active symbol.  Prior copies of
redefined symbols remain in the symbol table, smudged. Smudged words are
ignored (not a match) by `found?`

```
: found?   ( name -- xfa flag )
    vocabs (found?)
    begin
        <n6 c@+ >n5 drop n6 !
        ldi | N6
        st | N5
        nxt

: nextvocab   ( vocab nfa -- vocab' nfa )
    swap c@+ n5 ! swap ;

: nextvoc

: (found?)    ( nfa vocabs -- nfa )
    ;
code (found?)
    brk
    ldd | TOS
    st | N6
    inr | N6
    pull
    st | N3
    nxt


true = found
false = not found
: found?   ( name -- xfa flag )
    n2 off                      \ result
    vocabs @ 1+ n6 !  >n3       ( nfa )
    bloomfilter cbit@           ( nfa flag )
    if
        begin
            <n6 c@+ n5 2!       ( nfa ) \ next vocab
            symnew              ( nfa addr )
            not.in.thread?      ( xfa  flag )
        while
            =n3 pearson# 2* symtab @ +
            >r =n3 r>           ( nfa addr )
            not.in.thread?      ( xfa flag )
        while
            <n5 0=
        until
    then <n2 ;


```
: found?   ( nfa -- xfa flag )
    n2 off  >n3
    bloomfilter cbit@ dup 0= ?exit drop
    vocabs (found?)
    begin
        <n6 c@+ n5 2!
        symnew not.in.thread?
    while
        =n3 pearson# 2* symtab @ +
        >r =n3 r> not.in.thread?
    while
        <n5 0=
    until ;
```
#endif
#include "align.i65"
_foundq
    jsr enter
#include "pad.i65"
    .word vocabs
#include "page.i65"
    .word pfoundq
#include "pad.i65"
    .word _bloomfilter          ; sum of decimal digits in name % 64
#include "page.i65"
    .word cbitfetch
#include "parm.i65"
    .word qbranch               ;     if
    .byt <(foundq03-*+1)
#include "parm.i65"
foundq01                        ;     begin (loop through vocabs)
    .word zpfrom
    .byt R0L+2*N6
#include "pad.i65"
    .word cfetchplus
#include "parm.i65"
    .word blit
    .byt R0L+2*N5
#include "pad.i65"
    .word twostore
#include "page.i65"
    .word symnew
#include "page.i65"
    .word _notinthreadq
#include "parm.i65"
    .word qbranch               ;     while
    .byt <(foundq03-*+1)
#include "parm.i65"
    .word zpex
    .byt R0L+2*N3
#include "pad.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word tor
#include "parm.i65"
    .word zpex
    .byt R0L+2*N3
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word _notinthreadq
#include "parm.i65"
    .word qbranch               ;     while
    .byt <(foundq03-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N5
#include "pad.i65"
    .word zeq
#include "parm.i65"
    .word qbranch               ;     until then
    .byt <(foundq01-*+1)
#include "parm.i65"
foundq03
    .word zpfrom
    .byt R0L+2*N2
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EXISTS?
stack=( -- addr flag )
tags=interpreter,ext
parses the next token in the input stream.  Returns either the
address of the (unfound) token at HERE and a 0, or the code
field address of the word and -1 for normal, +1 for immediate
words

```
: exists?
   bl word ?dup ?: found? 0 and ;
```
#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name            ; ~~2
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word pquerycolon
    .word _foundq
    .word zero
#include "pad.i65"
    .word andx
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name='
stack=( -- cfa )
tags=forth-83
Parse the next token in the input stream and search for it,
returning the CFA if successful.  Otherwise aborts with the
message "NOT FOUND"

```
: '   ( "name" -- cfa )
    exists? dup 0=  3 ?error ;
```
#endif
#include "align.i65"
_tick
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qerror
    .byt 3                      ; NOT FOUND
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CREATE)
stack=( cfa -- )
tags=compiler,nosymbol
Create a new symbol in the symbol table

```
: (create)   ( cfa -- )
    eol? 4 ?error               \ "MISSING NAME"
    redefined off
    \ no need to set the bloom bit first
    exists? ?dup
    if                          ( cfa )
        <n7 dup redefined !
        .rvs  $. ."  [OFF]exists "
    then                        ( cfa )
    bloom                       ( symtail 2+ )
    current
    2swap over cfa,
    >syms here 3- ((create))
    3coff dup smudge newest !
    false (seekb)
    if
        unsmudge
    else
        <n3 dup redefined !
        RVSON emit
        id. ." exists{OFF}"
    then ;
```
#endif
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qerror
    .byt 4                      ; MISSING NAME
// check for end of line
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word off
#include "page.i65"
    .word _existsq
#include "parm.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word store
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N7
#include "pad.i65"
    .word dotrvs
#include "page.i65"
    .word _stringdot
#include "parm.i65"
    .word _pdq
    .byt <(pcreate01-*-1)
    .asc RVSOFF," EXISTS"
pcreate01
#include "pad.i65"
pcreate02
    .word bloom                 ; aka `symtail` +2
#include "page.i65"
    .word current
#include "page.i65"
    .word rot
#include "page.i65"
    .word _qalign
#include "page.i65"
    .word _cfacomma
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word newest
// CFA may move up one byte if $EA was enclosed (for paging)
//
#include "past.i65"
    .word *+2
    jsr harvests6
// tos=newest n0=symtail+2 n1=current n2=here
// * copy symbol @n7 to symtail
// * enclose 'here' as new CFA
// * current nonzero?
//      - set vocabulary bit
//      - append `current` at symtail
// * drop out a 00 00 00    symtail `3coff`
// * update symtail
// * set newest
    brk
    .byt popd | N0               ; symtail @
// N0 = usersymtail ACC = symtail
    .byt st | N3
    .byt ld | N2                ; cfa'
    .byt std | N3               ; write CFA to symtab, +2 N5 pointer
    .byt ld | N3
    .byt std | TOS              ; populate `newest`
    .byt ext
    .word swap73s
    .byt ext
    .word symcopys              ; copy the symbol/length
    .byt ldi | N1
    .byt bz , <(ppcreate01-*-2)
    .byt set | ACC
    .word $40
ppcreate01
    .byt st | TOS               ; TOS = $00 or $40 if vocab
    .byt inr | N7
    .byt pop | N7
    .byt st | N5
    .byt add | TOS
    .byt sti | N7               ; symbol length with a proper vocab bit
    .byt ld | N7
    .byt add | N5
    .byt st | N7
    .byt pop | N1
    .byt bz , <(ppcreate02-*-2)
    .byt sti | N7
ppcreate02
    .byt ld | N7
    .byt std | N0               ; update symtail
    .byt sub | ACC
    .byt sti | N7
    .byt std | N7
    .byt pull
    .byt rtn
    jmp exit

;--------------------------------------------------------------
#if 0
name=?VMMOVE
stack=( newsymtab -- )
tags=ext,nosymbol
* if `#blk` nonzero, move `vmbuf` area

```
: ?vmmove   ( newsymtab -- )
    #blk @
    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
     vmbuf !
    symtab ! ;
```
    jsr harvests4               ; grab just b/buf & vmbuf, leave newsymtab next
    brk
    .byt ldd | TOS              ; #blk@
    .byt st | TOS               ; if we leave abruptly, don't +MOVE anything
    .byt bz , <(qvmmovemagic01-*-2)
    .byt pull                   ; newsymtab
    .byt st | N2                ; put it somewhere safe, for now
    .byt sub | N6               ; old `symtab`

    ;~wut? more to do here, to support moving `vmbuf`

                                ; no blocks in VM buffer to worry about here
                                ; not much to do either, really
qvmmovemagic01
    .byt rtn
plant4
    ldy #4
    jmp plant






```
: ?vmmove   ( newsymtab -- )
    #blk @
    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
     vmbuf !
    symtab ! ;


: ?vmmove   ( newsymtab -- )
    vmbuf
    b/buf
    #blk
    (?vmmove).magic             ( newsymtab newvmbuf from to delta flag )
    ?: +move 3drop
    vmbuf !
    symtab ! ;

;(?vmmove).magic   ( newsymtab vmbuf b/buf #blk -- newvmbuf newsymtab )
qvmmovemagic
    jsr locals4                 ; grab just b/buf & vmbuf, leave newsymtab next
    brk
    .byt ldd | TOS              ; #blk@
    .byt st | TOS               ; in case must leave abruptly, don't +MOVE anything
    .byt bz , <(qvmmovemagic01-*-2)
    .byt pull                   ; newsymtab
    .byt st | N2                ; put it somewhere safe, for now
    .byt sub | N6               ; old `symtab`


                                ; no blocks in VM buffer to worry about here
                                ; not much to do either, really
qvmmovemagic01
    .byt rtn
    ldy #4
    jsr restack
    jmp next



    if  symtab @                \ old SYMTAB
                                ( newsymtab oldsymtab )
        2dup -                  \ newsymtab oldsymtab delta ) set up for +MOVE
        vmbuf @
        2dup + >r               ( newsymtab oldsymtab delta vmbuf@ newvmbuf )
        rot b/buf -     ( newsymtab delta vmbuf@ oldsymtab-1K )
        rot +move

        vmbuf under +!          \ update vmbuf pointer while we're at it
        rot +move               ( newsymtab )
    else
        dup b/buf - 2-
        dup off
    then
```
#endif
#include "align.i65"
_qvmmove
    jsr enter
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=!SYMTAB
stack=( cfa --  )
tags=ext,nosymbol
runs in the middle of `(forget)` to decide how much to allocate for `symtab`
and possibly move `vmbuf`

    brk
    ld tos
    sub n7

#endif
#include "align.i65"
_setsymtab
    jsr enter
#include "page.i65"
    .word newsymtab
#include "page.i65"
    .word studio
#include "page.i65"
    .word fetch
#include "parm.i65"
    .word zpfrom
    .byt  R0L+2*N7+1
#include "pad.i65"
    .word minus
#include "page.i65"
    .word plus
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch
#include "parm.i65"
    .word pquerycolon
    .word _plusmove
    .word threedrop
#include "past.i65"
    .word exit

    .word tozp
    .byt R0L+2*N5
#include "pad.i65"
    .word dup
#include "page.i65"
    .word bl                    ; 32
#include "page.i65"
    .word plusunder             ;( 16 0 pad+3 $5920 $5900 )
#include "page.i65"
    .word symtab
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch                 ;( 16 0 pad+3 $5920 $5900 symtab #blk )
#include "parm.i65"
    .word qbranch
    .byt <(automem01-*+1)
#include "pad.i65"
    .word _qvmmove              ; need to move vm buffer before symtab !
#include "page.i65"
automem01
    .word store                 ; set symtab
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NEWSYMTAB
stack=( -- addr )
tags=ext,nosymbol

    studio
    newsymtab
    brk
    ld tos
    sub n7
    push
    rtn

    ldd tos
    sub N7
    add
#endif
newsymtab
    clc
    lda userstudio+1
    sbc R0L+2*N7+1
    adc tos+1
    sbc #1                      ; <-- ~#resizestudio
    jmp pusha0
;[13]
    brk                         ;( 16 0 pad+3 studio )
    .byt ldd | TOS              ;( 16 0 pad+3 studio+2 )
    .byt st | N5
    .byt pull
    .byt sub | N7               ; negated size of interim symtab
    .byt add | N5               ; new size subtracted from studio, will round
    .byt push                   ; down to $FF00 AND
    .byt sub | ACC
    .byt std | N7               ; append end-of-symbols marker
    .byt sti | N7
    .byt rtn
    lda #0
    sta tos                     ; &= $FF00
    dec tos+1                   ; <-- ~#resizestudio startup code area here
;    dec tos+1                   ; -= $0200 leave 'some room'

;--------------------------------------------------------------
#if 0
name=>PASSBIT
stack=( index -- flag )
tags=interpreter,nfa,nosymbol

```
: >passbit   ( index -- addr mask )
    passbits >bit ;
```
#endif
#include "align.i65"
_topassbit
    jsr enter
#include "page.i65"
    .word passbits
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSBITS?
stack=( index -- flag )
tags=interpreter,nfa,nosymbol

```
: passbits?   ( index -- flag )
    passbits >bit cbit@ ;
```
#endif
#include "align.i65"
_passbitsq
    jsr enter
#include "page.i65"
    .word _topassbit
#include "page.i65"
    .word cbitfetch
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSBITS!
stack=( index -- )
tags=interpreter,nfa,nosymbol

```
: passbits?   ( index -- flag )
    passbits >bit cbit@ ;
```
#endif
#include "align.i65"
_passbitsstore
    jsr enter
#include "page.i65"
    .word _topassbit
#include "page.i65"
    .word cbitstore
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(FORGET).LOOPER
stack=( b a from to -- )
tags=interpreter,nfa,nosymbol
inner word, `b a do rewind begin cfa execute while copy? repeat loop`

#endif
#include "align.i65"
pforgetlooper
    jsr enter
#include "page.i65"
    .word set76                 ;( b a ) set `sym0 targ filter
#include "page.i65"
    .word zero
#include "parm.i65"
    .word pdo
    .byt <(pforgetlooper03-*+1)
#include "pad.i65"
pforgetlooper01
    .word i
#include "page.i65"
    .word _passbitsq
#include "parm.i65"
    .word qbranch
    .byt <(pforgetlooper02-*+1)
#include "pad.i65"
;    .word pfilterrewind         ; rewind symbol list, copies N6 to N3
#include "page.i65"
;    .word _extuntil             ; filterpass
#include "parm.i65"
pforgetlooper02
    .word ploop
    .byt <(pforgetlooper01-*+1)
#include "past.i65"
pforgetlooper03
    .word exit

set76
    brk
    .byt ld | TOS
    .byt st | N7                ; targ
    .byt pull
    .byt st | N6                ; sym0
    .byt pull
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(FORGET).KEEP
stack=( cfa -- flag )
tags=interpreter,nfa,nosymbol

#endif
#include "align.i65"
_pforgetkeep
    jsr enter
#include "page.i65"
    .word pforgetpostcfa
#include "page.i65"
    .word symcopy
#include "page.i65"
    .word swap73
#include "parm.i65"
    .word symplus
    .byt 1                      ; only include flag/len byte + symbol + vocabid
#include "pad.i65"
    .word swap73
#include "past.i65"
    .word exit

pforgetpostcfa
    brk
    .byt ld | TOS
    .byt std | N7
    .byt pull
    .byt nxt

;--------------------------------------------------------------
#if 0
name=SYM.NEXT
stack=( -- flag )
tags=interpreter,nfa,nosymbol
no `jsr enter` -- code fragment,
tail of the word that branches here

#endif
symnext01
    .word symplus
    .byt 3
#include "page.i65"
    .word symlen
#include "page.i65"             ; ( i )
    .word zeq
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=INIT.411
stack=( value 'filter -- )
tags=interpreter,nfa,nosymbol
Sweet16 primitive, sets `n4` to `value` and `r11` to `'filter`

```
: init.411    ( flag(r4) `filter(r11) -- )
    >r11 drop >n4 drop ;
```
#endif
init411
    brk
    .byt ld | TOS
    .byt st | R11
    .byt pull
    .byt st | N4
    .byt pull
    .byt nxt

;--------------------------------------------------------------
#if 0
name=SYMTAIL!
stack=( symx -- )
tags=dictionary,nosymbol
* Append a triple null end marker to symbol table
* Set SYMTAIL/SYMNEW after (FORGET) and (CREATE)
* Ordering of the input addresses is important.
* 2nd value of `n7` stored is +2 more than 1st `n7` value

`symnew` is where the indexed symbol table ends and the sequential list begins.
`symnew` doesn't change until the next `rehash`.  This is the word that changes
it.   It always points to the 3rd byte in the symbol, the `nfa`

`symtail` is where new symbols are appended.  Like the 6502 stack pointer, it
points to where the next byte (the `lsb` of a `cfa`) is to be written when the
next symbol is created.


```
: (forget)    ...  symtail symnew symtail! ;     \ reset symnew & symtail
: (create)    ... symtail symtail symtail! ;    \ only move symtail
```
(FORGET) sends `symnew` `symtail` to reset `symnew` & `symtail`
(CREATE) sends `symtail` `symtail` to append a new symbol

```
: symtail!   (  symtail symnew -- )
    <n7 dup dup 3off 2+ rot ! swap ! ;

; same size, even runs faster
[12]
symtailstore
    brk
    .byt ld | N7
    .byt std | TOS
    .byt pull
    .byt sub | ACC
    .byt std | N7
    .byt ld | N7
    .byt std | TOS
    .byt pull
    .byt sub | ACC
    .byt sti | N7
    .byt nxt
;
; slightly slower, uses BS/RS opcodes
[12]
symtailstore
    brk
    .byt bs , <(symtailstores-*-2)
    .byt nxt
symtailstores
    .byt bs , <(symtailstores1-*-2)
    ;fall through
symtailstores1
    .byt ld | N7
    .byt std | TOS
    .byt pull
    .byt sub | ACC
    .byt std | N7
    .byt rs
```
#endif
#include "align.i65"
symtailstore
    brk                         ;[7+2] (+2 for extra call from `(forget)`
    .byt ld | N7
    .byt std | TOS
    .byt pull
    .byt sub | ACC
    .byt std | N7
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(FORGET).PASS1
stack=( -- )
tags=interpreter,nfa,nosymbol

* This is the first pass filter.
* It copies the symbol table from SYMTAB @ to PAD,
**    sorted by (visible) length of symbol
**    ignoring words above a given address (NEWDP)
**    ignoring smudged words
**    keeping all words in TDICT

It assumes that the programmer won't attempt `forget` while creating
a definition.

    `: newdefinition [ forget newdefinition ] ;   \ doh!`

In the origin dictionary at cold start, there are no clones.  There are no
smudged words.

This means that any smudged words have been redefined.  How do we figure out
the most recently redefined word, that is still inside NEWDP?  The active
word is the clone with the highest (in-bounds) CFA.  It would be unlikely
for an unsmudged clone with code at a lower address to exist, as (CREATE)
does not allow it.

Once the system is up, the dictionary remains sorted and indexed.
Clones have the same name, PEARSON# value, and length, and will be
adjacent in a sorted symbol table, in ascending CFA order, with all
of them smudged but the one with the highest CFA.  These existing
well-established clones from Philadelphia will be encountered first.

Newly arrived clones from SYMNEW on up will also be sorted ascending
by CFA but may not be adjacent. All will certainly have higher CFAs
than their clone(s) in Philadelphia.

When encountering a smudged word
    store CFA in N2
    search upward in current thread (Philadelphians) for clones
    search upward in SYMNEW (Noobs) for clones
    is the CFA of the clone in-bounds?
    As soon as we find the first newer clone with an in-bounds CFA, we are done.
    We this is NOT the active clone.
    yes:    we are done.  Copy this older clone with smudge bit set
    no: we got to the end of the list without finding a twin
    regardless of whether that newer clone is smudged or not
    if we didn't find any juniors, this is the most recent.
        Unsmudge it.  Welcome to Philadelphia, brother.
    append CFA to PAD (N7++)

when a smudged word is found,
    compare its CFA to NEWDP.  If >= NEWDP, it is skipped (out of bounds)
    compare its CFA to N2.  If >N2, it replaces N2

The rule here is that the highest CFA that is less than NEWDP is saved, and
the word is copied to PAD as is, smudged.

```
: (forget).pass1   ( cfa -- )
    i if
        i symlen =
        if
            <n3 name>           ( cfa curr )
            2dup studio @ swap   ( cfa curr cfa studio curr )
            between? 0=         ( cfa curr flag )
            ?: drop (forget).keep
        then
    else
        passbits! bloomfilter cbit!
    then
    sym.next ;
```
#endif
#include "align.i65"
_pforgetpass1
    jsr enter
#include "page.i65"
    .word i
#include "parm.i65"
    .word qbranch
    .byt <(pforgetpass1b-*+1)
#include "pad.i65"
    .word i
#include "page.i65"
    .word symlen
#include "page.i65"
    .word eq
#include "parm.i65"
    .word qbranch
    .byt <(symnext01-*+1)       ; next!
;#refactor
#include "parm.i65"
    .word zpfrom                ; nfa
    .byt R0L+2*N3
#include "pad.i65"
    .word namefrom              ; nfa>cfa
#include "page.i65"
    .word twodup
#include "page.i65"
    .word studio
#include "page.i65"
    .word fetch
#include "page.i65"
    .word swap
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word betweenq
#include "parm.i65"
pforgetpass1a
    .word pquerycolon
    .word drop
    .word _pforgetkeep
#include "parm.i65"
    .word branch
    .byt <(symnext01-*+1)       ; next!
#include "pad.i65"
pforgetpass1b                   ; pass 0 only, set passbits and bloomfilter
    .word symlen
#include "page.i65"
    .word _passbitsstore         ; if ((i-1) = 0) set `passbits` for all lengths
#include "page.i65"
    .word _bloomfilter          ; doing this here speeds things up slightly,
#include "page.i65"             ; with a low risk of setting (inconsequential)
    .word cbitstore             ; false positives in `bloom#` for forgotten
#include "past.i65"             ; words.
    .word branch
    .byt <(symnext01-*+1)       ; next!

;--------------------------------------------------------------
#if 0
name=(FORGET).PASS2
stack=( -- )
tags=interpreter,nfa,nosymbol
* This is the second pass filter.
* It copies the symbol t
able from PAD to the new SYMTAB
**    sorted by pearson hash

Retrieves the pearson hash value for this word, stored on pass 1

```
: (forget)pass2   ( -- )
    pearson# i =
    ?: (forget).keep next
    sym.next ;
```
#endif
#include "align.i65"
_pforgetpass2
    jsr enter
#include "parm.i65"
    .word zpfrom                ; nfa
    .byt R0L+2*N3
#include "pad.i65"
    .word namefrom              ; nfa>cfa
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word i
#include "page.i65"
    .word ne
#include "past.i65"
    .word branch
    .byt <(pforgetpass1a-*+1)

;--------------------------------------------------------------
#if 0
name=(FORGET)
stack=( cfa -- )
tags=nfa,ext,nosymbol
(FORGET) rebuilds and reindexes the entire dictionary, balancing it
into 16 roughly equal-sized 'threads'.  (FORGET) merges symbols
created at SYMNEW since the last (FORGET) into their thread. Then
SYMNEW is set to SYMTAIL, emptying the 'noob' list

!!!Symbol table entry
|field| size| offset|h
|cfa| 2| -2|
|flags+length| 1| `NFA` 0|
|name| length| +1|
|voabcid| 1| +length+1|
A ''//clone//'' is a symbol which has the same name (and length) as well as
both belonging to the same vocabulary (or both [[FORTH]], no vocabulary).  The
distinction is that each `clone` has a different `cfa`.  When (CREATE) adds
a `clone`, this new definition replaces the original and smudges the lower,
earlier definition.  It is up to [[(FORGET)]] to reverse that process.

Smudge is set between ''[[:]]'' and ''[[;]]'' during a word's
creation. If there is an error during compilation, [[UNDEFINE]]
cleans up the partial (smudged) definition in the symbol table
and also moves [[DP]] back to where it started.  There should
only ever be one symbol at a time that is smudged during word
creation.

The other reason a word is smudged is when it is redefined.
When ''[[;]]'' closes the definition, if there is a previous
active definition ([[REDEFINED]] is non-zero) then it will be
smudged, and the new definition becomes active.  There should
only ever be one active `clone` (the most recent) at a time.

As [[FORGET]] sorts through the symbol table, when it finds a
smudged symbol, that is how it knows it found a `clone`.  Since
PASS1 processes Pearson-hashed symbols in [[SYMTAB]] first,
then [[SYMNEW]] symbols, the first clone found will also be
the original definition of the word.  This order corresponds
to the chronological order in which symbols are added.  At this
point, PASS1 collects all the other clones and smudges them.
When no more clones can be found, the last `clone` is unsmudged,
making it the active one.

[SYMTAB ... SYMTAIL] is also a long continuous chain of symbols, beginning at
SYMTAB+32 and ending at the triple null where SYMTAIL points.

    pad >syms
    migrate

code copy?
    doextreg
    jmp (R11)

_qvmmove

: migrate   ( cfa to from -- )
    going up or down?
        vector R11 (for speed)
        going down?
            initial length=1
            stash cfa in a register
        going up?
            initial hash=0
    begin
        copy?
            this word's address is < cfa
            it is the correct length

        ?copy
copy them down
    filter anything >= `cfa`
    set bloom filter bit for each `bloom#`
    set pass bit for each length

automem
    `cfa` dp !
    three nulls at end of pad area
    calculate new symtab location
    symtab !
    calculate new symnew location
    symnew !
    calculate new symtail location
    symtail !
    write three nulls at new symtail location also

passbit 0 off
copy them all up
    set thread pointers


```
: (forget)   ( cfa -- )
    plits 6

    passbits
    $80
    bloom
    8
    erase !+ off
    pad >syms
    migrate
    !symtab                     ( -- symtab )
    ?vmmove
    pad 2+
    migrate

b a do rewind begin cfa execute while copy? repeat loop`

: (forget).keep
    (forget).postcfa
    symcopy swap73 1 sym+ swap73 ;

pforgetpostcfa
    brk
    .byt ld | TOS
    .byt std | N7
    .byt pull
    .byt nxt

erase bloom filter
    bloom
    00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
passbit 0 only (all lengths)
    passbits
    10000000 00000000 00000000 00000000

tos                             sym0
n0                              cfa
n1                              target
n2
n3
n7                              target
n8                              sym.len (visible, no vocab)

0000  DC 64 22 57  4E 1A 00.00  88 1A 22.57  05 FF 00 00
0010  B8 06 F2.1A  05 00 .cfa.  00 01 1B 00  0A 93 67 6C

: keeper?   ( -- flag )
    <n3 name> <n0 < ;


: southerly
    i symlen <> ?exit
    <
    keeper? if (forget).keep then
    sym+


: (forget)   ( cfa -- )
    n0 !   pad n7 !             ( )
    bloom 12 erase
    16 0 do
        symtab @ i 2* + @       ( thread )
        begin
            i symlen =
            if
                southerly
            then
        until
    loop
    !symtab ?vmmove
    32 1 do
        northerly
    loop ;


    (forget).pass1 (filter)!
    32 0  >syms pad
    (forget).looper             \ does `ext-until` 32x, completing pass1

    passbits on
    (forget).pass2 (filter)!
    16 0  pad 3+ (automem)
    (forget).looper             \ does `ext-until` 16x, completing pass2
```
#endif
#include "align.i65"
_pforget
    jsr enter
#include "page.i65"
    .word _gosouth
#include "page.i65"
    .word _setsymtab
#include "page.i65"
    .word _qvmmove
#include "page.i65"
    .word _gonorth
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SOUTHERLY
stack=( )
tags=interpreter,extension,nosymbol

: southerly

    <n1 ?exit
    <n8 passbits >bit cbit! ;

: pforgetpass1
    i
    .word qbranch
    .byt <(pforgetpass1b-*+1)
    .word i
    .word symlen
    .word eq
    .word qbranch
    .byt <(symnext01-*+1)       ; next!
;#refactor
    .word zpfrom                ; nfa
    .byt R0L+2*N3
    .word namefrom              ; nfa>cfa
    .word twodup
    .word studio
    .word fetch
    .word swap
    .word oneplus
    .word betweenq
pforgetpass1a
    .word pquerycolon
    .word drop
    .word _pforgetkeep
    .word branch
    .byt <(symnext01-*+1)       ; next!
pforgetpass1b                   ; pass 0 only, set passbits and bloomfilter
    .word symlen
    .word _passbitsstore         ; if ((i-1) = 0) set `passbits` for all lengths
    .word _bloomfilter          ; doing this here speeds things up slightly,
#include "page.i65"             ; with a low risk of setting (inconsequential)
    .word cbitstore             ; false positives in `bloom#` for forgotten words
    .word branch
    .byt <(symnext01-*+1)       ; next!


southerly
    jsr symlens
    iny
    lda (n3),y
    and #$0F
    eor n1
    bne nextsymbol

nextsymbol
    beq lastone
    lda n1
    bne

lastone
    inc n1                      ; counter

    lda R0L+2*N1                ; counter 0..31

    i



#endif
#include "align.i65"
_southerly
    jsr enter
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=GOSOUTH
stack=( cfa -- targetend )
tags=interpreter,extension,nosymbol

: gosouth
    bloom 12 erase
    pad >syms 0
    callz
    harvests6
    (gosouth)





#endif
#include "align.i65"
_gosouth
    jsr enter
#include "page.i65"
    .word bloom                 ; cfa bloom )
#include "parm.i65"
    .word blit                 ; cfa bloom 12 )
    .byt <(userpassbits+4-userbloom)
#include "pad.i65"
    .word erase                 ; reset bloom filter, passbits
#include "page.i65"
    .word _pad
#include "page.i65"
    .word tosyms
#include "page.i65"
    .word pgosouth
#include "page.i65"
gosouth01                       ; begin
    .word doextreg
#include "parm.i65"             ;  ( flag )
    .word qbranch               ; until
    .byt <(gosouth01-*+1)
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(GOSOUTH)
stack=( -- flag )
tags=interpreter,extension,nosymbol
6EBE   .pgosouth:
6EBE  20 EF 06    jsr .harvests4
6EC1  00          brk
0000  DC 64 22 57  4E 1A F2 1A  88 1A DC 64  05 FF 00 00
0000  DC 64 22 57  4E 1A 00.00  88 1A 22.57  05 FF 00 00

0010  B8 06 06 02  05 00 34 D5  00 01 1B 00  0A 93 67 6C
0010  B8 06 F2.1A  05 00 .cfa.  00 01 1B 00  0A 93 67 6C

0040  AA AA AA AA  AA AA AA FF  00 01 AD 00  0C F2 4E 01
0070  BB BB BB BB  BB BB BB FF  53 00 24 00  00 1A 1A 10
0080  00 00 00 00  74 06 E6 8B  E6 8B 6C B5  6E 00 2E 5C
0090  55 E4 55 06  FF B3 00 1B  00 32 00 FF  00 00 00 00
00A0  00 0C 00 18  0C 00 1B 01  0C 20 00 00  00 00 00 00
00B0  03 00 00 00  05 0A 00 08  00 00 00 00  00 00 00 00
00C0  00 00 80 47  C0 83 0D 00  84 00 53 FC  18 00 C0 00
00D0  00 05 00 00  01 27 7A 02  18 0D 0E 17  00 47 00 47
00E0  80 80 80 80  80 80 80 81  81 81 81 81  81 82 82 82
00F0  82 82 82 82  83 83 83 83  83 34 00 21  52 FF FF 6E
0130  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20
0140  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20
0150  20 20 20 20  20 20 20 20  FF FF FF FF  FF FF FF FF
0160  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
0170  FF FF FF FF  FF FF FF FF  FF FF FF FF  FF FF FF FF
01E0  57 57 E4 57  03 00 0E 00  22 CF 05 68  06 06 2F 0F
01F0  26 12 26 C0  6E 9F 6E F2  6E 2A 6F 4C  6F 6D 6F 06
0410  4C 73 C3 22  00 5B 00 00  00 04 00 64  00 00 00 00
0420  00 0D 04 16  13 00 08 12  B3 01 0D D0  02 FF 86 40
0430  B2 E9 CE AA  AA AA AA AA  FE 52 00 53  A5 46 A5 46
0440  00 80 AA AA  00 80 D1 07  AA AA 00 04  AA AA 00 04
0450  AA AA AA AA  24 AA AA 08  B6 FF 00 00  00 FB 7B 00
0460  03 4C BB 00  BB BB BB BB  BB BB 00 00  00 00 8B 00
0470  00 04 0D 00  00 00 8B 80  C0 00 00 00  00 00 05 B3
0480  E6 77 D0 02  E6 78 AD 0A  02 C9 3A B0  0A C9 20 F0
0490  EF 38 E9 30  38 E9 D0 60  80 4F C7 52  7B 80 40 20
0660  01 88 84 1F  85 1E 20 C5  04 4C 66 06  0A 00 0D 17
0670  00 00 01 00  31 00 FE 01  00 00 78 D4  00 00 00 00
0680  32 68 08 6F  A2 1A 4E 1A  00 57 0A 00  0D 17 00 00
0690  01 00 21 52  02 00 00 00  01 00 00 00  0D 00 0C 00
06A0  02 00 00 00  00 00 00 00  00 00 03 28  00 C0 56 28
06B0  00 67 46 7F  02 00 09 00  00 00 00 00  00 00 00 00
06C0  30 00 00 00  00 00 01 65  00 00 00 00  00 00 00 00
06D0  DC 64 06 65  00 00 00 00  00 00 00 00  00 00 00 00


#endif
pgosouth
    jsr harvests4
    brk
    .byt set | R11
    .word _southerly
    .byt ld | TOS
    .byt st | N3
    .byt ld | N1
    .byt st | N7
    .byt sub | ACC
    .byt st | N1
    .byt nxt

;--------------------------------------------------------------
#if 0
name=GONORTH
stack=( -- )
tags=interpreter,extension,nosymbol

#endif
#include "align.i65"
_gonorth
    jsr enter
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PASSBIT?
stack=( -- flag )
tags=dictionary,nosymbol

#endif
passbitq
    stx z
    ldx #3
    clc
passbitq01
    rol userpassbits,x
    dex
    bpl passbitq01
    ldx z
    jmp xpushc

;--------------------------------------------------------------
#if 0
name=REHASH
stack=( -- )
tags=interpreter,extension
Rebuilds the PETTIL [[symbol table ~]].

```
: rehash  ( -- )
    here (forget) ;   \ effectively a FORGET nil
```
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _pforget
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORGET
stack=( "name" -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
checks FENCE, sorts symbol table, keeping only words below the CFA of the named word

```
: forget   ( "name" -- )
    '  dup  fence @  u<  7 ?error
    (forget) ;

~wut?  maybe new and improved 2017-09-04
: forget   ( "name" -- )
    '  dup  fence @ studio @ between 0=
    7 ?error (forget) ;
```
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word dup
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word ult
#include "parm.i65"
    .word qerror
    .byt 7                      ; CAN'T FORGET BELOW FENCE
#include "pad.i65"
    .word _pforget
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=FORTH
stack=( -- )
tags=vocabulary,forth-83
Reset the vocabulary search order to just CORE.  Equivalent to
`ONLY FORTH` in ANS Forth

```
: forth   ( -- )
    vocabs 12 erase ;
```
#endif
#include "align.i65"
_forth
    jsr enter
#include "page.i65"
    .word vocabs
#include "page.i65"
    .word count
#include "page.i65"
    .word erase
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEFINITIONS
stack=( -- )
tags=forth-83
Sets the compilation vocabulary by copying the first vocabulary in
the [[VOCABS]] search order to [[CURRENT]].

#endif
#include "align.i65"
definitions
    lda uservocabs+1
    sta usercurrent
    jmp next
