;------------------------------------------------------------------------------
/*
title: pettil-dictionary.a65
tags: source nosymbol

```
SYMTAB!     SYM0        SYM.LEN     SYM.STRANDS
SYM.COPY    (!SYMTAB)   !SYMTAB     STRAND
IMMEDORNOT  (FOUND?)    FOUND?      STRAND+
(FNORD)     >STRAND     NEXTVOCAB?  :WILLITBLEND?
FNORDITUDE  :SOSORTED   :SOSCRAMBLED

>NAME       EXISTS?     '           FORGET
DEFINITIONS REHASH      FORTH

 SYMBOL
+---------------+
|   CFA[low]    | <-- LFA      Link Field Address
|   CFA[high]   |              (2 bytes)
+-+-+-+-+-+-+-+-+
[V]       %vocab|              Name Field Address
| [S]    %smudge|
|   [I]   %immed|              (1 byte)
|     [length   ] <-- NFA
+-+-+-+-+-+-+-+-+
|   "H"         |     NFA+1    text of the name
|   "E"         |              (`length` bytes)
|   "R"         |
|   "E"         |
?---?---?---?---?
?   vocabid     ?     NFA+length+1
?---?---?---?---?         01 = assembler; 02 = editor; 03 = user's first vocab
                               (1 byte, present iff %vocab is true)
                          00 = labels.  Labels are temporary, may be loaded in
                               from tape.  They exist only in `symnew`..`symtail`
                               region of memory and are removed by invoking
                               `forget` or `rehash` which empties this region.

                               Meanwhile, use labels for whatever you wish. They
                               are created only once, and the value may be replaced
                               as often as you like with `:setmylabel` syntax
symbol
    lfa     contains the
    cfa     points to 6502 code
 %smudge    is smudged
 %vocab     has vocabid
 %immed     is immediate
 length     1..31, 0 = end of list
vocabid     present if %vocab is true, 0 = is label
```
*/
;------------------------------------------------------------------------------
/*
title: SYMTAB!
tags: nosymbol

code symtab!   ( -- )
*/
symtabset
    lda stackh+1,x
    clc
    sbc tos+1
    dex
    sta stackh,x
    sta usersymtab+1
    lda #32
    sta stackl,x
symtabset99
    jmp next
;------------------------------------------------------------------------------
/*
title: SYM0
tags: nosymbol

```
code sym0   ( -- )
  symtab 1+ lda,  n3 1+ sta,
  #34  # lda,  n3 sta,
  'symtabset99 bne,  \ next
```
*/
sym0
    lda usersymtab+1
    sta R0L+2*N3+1
    lda #34
    sta R0L+2*N3
    bne symtabset99                     ; bra next
;------------------------------------------------------------------------------
/*
title: SYM.LEN
tags: primitive nosymbol

Calculate length of a name

%vocab              $80
%smudge             $40
%immed              $20
length              [4..0]

This gets called often and should run fast.

|register |before |after |notes |h
|N2L |     |length |     |
|N3  |nfa  | -     |     |
|N8L |     |length |     |
|Y   |     |00     |     |
|N   |     |%vocab |also in C |
|V   |     |%smudge|     |
|Z   |     |%done  |(N8 & N2) |
|C   |     |%vocab |also in N |

```
code sym.len   ( -- len )
  'pushya 1- csplit
  # lda, pha,  # lda, pha,
\ %vocab %smudge %immed length(0..31)
:sym.lens
  0 # ldy,  n3 )y lda,  n2 sta,  clc,
  $80 # adc,  $1f # and,  n8 sta,
  n2 bit,  rts,  end-code
```
*/
symlen
    lda #>(pushya-1)
    pha
    lda #<(pushya-1)
    pha
symlens
    ldy #0                              ; %vocab %smudge %immed
    lda (R0L+2*N3),y
    sta R0L+2*N2
    cmp #$80                            ; copy N flag to C flag
    and #$1F
    sta R0L+2*N8
    bit R0L+2*N2
    rts                                 ;[26]
;------------------------------------------------------------------------------
/* SYM+
tags: nosymbol subroutine

This gets called often and should run fast.

|N2 |      |orig- |     |
|N3 |nfa   |nfa+  |     |
|N8 |      |len-  |     |
|A  |      |nfa.l |     |
|Y  |      |00    |     |
|C  |      |?     |pagewrapped? might be a good cue for entertainment |
|Z  |      |false |     |

*/
symplus
    jsr symlens
    adc #3
    adc R0L+2*N3
    sta R0L+2*N3
    bcc symplus01
    inc R0L+2*N3+1
symplus01
    rts                                 ; Z flag is always nonzero
;------------------------------------------------------------------------------
/*
title: (!SYMTAB)
tags: nosymbol

*/
psamtab
    brk
    .byt ld | N3
    .byt std | TOS              ; set `symnew`
    .byt popd | N3              ; 2-
    .byt ld | N3
    .byt std | TOS              ; set `symtail`
    .byt sub | ACC
    .byt std | N3               ; force cfa = 0
    .byt nxt
;------------------------------------------------------------------------------
/*
title: !SYMTAB
tags: nosymbol secondary

```
: !symtab   ( start end -- size addr )
    bloom 8 erase sym0 symtab @ bl
    begin
        sym.len >  if  <n3 !+ then
        bloomfilter cbit!
        sym.len  call sym+  sym.len 0=
    until (!symtab) 3drop ;
```
*/
#include "align.i65"
_setsymtab
    jsr enter
#include "page.i65"
    .word bloom
#include "page.i65"
    .word eight
#include "page.i65"
    .word erase                 ; reset the Bloom filter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word bl
#include "page.i65"
samtab01
    .word symlen
#include "page.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(samtab02-*+1)
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N3
#include "pad.i65"
    .word _storeplus
#include "page.i65"
samtab02
    .word _bloomfilter
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word symlen
#include "parm.i65"
    .word callz                         ; ~todo tidy up here
    .word symplus
#include "pad.i65"
    .word symlen
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qbranch
    .byt <(samtab01-*+1)
#include "pad.i65"
    .word symnew
#include "page.i65"
    .word psamtab               ; handle `symtab` tail
#include "page.i65"
    .word threedrop
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/* BLOOM#
tags: nosymbol

stack=( -- n )

The Bloom filter tries to answer the question, 'is this word a number?'

The string under consideration is pointed to by (N3) with a length of N8.

Generate a hash of a string, in the range 0..63, used as an index into the
sparsely populated `bloom` 8-byte bitfield.

A `true` bloom filter bit means, this word might be in the dictionary
A `false` bit means, this word is not present

`create` turns on the `bloom` bit for each new name
`forget` completely rebuilds the `bloom` filter

|reg |entry |exit |h
|^stack |^( nfa -- bloom# )|<|
|^N3 |^ |^nfa |
|^N8l |^ |^length |
|^N8h |^ |^0 |

code bloom#   ( nfa -- bloom# )

*/
bloomhash
    ldy R0L+2*N8                        ; length
    lda #0
    sta z
bloomhash01
    lda (R0L+2*N3),y
    eor #$30
    cmp #9
    bcs bloomhash02
    adc z
    sta z
bloomhash02
    dey
    bne bloomhash01
    lda z
    and #$3F                            ; width of the filter is 64 bits
    jmp pushya
;------------------------------------------------------------------------------
/* BLOOMFILTER
tags: nosymbol

stack=( -- mask addr )
*/
#include "align.i65"
_bloomfilter
    jsr enter
#include "page.i65"
    .word bloomhash
#include "page.i65"
    .word bloom
#include "page.i65"
    .word tobit
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: UNSMUDGE
tags: primitive

stack=( nfa -- )
*/
unsmudge
    clc
    .byt $29            ; AND #
    ; fall through
/*
title: SMUDGE
tags: primitive forth-79

stack=( nfa -- )
*/
smudge
    sec
    ;
    php
    ldy #0
    lda (tos),y
    asl
    plp
    ror
    sta (tos),y
    jmp drop
;------------------------------------------------------------------------------
/*
title: (>NAME)
tags: nosymbol

stack=( cfa -- nfa|0 )
*/
ptoname
    ldy #$FE
ptoname02
    dec R0L+2*N3+1
    lda (R0L+2*N3),y
    inc R0L+2*N3+1
    eor tos-$FE,y
    bne ptoname05
    iny
    bne ptoname02
    lda R0L+2*N3
    ldy R0L+2*N3+1
ptoname04
    jmp put
ptoname05
    ldy #0
    lda (R0L+2*N3),y
    beq ptoname04
    jsr symplus                 ; next!
    bne ptoname                 ; bra
;------------------------------------------------------------------------------
/*
title: >NAME
tags: forth-83

* search the dictionary for a given `cfa` and
* return the `nfa` if found, else `0`
* honors the smudge bit

```
: >name   ( cfa -- nfa|0 )
    sym0
    begin
        name> over <>
        sym.len and
    while
        3 sym+
    repeat
    name> nip ;
```
*/
#if 0
name=>NAME
tags=interpreter

#endif
#include "align.i65"
_toname
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word ptoname
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: (SEEK)
tags: nosymbol

|^stack |^( nfa.seek -- xfa flag )|<|h
|^N2 |^                 |^flags,len,og  |
|^N3 |^sym0             |^nfa.result    |
|^N4 |^seek.length      |^ .            |
|^N5 |^                 |^vocabid       |
|^N6 |^                 |^vocabs        |
|^N7 |^nfa.strand[0]    |^ .            |
|^N8L|^                 |^result.length |
|^N8H|^                 |^toggle sorted/unsorted |
|reg |entry             |exit           |f

code  (seek)   ( nfa -- xfa flag )
  r14 1+ asl,  n8 1+ inc,
  '(seek100) bne,
:(seek10)
  n8 1+ lda,  lsr,  '(seek20) bcc,
  '(seek86) bne,  iny,
:(seek200)
  dey,  '(seek42) beq,  tos )y lda,
  n3 )y eor,  '(seek200) beq,
:(seek20)
  'sym+ jsr,
:(seek100)
  'sym.lens jsr,  '(seek86) beq,
  n2 bit,  '(seek10) bmi,  tay,
  '(seek10) bvc,
  n5 lda,  '(seek10) beq,
  iny,  iny,  '(seek10) bne,
:(seek42)
  r14 1+ inc,
:(seek86)
  rts,  end-code




r14h 2*!    \ assume not found
n8h 1+!     \ toggle unsorted/sorted
begin
    symlen  %done not
while
    %smudge not
while
    y=len+1 a=vocabid
    %vocab
    if
        0= not
        if
            yabba

:yabba
    dey 0=
until  goteem

pseek
    asl R0L+2*R14+1             ; not found
    inc R0L+2*N8+1              ; toggle odd=unsorted; even=sorted
pseek10
    jsr symlens                 ; pass N3=NFA of first symbol on list
    beq pseek86                 ; %done ?
    bvs pseek1999               ; Beavis, is it %smudged? next
pseek30
    tay
    iny
    lda R0L+2*N5
                    ; n5\c    true              false
                    ;  = 0     mismatch         match (core)
                    ;  <> 0    match(vocabid)   mismatch
    bcc smore
    bne doob
    .byt $2C
smore
    bne pseek66
yabba
    dey
    beq pseek42
dabba
    lda (tos),y
doob
    eor (N3),y
    beq yabba
    ; bne pseek66
pseek66
    lda R0L+2*N8
    cmp R0L+2*N4                ; length
    bcc pseek20
    lda R0L+2*N8+1
    lsr
    bcs pseek86
pseek1999
    jsr symplus                 ; party on
    bne pseek10                 ; bra
pseek42
    inc R0L+2*R14+1             ; found it
pseek86
    rts



*/
pseek
    asl R0L+2*R14+1             ; not found
    inc R0L+2*N8+1              ; toggle odd=unsorted; even=sorted
pseek10
    jsr symlens                 ; pass N3=NFA of first symbol on list
    beq pseek86                 ; %done ?
    bvs pseek100                ; is it %smudged, Beavis?
    tay
    eor R0L+2*N4                ; length
    sbc #$FF

    bne pseek100                ; diff length ?
    lda R0L+2*N5                ; vocabid
    bcs pseek150                ; %vocab ?
    bne pseek100
pseek200
    lda (tos),y
    ;
pseek300
    eor (R0L+2*N3),y
    bne pseek100
    dey
    bne pseek200
pseek42
    inc R0L+2*R14+1             ; found it
pseek86
    rts

pseek100
    cpy R0L+2*N4                ; length
    bcc pseek199

    lda R0L+2*N8+1
    lsr
    bcs pseek86
pseek199
    jsr symplus
    bne pseek10                 ; bra

pseek150


    beq pseek100                ; vocabid must be nonzero
    iny
    .byt $2C
    lda R0L+2*N8+1
    lsr                         ; %unsorted
    bcs pseek199
    dey
    cpy R0L+2*N4
    bcs pseek86                 ; %sorted early exit

;------------------------------------------------------------------------------
/*
title: (FOUND?)
tags: nosymbol

~ use N4 to hold either:
~    length.seek (as set by >strand )
~    length.32 (to prevent ever reaching it)

calculate n7=strand
for each vocabulary
    n3=symnew+2
    check unsorted (symnew...)
    n3=n7
    check sorted (>strand...)

```
code (found?)   ( nfa -- xfa flag )
    brk,  vocabs 1+ n6 set,             \ first vocab
:found1
    n6 ldd@,  n5 st,                    \ get vocabid
:found2
    symnew n3 set,  n3 ldd@,
    n3 st,  n3 ldd@,  '(seek) ext,
    '>strand ext,  '(seek) ext,
```


#include "parm.i65"
    .word tozp
    .byt R0L+2*N3
#include "pad.i65"
    .word symlen
#include "page.i65"
    .word drop



code >strand   ( nfa -- nfa ; n3=strand )
  'symlens jsr,  n4 sta,  iny,
  tos )y lda,  $0f # and,  asl,  n7 sta,
  symtab 1+ lda,  n7 1+ sta,
  rts,  end-code

code (found?)   ( nfa -- xfa flag )
    brk,  vocabs 1+ n6 set,             \ first vocab
:pfoundq01
    n6 ldd@, n5 st,                     \ get vocabid
    symnew tos set,
    (seek) ext,                         \ check unsorted
    >strand tos set,
    (seek) ext,                         \ check sorted
    n6 ld@, 'pfoundq01 bnz,
    nxt,
```
code found00
    'symlens jsr,  n4 sta,  iny,
    n3 )y lda,  $0F # and,  asl,
    n7 sta,  symtab 1+ lda,  n7 1+ sta,
    next jmp,  end-code

    n3 !  callz symlen
*/
pfoundq
    brk
    .byt set | N6
    .word uservocabs+1                  ; first vocab
pfoundq01
    .byt ldd | N6
    .byt st  | N5                       ; get vocabid
    .byt set | N3
    .word usersymnew
    .byt ldd | N3
    .byt st  | N3
    .byt ext
    .word pseek
    .byt bc  , <(pfound99-*-2)          ; early exit if it was found
    .byt ld  | N7                       ; let's have a look at the sorted list then
    .byt st  | N3
    .byt ext                            ; if we're still here, we haven't exited
    .word pseek                         ; search sorted until 0= or len>seeklen(n4)
    .byt bc  , <(pfound99-*-2)
    .byt ld  | N5                       ; get vocabid
    .byt bnz  , <(pfoundq01-*-2)        ; until last vocab
    .byt rtn
    jmp false
pfound99
    .byt popd | N3                       ; tell 'em what happened
    .byt st   | TOS
    .byt rtn
    bit R0L+2*N2                        ; check immediate bit
    bvc pfoundnormal
    jmp one
pfoundnormal
    jmp minusone
;------------------------------------------------------------------------------
/*
title: FOUND?
tags: nosymbol secondary

Search the dictionary for a name

| flag | meaning | 2os |h
| -1 | found | cfa |
|  0 | not found | nfa |
| +1 | immediate word | cfa |

```
: found?   ( nfa -- xfa flag )
  >n3 found00                           ( nfa ; n3=nfa n4=n8=seek.length )
  bloomfilter cbit@                     ( nfa flag )
  ?: (found?) false ;
```
*/
#include "align.i65"
_foundq
    jsr enter
#include "parm.i65"
    .word tozp
    .byt R0L+2*N3
#include "page.i65"
    .word found00
#include "page.i65"
    .word _bloomfilter          ; in sought name, sum of digits ['0-9'+1] modulo 64
#include "page.i65"             ; e.g. `dup` = 0, and `3.1459` = 27
    .word cbitfetch
#include "parm.i65"
    .word pquerycolon
    .word pfoundq
    .word false
#include "past.i65"
    .word exit
found00
    jsr symlens
    sty R0L+2*N8+1                      ; reset the sorted/unsorted toggle
    iny
    lda (R0L+2*N3),y                    ; 1st character of name
    and #$0F                            ; low 4-bits only
    asl                                 ; *2
    sta R0L+2*N7                        ; sym0 (sorted)
    lda usersymtab+1
    sta R0L+2*N7+1
    brk
    .byt ldd | N7
    .byt st  | N7                       ; j'adoube
    .byt ld  | N8                       ; seek.length
    .byt st  | N4                       ; N4H = even/odd sorted/unsorted flag
    .byt nxt
;------------------------------------------------------------------------------
/*
title: EXISTS?
tags: secondary vocabulary

search the dictionary for a name
bill had a billboard he also had a board bill the board bill bored bill so bill sold
the billboard to pay the board bill so the board bill no longer bored bill

```
: exists?   ( "name" ; -- cfa|0 )
  bl name ?dup  ?: found? false  and ;
```
*/
#if 0
name=EXISTS?
tags=vocabulary

#endif
#include "align.i65"
_existsq
    jsr enter
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word pquerycolon
    .word _foundq
    .word false
#include "pad.i65"
    .word andx
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: `'`
tags: forth-83

stack=( -- cfa )
*/
#if 0
name='
tags=forth-83

#endif
#include "align.i65"
_tick
    jsr enter
#include "page.i65"
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word qerror
    .byt 3                      ; NOT FOUND
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: (CREATE)
tags: nosymbol

stack=( cfa -- )
Create a new symbol in the symbol table

|^ |^pass |^exit |h
|^redefined |^ |^here ~+/-3 |
|^dp        |^ |^enclose `JSR cfa`<br/>page crossing<br/>dp += 2 |
|^symtail   |^points to `0` |^enclose `dp` +3 ~ -3<br/>set `flags/length` byte<br/>append `vocabid` if needed<br/>`cmove`  symbol name |
|^newest |^ |^ |
|^symbol.flags.length |^ |^ |
|^symbol.txt |^ |^ |
|^symbol.vocabid |^ |^ |
|^%smudge |^ |^ |
|^current |^ |^ |
|^ |^ |^ |

* check for "MISSING NAME"
* look up the name
* found?
** ( NFA ) redefined !   ( smudge ya later! )
** "[RVS] " nfa $. "[OFF] EXISTS"
** enclose cfa jsr,
** set bloom filter bit true
** store created word's CFA at symtail++
** set newest where symtail is now

** store length/vocab at symtail+
** sym+s calculatesss new symtail?
** turn off byte at new symtail



** immediate bit? always 0 here.
** if current != 0 then ORA $20 that length(N8)
** (`from` = n3; `to`=symtail, `howmany`=length+vocab bit)
** jsr plants8
* bloom  symtail+2 current  rot
* ?align cfa,  here 3-  newest
** enclose nop byte, if needed
** 3 dp +!
** set newest to jsr opcode's address


* create00
code create00
  brk,  harvests6 ext,  n0 popd@,
  n3 st,  n2 ld,  n3 std@,  n3 ld,
  tos std@,  n7 ld ,  n3 st,  tos popd@,
  tos st,  symcopy ext,  n1 ld@,
  'create01 bz,  $40 acc set,
:create01
  tos st,  n7 inr,  n7 pop,  n5 st,
  tos add,  n7 st@,  n7 ld,  n5 add,
  n7 st,  n1 pop, 'create02 bz,
  n7 st@,
:create02
  n7 ld,  n0 std@,  acc sub,  n7 st@,
  n7 std@,  pull,  rtn,  exit jmp,

|^N2 |^                 |^flags,len,og  |
|^N4 |^seek.length      |^ .            |
|^N5 |^                 |^vocabid       |
|^N6 |^                 |^vocabs        |
|^N7 |^nfa.strand[0]    |^ .            |
|^N8L|^                 |^result.length |
|^N8H|^                 |^toggle sorted/unsorted |

|^stack |^( cfa -- )|<|h
|^N0 |^                 |^              |
|^N1 |^                 |^              |
|^N2 |^                 |^nfa.flags.length |
|^N3 |^ .               |^nfa.result    |
|^N4 |^ .               |^seek.length |
|^N5 |^ .               |^              |
|^N6 |^ .               |^              |
|^N7 |^ .               |^              |
|^N8 |^                 |^nfa.length    |
|^N9 |^                 |^              |
|^redefined |^          |^true iff name already existed |
|reg |entry             |exit           |f



*/
#include "align.i65"
_pcreate
    jsr enter
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qerror
    .byt 4                      ; MISSING NAME
#include "pad.i65"
    .word _lbuf
#include "page.i65"
    .word in
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "pad.i65"
    .word swap
#include "page.i65"
    .word redefined
#include "page.i65"
    .word off
#include "page.i65"
    .word _existsq
#include "parm.i65"
    .word qbranch
    .byt <(pcreate02-*+1)
#include "parm.i65"
    .word zpfrom                        ; ~~ code path appears broken
    .byt R0L+2*N3
#include "pad.i65"
    .word redefined
#include "page.i65"
    .word store
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N7                       ; ~~ eschew n7
#include "pad.i65"
    .word dotrvs
#include "page.i65"
    .word _stringdot
#include "parm.i65"
    .word _pdq
    .byt <(pcreate01-*-1)
    .asc RVSOFF," EXISTS"
pcreate01
#include "pad.i65"
pcreate02
    .word _cfacomma
#include "page.i65"
    .word _bloomfilter
#include "page.i65"
    .word cbitstore
#include "page.i65"
    .word bloom                 ; `symtail 2+`
#include "page.i65"
    .word newest
#include "page.i65"
    .word here
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word create00                      ; ( from to howmany )
#include "page.i65"
    .word cmove                         ; drop the text into place
#include "past.i65"
    .word exit

/*

usernewest      = uendcore+18   ;1  field ordering optimization
usercurrent     = uendcore+20   ;2

```
code create00
  brk  'harvests4 ext,
  n0 popd,  n2 st,  tos ld,  n2 std,
  n2 ld,  n1 std,  acc inr,  n4 add,
  tos st,  n4 ld,  n5 st,  n1 ldi,
  0= not if,
    $20 acc set,  n5 add,  n5 st,
  then,
  tos ld,  n0 std,  n5 ld,  n2 sti,
  n2 ld,  tos st,  n4 ld,  push,  nxt,
```
*/
create00
    brk
    .byt ext
    .word harvests4
    .byt popd | N0              ; symtail
    .byt st   | N2              ; LFA
    .byt ld   | TOS             ; cfa
    .byt std  | N2              ; lfa !+
    .byt ld   | N2              ; nfa
    .byt std  | N1              ; newest !+
    .byt inr  | ACC
    .byt add  | N4 
    .byt st   | TOS
    .byt ld   | N4
    .byt st   | N5
    .byt ldi  | N1             ; current c@
    .byt bz , <(create00c-*-2)
    .byt sti  | TOS
    .byt set  | ACC
    .word $80
    .byt add  | N5
    .byt st   | N5
create00c
    .byt ld   | TOS
    .byt std  | N0              ; update symtail
    .byt sub  | ACC
    .byt std  | TOS             ; write three nulls to mark tail
    .byt sti  | TOS
    .byt ld   | N5              ; len/flags
    .byt sti  | N2
    .byt ld   | N2
    .byt st   | TOS
    .byt ld   | N4
    .byt push
    .byt nxt

;------------------------------------------------------------------------------
/*
title: STRAND+
tags: nosymbol

increment the length byte (N4l) until it
reaches 32, then increment strand (N4h)

code strand+   ( -- )
  n4 inc,  32 # lda,  n4 eor,
  0<> if,  n4 sta,  n4 1+ inc,  then,
  rts,
*/
strandplus
    inc R0L+2*N4
    lda #32
    eor R0L+2*N4
    bne straplu01
    sta R0L+2*N4
    inc R0L+2*N4+1
straplu01
    rts

;------------------------------------------------------------------------------
/*
title: :WILLITBLEND?
tags: nosymbol sweet16

Evaluate (and maybe retain) a name
|tos|symnew             |symnew             |
|n0 |cfa(n3)            |cfa(n3)            |
|n2 |studio             |studio             |
|n3 |nfa                |nfa+               |
|n4 |                   |stepper len/strand |
|n5 |                   |output to pad      |
|n6 |                   |cutoff             |

:willitblend?
    'sym.strand ext,
    n4 ld,  n8 cpr,  'wiblend02 bnz,    \ len/strand must match exactly
    n3 ld,  n0 st,
    n0 popd,  n6 cpr,  'wiblend01 bp,   \ and cfa must be in bounds
    n2 cpr,  'wiblend02 bp,
:wiblend01
    'sym.copy ext,
:wiblend02
    'sym+ ext,  rs,
*/
willitblendq
    .byt ext
    .byt ld  | N4
    .byt cpr | N8                       ; shall I compare n4 to a summer's day?
    .byt bnz , <(wiblend02-*-2)         ; move over to unsorted list if they differ
    .byt popd | N3
    .byt ldd  | N3                      ; get cfa without disturbing n3
    .byt cpr | N2                       ; compare to studio
    .byt bp , <(wiblend01-*-2)
    .byt cpr | N6                       ; compare to cfa
    .byt bp , <(wiblend02-*-2)
wiblend01
;    .byt ext
;    .word symcopy
wiblend02
    .byt ext
    .word symplus
    .byt rs

;------------------------------------------------------------------------------
/*
title: (FNORD)
tags: nosymbol sweet16 tiny

```
code fnorditude   ( cfa pad 'studio -- pad size )
    brk, tos ldd, n2 st,  pull, n5 st,
    pull, n6 st,  acc sub, n4 st,       \ n2=studio n3=sym0 n4=0 n5=pad n6=cfa
    symnew tos set,  tos ldd,  tos st,  \ unsorted symbols
```
*/
pfnord
    brk
    .byt ldd | TOS
    .byt st  | N2                       ; n2=studio
    .byt pull
    .byt st  | N5                       ; n5=output buffer (pad)
    .byt pull
    .byt st  | N6                       ; n6=cfa copy
    .byt sub | ACC
    .byt st  | N4                       ; n4=current len/strand off
    ; fall through
;------------------------------------------------------------------------------
/*
title: :SOSORTED
tags: nosymbol

```
:sosorted
    'willitblend? bs, 'sosorted bz,     \ copy sorted names for len/strand=n4
    n3 ld,  tos cpr,  'fnordout bp,     \ while  n3 < symnew
    tos ld,  n0 st,
    n3 ld, push,  n8 ld, push,          \ TOS is next sorted len/strand
```
*/
sosorted
    .byt bs , <(willitblendq-*-2)
    .byt bz , <(sosorted-*-2)
    .byt ld  | N3
    .byt cpr | TOS
    .byt bp , <(fnordout-*-2)
    .byt ld  | TOS
    .byt st  | N0
    .byt ld  | N3
    .byt push,
    .byt ld  | N8
    .byt push,
    ; fall through
;------------------------------------------------------------------------------
/*
title: :SOSCRAMBLED
tags: nosymbol

:soscrambled
    n0 ld,  n3 st,                      \ n3=symnew
:howaboutthis
    'willitblend? bs,
    n3 ldd, :howaboutthis bnz,
    'strand+ ext,
       <n4 tos =
    'soscrambled bnz,
    tos ld, n8 st, pull, n3 st,
    n0 ld, tos st,
    'sosorted br,               \ repeat
:fnordout
    nxt,
```
*/
soscrambled
    .byt ld | N0
    .byt st | N3
howaboutthis
    .byt bs , <(willitblendq-*-2)
    .byt ldd | N3
    .byt bnz , <(howaboutthis-*-2)
    .byt ext
    .word strandplus
    .byt ld | N4
    .byt cpr | TOS
    .byt bnz , <(soscrambled-*-2)
    .byt ld | TOS
    .byt st | N8
    .byt pull,
    .byt st | N3
    .byt ld | N0
    .byt st | TOS
    .byt br ,  <(sosorted-*-2)
fnordout
    .byt nxt
;------------------------------------------------------------------------------
/*
title: FNORD
tags: nosymbol secondary

code strand.len+
    lda n4
    and #31
    bne +
    sta n4
    inc n4+1
    lda n4+1
    and #15
    beq seeyabye
seeyabye
    rts
+
end-code

```
: fnord   ( cfa -- )
    sym0  pad studio                    ( cfa pad 'studio )
    fnorditude !symtab ;
```
*/
#include "align.i65"
_fnord
    jsr enter
#include "page.i65"
    .word sym0
#include "page.i65"
    .word _pad
#include "page.i65"
    .word studio
#include "page.i65"                     ; ~goto symtab! to end (fnord)
    .word pfnord
#include "page.i65"
    .word _setsymtab
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: FORGET
tags: secondary dictionary fig forth-79 forth-83

```
: forget   ( "name" ; -- )  '           \ next token from input stream
  dup fence @ u<  7 ?error              \ can't forget below fence
  (fnord) ;
```
*/
#if 0
name=FORGET
tags=fnord
#endif
#include "align.i65"
_forget
    jsr enter
#include "page.i65"
    .word _tick
#include "page.i65"
    .word fence
#include "page.i65"
    .word fetch
#include "page.i65"
    .word under
#include "page.i65"
    .word ult
#include "parm.i65"
    .word qerror
    .byt 7                      ; CAN'T FORGET BELOW FENCE
#include "pad.i65"
    .word _fnord
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: DEFINITIONS
tags: forth-83

Set `current` vocabulary for `create`

```
code definitions   ( -- )
  vocabs 1+ lda,  current sta,
  next jmp,
```
*/
#if 0
name=DEFINITIONS
tags=fnord
#endif
definitions
    lda uservocabs+1
    sta usercurrent
    jmp next
;------------------------------------------------------------------------------
/*
title: REHASH
tags: secondary pettil dictionary

Sort/merge a fresh dictionary

```
: rehash   ( -- )
  here (fnord) ;
```
*/
#if 0
name=REHASH
tags=fnord
#endif
#include "align.i65"
_rehash
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word _fnord
#include "past.i65"
    .word exit
;------------------------------------------------------------------------------
/*
title: FORTH
tags: vocabulary forth-83

Search only the main forth vocabulary

```
\ must be first vocabulary defined
#voc on  vocabulary forth
```
~~~code golf~~~
[-7 bytes] chitselb 2020-05-11
*/
#if 0
name=FORTH
tags=fnord
#endif
#include "align.i65"
_forth
    jsr dovocab
    .byt 0                              ; vocabulary identifier
