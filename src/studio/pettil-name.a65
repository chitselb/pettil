; pettil-name.a65
;#echo .       pettil-name.a65           Text parser

;--------------------------------------------------------------
#if 0
name=SKIP
stack=( -- offset )
tags=nosymbol
`addr1` is the starting address in the input stream where up
to `size1` bytes are skipped *WHILE* they match `delim` in `n6`.  Returns
`addr2` as the address of the first non-matching character and
`count2` as the remaining number of bytes in the buffer.
#endif
skip
    lda #$F0                    ; BEQ opcode
    .byt $2C                    ; BIT abs
    ;fall through
;--------------------------------------------------------------
#if 0
name=SCAN
stack=( -- offset )
tags=self-modifying,nosymbol
Pass through the input stream until `delim` either matches (or for `skip`, does not match).  Leave the `offset` into the line buffer on the stack.

N6 line buffer
N7 char delimiter
#endif
scan
    lda #$D0                    ; BNE opcode
    ;
    sta skipscan03              ; #selfmodifying
    ldy userin                  ; `in`
    dey
skipscan01                                                                      BEGIN
    iny
    cpy userspan
    bcs skipscan05
    lda (R0L+2*N6),y            ; get char from buffer
    eor R0L+2*N7                ; compare to character we seek
skipscan03
    bvc skipscan01              ; dummy opcode, BEQ(skip) BNE(scan)             UNTIL
skipscan05
    sty userin                  ; found char !, move `in`
    tya
    jmp push0a                  ;( offset )

;--------------------------------------------------------------
#if 0
name==CURSOR
stack=( addr|0 -- )
tags=primitive,ext
This word serves the purposes of:

# Simultaneously fetch and store the firmware cursor in a portable way
# Manage multiple cursor instances

|tos|swap `cursor` uservar with...|<|h
|0|hardware cursor|(use `0`, although any zp address works)|
|256..65535|6 consecutive bytes at `addr`||

```
        0 =cursor               \ swap 6 bytes at `cursor` uservar with firmware cursor values
 mycursor =cursor               \ swap 6 bytes at `cursor` with `mycursor`
```
#endif
exchgcursor
    stx z
    ldx #<(-6)
    ldy #0
excur01
    lda tos+1
    bne excur02                 ; when argument is 0,
    ldy firmwarecursor-250,x    ; get Y from a list of cursor zeropage addresses
excur02
    lda (tos),y
    pha
    lda usercursor-250,x
    sta (tos),y
    iny
    pla
    sta usercursor-250,x
    inx
    bmi excur01
dropfixup
    ldx z
    jmp drop

firmwarecursor
    ;    $AF   $C6  $D5  ($C4)     $D8
    .byt DFLTN,PNTR,TBLX,PNT,PNT+1,LNMX
    ;    3     in   lin  lin*40    span
    ;                    +blkbuf
; C4 PNT   current (logical) screen line address
; C6 PNTR  current cursor column on current line
; D8 LNMX  width of the screen (39 or 79)

;--------------------------------------------------------------
#if 0
name=QUERY
stack=( -- )
tags=secondary,fig,interpreter
Accept another line of input from the keyboard to `tib`

```
: query
    span c@ ?exit
    tib 80 expect ;
```
#endif
#include "align.i65"
_query
    jsr enter
#include "page.i65"
    .word tib
#include "pad.i65"
    .word eighty
#include "page.i65"
    .word expect
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REFILL
stack=( -- )
tags=secondary,outer,extra,nosymbol
Uses CHRIN via `expect` to load `sib` buffer with line `lin` from `blkbuf`

assumptions:
    `lin` is valid (0..24)

    lin buf.wrap >bit cbit@             \ 0=80 1=40
    ?: 40 80 dup r> c!

;   ( 40|80 buf.line cursor -- )
: !buf.cursor
    3 c!+                        \ DFLTN device = screen(3)
                                        \ PNTR cursor position on line = 0 to capture the whole line
                                        \ TBLX = 0
    ( buffer cursor+2 )
: refill   ( -- )
    sib                                 ( sib )
    lin 40* blk@ block +                ( sib buf.line )
    lin buf.wrap >bit cbit@             ( sib buf.line 1|0 )
    ?: forty eighty swap                ( sib 40|80 buf.line )
    cursor                              ( sib 40|80 buf.line cursor )
    !buf.cursor                         ( sib 40|80 )

    lin 40* rot + !+  >r
    lin buf.wrap >bit cbit@

```
: refill   ( -- )
    sib  blk@ block   ( sib blkbuf )
    cursor
        3 c!+  0 !+
        lin 40* rot + !+  >r
        lin buf.wrap >bit cbit@
        ?: forty eighty  dup  r> c!
    0 =cursor  expect  0 =cursor ;

: refill   ( -- )
    sib  blk@ block
    cursor
        3 c!+  0 !+
        lin 40* rot + !+  >r
        lin buf.wrap >bit cbit@
        ?: forty eighty  dup  r> c!
    0 =cursor  expect  0 =cursor ;
```
#endif
#include "align.i65"
_refill
    jsr enter
#include "page.i65"
    .word sib
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word _block
#include "page.i65"
    .word cursor
#include "page.i65"
    .word three
#include "page.i65"
    .word cstoreplus
#include "page.i65"
    .word zero
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word lin
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word rot
#include "page.i65"
    .word plus
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word tor
#include "page.i65"
    .word lin
#include "page.i65"
    .word _bufwrap
#include "page.i65"
    .word tobit
#include "page.i65"
    .word cbitfetch
#include "parm.i65"
    .word pquerycolon
    .word forty
    .word eighty
#include "pad.i65"
    .word dup
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word cstore
#include "page.i65"
    .word zero
#include "page.i65"
    .word exchgcursor
#include "page.i65"
    .word expect
#include "page.i65"
    .word zero
#include "page.i65"
    .word exchgcursor
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LIN+
stack=( -- flag )
tags=primitive,outer,extra,nosymbol
Return `false` when last line of screen is reached

#endif
linplus
    ldy userlin
    bmi linplus01               ; lin = -1 means top of screen, +1
    bit usercursor+5            ; V is opposite of linewrap bit for this line (0=40 true=80)
    bvc linplus01               ; ( 40 ) lin 1+!
    iny                         ; ( 80 ) lin 2+!
linplus01
    iny
    sty userlin
    jmp next

;--------------------------------------------------------------
#if 0
name=EOI?
stack=( -- flag )
tags=primitive,outer,extra,nosymbol
Return `true` when end of line input buffer is reached

#endif
eoiq
    lda userblk
    beq eolq
    lda userlin
    cmp #LPERSCR
    bcc eolq09
    ;fall through
;--------------------------------------------------------------
#if 0
name=EOL?
stack=( -- flag )
tags=primitive,outer,extra,nosymbol

#endif
eolq
    lda userin
    cmp userspan
eolq09
    jmp xpushc

/* tiddlypettil
created: 20191004085624546
creator: chitselb

modified: 20191004091301129
modifier: PETTIL

tags: fun seamonkeys deprecated concepts
title: tiddlypettil documentation test

[img[logo2018-05-13-22-58.png]]
<br/>This should be fun

If all goes well, I will become an actual tiddler in the generated docs.

In tiddler .tid format to make exported tiddlers more usable

|table|are|easy|now|h
|such||table||
||^ wow|table||
||~|>| yes|
| woot footer|<|<||f
*/

;--------------------------------------------------------------
#if 0
name=EMPTY?
stack=( -- flag )
tags=primitive,outer,extra,nosymbol
Did the user just hit RETURN on an empty line?

This relies on `n0` as a (very) temporary mailbox written by `expect`!

#endif
emptyq
    ldy n                       ; mailbox. if populated with $FF by `expect`, that's why.
    iny                         ; presumably, the user will just hit return all day long
    jmp xpushz
;[6]

;--------------------------------------------------------------
#if 0
name=REFILL?
stack=( -- flag )
tags=secondary,outer,extra,nosymbol
Returns `true` then the input stream is available (not exhausted),
after properly reloading the line buffers as needed.

                    interactive         loading
'return'            true                false               refill? returns false  name returns true
'end of line'       true                false
'end of screen'     n/a                 true

eol?                in >= span          end of line
eoi?                lin >= l/scr        end of screen
empty?              n0 = -1             blank line


uservar cursor   ( -- addr )
    uservar, 6-byte virtual cursor
                            loading                     interactive session
        DFLTN                   3                           0
        PNTR                    in                          screen horiz position
        TBLX                    0                           screen vertical line position
        (PNT)                   blkbuf+lin*40               screen line address
        LNMX                    40 or 80                    39 or 79, logical line length

uservar in   ( -- addr )
    uservar, horizontal position in line buffer
    initialized by `expect`
    updated by `skip` and `scan`

uservar lin   ( -- value )
    upper byte of `in`, vertical line in line buffer
    always points to start of a logical line
    initialized by `load`
    updated by `lin+`

code eol?   ( -- flag )
    true when `in` reached end of line
    true when in >= span

code eoi?   ( -- flag )
    true when `lin` reached end of screen
    true when lin >= l/scr

code empty?   ( -- flag )
    true when `expect` received a blank line of input

code lin+   ( -- )
    add +1 (40) or +2 (80) to virtual screen pointer `lin`, based on `sib` size
    line size from `cursor` LNMX field

: refill   ( -- )
    `expect` transforms (via CHRIN) a line from `blkbuf` into `sib`,
    retrieve the block if `prev` <> `blk`

code expect   ( buff size -- )
    receive up to `size` characters into `buff` via CHRIN
    initialize `in` and `span`
    leave a true copy of span in `n0` for `empty?`
    called by `query` and `refill`

: query   ( -- )
    receive a (logical) line of input from the terminal into `tib`
    called only during interactive session

code =cursor   ( addr|0 -- )
    swap hardware cursor with `cursor`
    called only when loading

: parse   ( -- size )
    identify next token in the input stream, returning its length
    set `n8` = length
    point `in` at the character following the parsed token

code skip   ( -- )
    skip to non-match of char in `n7`, in line buffer pointed to by `(n6)`

code scan   ( -- )
    scan to next match of char in `n7`, in line buffer pointed to by `(n6)`

refill?   ( -- flag )
    load the line buffer `sib` or `tib`, if possible and necessary.
    return true when `in` has not reached `span` (end of line)
    ---
    loading:
    add +1 or +2 to `lin`
    return true if screen is exhausted
    otherwise, build a fake cursor
    retrieve block `blk@`
    refill `sib` from line `lin`
    reset `in` to 0
    return not `eoi?`
    ---
    interactive session:
    return true if the user has already entered an empty line
    otherwise, `query` the terminal for a line of input
    return true
    ---

    : refill?   ( -- flag )
        eol? 0= dup ?exit
        blk@
        if
            lin+  eoi?  ?dup ?exit
            reflll eoi? 0=
        else
            true  empty? ?exit
            query
        then ;
```
#endif
#include "align.i65"
_refillq
    jsr enter
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qbranch
    .byt <(qrefill02-*+1)
#include "pad.i65"
    .word blkfetch
#include "parm.i65"
    .word qbranch
    .byt <(qrefill01-*+1)
#include "pad.i65"
    .word linplus
#include "page.i65"
    .word eoiq
#include "page.i65"
    .word qdup
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word _refill
#include "page.i65"
    .word eoiq
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word branch
    .byt <(qrefill02-*+1)
#include "pad.i65"
qrefill01
    .word true
#include "page.i65"
    .word emptyq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word _query
#include "past.i65"
qrefill02
    .word exit
/*
tags:
uservar                         system variable
constant                        value
variable                        address
vocabulary                      add vocabid to `vocabs`
subroutine
primitive
secondary
data                            messages, initialization values, BASIC loader
table                           data containing addresses

*/

;--------------------------------------------------------------
#if 0
name=PARSE
stack=( -- nfa|0 )
tags=secondary,outer,extra,nosymbol

* set n7 delimiter char
* refill the line buffer (if empty)
* skip/scan move `in` past token
* set n8 token length
* put length before text in buffer
* move `in` past trailing space

```
: parse   ( -- length )
    skip dup 1- <n6 +
    scan rot -
    dup !nfa ;

: !nfa
    >n8 over c!  in 1+! ;
```
#endif
#include "align.i65"
_parse
    jsr enter
#include "page.i65"
    .word skip                  ; start of name
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N6               ; line buffer
#include "pad.i65"
    .word plus
#include "page.i65"
    .word scan                  ; end of name (and/or buffer)
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus                 ; length
#include "parm.i65"
    .word tozp
    .byt R0L+2*N8               ; name.len
#include "pad.i65"
    .word tuck                  ; ( len buf len )
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplusstore
#include "parm.i65"
    .word pquerycolon
    .word tuck                  ; ( buf len buf )
    .word under                 ; ( 0 0 buf )
#include "pad.i65"
    .word cstore
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME
stack=( char -- nfa|false )
tags=outer,extra
    return address of next token in the line buffer, or
    return false when the input stream is exhausted.
    ---
    `name` is the name of the word formerly known as `word`, which is not
    present.  Absence of `word` is a variance from the Forth-83 standard, and
    the new and improved `name` fulfills all the original purposes of `word`.

```
: name   ( char -- nfa|false )
    blk@ ?: sib tib  n6 2!
    begin  refill?  until
    eoi? ?: false parse ;
```
#endif
#include "align.i65"
_name
    jsr enter
#include "page.i65"
    .word blkfetch
#include "parm.i65"
    .word pquerycolon
    .word sib
    .word tib
#include "parm.i65"
    .word blit
    .byt R0L+2*N6
#include "pad.i65"
    .word twostore              ; set n6=lib; n7=char
#include "page.i65"
name01
    .word _refillq
#include "parm.i65"
    .word qbranch
    .byt <(name01-*+1)
#include "pad.i65"
    .word eolq
#include "parm.i65"
    .word pquerycolon
    .word false
    .word _parse
#include "past.i65"
    .word exit
