; pettil-name.a65
;#echo .       pettil-name.a65           Text parser

;--------------------------------------------------------------
#if 0
name=SKIP
stack=( -- offset )
tags=nosymbol
`addr1` is the starting address in the input stream where up
to `size1` bytes are skipped *WHILE* they match `delim` in `n6`.  Returns
`addr2` as the address of the first non-matching character and
`count2` as the remaining number of bytes in the buffer.
#endif
skip
    lda #$F0                    ; BEQ opcode
    .byt $2C                    ; BIT abs
    ;fall through
;--------------------------------------------------------------
#if 0
name=SCAN
stack=( -- offset )
tags=self-modifying,nosymbol
Pass through the input stream until `delim` either matches (or for `skip`, does not match).  Leave the `offset` into the line buffer on the stack.

N6 line buffer
N7 char delimiter
#endif
scan
    lda #$D0                    ; BNE opcode
    ;
    sta skipscan03              ; #selfmodifying
    ldy userin                  ; `in`
    dey
skipscan01                                                                      BEGIN
    iny
    cpy userspan
    bcs skipscan05
    lda (R0L+2*N6),y            ; get char from buffer
    eor R0L+2*N7                ; compare to character we seek
skipscan03
    bvc skipscan01              ; dummy opcode, BEQ(skip) BNE(scan)             UNTIL
skipscan05
    sty userin                  ; found char !, move `in`
    tya
    jmp push0a                  ;( offset )

;--------------------------------------------------------------
#if 0
name==CURSOR
stack=( addr|0 -- )
tags=primitive,ext
This word serves the purposes of:

# Simultaneously fetch and store the firmware cursor in a portable way
# Manage multiple cursor instances

|tos|swap `cursor` uservar with...|<|h
|0|hardware cursor|(use `0`, although any zp address works)|
|256..65535|6 consecutive bytes at `addr`||

```
        0 =cursor               \ swap 6 bytes at `cursor` uservar with firmware cursor values
 mycursor =cursor               \ swap 6 bytes at `cursor` with `mycursor`
```
#endif
exchgcursor
    stx z
    ldx #<(-6)
    ldy #0
excur01
    lda tos+1
    bne excur02                 ; when argument is 0,
    ldy firmwarecursor-250,x    ; get Y from a list of cursor zeropage addresses
excur02
    lda (tos),y
    pha
    lda usercursor-250,x
    sta (tos),y
    iny
    pla
    sta usercursor-250,x
    inx
    bmi excur01
dropfixup
    ldx z
    jmp drop

firmwarecursor
    ;    $AF   $C6  $D5  ($C4)     $D8
    .byt DFLTN,PNTR,TBLX,PNT,PNT+1,LNMX
    ;    3     in   lin  lin*40    span
    ;                    +blkbuf
; C4 PNT   current (logical) screen line address
; C6 PNTR  current cursor column on current line
; D8 LNMX  width of the screen (39 or 79)

;--------------------------------------------------------------
#if 0
name=QUERY
stack=( -- )
tags=secondary,fig,interpreter
Accept another line of input from the keyboard to `tib`

```
: query
    span c@ ?exit
    tib 80 expect ;
```
#endif
#include "align.i65"
_query
    jsr enter
#include "page.i65"
    .word tib
#include "pad.i65"
    .word eighty
#include "page.i65"
    .word expect
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REFILL
stack=( -- )
tags=secondary,outer,extra,nosymbol
Uses CHRIN via `expect` to load `sib` buffer with line `lin` from `blkbuf`

assumptions:
    `lin` is valid (0..24)

    lin buf.wrap >bit cbit@             \ 0=80 1=40
    ?: 40 80 dup r> c!

;   ( 40|80 buf.line cursor -- )
: !buf.cursor
    3 c!+                        \ DFLTN device = screen(3)
                                        \ PNTR cursor position on line = 0 to capture the whole line
                                        \ TBLX = 0
    ( buffer cursor+2 )
: refill   ( -- )
    sib                                 ( sib )
    lin 40* blk@ block +                ( sib buf.line )
    lin buf.wrap >bit cbit@             ( sib buf.line 1|0 )
    ?: forty eighty swap                ( sib 40|80 buf.line )
    cursor                              ( sib 40|80 buf.line cursor )
    !buf.cursor                         ( sib 40|80 )

    lin 40* rot + !+  >r
    lin buf.wrap >bit cbit@

```
: refill   ( -- )
    sib  blk@ block   ( sib blkbuf )
    cursor
        3 c!+  0 !+
        lin 40* rot + !+  >r
        lin buf.wrap >bit cbit@
        ?: forty eighty  dup  r> c!
    0 =cursor  expect  0 =cursor ;

: refill   ( -- )
    sib  blk@ block
    cursor
        3 c!+  0 !+
        lin 40* rot + !+  >r
        lin buf.wrap >bit cbit@
        ?: forty eighty  dup  r> c!
    0 =cursor  expect  0 =cursor ;
```
#endif
#include "align.i65"
_refill
    jsr enter
#include "page.i65"
    .word sib
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word _block
#include "page.i65"
    .word cursor
#include "page.i65"
    .word three
#include "page.i65"
    .word cstoreplus
#include "page.i65"
    .word zero
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word lin
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word rot
#include "page.i65"
    .word plus
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word tor
#include "page.i65"
    .word lin
#include "page.i65"
    .word _bufwrap
#include "page.i65"
    .word tobit
#include "page.i65"
    .word cbitfetch
#include "parm.i65"
    .word pquerycolon
    .word forty
    .word eighty
#include "pad.i65"
    .word dup
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word cstore
#include "page.i65"
    .word zero
#include "page.i65"
    .word exchgcursor
#include "page.i65"
    .word expect
#include "page.i65"
    .word zero
#include "page.i65"
    .word exchgcursor
#include "past.i65"
    .word exit

linplus
    ldy userlin
    bmi linplus01               ; lin = -1 means top of screen
    bit usercursor+5
    bvc linplus01               ; 40
    iny                         ; 80
linplus01
    iny
    sty userlin
    jmp next

/*
    {programmer} --> CHRIN --> tib
    blkbuf  --> CHRIN --> sib

    interpret
        begin
            ?stack
            name
                parse
        while
            found?
                true:   interpret.cfa
                false:  number
        repeat ;

    loading? get another line
    interactive? print "OK" and get another line

    : !buf.cursor

*/

;   ( 40|80 buf.line cursor -- )
setbufcursor
    brk
    .byt ld | TOS
    .byt st | N0
    .byt set | ACC
    .word 3
    .byt sti | N0                       ; set DFLTN = 3 (screen)
    .byt sub | ACC
    .byt std | N0                       ; set PNTR, LNMX = 0 (pretend it's the top line)
    .byt pull
    .byt std | N0
    .byt pull
    .byt sti | N0
    .byt nxt
;[14]

;--------------------------------------------------------------
#if 0
name=EOI?
stack=( -- flag )
tags=primitive,outer,extra,nosymbol
Return `true` when end of line input buffer is reached

#endif
eoiq
    lda userblk
    beq eolq
    lda userlin
    cmp #LPERSCR
    bcc eolq09

;--------------------------------------------------------------
#if 0
name=EOL?
stack=( -- flag )
tags=primitive,outer,extra,nosymbol

#endif
eolq
    lda userin
    cmp userspan
eolq09
    jmp xpushc

;--------------------------------------------------------------
#if 0
name=MORE?
stack=( -- flag )
tags=secondary,outer,extra,nosymbol

```
: more?   ( -- flag )
    blk@ ?: eoi? eol? not ;
```
#endif
#include "align.i65"
_moreq
    jsr enter
#include "page.i65"
    .word blkfetch
#include "parm.i65"
    .word pquerycolon
    .word eoiq
    .word eolq
#include "pad.i65"
    .word not
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?REFILL
stack=( -- flag )
tags=secondary,outer,extra,nosymbol
Returns `true` then the input stream is available (not exhausted),
after properly reloading the line buffers as needed.

fill line buffer

eol? := ( in >= span )
    false
                there is a valid line buffer.  Return true


eol? ?: exit


 if
    span c@ 0= if


reload when
    prev <> blk                 ; returning from loading something else


?  block

```
: empty?   ( -- flag )

eol? span @ blk@ or 0= if
tib 80 query then

eol? blk@ if
( loading )
    prev @ blk@ =
    if
    else
        refill
    then
else
( interactive )
    ( eol? ) span c@ 0=  and
    if  tib 80 query  then
then

name returns 0 when the buffer is empty
in an interactive session, this is the end of the line
                                ( blk = 0 ) AND ( in >= span ) AND ( span > 0 )
For loading, this means reaching the end of the last line from the block buffer
                                ( blk > 0 ) AND ( in >= span ) AND ( lin >= l/scr )
prior to throwing a 0, empty? will attempt to refill the buffer

* return
** false = buffer exhausted
** true  = buffer available for `parse`
    N6 = line input buffer (tib or sib)
    N7 = character (usually a space)
    tib = last line typed
    sib = current line for `load`
    blk = interactive=0, else screen being loaded
    in = position
    lin = current line on screen
* reload current line to `sib` when `prev` <> `blk`
* lin +1 or +2

line.size

reload
use CHRIN to translate a line of input via `expect` from `blkbuf` to `sib`


refill

scenario:interactive via `quit`
blk=0

scenario:loading called interactively
blk=2

scenario:nested loading of screens
blk=1

eoi?
blk@
if

else

then

0
 (blk@ = 0) and (in >= span) and (span > 0)             end of line
 (blk@ > 0) and (in >= span) and (lin >= l/scr)         end of block




blk@
if

else
    eol?
then

 or when the blkbuf is empty

buffer is empty w    eol?

blk@                    blk             interactive
    in                  0 .. span       0 .. span
    lin                 0 .. l/scr      0
                                        span
                                            width of line
                                            0 = first time
interactive
    empty when (span <> 0) AND (in >= span)

eoiq_loading
    lda userblk
    beq eoiq_interactive

eoiq_interactive
    lda userin
    cmp userspan
    bne eoiq
    clc
eoiq
    jmp putc
: empty?
    blk@ prev @ <> if refill then

: refill?   ( -- flag )
    blk@ ?: eoi? eol? not ;

: refill
    \ build the cursor
    \

inputs
    blk                     0 = interactive                 +u = loading
    in                      position on line
    lin
    span
    prev


    N6                      line buffer pointer for `found?`                    set by `name`
    N7                      search character                                    set by `name`
    N8                      name.len                                            set by `parse`

processes & outputs

    cursor                      interactive                 loading
        DFLTN                   Kernel screen               3
        PNTR                    editor values               0
        TBLX                                                0
        PNT                                                 (blkbuf + lin * 40)
        LNMX                                                40|80  <-- this line's linewrap bit
    tib                         x
    sib                                                     x

eoi?                flag: end of input?
eol?                flag: end of line?
lin+                get linewrap bit for `lin` and add +1 or +2
refill              `expect` current line into `sib` from `blkbuf`
query               `expect` a line into `tib` from the terminal
expect              zeroes `in`
=cursor             switches hardware cursor with `cursor`
expect              sets `in` = 0; `span` = line.len
parse               sets N8 = name.len; adds +1 to `in`
skip                skip to non-match of character N7 in line buffer (N6)
scan                scan to next match of character N7 in line buffer (N6)

buffloadedq
    lda userspan
    beq blq01
    lda userin
    cmp userspan





: ?refill   ( -- )
    blk@ ?: eoi? eol? span c@ and ?exit
    blk@
    if  eol?  if  lin+  then
        eoi? ?exit  refill
    else  query
    then ;


: ?refill
    eol?
    if
        blk@
        if \ loading?
            lin+ eoi? ?exit
            refill
        else \ interactive?
            span c@ ?: \ query
        then
    then
    loading?

```
#endif
#include "align.i65"
_qrefill
    jsr enter
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qbranch
    .byt <(qrefill02-*+1)
#include "pad.i65"
    .word blkfetch
#include "parm.i65"
    .word qbranch
    .byt <(qrefill01-*+1)
#include "pad.i65"
    .word linplus
#include "page.i65"
    .word eoiq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word _refill
#include "parm.i65"
    .word branch
    .byt <(qrefill02-*+1)
#include "pad.i65"
qrefill01
    .word span
#include "page.i65"
    .word cfetch
#include "parm.i65"
    .word pquerycolon
    .word backslash
    .word _query
#include "past.i65"
qrefill02
    .word exit

;--------------------------------------------------------------
#if 0
name=PARSE
stack=( -- nfa|0 )
tags=secondary,outer,extra,nosymbol

* set n7 delimiter char
* refill the line buffer (if empty)
* skip/scan move `in` past token
* set n8 token length
* put length before text in buffer
* move `in` past trailing space

```
: name.parse   ( -- length )
    skip dup 1- <n6 +
    scan rot -
    dup !nfa ;

: !nfa
    >n8 over c!  in 1+! ;
```
#endif
#include "align.i65"
_parse
    jsr enter
#include "page.i65"
    .word skip                  ; start of name
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N6               ; line buffer
#include "pad.i65"
    .word plus
#include "page.i65"
    .word scan                  ; end of name (and/or buffer)
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus                 ; length
#include "parm.i65"
    .word tozp
    .byt R0L+2*N8               ; name.len
#include "pad.i65"
    .word tuck                  ; ( len buf len )
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplusstore
#include "parm.i65"
    .word pquerycolon
    .word tuck                  ; ( buf len buf )
    .word under                 ; ( 0 0 buf )
#include "pad.i65"
    .word cstore
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME
stack=( char -- nfa|0 )
tags=outer,extra
Return the address of a counted string in the input stream, or 0 if the input stream is exhausted

`name` is the name of the word formerly known as `word`, which is not present.  Absence of `word` is a variance from the Forth-83 standard, and the new and improved `name` fulfills all the original purposes of `word`.

PETTIL uses a lazy loading design pattern

|What is a WORD?|<|<|h
|1|word|entry in the Forth dictionary|
|2|word|16 bits of memory|
|3|word|an English word|
|4|word|//required// reserved Forth-83 standard word to parse the input stream|
|5|word|things Cameo say before `up`|

* set `n6` to `tib`(interactive) or `sib`(loading)
* set `n7` to delimiter char ' '
* `refill?` will refill the line buffer, if needed

* test if line buffer (and screen buffer, if loading) exhausted
* set `n8` length
* return `false` or `nfa`
* Advance `in` past the parsed `word`.

`eoi` true when skip/scan reached end of line last time through

```

: name
\ set N6 = buffer addr, N6 = search char
\ (maybe) refill line buffer?

: name   ( char -- nfa|0 )
    blk@ ?: sib tib  N6 2!
    empty? ?: false parse  ;
```
#endif
#include "align.i65"
_name
    jsr enter
#include "page.i65"
    .word blkfetch
#include "parm.i65"
    .word pquerycolon
    .word sib
    .word tib
#include "parm.i65"
    .word blit
    .byt R0L+2*N6
#include "pad.i65"
    .word twostore              ; set n6=lib; n7=char
#include "page.i65"
    .word _qrefill
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word pquerycolon
    .word false
    .word _parse
#include "past.i65"
    .word exit
