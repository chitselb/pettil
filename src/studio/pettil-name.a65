; pettil-name.a65
;#echo .       pettil-name.a65           Text parser

;--------------------------------------------------------------
#if 0
name=SKIP
stack=( -- offset )
tags=nosymbol
skip to non-match of char in `n7`, in line buffer

```
code skip   ( -- offset )
    $f0 #       lda,
    $2c c,  \ bit abs opcode
    \ fall through
end-code
```
#endif
skip
    lda #$F0                    ; BEQ opcode
    .byt $2C                    ; BIT abs
    ;fall through
;--------------------------------------------------------------
#if 0
name=SCAN
stack=( -- offset )
tags=self-modifying,nosymbol
scan to next match of char in `n7`, in line buffer pointed to by `(n6)`

N6 line buffer
N7 char delimiter

```
code scan   ( -- offset )
    $d0 #           lda,
    \ entry from skip
    '+              sta,
    in              ldy,
                    dey,
here            &-
                    iny,
    span            cpy,
                '++ bcs,
    n6 )y           lda,
    n7              eor,
here &+     \ self-modifying
    '-              bvc,
here            &++
    in              sty,
                    tya,
    'push0a         jmp,
end-code
```
#endif
scan
    lda #$D0                    ; BNE opcode
    ;
    sta skipscan03              ; #selfmodifying
    ldy userin                  ; `in`
    dey
skipscan01                                                                      BEGIN
    iny
    cpy userspan
    bcs skipscan05
    lda (R0L+2*N6),y            ; get char from buffer
    eor R0L+2*N7                ; compare to character we seek
skipscan03
    bvc skipscan01              ; dummy opcode, BEQ(skip) BNE(scan)             UNTIL
skipscan05
    sty userin                  ; found char !, move `in`
    tya
    jmp push0a                  ;( offset )

;--------------------------------------------------------------
#if 0
name==CURSOR
stack=( addr|0 -- )
tags=primitive,ext
This word serves the purposes of:

# Simultaneously fetch and store the firmware cursor in a portable way
# Manage multiple cursor instances

|tos|swap `cursor` uservar with...|<|h
|0|hardware cursor|(use `0`, although any zp address works)|
|256..65535|6 consecutive bytes at `addr`||

```
        0 =cursor               \ swap 6 bytes at `cursor` uservar with firmware cursor values
 mycursor =cursor               \ swap 6 bytes at `cursor` with `mycursor`
```
#endif
exchgcursor
    stx z
    ldx #<(-6)
    ldy #0
excur01
    lda tos+1
    bne excur02                 ; when argument is 0,
    ldy firmwarecursor-250,x    ; get Y from a list of cursor zeropage addresses
excur02
    lda (tos),y
    pha
    lda usercursor-250,x
    sta (tos),y
    iny
    pla
    sta usercursor-250,x
    inx
    bmi excur01
dropfixup
    ldx z
    jmp drop

firmwarecursor
    ;    $AF   $C6  $D5  ($C4)     $D8
    .byt DFLTN,PNTR,TBLX,PNT,PNT+1,LNMX
    ;    3     in   lin  lin*40    span
    ;                    +blkbuf
; C4 PNT   current (logical) screen line address
; C6 PNTR  current cursor column on current line
; D8 LNMX  width of the screen (39 or 79)

;--------------------------------------------------------------
#if 0
name=QUERY
stack=( -- )
tags=secondary,fig,interpreter
Accept another line of input from the keyboard to `tib`

```
: query
    span c@ ?exit
    tib 80 expect ;
```
#endif
#include "align.i65"
_query
    jsr enter
#include "page.i65"
    .word tib
#include "pad.i65"
    .word eighty
#include "page.i65"
    .word expect
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REFILL
stack=( -- )
tags=secondary,outer,extra,nosymbol
Uses CHRIN via `expect` to load `sib` buffer with line `lin` from `blkbuf`

assumptions:
    `lin` is valid (0..24)

    lin buf.wrap >bit cbit@             \ 0=80 1=40
    ?: 40 80 dup r> c!

;   ( 40|80 buf.line cursor -- )
: !buf.cursor
    3 c!+                        \ DFLTN device = screen(3)
                                        \ PNTR cursor position on line = 0 to capture the whole line
                                        \ TBLX = 0
    ( buffer cursor+2 )
: refill   ( -- )
    sib                                 ( sib )
    lin 40* blk@ block +                ( sib buf.line )
    lin buf.wrap >bit cbit@             ( sib buf.line 1|0 )
    ?: forty eighty swap                ( sib 40|80 buf.line )
    cursor                              ( sib 40|80 buf.line cursor )
    !buf.cursor                         ( sib 40|80 )

    lin 40* rot + !+  >r
    lin buf.wrap >bit cbit@

```
: refill   ( -- )
    sib  blk@ block   ( sib blkbuf )
    cursor
        3 c!+  0 !+
        lin 40* rot + !+  >r
        lin buf.wrap >bit cbit@
        ?: forty eighty  dup  r> c!
    0 =cursor  expect  0 =cursor ;

: refill   ( -- )
    sib  blk@ block
    cursor
        3 c!+  0 !+
        lin 40* rot + !+  >r
        lin buf.wrap >bit cbit@
        ?: forty eighty  dup  r> c!
    0 =cursor  expect  0 =cursor ;
```
#endif
#include "align.i65"
_refill
    jsr enter
#include "page.i65"
    .word sib
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word _block
#include "page.i65"
    .word cursor
#include "page.i65"
    .word three
#include "page.i65"
    .word cstoreplus
#include "page.i65"
    .word zero
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word lin
#include "page.i65"
    .word fortytimes
#include "page.i65"
    .word rot
#include "page.i65"
    .word plus
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word tor
#include "page.i65"
    .word lin
#include "page.i65"
    .word _bufwrap
#include "page.i65"
    .word tobit
#include "page.i65"
    .word cbitfetch
#include "parm.i65"
    .word pquerycolon
    .word forty
    .word eighty
#include "pad.i65"
    .word dup
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word cstore
#include "page.i65"
    .word zero
#include "page.i65"
    .word exchgcursor
#include "page.i65"
    .word expect
#include "page.i65"
    .word zero
#include "page.i65"
    .word exchgcursor
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LIN+
stack=( -- flag )
tags=primitive,outer,extra,nosymbol
Return `false` when last line of screen is reached

#endif
linplus
    ldy userlin
    bmi linplus01               ; lin = -1 means top of screen, +1
    bit usercursor+5            ; V is opposite of linewrap bit for this line (0=40 true=80)
    bvc linplus01               ; ( 40 ) lin 1+!
    iny                         ; ( 80 ) lin 2+!
linplus01
    iny
    sty userlin
    jmp next

;--------------------------------------------------------------
#if 0
name=EOI?
stack=( -- flag )
tags=primitive,outer,extra,nosymbol
( interactive ) true when `in` reaches end of line
( loading ) true when `lin` reaches end of screen

#endif
eoiq
    lda userblk
    beq eolq
    lda userlin
    cmp #LPERSCR
    bcc eolq09
    ;fall through
;--------------------------------------------------------------
#if 0
name=EOL?
stack=( -- flag )
tags=primitive,outer,extra,nosymbol
true when `lin` reaches end of screen

#endif
eolq
    lda userin
    cmp userspan
eolq09
    jmp xpushc

;--------------------------------------------------------------
#if 0
name=EMPTY?
stack=( -- flag )
tags=primitive,outer,extra,nosymbol
Did the user just hit RETURN on an empty line?

This relies on `n0` as a (very) temporary mailbox written by `expect`!

#endif
emptyq
    ldy n                       ; mailbox. if populated with $FF by `expect`, that's why.
    iny                         ; presumably, the user will just hit return all day long
    jmp xpushz
;[6]

;--------------------------------------------------------------
#if 0
name=HUNGRY?
stack=( -- flag )
tags=secondary,outer,extra,nosymbol

```
: hungry?   ( -- flag )
    blk@ ?: eoi? eol? ;
```
#endif
#include "align.i65"
_hungryq
    jsr enter
#include "page.i65"
    .word blkfetch
#include "parm.i65"
    .word pquerycolon
    .word eoiq
    .word eolq
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=EXHAUSTED?
stack=( -- flag )
tags=primitive,outer,extra,nosymbol
true when input stream is exhausted

```
: exhausted?   ( -- flag )
    blk@ ?: eoi? eol? ;
```
#endif
#include "align.i65"
_exhaustedq
    jsr enter
#include "page.i65"
    .word blkfetch
#include "parm.i65"
    .word pquerycolon
    .word eoiq
    .word eolq
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?QUERY?
stack=( -- )
tags=primitive,outer,extra,nosymbol
`?query?` receives a line of input from the user if they didn't hit return

//maybe-query//

```
    : ?query   ( -- )
        empty? ?exit  query ;
```
#endif
#include "align.i65"
_maybequery
    jsr enter
#include "page.i65"
    .word emptyq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word _query
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?RELOAD
stack=( -- )
tags=secondary,outer,extra,nosymbol
receive a line of input to `sib` from virtual screen, unless eoi?

//maybe-reload//

```
: reload   ( -- )
    lin+  eoi? ?exit  refill ;
```
#endif
#include "align.i65"
_maybereload
    jsr enter
#include "page.i65"
    .word linplus
#include "page.i65"
    .word eoiq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word _refill
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?REFILL
stack=( -- )
tags=secondary,outer,extra,nosymbol
eturns `true` then the input stream is available (not exhausted),
reload line buffer as needed.


code empty?   ( -- flag )
    true when `expect` received a blank line of input

code lin+   ( -- )
    add +1 (40) or +2 (80) to virtual screen pointer `lin`, based on `sib` size
    line size from `cursor` LNMX field

: refill   ( -- )
    `expect` transforms (via CHRIN) a line from `blkbuf` into `sib`,
    retrieve the block if `prev` <> `blk`

code expect   ( buff size -- )
    receive up to `size` characters into `buff` via CHRIN
    initialize `in` and `span`
    leave a true copy of span in `n0` for `empty?`
    called by `query` and `refill`

: query   ( -- )
    receive a (logical) line of input from the terminal into `tib`
    called only during interactive session

code =cursor   ( addr|0 -- )
    swap hardware cursor with `cursor`
    called only when loading

: parse   ( -- size )
    identify next token in the input stream, returning its length
    set `n8` = length
    point `in` at the character following the parsed token

code skip   ( -- )
    skip to non-match of char in `n7`, in line buffer pointed to by `(n6)`

code scan   ( -- )
    scan to next match of char in `n7`, in line buffer pointed to by `(n6)`

refill?   ( -- flag )
    is the line buffer available?
    ---
    load the line buffer `sib` or `tib`, if possible and necessary.
    return true when `in` has not reached `span` (end of line)
    ---
    loading:
    add +1 or +2 to `lin`
    return true if screen is exhausted
    otherwise, build a fake cursor
    retrieve block `blk@`
    refill `sib` from line `lin`
    reset `in` to 0
    return not `eoi?`
    ---
    interactive session:
    return true if the user has already entered an empty line
    otherwise, `query` the terminal for a line of input
    return true
    ---

maybequery

    : ?query   ( true -- true )
        empty? ?exit query ;

    : refill?   ( -- flag true | -- false )

    begin
        eol? 0=
               dup ?exit         ( true when already stuff in buffer )
        lin+         eoi? ?exit         ( false at end of screen )
        ( false )
if we get here, EOI? is false and EOL? is true. LIN is pointing to the next line

        blk@ ?: refill ?query?
    repeat ( flag ) ;

    begin
        eol? 0=       dup ?exit         ( true when already stuff in buffer )
        lin+         eoi? ?exit         ( false at end of screen )
        ( false )
if we get here, EOI? is false and EOL? is true. LIN is pointing to the next line

        blk@ ?: refill ?query?
    repeat ( flag ) ;




        blk@
        if
            lin+  eoi?  ?dup ?exit
            reflll eoi? 0=
        else
            empty? ?exit                ( false at end of line )
                                        ( false at empty line )
            query
        then ;


        get lines until


begin

        interactive and we got a blank line, exit with "true"

                blk@ 0= empty? and ?dup ?exit


        loading and eoi? reached, exit with "true"

                eoi? ?dup ?exit



        eol? 0= dup ?exit         ( true when already stuff in buffer )

: refill?   ( -- flag )
    blk@ 0=
    if

    if

    else
        empty? ?dup ?exit
    then ;

    begin
        lin+         eoi? ?exit         ( false at end of screen )
        ( false )
if we get here, EOI? is false and EOL? is true. LIN is pointing to the next line

        blk@ ?: refill ?query?
    repeat ( flag ) ;

    begin
        eol? 0=       dup ?exit         ( true when already stuff in buffer )
        lin+         eoi? ?exit         ( false at end of screen )
        ( false )
if we get here, EOI? is false and EOL? is true. LIN is pointing to the next line

        blk@ ?: refill ?query?
    repeat ( flag ) ;


: 'stream   ( -- nfa|0 )

: reload?   ( -- flag )


                eol? dup 0= ?exit
                eol? ?dup ?exit         \ better with inverted flag

: ?query?   ( -- flag )
    empty? ?exit  true query ;

: refill?   ( -- flag )
    eol? dup 0= ?exit ( false )         \ stuff in the buffer
    ( true )
    blk@ ?: ?reload ?query ;

: ?refill
    blk@ ?: ?reload ?query ;

: exhausted?   ( -- false ) | ( -- flag true )
    blk@ ?: eoi?

    eol? 0= ?dup ?exit ( true true )

    eol?  0=

: name
    setup
    begin
        do we need a line?
    while
        get a line
    until
    is buffer exhausted?
    if
        false
    else
        parse                           \ the sought-after treasure!
    then ;

: name   ( char -- nfa|false )
    blk@ ?: sib tib  n6 2!  \ setup
    begin                   \ hungry?
        eol?                \ probably not hungry
        if                  \ me so hungry! give me cookie! nom nom nom!
            blk@            \ well what am I hungry for?
            if              \ loading?

            else            \ interactive?
            then
        else                \ wasn't hungry
            false
        then
    while
        ?refill
    repeat
    exhausted?

: reload?   ( -- )

: hungry?   ( -- flag )
    blk@ empty? xor

an interactive seesion first brings us here after startup
/* script
who are you?  I am `name`
what is my purpose? hand me a character, and I scan ahead in the input stream for it
what do you tell us? I either provide a token address, or say "there was nothing"
*/
 a character


empty?        interactive         loading
false           query
true            no query          +refill

-- fun zone --
empty?        interactive       loading
false           true
true            false             true

eol?          interactive       loading
false           true
true            false             true

eoi?          interactive       loading
false           true
true            false             true
-- end fun zone --

: exhausted?   ( -- flag )
        blk@ 0= empty? or eoi? or ;
                       \
: ?query   ( -- )
    empty? ?exit  query ;

: name   ( char -- nfa|false )
    blk@ ?: sib tib  n6 2!  \ setup
    begin                   \ hungry?
        eol?                \ probably not hungry
        if                  \ me so hungry! give me cookie! nom nom nom!
            blk@            \ well what am I hungry for?
            if              \ loading?

            else            \ interactive?
            then
        else                \ wasn't hungry
            false
        then
    while
        ?refill
    repeat
    exhausted?



        |
        ( eol? and not )
        ( interactive? AND eol? -- we will later find out, AND not empty? )
        ( loading? AND eol? )
    while
        blk@ ?: ?reload ?query
    repeat
    exhausted? ?: false parse ;
        blk@ if
            eoi?  if  1+under  then
        else
            empty?  if 1+under then
        then

         ?: eoi? empty? xor

        \ true first time when interacive
        \ true until eoi? when loading
    while
        refill?

\ hits return                           ( false true )
\ end of interactive line               ( false true )
\ end of screen                         ( false true )
        ?dup until
    until ( flag )
    ?: parse false ;

: refill?  ( -- exhausted? )
    begin
        hungry?
    while
        ?refill
    until
    exhausted? ;

: ?reload ( -- )


code empty?
    N0        inc,
    'xpushz   jmp,
end-code

code eoi?
    blk       lda,
    'eol?     beq,
    'lin      lda,
    l/scr #   cmp,
    'eolq09   bcc,
end-code
    \ fall through
              here &eol?
code eol?
    in        lda,
    span      cmp,
here &eolq09
    'xpushc   jmp,
end-code

: exhausted?   ( -- flag )
    blk@ ?: eoi? eol? ;
: reload   ( -- )
    lin+  eoi? ?exit  refill ;
: ?refill   ( -- )
    begin  hungry?  while
    blk@ ?: ?reload ?query  until ;
```
#endif
#include "align.i65"
_qrefill
    jsr enter
#include "page.i65"
_qrefill01
    .word _hungryq
#include "parm.i65"
    .word qbranch
    .byt <(qrefill02-*+1)
#include "pad.i65"
    .word blkfetch
#include "parm.i65"
    .word pquerycolon
    .word _maybereload
    .word _maybequery
#include "parm.i65"
    .word branch
    .byt <(qrefill01-*+1)
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REFILL?
stack=( -- flag )
tags=secondary,outer,extra,nosymbol
Returns `true` then the input stream is available (not exhausted),
after properly reloading the line buffers as needed.

                    interactive         loading
'return'            true                false               refill? returns false  name returns true
'end of line'       true                false
'end of screen'     n/a                 true

eol?                in >= span          end of line
eoi?                lin >= l/scr        end of screen
empty?              n0 = -1             blank line


uservar cursor   ( -- addr )
    uservar, 6-byte virtual cursor
                            loading                     interactive session
        DFLTN                   3                           0
        PNTR                    in                          screen horiz position
        TBLX                    0                           screen vertical line position
        (PNT)                   blkbuf+lin*40               screen line address
        LNMX                    40 or 80                    39 or 79, logical line length

uservar in   ( -- addr )
    uservar, horizontal position in line buffer
    initialized by `expect`
    updated by `skip` and `scan`

uservar lin   ( -- value )
    upper byte of `in`, vertical line in line buffer
    always points to start of a logical line
    initialized by `load`
    updated by `lin+`

code eol?   ( -- flag )
    true when `in` reached end of line
    true when in >= span

code eoi?   ( -- flag )
    true when `lin` reached end of screen
    true when lin >= l/scr

code empty?   ( -- flag )
    true when `expect` received a blank line of input

code lin+   ( -- )
    add +1 (40) or +2 (80) to virtual screen pointer `lin`, based on `sib` size
    line size from `cursor` LNMX field

: refill   ( -- )
    `expect` transforms (via CHRIN) a line from `blkbuf` into `sib`,
    retrieve the block if `prev` <> `blk`

: query   ( -- )
    receive a (logical) line of input from the terminal into `tib`
    called only during interactive session

code =cursor   ( addr|0 -- )
    swap hardware cursor with `cursor`
    called only when loading

: parse   ( -- size )
    identify next token in the input stream, returning its length
    set `n8` = length
    point `in` at the character following the parsed token

refill?   ( -- flag )
    is the line buffer available?
    ---
    load the line buffer `sib` or `tib`, if possible and necessary.
    return true when `in` has not reached `span` (end of line)
    ---
    loading:
    add +1 or +2 to `lin`
    return true if screen is exhausted
    otherwise, build a fake cursor
    retrieve block `blk@`
    refill `sib` from line `lin`
    reset `in` to 0
    return not `eoi?`
    ---
    interactive session:
    return true if the user has already entered an empty line
    otherwise, `query` the terminal for a line of input
    return true
    ---

maybequery

    : ?query   ( true -- true )
        empty? ?exit query ;

    : refill?   ( -- flag true | -- false )

    begin
        eol? 0=
               dup ?exit         ( true when already stuff in buffer )
        lin+         eoi? ?exit         ( false at end of screen )
        ( false )
if we get here, EOI? is false and EOL? is true. LIN is pointing to the next line

        blk@ ?: refill ?query?
    repeat ( flag ) ;

    begin
        eol? 0=       dup ?exit         ( true when already stuff in buffer )
        lin+         eoi? ?exit         ( false at end of screen )
        ( false )
if we get here, EOI? is false and EOL? is true. LIN is pointing to the next line

        blk@ ?: refill ?query?
    repeat ( flag ) ;




        blk@
        if
            lin+  eoi?  ?dup ?exit
            reflll eoi? 0=
        else
            empty? ?exit                ( false at end of line )
                                        ( false at empty line )
            query
        then ;


        get lines until


begin

        interactive and we got a blank line, exit with "true"

                blk@ 0= empty? and ?dup ?exit


        loading and eoi? reached, exit with "true"

                eoi? ?dup ?exit



        eol? 0= dup ?exit         ( true when already stuff in buffer )

: refill?   ( -- flag )
    blk@ 0=
    if

    if

    else
        empty? ?dup ?exit
    then ;

    begin
        lin+         eoi? ?exit         ( false at end of screen )
        ( false )
if we get here, EOI? is false and EOL? is true. LIN is pointing to the next line

        blk@ ?: refill ?query?
    repeat ( flag ) ;

    begin
        eol? 0=       dup ?exit         ( true when already stuff in buffer )
        lin+         eoi? ?exit         ( false at end of screen )
        ( false )
if we get here, EOI? is false and EOL? is true. LIN is pointing to the next line

        blk@ ?: refill ?query?
    repeat ( flag ) ;


: 'stream   ( -- nfa|0 )

: reload?   ( -- flag )


                eol? dup 0= ?exit
                eol? ?dup ?exit         \ better with inverted flag

: ?query?   ( -- flag )
    empty? ?exit  true query ;

: refill?   ( -- flag )
    eol? dup 0= ?exit ( false )         \ stuff in the buffer
    ( true )
    blk@ ?: ?reload ?query ;

: ?refill
    blk@ ?: ?reload ?query ;

: exhausted?   ( -- false ) | ( -- flag true )
    blk@ ?: eoi?

    eol? 0= ?dup ?exit ( true true )

    eol?  0=

: name
    setup
    begin
        do we need a line?
    while
        get a line
    until
    is buffer exhausted?
    if
        false
    else
        parse                           \ the sought-after treasure!
    then ;

: reload?   ( -- )

: hungry?   ( -- flag )
    blk@ empty? xor

an interactive seesion first brings us here after startup
/* script
who are you?  I am `name`
what is my purpose? hand me a character, and I scan ahead in the input stream for it
what do you tell us? I either provide a token address, or say "there was nothing"
*/
 a character


empty?        interactive         loading
false           query
true            no query          +refill

-- fun zone --
empty?        interactive       loading
false           true
true            false             true

eol?          interactive       loading
false           true
true            false             true

eoi?          interactive       loading
false           true
true            false             true
-- end fun zone --

: exhausted?   ( -- flag )
        blk@ 0= empty? or eoi? or ;
                       \
: ?query   ( -- )
    empty? ?exit  query ;

: hungry?   ( -- flag )
    empty? 0= eol? and ;




        |
        ( eol? and not )
        ( interactive? AND eol? -- we will later find out, AND not empty? )
        ( loading? AND eol? )
    while
        blk@ ?: ?reload ?query
    repeat
    exhausted? ?: false parse ;
        blk@ if
            eoi?  if  1+under  then
        else
            empty?  if 1+under then
        then

         ?: eoi? empty? xor

        \ true first time when interacive
        \ true until eoi? when loading
    while
        refill?

\ hits return                           ( false true )
\ end of interactive line               ( false true )
\ end of screen                         ( false true )
        ?dup until
    until ( flag )
    ?: parse false ;

: refill?  ( -- exhausted? )
    begin
        hungry?
    while
        ?refill
    until
    exhausted? ;

: ?reload ( -- )

: ?query ( -- )

code eoi?
    blk       lda,    'eol?     beq,
    'lin      lda,    l/scr #   cmp,
    'eolq09   bcc,
end-code     here &eol?  \ fall through
code eol?
    in        lda,    span      cmp,
here &eolq09          'xpushc   jmp,
end-code

: hungry?   ( -- flag )
    eol? ;

: exhausted?   ( -- flag )
    eoi? ;

: ?refill   ( -- )
    begin
        hungry?
    while
        blk@ ?: ?reload ?query
    until ;
```
#endif
#include "align.i65"
_refillq
    jsr enter
#include "page.i65"
    .word eolq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qdup
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word blkfetch
#include "parm.i65"
    .word qbranch
    .byt <(qrefill01-*+1)
#include "pad.i65"
    .word linplus
#include "page.i65"
    .word eoiq
#include "page.i65"
    .word qdup
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word _refill
#include "page.i65"
    .word eoiq
#include "page.i65"
    .word zeq
#include "parm.i65"
    .word branch
    .byt <(qrefill02-*+1)
#include "pad.i65"
qrefill01
    .word false
#include "page.i65"
    .word emptyq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word _query
#include "past.i65"
qrefill02
    .word exit

;--------------------------------------------------------------
#if 0
name=PARSE
stack=( -- nfa|0 )
tags=secondary,outer,extra,nosymbol

* set n7 delimiter char
* refill the line buffer (if empty)
* skip/scan move `in` past token
* set n8 token length
* put length before text in buffer
* move `in` past trailing space

```
: parse   ( -- length )
    skip dup 1- <n6 +
    scan rot -
    dup !nfa ;

: !nfa
    >n8 over c!  in 1+! ;
```
#endif
#include "align.i65"
_parse
    jsr enter
#include "page.i65"
    .word skip                  ; start of name
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneminus
#include "parm.i65"
    .word zpfrom
    .byt R0L+2*N6               ; line buffer
#include "pad.i65"
    .word plus
#include "page.i65"
    .word scan                  ; end of name (and/or buffer)
#include "page.i65"
    .word rot
#include "page.i65"
    .word minus                 ; length
#include "page.i65"
    .word in
#include "page.i65"
    .word oneplusstore
#include "parm.i65"
    .word tozp
    .byt R0L+2*N8               ; name.len
#include "pad.i65"
    .word tuck                  ; ( len buf len )
#include "parm.i65"
    .word pquerycolon
    .word tuck                  ; ( buf len buf )
    .word under                 ; ( 0 0 buf )
#include "pad.i65"
    .word cstore
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NAME
stack=( char -- nfa|false )
tags=outer,extra
`name` is the name of the word formerly known as `word`, which is not
present.  Absence of `word` is a variance from the Forth-83 standard, and
the new and improved `name` fulfills all the original purposes of `word`.
---
return address of next token in the line buffer, or
return false when the input stream is exhausted.

```
: name   ( char -- nfa|false )
    blk@ ?: sib tib  n6 2!
    ?refill  exhausted? empty? or ?: false parse
    n0 off ;
```
#endif
#include "align.i65"
_name
    jsr enter
#include "page.i65"
    .word blkfetch
#include "parm.i65"
    .word pquerycolon
    .word sib
    .word tib
#include "parm.i65"
    .word blit
    .byt R0L+2*N6
#include "pad.i65"
    .word twostore              ; set n6=lib; n7=char
#include "page.i65"
    .word _qrefill
#include "page.i65"
    .word _exhaustedq
#include "page.i65"
    .word emptyq
#include "page.i65"
    .word orx
#include "parm.i65"
    .word pquerycolon
    .word false
                                ; "             !-!        !-!      "
                                ; "      ->  #. ! !  -  #  ! !      "
                                ;
    .word _parse                ; "  / #  !@!  ::  (())  !@!  //\\  " -- Infidel
#include "parm.i65"
    .word blit
    .byt R0L+2*N6               ; empty n0 `empty?` mailbox, if it was even set
#include "pad.i65"
    .word coff
#include "past.i65"
    .word exit
