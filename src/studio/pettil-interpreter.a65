; pettil-interpreter.a65
;#echo .       pettil-interpreter.a65    Outer Interpreter

;--------------------------------------------------------------
#if 0
name=ERROR.MSG
stack=( -- addr flag )
tags=interpreter,ext,nosymbol
Instead of RESTART performing an ABORT at the end to start the
QUIT-INTERPRET loop, it does a FENCE @ (FORGET) and sends us here.

If WARNING is non-zero, FAIL executes it, which also points here.
When WARNING is 0, FAIL will perform

WARNING @  ?: WARNING STARTUP  @ EXECUTE

* Prints an error message
* performs ABORT
```
```
#endif
#include "align.i65"
_errormsg
    jsr enter
#include "page.i65"
    .word twostar
#include "parm.i65"
    .word plit
    .word messages
#include "pad.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word space
#include "page.i65"
    .word _stringdot
#include "page.i65"
    .word cr
#include "past.i65"
    .word _abort

;--------------------------------------------------------------
#if 0
name=INTERPRET.CFA
stack=( cfa -1|+1 -- )
tags=secondary,interpreter,nosymbol
Either compile an execution token or `execute` the CFA


```
: interpret.cfa   ( cfa flag -- )
    compiling? <>
    ?: execute xt, ;
```
#endif
#include "align.i65"
_interpretcfa
    jsr enter
#include "page.i65"
    .word compilingq
#include "page.i65"
    .word ne
#include "page.i65"
    .word pquerycolon
    .word execute
    .word _xtcomma
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=\
stack=( "text$ -- )
tags=primitive,extra
flags=immediate
After `\`,  `interpret` will ignore all text to the end of the current line, useful as a comment delimiter.

```
: \   ( -- )
   span coff ; immediate
```
#endif
backslash
    lda userspan
    sta userin
backslash00
    lda userblk
    bne backslash01
    inc usereoi
;    lda #0
;    sta userspan                ; ~wut? does not bother with high byte of SPAN
backslash01
    jmp next

;--------------------------------------------------------------
#if 0
name=INTERPRET
stack=( -- )
tags=secondary,fig,forth-79,forth-83,interpreter
The Forth interpreter loop in PETTIL uses a lazy-loading approach.  The traditional approach preloads a line buffer and sends it to `interpret`, which scans through the space-delimited tokens on the line and decides what to do with each one.  PETTIL merely asks `interpret` to do a line or screen of input, and `interpret` itself takes care of loading the line buffer (or the screen).

`span` off triggers `name` to refill either the `tib` (from the keyboard) or
`sib` (when loading) buffer with the next line of input.  When `name` returns
`0`, `interpret` exits (to `quit` or `load`).

* at the end of a line in interactive mode
* at the end of a screen when loading

If `name` returns an `nfa`, then `found?` will search the dictionary or try
parse it as a `number` if it is not found. Depending on `compiling?` state,
`cfa`s and numbers are either compiled or executed.

|^condition|^exit|^mode|^buffer|h
|^blk = 0|^end of line|^interactive|^tib|
|^blk > 0|^end of screen|^loading|^sib|

`name` semaphore pattern will return 0 when the previous token ended the line.

interactive session
quit --> interpret --> name --> refill? -->
query

loading
quit --> interpret --> name --> refill? --> refill.loading --> block -->
sib line.size  expect

```
: interpret   ( -- )
    begin
        begin  ?stack  eoi? ?exit  eol?
        while  blk@  ?: refill query
        repeat
        bl name  ?dup
    while  found?
        ?dup  ?: interpret.cfa number
    repeat ;


: interpret   ( -- )
    begin
        begin
            ?stack
            eoi? ?exit
            eol?
        while
            blk@ ?: refill query
        repeat
        bl name ?dup
    while
        found? ?dup ?: interpret.cfa number
    repeat ;
```
#endif
#include "align.i65"
_interpret
    jsr enter
#include "page.i65"
interpret01
    .word qstack
#include "page.i65"
    .word eoiq
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word eolq
#include "parm.i65"
    .word qbranch
    .byt <(interpret02-*+1)
#include "pad.i65"
    .word blkfetch
#include "parm.i65"
    .word pquerycolon
    .word _refill
    .word _query
#include "parm.i65"
    .word branch
    .byt <(interpret01-*+1)
#include "pad.i65"
interpret02
    .word bl
#include "page.i65"
    .word _name                 ;( nfa|0 )
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word qbranch
    .byt <(interpret01-*+1)
#include "pad.i65"
    .word _foundq               ; ( nfa -- cfa )
#include "page.i65"
    .word qdup
#include "page.i65"
    .word pquerycolon
    .word _interpretcfa         ; ( a -- )
    .word _number               ; ( a -- )
#include "parm.i65"
    .word branch
    .byt <(interpret01-*+1)

;--------------------------------------------------------------
#if 0
name=.OK
stack=( -- )
tags=secondary,interpreter,nosymbol
Print the OK message at the end of each line in an interactive session

```
: .ok
    ." ok" cr ;
```
#endif
#include "align.i65"
_dotok
    jsr enter
#include "parm.i65"
    .word _pdq
    .byt (dotok01-*-1)
    .asc    " OK"
dotok01
#include "pad.i65"
    .word cr
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=QUIT
stack=( -- )
tags=secondary,forth-79,forth-83,interpreter
`quit` will accept and `interpret` an infinite number of lines typed in from the keyboard in interactive mode.

This is the infinite outer interpreter loop.  PETTIL uses a lazy loading scheme such that when `interpret` finds it has nothing in the buffer (`span` is 0) it will reload the buffer.

```
: quit
    rp! blk 12 erase            \ erases line editing uservars
    begin                       \ `interpret` will get new line from keyboard
        interpret
        compiling? ?: cr .ok
    again ( ; )
```
#endif
#include "align.i65"
_quit
    jsr enter
#include "page.i65"
    .word rpstore               ; reset return stack pointer
#include "page.i65"
    .word blk
#include "parm.i65"
    .word blit
    .byt 12                     ; `blk` `in` `span` `#out` `#line` `editing`
#include "pad.i65"
    .word erase
#include "page.i65"
quit01                          ; BEGIN
    .word _interpret            ; outer interpreter main loop
#include "page.i65"
    .word compilingq
#include "parm.i65"
    .word pquerycolon
    .word cr
    .word _dotok
#include "past.i65"             ; AGAIN
    .word branch
    .byt <(quit01-*+1)
;#include "past.i65"            ; you can check out any time you like
;    .word exit                 ; but you can never leave

;--------------------------------------------------------------
#if 0
name=ABORT
stack=( -- )
tags=secondary,fig,forth-79,forth-83,interpreter,startup
* Clear data stack
* Reset `current` and `vocabs` vocabulary to `forth`
* perform `quit`

`abort` sets up and starts `quit` to bgin an interactive session.

#endif
#include "align.i65"
_abort
    jsr enter
#include "page.i65"
    .word spstore               ; reset data stack
#include "page.i65"
    .word _forth                ; resset `vocabs` to core-only
#include "page.i65"
    .word definitions           ; set `core` as `current`
#include "past.i65"
    .word _quit

;--------------------------------------------------------------
#if 0
name=3R>!
stack=( addr -- )
tags=primitive,double,stack,ext
pop 6 bytes from the return stack to `addr`

~alternate, could be ( n addr -- ) stack diagram, which pops `n+1` bytes to replace memory at `addr+0`...`addr+n`

These words are limited to moving 128 bytes to/from the return stack.  This is a good idea as long as PETTIL uses $0130..017F as `sib` (Screen Input Buffer)

: load
    5 blk #@>r
    interpret
    5 blk #r>!

code #r>!   ( n addr -- )
numrfromstore                   \ pop `n+1` bytes from return stack to `addr`
    ldy #$FF
numr01
    iny
    pla
    sta (tos),y
    tya
    cmp stackl,x
    bne numr01
    jmp twodrop


: #@>r   ( n addr -- )
numfetchtor                     \ push `n+1` bytes to return stack from `addr`
    ldy stackl,x
numf01
    lda (tos),y
    pha
    dey
    bpl threef01
    jmp drop

#endif
threerfromstore
    ldy #$FF
threer01
    iny
    pla
    sta (tos),y
    cpy #5                      ; ~could be ` cpy stackl,x` for `#r>!`
    bne threer01                ; ~if so, ` inx` here to remove 2os
    jmp drop

;--------------------------------------------------------------
#if 0
name=LOAD
stack=( u -- )
tags=interpreter,forth-83
Redirect the input stream to screen `u` of Forth source and `interpret` it.

* 1 is the lowest block which may be loaded, as 0 is the keyboard
* `load` will not create empty blocks
* `u` must be presently available in `vmbuf`
* error conditions (`BLOCK OUT OF RANGE`)
** `u` < 1
** `u` >= `#blk`



 The contents of >IN and BLK , which locate the current input
 stream, are saved.  The input stream is then redirected to
 the beginning of screen u by setting >IN to zero and BLK to
 u.  The screen is then interpreted.  If interpretation from
 screen u is not terminated explicitly it will be terminated
 when the input stream is exhausted and then the contents of
 >IN and BLK will be restored.  An error condition exists if
 u is zero.  See  [[>IN]] [[BLK]] [[BLOCK]]



```
: load   ( scr -- )
    ?dup
    if
    dup #blk @ > ?exit
        blk 2@ ( >in @ ) 2>r
        blk !  source! interpret
        2r> ( >in ! ) blk 2!  source!
    then ;

: load   ( blk -- )
    0 #blk @ third between? 0= 8 ?error
    0 over < #blk @ third > or
  \ checks requested block within range 0 .. #blk or error message
  \ pushes >in and blk to return stack
  \ resets >in
  \ interpret
  \ restores blk and >in from return stack
  0 2dup  #blk @  between? 0=
  8 ?error
  blk 2@ ( >in @ )  2>r
  blk 2! ( >in off )
  interpret
  2r>  blk 2! ( >in ! ) ;


* check that `u` is in range of loaded blocks `0 < u < #blk`
* push `blk` `in` `span` to return stack
* interpret
* pop `blk` `in` `span` from  return stack

: load   ( u -- )
    0 #blk @ third between? 0= 8 ?error
    blk tuck 3@>r !+ 2off prev on
    interpret
    blk 3r>!


: load   ( u -- )
    0 #blk @ 1- third between? 0=  8 ?error \ "BLOCK OUT OF RANGE"
    blk tuck                    ( blk u blk )
    \ bookmark location in the input stream
    3@>r                        \ push `blk in lin span eoi` to return stack,
    !+ 2off                     \ blk = u \ in = 0 \ lin = 0 \ span = 0 \ eoi = 0
    prev on                     \ force a refresh of `blkbuf`
    interpret                   \ process a screen before EOI
    \ restore input stream bookmark
    blk 3r>! ;                  \ pop `blk in lin span eoi` from return stack


```
#endif
#include "align.i65"
_load
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word third
#include "page.i65"
    .word betweenq
#include "page.i65"
    .word zeq                   ; `blk` must be available in `vmbuf`
#include "parm.i65"
    .word qerror
    .byt 8                      ; "BLOCK OUT OF RANGE"
#include "pad.i65"
    .word blk
#include "page.i65"
    .word tuck                  ;( blk u blk )
#include "page.i65"
    .word threefetchtor         ; stash `blk` `in` `span` on return stack
#include "page.i65"
    .word _storeplus            ; just like `blk !  in`
#include "page.i65"
    .word twooff
#include "page.i65"
    .word prev
#include "page.i65"
    .word on                    ; forces `block` to load buffer
#include "page.i65"
    .word _interpret            ; interpret has two clients, `load` and `quit`
#include "page.i65"
    .word blk
#include "page.i65"
    .word threerfromstore       ; restore prior `blk` `in` `span`
#include "past.i65"
    .word exit
