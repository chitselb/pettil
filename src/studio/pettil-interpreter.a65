; pettil-interpreter.a65
;#echo .       pettil-interpreter.a65    Outer Interpreter

;--------------------------------------------------------------
#if 0
name=ERROR.MSG
stack=( -- )
tags=interpreter,ext,nosymbol
Instead of RESTART performing an ABORT at the end to start the
QUIT-INTERPRET loop, it does a FENCE @ (FORGET) and sends us here.

If `warning` is non-zero, FAIL executes it, which also points here.
When `warning` is 0, `fail` performs `.err` which outputs the error number.

```
: error.msg   ( -- )
    2* 'messages + @ space $. cr abort ; -2 allot
```
#endif
#include "align.i65"
_errormsg
    jsr enter
#include "page.i65"
    .word twostar
#include "parm.i65"
    .word plit
    .word messages
#include "pad.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word space
#include "page.i65"
    .word _stringdot
#include "page.i65"
    .word cr
#include "past.i65"
    .word _abort

;--------------------------------------------------------------
#if 0
name=INTERPRET.CFA
stack=( cfa -1|+1 -- )
tags=secondary,interpreter,nosymbol
Either compile an execution token or `execute` the CFA


```
: interpret.cfa   ( cfa flag -- )
    compiling? <>
    ?: execute xt, ;
```
#endif
#include "align.i65"
_interpretcfa
    jsr enter
#include "page.i65"
    .word compilingq
#include "page.i65"
    .word ne
#include "page.i65"
    .word pquerycolon
    .word execute
    .word _xtcomma
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=\
stack=( "text$ -- )
tags=primitive,extra
flags=immediate
After `\`,  `interpret` will ignore all text to the end of the current line, useful as a comment delimiter.

```
: \   ( -- )
   span coff ; immediate
```
#endif
backslash
    lda #0
    sta userspan
    jmp next

;--------------------------------------------------------------
#if 0
name=INTERPRET
stack=( -- )
tags=secondary,fig,forth-79,forth-83,interpreter
The Forth interpreter loop in PETTIL uses a lazy-loading approach.  The traditional approach preloads a line buffer and sends it to `interpret`, which scans through the space-delimited tokens on the line and decides what to do with each one.  PETTIL merely asks `interpret` to do a line or screen of input, and `interpret` itself takes care of loading the line buffer (or the screen).

`span` off triggers `name` to refill either the `tib` (from the keyboard) or
`sib` (when loading) buffer with the next line of input.  When `name` returns
`0`, `interpret` exits (to `quit` or `load`).

* at the end of a line in interactive mode
* at the end of a screen when loading

If `name` returns an `nfa`, then `found?` will search the dictionary or try
parse it as a `number` if it is not found. Depending on `compiling?` state,
`cfa`s and numbers are either compiled or executed.

|^condition|^exit|^mode|^buffer|h
|^blk = 0|^end of line|^interactive|^tib|
|^blk > 0|^end of screen|^loading|^sib|

`name` semaphore pattern will return 0 when the previous token ended the line.

interactive session
quit --> interpret --> name --> refill? -->
query

loading
quit --> interpret --> name --> refill? --> refill.loading --> block -->
sib line.size  expect

```
: interpret   ( -- )           begin
    ?stack eol?               if
      blk@                if
      refill lin+       else
      query             then
                            then
    more?                      while
    bl name ?dup               until
    found? ?dup ?: interpret.cfa number
                              repeat   ;

: interpret   ( -- )
    begin
        ?stack  more?
    while
        bl name ?dup
        if
            found? ?dup
            ?: interpret.cfa number
        then
    repeat ;

: interpret   ( -- )
    begin   ?stack  bl name ?dup
    while   found? ?dup
            ?: interpret.cfa number
    repeat ;
```
#endif
#include "align.i65"
_interpret
    jsr enter
#include "page.i65"
interpret01
    .word qstack
#include "page.i65"
    .word bl
#include "page.i65"
    .word _name                 ;( nfa|0 )
#include "page.i65"
    .word qdup
#include "parm.i65"
    .word qbranch
    .byt <(interpret05-*+1)
#include "pad.i65"
    .word _foundq               ; ( nfa -- xfa flag )
#include "page.i65"
    .word qdup
#include "page.i65"
    .word pquerycolon
    .word _interpretcfa         ; ( cfa -- )
    .word _number               ; ( nfa -- )
#include "parm.i65"
    .word branch
    .byt <(interpret01-*+1)
#include "past.i65"
interpret05
    .word exit

;--------------------------------------------------------------
#if 0
name=.OK
stack=( -- )
tags=secondary,interpreter,nosymbol
Print the OK message at the end of each line in an interactive session

```
: .ok
    ." ok" cr ;
```
#endif
#include "align.i65"
_dotok
    jsr enter
#include "parm.i65"
    .word _pdq
    .byt (dotok01-*-1)
    .asc    " OK"
dotok01
#include "pad.i65"
    .word cr
#include "past.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=QUIT
stack=( -- )
tags=secondary,forth-79,forth-83,interpreter
`quit` will accept and `interpret` an infinite number of lines typed in from the keyboard in interactive mode.

This is the infinite outer interpreter loop.  PETTIL uses a lazy loading scheme such that when `interpret` finds it has nothing in the buffer (`span` is 0) it will reload the buffer.

```
: quit
    rp! blk 6 erase            \ erases line editing uservars
    begin                       \ `interpret` will get new line from keyboard
        interpret
        compiling? ?: cr .ok
    again ( ; )
```
#endif
#include "align.i65"
_quit
    jsr enter
#include "page.i65"
    .word rpstore               ; reset return stack pointer
#include "page.i65"
    .word blk
#include "page.i65"
    .word twooff
#include "page.i65"
quit01                          ; BEGIN
    .word span
#include "page.i65"
    .word off
#include "page.i65"
    .word _interpret            ; outer interpreter main loop
#include "page.i65"
    .word compilingq
#include "parm.i65"
    .word pquerycolon
    .word cr
    .word _dotok
#include "past.i65"             ; AGAIN
    .word branch
    .byt <(quit01-*+1)
;#include "past.i65"            ; you can check out any time you like
;    .word exit                 ; but you can never leave

;--------------------------------------------------------------
#if 0
name=ABORT
stack=( -- )
tags=secondary,fig,forth-79,forth-83,interpreter,startup
* Clear data stack
* Reset `current` and `vocabs` vocabulary to `forth`
* perform `quit`

`abort` sets up and starts `quit` to bgin an interactive session.

#endif
#include "align.i65"
_abort
    jsr enter
#include "page.i65"
    .word spstore               ; reset data stack
#include "page.i65"
    .word _forth                ; resset `vocabs` to core-only
#include "page.i65"
    .word definitions           ; set `core` as `current`
#include "past.i65"
    .word _quit

;--------------------------------------------------------------
#if 0
name=3R>!
stack=( addr -- )
tags=primitive,double,stack,ext
pop 6 bytes from the return stack to `addr`

#endif
threerfromstore
    ldy #$FF
threer01
    iny
    pla
    sta (tos),y
                    ;cpy stackl,x       alternative `#r>!   ( count addr -- )`
    cpy #5
    bne threer01
                    ;inx
    jmp drop

;--------------------------------------------------------------
#if 0
name=LOAD
stack=( u -- )
tags=interpreter,forth-83
Redirect the input stream to screen `u` of Forth source and `interpret` it.

* 1 is the lowest block which may be loaded, as 0 is the keyboard
* `load` will not create empty blocks
* `u` must be presently available in `vmbuf`
* error conditions (`BLOCK OUT OF RANGE`)
** `u` < 1
** `u` >= `#blk`



 The contents of >IN and BLK , which locate the current input
 stream, are saved.  The input stream is then redirected to
 the beginning of screen u by setting >IN to zero and BLK to
 u.  The screen is then interpreted.  If interpretation from
 screen u is not terminated explicitly it will be terminated
 when the input stream is exhausted and then the contents of
 >IN and BLK will be restored.  An error condition exists if
 u is zero.  See  [[>IN]] [[BLK]] [[BLOCK]]



```
: load   ( scr -- )
    ?dup
    if
    dup #blk @ > ?exit
        blk 2@ ( >in @ ) 2>r
        blk !  source! interpret
        2r> ( >in ! ) blk 2!  source!
    then ;

: load   ( blk -- )
    0 #blk @ third between? 0= 8 ?error
    0 over < #blk @ third > or
  \ checks requested block within range 0 .. #blk or error message
  \ pushes >in and blk to return stack
  \ resets >in
  \ interpret
  \ restores blk and >in from return stack
  0 2dup  #blk @  between? 0=
  8 ?error
  blk 2@ ( >in @ )  2>r
  blk 2! ( >in off )
  interpret
  2r>  blk 2! ( >in ! ) ;


* check that `u` is in range of loaded blocks `0 < u < #blk`
* push `blk` `in` `span` to return stack
* interpret
* pop `blk` `in` `span` from  return stack

: load   ( u -- )
    0 #blk @ third between? 0= 8 ?error
    blk tuck 3@>r !+ 2off prev on
    interpret
    blk 3r>!

( blk u blk )
preload
    push blk, in, lin, span to return stack


: load   ( u -- )
    0 #blk @ 1- third between? 0=  8 ?error \ "BLOCK OUT OF RANGE"
    6 blk m>r                   ( u ) \ push `blk in lin span` to return stack
    blk !  in on  span off
    interpret                   \ process an entire screen
    6 blk r>m ;                 \ pop `blk in lin span` from return stack


```
#endif
#include "align.i65"
_load
    jsr enter
#include "page.i65"
    .word zero
#include "page.i65"
    .word numblk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word third
#include "page.i65"
    .word betweenq
#include "page.i65"
    .word zeq                   ; `blk` must be available in `vmbuf`
#include "parm.i65"
    .word qerror
    .byt 8                      ; "BLOCK OUT OF RANGE"
#include "pad.i65"
    .word blk
#include "page.i65"
    .word tuck                  ;( blk u blk )
#include "page.i65"
    .word threefetchtor         ; stash `blk` `in` `span` on return stack
#include "page.i65"
    .word _storeplus            ; just like `blk !  in`
#include "page.i65"
    .word true
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word off
#include "page.i65"
    .word _interpret            ; interpret has two clients, `load` and `quit`
#include "page.i65"
    .word blk
#include "page.i65"
    .word threerfromstore       ; restore prior `blk` `in` `span`
#include "past.i65"
    .word exit
