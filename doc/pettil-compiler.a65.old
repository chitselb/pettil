; pettil-compiler.a65
#echo .       pettil-compiler.a65       Compiler

;--------------------------------------------------------------
#if 0
name=HERELSB
stack=( -- c )
tags=compiler,nosymbol
 Returns the least significant byte of DP
#endif
#include "align.i65"
herelsb
    lda uarea+userdp-userarea
    jmp push0a

;--------------------------------------------------------------
#if 0
name=ALLOT
stack=( n -- )
tags=compiler

#endif
#include "align.i65"
_allot
    jsr enter
#include "page.i65"
    .word dp
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=,
stack=( w -- )
tags=compiler
#endif
#include "align.i65"
_comma
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word store
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=C,
stack=( b -- )
tags=compiler
#endif
#include "align.i65"
_ccomma
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"20
    .word cstore
#include "page.i65"
    .word one
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CFA,
stack=( addr -- )
tags=compiler,nosymbol
Set the code field of a new definition, taking page alignment
into account.  The address is the creator word's CFA, e.g. [[:]]
or [[VARIABLE]]

```
: cfa,   ( xt -- )
    \ test for $xxFC or $xxFD, insert NOP
    begin
        herelsb $fe and $fc =
    while
        $ea c,
    repeat
    $20 c,
    , ;

```
#endif
#include "align.i65"
_cfacomma
    jsr enter
#include "page.i65"
cfacomma01
    .word herelsb
#include "page.i65"
    .word clit
    .byt $fe
#include "pad.i65"
    .word andx
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(cfacomma02-*+1)
#include "pad.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word branch
    .byt <(cfacomma01-*+1)
#include "pad.i65"
cfacomma02
#include "page.i65"
    .word bl                    ; JSR instruction
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=NEXTPAGE
stack=( -- )
tags=compiler,nosymbol
Moves [[DP]] to the next page if needed, to preserve page alignment

```
: nextpage   ( -- )
    ['] page here !
    $100 herelsb - dp +! ;
```
#endif
#include "align.i65"
_nextpage
    jsr enter
#include "page.i65"
    .word plit
    .word page
#include "pad.i65"
    .word here
#include "page.i65"
    .word store
#include "page.i65"
    .word plit
    .word $100
#include "pad.i65"
    .word herelsb
#include "page.i65"
    .word minus
#include "page.i65"
    .word dp
#include "page.i65"
    .word plusstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PAGEMARGIN
stack=( -- )
tags=compiler,nosymbol
Moves [[DP]] to the next page if it is past the margin, to
work around the NMOS jmp ($xxFF) bug.  The value of `margin`
is the highest usable address within a page, which is `$xxFC`
by default.  The `margin` is located in the code immediately 
following the call to `PAGEMARGIN`.
#endif
pagemargin
    ldy #1
    inc ip
    lda uarea+userdp-userarea
    cmp (ip),y
    bcs _nextpage
    jmp next

;--------------------------------------------------------------
#if 0
name=XT,
stack=( xt -- )
tags=compiler,nosymbol
Encloses the execution token into the dictionary, paying heed
to page alignment and inserting the 'page' token into the
dictionary stream at page boundaries

```
: xt,   ( xt -- )
    $fc ?page  , ;
```
#endif
#include "align.i65"
_xtcomma
    jsr enter
#include "page.i65"
    .word pagemargin
    .byt $fc
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UNDEFINE
stack=( -- )
tags=interpreter,dictionary,forth-83,forth-79,fig
Removes the most recently defined symbol in SYMNEW.  Used by
error recovery

```
: undefine   ( -- )
    latest 2-  dup symtail !  dup @ dp !  3 erase ;
```
#endif
#include "align.i65"
_undefine
    jsr enter
#include "page.i65"
    .word _latest
#include "page.i65"
    .word twominus
#include "page.i65"
    .word dup
#include "page.i65"
    .word symtail
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dp
#include "page.i65"
    .word store
#include "page.i65"
    .word three
#include "page.i65"
    .word _erase
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?ERROR
stack=( flag errcode -- )
tags=ext,compiler
Aborts with a numbered error if the flag is true

```
: ?error   ( flag errcode -- )
    swap  ?: fail drop ;
```
#endif
#include "align.i65"
_qerror
    jsr enter
#include "page.i65"
    .word swap
#include "page.i65"
    .word pquerycolon
    .word _fail
    .word drop
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?COMP
stack=( -- )
tags=compiler,nosymbol
Check the [[STATE]] variable to see if we are compiling, issue an
error if [[STATE]] is off ([[INTERPRET]] mode)

```
: ?comp   ( -- )
    compiling? 5 ?error ;
```
#endif
#include "align.i65"
_qcomp
    jsr enter
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word zeq
#include "page.i65"
    .word five                      ; "COMPILATION ONLY"
#include "page.i65"
    .word _qerror
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=COMPILE
stack=( -- )
tags=compiler,nosymbol

#endif
#include "align.i65"
_compile
    jsr enter
#include "page.i65"
    .word _qcomp
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _xtcomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CREATE
stack=( "name" -- )
tags=compiler,defining
 A defining word executed in the form

     `CREATE <name>`

     Creates a dictionary entry for <name>.  After <name> is
     created, the next available dictionary location is the first
     byte of <name>'s parameter field.  When <name> is
     subsequently executed, the address of the first byte of
     <name>'s parameter field is left on the stack.  CREATE does
     not allocate space in <name>'s parameter field.

#endif
#include "align.i65"
_create
    jsr enter
#include "page.i65"
    .word plit
    .word docreate
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=:
stack=( -- )
tags=compiler,defining,fig
 A defining word executed in the form:

 `: <name> ... ;`

 Creates a word definition for `<name>` in the compilation
 vocabulary and sets compilation state true. Text from the
 input stream is subsequently compiled.  `<name>` is called
 a "colon definition".  The newly created word definition
 for `<name>` cannot be found in the dictionary until the
 corresponding `;` or `;CODE` is successfully processed.

 An error condition exists if a word is not found and cannot
 be converted to a number or if, during compilation from mass
 storage, the input stream is exhausted before encountering `;`
 or `;CODE`.  The stack is checked for balance when a `;`
 terminates the definition.

!!! pronounced: "colon"

```
: :   ( -- )
    0pairs  redefined off  ['] enter literal (create)
    !csp latest smudge ] ;
```
#endif
#include "align.i65"
_colon
    jsr enter
#include "page.i65"
    .word zeropairs
#include "page.i65"
    .word redefined
#include "page.i65"
    .word off                   ; turn REDEFINED off before (CREATE)
#include "page.i65"
    .word plit
    .word enter
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word storecsp
#include "page.i65"
    .word _latest
#include "page.i65"
    .word smudge                ; smudge the newly minted symbol
#include "page.i65"
    .word _rbracket
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CLOSE-DEFINITION
stack=( -- )
tags=compiler,fig,nosymbol
Terminates `:` and `CODE` definitions by unsmudging the header
and resetting `REDEFINED`.  Used by `;` `;CODE` and `END-CODE`

```
: close-definition   ( -- )
    ?csp  latest unsmudge  redefined dup @ dup
    ?: smudge drop  off  [ ;
```
#endif
#include "align.i65"
_closedefinition
    jsr enter
#include "page.i65"
    .word _qpairsclosed
#include "page.i65"
    .word qcsp
#include "page.i65"
    .word _latest
#include "page.i65"
    .word unsmudge
#include "page.i65"
    .word redefined
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word dup
#include "page.i65"
    .word pquerycolon
    .word smudge
    .word drop
#include "pad.i65"
    .word off
#include "page.i65"
    .word _lbracket
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=;
stack=( -- )
tags=compiler,fig
flags=immediate
 An immediate word which terminates a colon-definition and
 stops further compilation. Compiles the run-time `exit`

!!! pronounced: "semi"

```
: ;   ( -- )
    [compile] exit  closedefinition ; immediate
```
#endif
#include "align.i65"
_semi
    jsr enter
#include "page.i65"
    .word _compile
    .word exit
#include "pad.i65"
    .word _closedefinition
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?:
stack=( "name1" "name2" -- )
tags=compiler,ext
flags=immediate
Immediate word that compiles its own runtime word (?:) and two branches. The first branch is the true
branch, and the second is the false branch.  One of those is executed by (?:) at runtime.

Used in the form

```
( flag ) :? this that

is equivalent to

if this else that then

: ?:   ( "name1" "name2" -- )
    ?comp  $f8 ?page [compile] (?:) ' , ' , ; immediate
```
~ fix this page management.  $f8 is overkill
#endif
#include "align.i65"
_querycolon
    jsr enter
#include "page.i65"
    .word _qcomp
#include "page.i65"
    .word pagemargin
    .byt $f8
#include "pad.i65"
    .word _compile
    .word pquerycolon
#include "pad.i65"
    .word _tick
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DPSWAP
stack=( -- )
tags=compiler
Switches the transient dictionary pointer [[TDP]] with the core
dictionary pointer [[DP]]

```
: dpswap   ( -- )
    dp tdp @swap! ;
```
#endif
#include "align.i65"
_dpswap
    jsr enter
#include "page.i65"
    .word dp
#include "page.i65"
    .word tdp
#include "page.i65"
    .word _fetchswapstore
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DOES>
stack=( -- )
tags=compiler
flags=immediate
Terminates the compile-time (parent) code of a `<BUILDS ... DOES> ...`
definition in the transient dictionary and begins compilation of the
commonly shared run-time (child) code into the core dictionary

```
: does>
    ?comp  0pairs [compile] exit dp @ tdp @ > if dpswap then
    ['] dodoes cfa, ; immediate
```
#endif
#include "align.i65"
_does
    jsr enter
#include "page.i65"
    .word _qcomp
#include "page.i65"
    .word zeropairs
#include "page.i65"
    .word _compile
    .word exit
#include "pad.i65"
    .word dp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word tdp
#include "page.i65"
    .word fetch
#include "page.i65"
    .word gt
#include "page.i65"
    .word qbranch
    .byt <(does01-*+1)
#include "pad.i65"
    .word _dpswap
#include "page.i65"
does01
    .word plit
    .word dodoes
#include "pad.i65"
    .word _cfacomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BISHWHET
stack=( dp tdp latest -- a a c b-a )
tags=compiler,defining,nosymbol
helper word for `<BUILDS` in compile state

```
core                    tdict             symnew
----+----+---           ----+----*-       ----.-+-------
    ^A   ^B                 ^C   ^D           ^E^F
A = @E          B = @DP         C = @TDP        X = b-a
DP = C+X        TDP = A         E = C           [C..D] = [A..B]
0000  00 01 d7 63  76 06 86 06  00 00 05 50  00 01 07 70
            latest dp    tdp
```
#endif
bishwhet
    jsr locals4
    brk
    .byt popd | TOS
    .byt st | N2        ; A
    .byt ldd | N0       ; @dp
    .byt popd | N0      ; reget B
    .byt sub | N2       ; size
    .byt st | N3        ; B-A
    .byt ldd | N1       ; @tdp
    .byt popd | N1      ; reget C
    .byt st | N4
    .byt std | TOS      ; set latest E = C
    .byt add | N3
    .byt std | N0       ; set DP = C+X
    .byt ld | N2
    .byt std | N1
    .byt st | TOS       ; ( a )
    .byt push           ; ( a a )
    .byt ld | N4
    .byt push           ; ( a a c )
    .byt ld | N3
    .byt push           ; ( a a c b-a )
    .byt nxt

;--------------------------------------------------------------
#if 0
name=<BUILDS
stack=( == ; "name" -- )
tags=compiler,defining
flags=immediate
 A defining word executed in the form

 `<BUILDS <name> ... DOES> ... ;`

Creates a dictionary entry for <name>.  After <name> is
created, the next available dictionary location is the first
byte of <name>'s parameter field.  When <name> is
subsequently executed, the address of the first byte of
<name>'s parameter field is left on the stack.  CREATE does
not allocate space in <name>'s parameter field.
<br/>
The compile-time portion of the word between `<BUILDS ... DOES>`
is added to the [[transient dictionary|TDICT]] to conserve
space in core.  Run-time behavior shared by child words is
added to the core dictionary.

```
: <builds   ( == ; "name" -- )
    ?comp  0pairs dp tdp latest bishwhet cmove 
    [compile] plit , [compile] (create)
    ; immediate
```
#endif
#include "align.i65"
_builds
    jsr enter
#include "page.i65"
    .word _qcomp
#include "page.i65"
    .word zeropairs
#include "page.i65"
    .word dp
#include "page.i65"
    .word tdp
#include "page.i65"
    .word _latest
#include "page.i65"
    .word bishwhet
#include "page.i65"
    .word cmove
#include "page.i65"
    .word _compile
    .word plit
#include "pad.i65"
    .word _comma
#include "page.i65"
    .word _compile
    .word _pcreate
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CONSTANT
stack=( "name" ; n == ) ( -- n )
tags=compiler

```
: constant   ( "name" ; n == ) ( -- n )
    doconst (create) , ;
```
#endif
#include "align.i65"
_constant
    jsr enter
#include "page.i65"
    .word plit
    .word doconst
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=CCONSTANT
stack=( "name" ; c == ) ( -- c )
tags=compiler

create an 8-bit constant

```
: cconstant   ( "name" ; c == ) ( -- c )
    doconst (create) c, ;
```
#endif
#include "align.i65"
_cconstant
    jsr enter
#include "page.i65"
    .word plit
    .word docconst
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=2CONSTANT
stack=( "name" ; d == ) ( -- d )
tags=compiler

```
: 2constant   ( "name" ; d == ) ( -- d )
    do2const (create) , , ;
```
#endif
#include "align.i65"
_twoconstant
    jsr enter
#include "page.i65"
    .word plit
    .word dotwoconst
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word _comma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VARIABLE
stack=( -- )
tags=compiler,forth-79
A defining word executed in the form:
       `VARIABLE <name>`
A dictionary entry for <name> is created and two bytes are
ALLOTted in its parameter field.  This parameter field is to
be used for contents of the variable.  The application is
responsible for initializing the contents of the variable
which it creates.  When <name> is later executed, the
address of its parameter field is placed on the stack.
#endif
#include "align.i65"
_variable
    jsr enter
#include "page.i65"
    .word _create
#include "page.i65"
    .word two
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LATEST
stack=( -- nfa )
tags=compiler
Leaves the name field address of the top-most word in the
symbol table.
#endif
#include "align.i65"
_latest
    jsr enter
#include "page.i65"
    .word newest
#include "page.i65"
    .word fetch
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=$,
stack=( addr -- )
tags=string
Enclose a quoted string in the dictionary

~ doesn't handle page boundaries
#endif
#include "align.i65"
_stringcomma
    jsr enter
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=$>PAD $.>PAD $>PAD $>PAD
stack=( addr -- )
tags=string
Move a string at `addr` to the [[PAD]]
#endif
#include "align.i65"
_stringtopad
    jsr enter
#include "page.i65"
    .word _pad
#include "page.i65"
    .word duptor
#include "page.i65"
    .word over
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _move
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(
stack=( text) -- )
tags=forth-83
flags=immediate
Begins a Forth comment, terminated by the next ')' character in
the input stream
#endif
#include "align.i65"
_lparen
    jsr enter
#include "page.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=\
stack=( text$ -- )
tags=forth-83
flags=immediate
Begins a Forth comment, terminated by the end of the current
logical line

~todo
#endif
#include "align.i65"
_backslash
    jsr enter
;#include "page.i65"
;    .word clit
;    .asc ')'
;#include "pad.i65"
;    .word _qchar
;#include "page.i65"
;    .word drop
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(."")
stack=( cfa text" -- )
tags=compiler,i/o,nosymbol
common code for ." and "

```
: (."")  ( cfa -- )
    compiling?  dup>r  ?: xt, drop
    [char] " ?char swap  r>
    if
        $, rdrop
    then
    drop ;
```
~ gross.  doesn't handle paging properly
#endif
#include "align.i65"
_pdqq
    jsr enter
#include "page.i65"
    .word state
#include "page.i65"
    .word fetch
#include "page.i65"
    .word duptor
#include "page.i65"
    .word pquerycolon
    .word _xtcomma
    .word drop
#include "pad.i65"
    .word clit
    .byt '"'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word qbranch
    .byt <(pdqq01-*+1)
#include "pad.i65"
    .word _stringcomma
#include "page.i65"
    .word rdrop
#include "page.i65"
pdqq01
    .word exit

;--------------------------------------------------------------
#if 0
name="
stack=( text" == ) ( -- addr )
tags=string
flags=immediate
State-smart string literal.  In compile mode, encloses a string
in the dictionary.  In interpret mode, returns the address of a
string ([[PAD]])

```
: "   ( text" == ) ( -- addr )
    [ ' (") ] literal   (."")  $>pad ;
```
!!!pronounced: "quote"
#endif
#include "align.i65"
_quote
    jsr enter
#include "page.i65"
    .word plit
    .word pquote
#include "pad.i65"
    .word _pdqq
#include "page.i65"
    .word _stringtopad
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=." ".&quot;"
stack=( text" -- )
tags=compiler,i/o
flags=immediate
Output a string

Scans ahead in the input stream for a close " character and
encloses the string in the dictionary.

```
: ."   ( text" == ) ( -- addr )
    [ ' (.") ] literal   (."")  $. ;
```
!!!pronounced: "dot-quote"
#endif
#include "align.i65"
_dotq
    jsr enter
#include "page.i65"
    .word plit
    .word pdq
#include "pad.i65"
    .word _pdqq
#include "page.i65"
    .word _stringdot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=ABORT"
stack=( flag -- ) ( -- ; compiling )
tags=compiler
flags=immediate
#endif
#include "align.i65"
_abortq
    jsr enter
#include "page.i65"
    .word _dotq
#include "page.i65"
    .word _compile
    .word _abort
#include "pad.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=[ {
stack=( -- )
tags=compiler
flags=immediate
Exit compile mode
#endif
#include "align.i65"
_lbracket
    jsr enter
#include "page.i65"
    .word state
#include "page.i65"
    .word off
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=] "]"
stack=( -- )
tags=compiler

#endif
#include "align.i65"
_rbracket
    jsr enter
#include "page.i65"
    .word state
#include "page.i65"
    .word on
#include "page.i65"
    .word qstack
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=.(
stack=( -- )
tags=compiler
flags=immediate

#endif
#include "align.i65"
_dotp
    jsr enter
#include "page.i65"
    .word clit
    .asc ')'
#include "pad.i65"
    .word _qchar
#include "page.i65"
    .word count
#include "page.i65"
    .word type
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=['] {'}
stack=( == ) ( -- n )
tags=compiler
flags=immediate
Enclose the code field address of the next word in the input stream
into the dictionary as a [[literal|LITERAL]].  Forces compilation of
immediate words
#endif
#include "align.i65"
_brtick
    jsr enter
#include "page.i65"
    .word _qcomp
#include "page.i65"
    .word _tick
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=IMMEDIATE
stack=
tags=compiler

#endif
#include "align.i65"
_immediate
    jsr enter
#include "page.i65"
    .word _latest
#include "page.i65"
    .word clit
    .byt $80
#include "pad.i65"
    .word toggle
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VOCABULARY
stack=( "name" -- )
tags=compiler,defining
PETTIL vocabularies are flat

see [[FD-V05N3 p. 5|http://www.forth.org/fd/FD-V05N3.pdf]]

```
: vocabulary   ( "name" -- )
    current dup @ over 2>r off
    ['] dovocab  (create)  #voc dup 1+! @ c,
    latest c@ $1f and swap c!
    2r> ! ;
```
#endif
#include "align.i65"
_vocabulary
    jsr enter
#include "page.i65"
    .word current
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word twotor
#include "page.i65"
    .word off
#include "page.i65"
    .word plit
    .word dovocab
#include "pad.i65"
    .word _pcreate
#include "page.i65"
    .word numvoc
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word _latest
#include "page.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $1f
#include "pad.i65"
    .word andx
#include "page.i65"
    .word swap
#include "page.i65"
    .word cstore
#include "page.i65"
    .word tworfrom
#include "page.i65"
    .word store
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DEDUPVOCAB
stack=( -- )
tags=compiler,primitive,nosymbol
remove duplicates from [[VSTACK]]
#endif
dedupvocab
    ldy #4              ; start after JSR DOVOCAB and new vocid
dovocab02
    lda vstack,y
    beq dovocab04       ; all done when we hit FORTH vocab
    eor vstack+3        ; compare to new vocid
    beq dovocab03       ; this vocabulary is a duplicate?
    iny
    bne dovocab02       ; bra
dovocab03
    iny
    lda vstack,y
    sta vstack-1,y
    bne dovocab03
dovocab04
    jmp next

;--------------------------------------------------------------
#if 0
name=(VOCAB)
stack=( -- )
tags=compiler,nosymbol
The business end of a word defined by [[VOCABULARY]].  Gets the
vocid from the vocabulary and prepends it to [[VSTACK]]

```
: (vocab)   ( -- )
    vstack dup 1+ 8  cmove>
    r@ 1+ c@ vstack c! dedupvocab ;
```
#endif
#include "align.i65"
dovocab
    jsr enter
#include "page.i65"
    .word _caller
#include "page.i65"
    .word vstack
#include "page.i65"
    .word dup
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word eight
#include "page.i65"
    .word cmovegt
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word vstack
#include "page.i65"
    .word cstore
#include "page.i65"
    .word dedupvocab
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VDROP
stack=( -- )
vocab=1
tags=vocabulary,ext
Remove the first vocabulary from [[VSTACK]].

```
: vdrop   ( -- )
    current @ context ! ?csp latest unsmudge ;
```
#endif
#include "align.i65"
_vdrop
    jsr enter
#include "page.i65"
    .word vstack
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word vstack
#include "page.i65"
    .word clit
    .byt 9
#include "pad.i65"
    .word cmove
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=2VARIABLE
stack=( == ) ( -- )
tags=compiler
Create storage for a new double
#endif
#include "align.i65"
_twovariable
    jsr enter
#include "page.i65"
    .word _variable
#include "page.i65"
    .word two
#include "pad.i65"
    .word _allot
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DROPLIT
stack=( d == ) ( -- n )
tags=compiler,nosymbol
Compiles the least significant 16 bits of a double into the dictionary as
a numeric literal

!!!pronounced: drop-lit
#endif
#include "align.i65"
_droplit
    jsr enter
#include "page.i65"
    .word drop
#include "page.i65"
    .word branch
    .byt <(literal00-*+1)

;--------------------------------------------------------------
#if 0
name=LITERAL
stack=( n == ) ( -- n )
tags=compiler
flags=immediate
Enclose `n` into the dictionary.  At runtime, leaves `n` on the
stack.
#endif
#include "align.i65"
_literal
    jsr enter
#include "page.i65"
literal00
    .word dup
#include "page.i65"
    .word plit
    .word 256
#include "pad.i65"
    .word ult
#include "page.i65"
    .word qbranch
    .byt <(literal01-*+1)
#include "pad.i65"
    .word _compile
    .word clit
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word branch
    .byt <(literal02-*+1)
#include "pad.i65"
literal01
    .word _compile
    .word plit
#include "pad.i65"
    .word _comma
#include "page.i65"
literal02
    .word exit

;--------------------------------------------------------------
#if 0
name=DLIT
stack=( d == ) ( -- d )
tags=compiler
Compiles a double into the dictionary as a numeric literal
!!!pronounced: d-lit
#endif
#include "align.i65"
_dlit
    jsr enter
#include "page.i65"
    .word swap
#include "page.i65"
    .word _literal
#include "page.i65"
    .word _literal
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD
stack=( u -- )
tags=compiler

 The contents of >IN and BLK , which locate the current input
 stream, are saved.  The input stream is then redirected to
 the beginning of screen u by setting >IN to zero and BLK to
 u.  The screen is then interpreted.  If interpretation from
 screen u is not terminated explicitly it will be terminated
 when the input stream is exhausted and then the contents of
 >IN and BLK will be restored.  An error condition exists if
 u is zero.  See  >IN  BLK  BLOCK

```
: load   ( scr -- )
    ?dup
    if
        blk @  >in @ 2>r
        blk !  source! interpret
        r> >in !  r> blk !  source!
    then ;
```
#endif
#include "align.i65"
_load
    jsr enter
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(load01-*+1)
#include "pad.i65"
    .word blk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word toin
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twotor
#include "page.i65"
    .word blk
#include "page.i65"
    .word store
#include "page.i65"
    .word _sourcestore
#include "page.i65"
    .word _interpret
#include "page.i65"
    .word tworfrom
#include "page.i65"
    .word toin
#include "page.i65"
    .word store
#include "page.i65"
    .word blk
#include "page.i65"
    .word store
#include "page.i65"
    .word _sourcestore
#include "page.i65"
load01
    .word exit

;--------------------------------------------------------------
#if 0
name=SAVE-FORTH
stack=( -- )
tags=compiler,unimplemented

 Writes a binary file of the core dictionary to mass storage
 ($0401 to HERE)

#endif
#include "align.i65"
_saveforth
;    jsr enter
;#include "page.i65"
;    .word exit






























;--------------------------------------------------------------
#if 0
name=?CSP
stack=( -- )
tags=compiler,nosymbol
Generates an error if the data stack is unbalanced when defining
`CODE` or `:` words
#endif
qcsp
    ldy #4              ; DEFINITION UNFINISHED
    cpx uarea+usercsp-userarea
    bne pairs04
    ; fall through
;--------------------------------------------------------------
#if 0
name=!CSP
tags=compiler
#endif
#include "align.i65"
storecsp
    stx uarea+usercsp-userarea
    jmp next

;--------------------------------------------------------------
#if 0
name=?PAIRSCLOSED
stack=( -- )
tags=compiler,nosymbol
Aborts compilation if any control structures are still open

|ID|Open|Test|Close|h
|^1|^BEGIN|^WHILE|^REPEAT<br/>UNTIL<br/>AGAIN|
|^2|^IF|^ELSE|^THEN|
|^3|^DO<br/>?DO|^LEAVE<br/>?LEAVE|^LOOP<br/>+LOOP|
```
: ?pairs
    [ 'pairs ] literal  3c@ or six ?error ; 
```
!!! pronounced: //"query-pairs-closed"//
#endif
#include "align.i65"
_qpairsclosed
    jsr enter
#include "page.i65"
    .word plit
    .word pairs
#include "pad.i65"
    .word threecfetch
#include "page.i65"
    .word orx
#include "page.i65"
    .word six
#include "page.i65"
    .word _qerror
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?PAIROPEN
stack=( 1|2|3 -- )
tags=compiler,control,nosymbol
Aborts compilation unless there is at least one open control structure of
the type of the given argument
#endif
qpairopen
    ldy tos
    lda pairs-1,y
    bne pairs02         ; OKAY
pairs03
    ldy #6              ; UNPAIRED CONDITIONALS
pairs04
    jmp error

;--------------------------------------------------------------
#if 0
name=0PAIRS
stack=( -- )
tags=compiler,nosymbol
clear the three [[PAIRS]] counters

```
: 0pairs   ( -- )
    [ 'pairs ] literal  3 erase ;
```
!!! pronounced: "query-pairs"
#endif
#include "align.i65"
zeropairs
    ldy #$fd            ; -3
    lda #0
zeropairs01
    sta pairs-$fd,y
    iny
    bne zeropairs01
    jmp next

;--------------------------------------------------------------
#if 0
name=PAIRS
stack=( flag -- )
tags=compiler,control,nosymbol
Counters for the IF/ELSE/THEN, BEGIN/WHILE/REPEAT/AGAIN/UNTIL, and DO/LEAVE/LOOP used by the compiler to match up opening and closing pairs
of conditional control words
#endif
pairs
    .dsb 3,0            ; storage for counters

;--------------------------------------------------------------
#if 0
name=+PAIRS
stack=( 1|2|3 -- )
tags=compiler,control,nosymbol
Increments the pair counter
#endif
pluspairs
    sec
    .byt $29            ; AND immediate
    ; fall through
;--------------------------------------------------------------
#if 0
name=-PAIRS
stack=( 1|2|3 -- )
tags=compiler,control,nosymbol
Decrements the pair counter
#endif
minuspairs
    clc
    txa
    ldx tos
    bcc pairs01
    inc pairs-1,x
    inc pairs-1,x
pairs01
    dec pairs-1,x
    php
    tax
    plp
    bmi pairs03         ; UNPAIRED CONDITIONALS if counter negative
pairs02
    ldy #5              ; COMPILATION ONLY
    lda uarea+userstate-userarea
    beq pairs04
    jmp drop



































;--------------------------------------------------------------
#if 0
name=CONDITIONAL,
stack=( )
tags=compiler,control,nosymbol
compiles runtime code for control word

```
```
#endif
#include "align.i65"
_conditionalcomma
    jsr enter
#include "page.i65"
    .word pagemargin
    .byt $fb
#include "pad.i65"
    .word fetch
#include "page.i65"
    .word _xtcomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CONDITIONAL-OPEN)
stack=( addr -- dp )
tags=compiler,control,nosymbol
compiles runtime code for LOOP or +LOOP

14+21+29

```
does>
    c@+ +pairs  [ $fb ] pagemargin  @ xt,
    0 c, here ;
```
#endif
#include "align.i65"
_conditionalopen
    jsr dodoes
#include "page.i65"
    .word cfetchplus
#include "page.i65"
    .word pluspairs
#include "page.i65"
    .word _conditionalcomma
#include "page.i65"
    .word here
#include "page.i65"
    .word zero
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CONDITIONAL-MIDDLE)
stack=( addr -- dp )
tags=compiler,control,nosymbol
compiles runtime code for LOOP or +LOOP

```
does>
    c@+ +pairs  [ $fb ] pagemargin  @ xt,
    0 c, here ;
```
#endif
#include "align.i65"
_conditionalmiddle
    jsr dodoes
#include "page.i65"
    .word cfetchplus
#include "page.i65"
    .word qpairopen
#include "page.i65"
    .word _conditionalcomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CONDITIONAL-CLOSE)
stack=( xt -- )
tags=compiler,control,nosymbol

compiles runtime code for LOOP or +LOOP
```
does>
    c@+ -pairs  [ $fb ] pagemargin  @ xt,
    c@+ ['] -pairs (conditional-cfa)
    0 c, here ;

does>  
    ['] -pairs (conditional-cfa)
    0 c, here ;

    c@+ -pairs
    [ $fb ] pagemargin
    @ xt,
    dup>r here swap - dup
    2+ r> c! 2- negate c, ;
```
#endif
#include "align.i65"
_conditionalclose
    jsr dodoes
#include "page.i65"
    .word cfetchplus
#include "page.i65"
    .word minuspairs
#include "page.i65"
    .word _conditionalcomma
#include "page.i65"
    .word duptor
#include "page.i65"
    .word here
#include "page.i65"
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word cstore
#include "page.i65"
    .word twominus
#include "page.i65"
    .word negate
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(CONDITIONAL-ELSE)
stack=( )
tags=compiler,control,nosymbol

compiles runtime code for ELSE
```
does>
    c@+ -pairs  [ $fb ] pagemargin  @ xt,
    c@+ ['] -pairs (conditional-cfa)
    0 c, here ;

does>  
    ['] -pairs (conditional-cfa)
    0 c, here ;

    c@+ -pairs
    [ $fb ] pagemargin
    @ xt,
    dup>r here swap - dup
    2+ r> c! 2- negate c, ;
```
#endif
#include "align.i65"
_conditionalelse
    jsr dodoes
#include "page.i65"
    .word cfetchplus
#include "page.i65"
    .word qpairopen
#include "page.i65"
    .word dup
#include "page.i65"
    .word _conditionalcomma
#include "page.i65"
    .word duptor
#include "page.i65"
    .word here
#include "page.i65"
    .word swap
#include "page.i65"
    .word exit











;--------------------------------------------------------------
#if 0
name=?>MARK
stack=( marker -- dp )
tags=compiler,nosymbol

```
: ?>mark
    here swap c, ;
```
#endif
#include "align.i65"
_qtomark
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word swap
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?<MARK
stack=( -- dp 0 )
tags=compiler,nosymbol

```
: ?<mark
    here 0 ;
```
#endif
#include "align.i65"
_qfrommark
    jsr enter
#include "page.i65"
    .word here
#include "page.i65"
    .word zero
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?>RESOLVE
stack=
tags=compiler,nosymbol

```
: ?>resolve
    begin
        ?dup
    while
        dup c@ here third - 1+ rot c!
    repeat ;
```
#endif
#include "align.i65"
_qtoresolve
    jsr enter
#include "page.i65"
qtoresolve01
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(qtoresolve02-*+1)
#include "pad.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word here
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word rot
#include "page.i65"
    .word cstore
#include "page.i65"
    .word branch
    .byt <(qtoresolve01-*+1)
#include "pad.i65"
qtoresolve02
    .word exit

;--------------------------------------------------------------
#if 0
name=?<RESOLVE
stack=
tags=compiler,nosymbol
flags=immediate

```
: ?<resolve
    swap here - 1+ c, ?>resolve ;
```
#endif
#include "align.i65"
_qltresolve
    jsr enter
#include "page.i65"
    .word swap
#include "page.i65"
    .word here
#include "page.i65"
    .word minus
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word _ccomma
#include "page.i65"
    .word _qtoresolve
    .word exit

;--------------------------------------------------------------
#if 0
name=ADD>MARK
stack=( dp marker -- ; )
tags=compiler,nosymbol

```
: add>mark
    true >r
    begin
        swap 2dup >r
        and
    until
    drop ?>mark
    begin
        r> dup true
        and
    until
    drop ;
```
#endif
#include "align.i65"
_addtomark
    jsr enter
#include "page.i65"
    .word true
#include "page.i65"
    .word tor
#include "page.i65"
addtomark01
    .word swap
#include "page.i65"
    .word twodup
#include "page.i65"
    .word tor
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(addtomark01-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word _qtomark
#include "page.i65"
addtomark02
    .word rfrom
#include "page.i65"
    .word dup
#include "page.i65"
    .word true
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(addtomark02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word exit

























;--------------------------------------------------------------
#if 0
name=DO
stack=( == dp ) ( limit start -- )
tags=compiler,control
flags=immediate

d;m 0 8f;m 1f0 1ff;z

```
: do   ( )
    [ $fb ] pagemargin compile (do) 3 +pairs here ; immediate
```
#endif
#include "align.i65"
_do
    jsr _conditionalopen
    .byt 3
    .word pdo

;--------------------------------------------------------------
#if 0
name=?DO
stack=( == dp ) ( limit start -- )
tags=compiler,control
flags=immediate

```
: ?do   ( )
    $fb ?page  compile (?do)  0 ?>mark  ?<mark drop swap 3 ; immediate
```
#endif
#include "align.i65"
_qdo
    jsr _conditionalopen
    .byt 3
    .word pqdo

;--------------------------------------------------------------
#if 0
name=LOOP
stack=( == ) ( -- )
tags=compiler,control
flags=immediate

Immediate word, compiles runtime code to terminate a loop that
counts up by 1.  The loop index and limit are treated as
unsigned, e.g. `0 0 DO LOOP` will iterate 65536 times.  This
is distinct from [[+LOOP]] which treats the loop index/limit
both as signed integers.

d;m 0 8f;m 1e0 1ff;z

```
: loop   ( )
    3 -pairs  [ $fb ] pagemargin  compile (loop)
    dup>r here
    - dup r> c!
    negate c, ; immediate
```
#endif
_loop
    jsr _conditionalclose
    .byt 3          ; word 'family'
    .word ploop     ; runtime CFA

;--------------------------------------------------------------
#if 0
name=+LOOP
stack=( == ) ( increment -- )
tags=compiler,control
flags=immediate

Immediate word, compiles runtime code to terminate a loop that
steps by an arbitrary value on the stack, terminating when the
loop index goes past the limit.

[[Posted question on comp.lang.forth|https://groups.google.com/d/msg/comp.lang.forth/V9evPkLwRoM/Khwons3O4QwJ]]

```
: +loop   ( )
    3 ?pairs  compile (+loop)  ?<resolve ; immediate
```
#endif
#include "align.i65"
_plusloop
    jsr _conditionalclose
    .byt 3          ; word 'family'
    .word pploop    ; runtime CFA

;--------------------------------------------------------------
#if 0
name=LEAVE
stack=( -- )
tags=compiler,control
flags=immediate

#endif
#include "align.i65"
_leave
    jsr _conditionalmiddle
    .byt 3
    .word unloop

;--------------------------------------------------------------
#if 0
name=?LEAVE
stack=( == ) ( flag -- )
tags=compiler,control
flags=immediate
Equivalent to `IF LEAVE THEN`

#endif
#include "align.i65"
_qleave
    jsr _conditionalmiddle
    .byt 3
    .word pqleave

;--------------------------------------------------------------
#if 0
name=IF
stack=( == ) ( flag -- )
tags=compiler,control
flags=immediate

```
: if   ( )
    0 0 compile ?branch  ?>mark 2 ; immediate
```
#endif
#include "align.i65"
_if
    jsr _conditionalopen
    .byt 2
    .word qbranch

;--------------------------------------------------------------
#if 0
name=ELSE
stack=( == ) ( flag -- )
tags=compiler,control,nosymbol
flags=immediate

#endif
#include "align.i65"
_else
    jsr _conditionalelse
    .byt 2
    .word branch

;--------------------------------------------------------------
#if 0
name=THEN
stack=
tags=compiler,control
flags=immediate

```
: then   ( )
    ?comp abs 8 ?pairs ?>resolve ?>resolve ; immediate
#endif
#include "align.i65"
_then
    jsr _conditionalclose
    .byt 2
    .word 0



































;--------------------------------------------------------------
#if 0
name=BEGIN
stack=( == dp 0 4 ) ( -- )
tags=compiler,control
flags=immediate

```
: begin   ( == here 0 4 ) ( -- )
    ?<mark 4 ;
```
#endif
#include "align.i65"
_begin
    jsr enter
#include "page.i65"
    .word _qfrommark
#include "page.i65"
    .word four
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UNTIL
stack=( == ) ( flag -- )
tags=compiler,control
flags=immediate

```
: until   ( )
    4 ?pairs  compile ?branch  ?<resolve ; immediate
```
#endif
#include "align.i65"
_until
    jsr enter
#include "page.i65"
    .word four
#include "page.i65"
;    .word _qpairs
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=REPEAT
stack=( == ) ( -- )
tags=compiler,control
flags=immediate

synonym for AGAIN
#endif
#include "align.i65"
_repeat
    ; fall through
;--------------------------------------------------------------
#if 0
name=AGAIN
stack=( == ) ( -- )
tags=compiler,control
flags=immediate

```
: again   ( )
    4 ?pairs  compile branch  ?<resolve ; immediate
```
#endif
#include "align.i65"
_again
    jsr enter
#include "page.i65"
    .word four
#include "page.i65"
;    .word _qpairs
#include "page.i65"
    .word _compile
    .word branch
#include "pad.i65"
    .word _qltresolve
#include "page.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=WHILE
stack=( == ) ( flag -- )
tags=compiler,control
flags=immediate

```
: while   ( )
    compile ?branch  1 add>mark ; immediate
```
#endif
#include "align.i65"
_while
    jsr enter
#include "page.i65"
    .word _compile
    .word qbranch
#include "pad.i65"
    .word four
#include "page.i65"
    .word _addtomark
#include "page.i65"
    .word exit
