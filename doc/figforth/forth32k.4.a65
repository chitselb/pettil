 bit7 = $80
 bit6 = $40
 bit5 = $20

 ip = $82
 w2 = $85 ; used for jmp ($xxff) workaround
 w = $88
 stash = $8c
 basic = $0400

 .word basic+1 ; load address
 * = basic+1
ANFANG
 .word $040b ; link to BASIC end-of-line
 .word 10 ; BASIC line number 10
 .byt 158 ; BASIC SYS token
 .asc "1037" ; address of ENTER
basend
 .byt 0 ; basic end-of-line
 .word 0
ENTER jmp ICE
UAREA
 .word $39dd
 .word $009d
 .word $7f80
 .word $0072
 .word $01ff
 .word $0100
 .word $001f
 .word $0000
 .word $1d40
 .word $3a4b
 .word V3651 ; wut?

;~~~
L0426 .byt 3 | bit7
 .asc "LI","T"|bit7
 .word 0 ; bottom of dictionary
LIT
 .word *+2
 lda (ip),y
 pha
 inc ip
 bne P0437
 inc ip+1
P0437
 lda (ip),y
P0439 ; this could use a better label
 inc ip
 bne PUSH
 inc ip+1
PUSH
 dex
 dex
PUT
 sta $01,x
 pla
 sta $00,x
NEXT
 ldy #$01
NEXT2
 lda (ip),y
 sta w+1
 dey
 lda (ip),y
 sta w
 cmp #$ff
 beq P0463 ; workaround for 6502 page break bug
 clc
 lda ip
 adc #$02
 sta ip
 bcc P0460
 inc ip+1
P0460 jmp w-1
P0463 lda (w),y
 sta w2
 iny
 lda (w),y
 sta w2+1
 clc
 lda ip
 adc #$02
 sta ip
 bcc P0477
 inc ip+1
P0477 dey
 jmp w2-1

;~~~
L047b .byt 4 | bit7
 .asc "CLI","T"|bit7
 .word L0426
CLIT
 .word *+2
 lda (ip),y
 pha
 tya
 beq P0439 ; is this bra?
P048a ; this could use a better label
 asl
 sta $79
P048d
 lda $00,x
 sta $007a,y
 inx
 iny
 cpy $79
 bne P048d
 ldy #$00
 rts

;~~~
L049b .byt 7 | bit7
 .asc "EXECUT","E"|bit7
 .word L047b
EXECUTE
 .word *+2
 lda $01,x
 sta w+1
 lda $00,x
 sta w
 inx
 inx
 cmp #$ff ; eww
 beq P04b8
 jmp w-1
P04b8
 ldy #$01
 lda (w),y
 sta w2+1
 dey
 lda (w),y
 sta w2
 jmp w2-1
 lda #$07	; FULL STACK
ABEND		; entry point for other error messages, message# passed in A
 pha
 ldx #$70
 lda #<ERRENTRY
 sta ip
 lda #>ERRENTRY
 sta ip+1
 pla
 jmp PUSHOA
 lda #<QUITENTRY
 sta ip
 lda #>QUITENTRY
 sta ip+1
 JMP NEXT

;~~~
L04e2 .byt 6 | bit7
 .asc "BRANC","H"|bit7
 .word L049b
BRANCH .word *+2
 cpx #$11
 bcc $04c6
 lda $e812
 cmp #$ef
 beq $04d7
 clc
 lda (ip),y
 adc ip
 pha
 iny
 lda (ip),y
 adc ip+1
 sta ip+1
 pla
 sta ip
 jmp NEXT2

;~~~
L050b .byt 7 | bit7
 .asc "0BRANC","H"|bit7
 .word L04e2
ZBRAN .word *+2
 inx
 inx
 lda $fe,x
 ora $ff,x
 beq $04ed
 clc
 lda ip
 adc #$02
 sta ip
 bcc $052a
 inc ip+1
 JMP NEXT

;~~~
L052d .byt 6 | bit7
 .asc "(LOOP",")"|bit7
 .word L050b
PLOOP .word *+2
 stx stash
 tsx
 inc $0101,x
 bne $0543
 inc $0102,x
 clc
 lda $0103,x
 sbc $0101,x
 lda $0104,x
 sbc $0102,x
PL2
 ldx stash
 asl
 bcc $04ed
 pla
 pla
 pla
 pla
 jmp $051f

;~~~
L055c .byt 7 | bit7
 .asc "(+LOOP",")"|bit7
 .word L052d
PPLOOP
 .word *+2
 inx
 inx
 stx stash
 lda $ff,x
 pha
 pha
 lda $fe,x
 tsx
 inx
 inx
 clc
 adc $0101,x
 sta $0101,x
 pla
 adc $0102,x
 sta $0102,x
 pla
 bpl $0543
 clc
 lda $0101,x
 sbc $0103,x
 lda $0102,x
 sbc $0104,x
 jmp PL2

;~~~
L0596 .byt 4 | bit7
 .asc "(DO",")"|bit7
 .word L055c
PDO
 .word *+2
 lda $03,x
 pha
 lda $02,x
 pha
 lda $01,x
 pha
 lda $00,x
 pha
POPTWO
 inx
 inx
POP
 inx
 inx
 cpx #$73
 bcs P05b6
 JMP NEXT
P05b6
 lda #$01	; EMPTY STACK
 jmp ABEND

;~~~
L05bb .byt 1 | bit7
 .asc "I"|bit7
 .word L0596
I
 .word RFETCH+2

;~~~
L05c1 .byt 5 | bit7
 .asc "DIGI","T"|bit7
 .word L05bb
DIGIT .word *+2
 sec
 lda $02,x
 sbc #$30
 bmi $05ea
 cmp #$0a
 bmi $05dd
 sec
 sbc #$07
 cmp #$0a
 bmi $05ea
 cmp $00,x
 bpl $05ea
 sta $02,x
 lda #$01
 pha
 tya
 jmp PUT
 tya
 pha
 inx
 inx
 jmp PUT

;~~~
L05f1 .byt 6 | bit7
 .asc "(FIND",")"|bit7
 .word L05c1
PFIND .word *+2
 lda #$02
 jsr P048a
 stx stash
 ldy #$00
 lda ($7a),y
 eor ($7c),y
 and #$3f
 bne $063a
 iny
 lda ($7a),y
 eor ($7c),y
 asl
 bne $0638
 bcc $060d
 ldx stash
 dex
 dex
 dex
 dex
 clc
 tya
 adc #$05
 adc $7a
 sta $02,x
 ldy #$00
 tya
 adc $7b
 sta $03,x
 sty $01,x
 lda ($7a),y
 sta $00,x
 lda #$01
 pha
 jmp PUSH
 bcs $063f
 iny
 lda ($7a),y
 bpl $063a
 iny
 lda ($7a),y
 tax
 iny
 lda ($7a),y
 sta $7b
 stx $7a
 ora $7a
 bne $0603
 ldx stash
 lda #$00
 pha
 jmp PUSH

;~~~
L0656 .byt 7 | bit7
 .asc "ENCLOS","E"|bit7
 .word L05f1
ENCLOSE .word *+2
 lda #$02
 jsr P048a
 txa
 sec
 sbc #$08
 tax
 sty $03,x
 sty $01,x
 dey
 iny
 lda ($7c),y
 cmp $7a
 beq $0671
 sty $04,x
 lda ($7c),y
 bne $068c
 sty $02,x
 sty $00,x
 tya
 cmp $04,x
 bne $0689
 inc $02,x
 JMP NEXT
 sty $02,x
 iny
 cmp $7a
 bne $067a
 sty $00,x
 jmp NEXT

;~~~
L0698 .byt 4 | bit7
 .asc "EMI","T"|bit7
 .word L0656
EMIT
 .word DOEMIT

;~~~
L06a1 .byt 3 | bit7
 .asc "KE","Y"|bit7
 .word L0698
KEY
 .word DOKEY

;~~~
L06a9 .byt 9 | bit7
 .asc "?TERMINA","L"|bit7
 .word L06a1
QTERM
 .word DOQTERM

;~~~
L06b7 .byt 2 | bit7
 .asc "C","R"|bit7
 .word L06a9
CR
 .word DOCR

;~~~
L06be .byt 5 | bit7
 .asc "CMOV","E"|bit7
 .word L06b7
CMOVE
 .word *+2
 lda #$03
 jsr P048a
P06cd
 cpy $7a
 bne P06d8
 dec $7b
 bpl P06d8
 jmp NEXT
P06d8
 lda ($7e),y
 sta ($7c),y
 iny
 bne P06cd
 inc $7f
 inc $7d
 jmp P06cd

;~~~
L06e6 .byt 2 | bit7
 .asc "U","*"|bit7
 .word L06be
USTAR
 .word *+2
 lda $02,x
 sta $7a
 sty $02,x
 lda $03,x
 sta $7b
 sty $03,x
 ldy #$10
 asl $02,x
 rol $03,x
 rol $00,x
 rol $01,x
 bcc $0718
 clc
 lda $7a
 adc $02,x
 sta $02,x
 lda $7b
 adc $03,x
 sta $03,x
 lda #$00
 adc $00,x
 sta $00,x
 dey
 bne $06fb
 JMP NEXT

;~~~
L071e .byt 2 | bit7
 .asc "U","/"|bit7
 .word L06e6
USLASH
 .word *+2
 lda $04,x
 ldy $02,x
 sty $04,x
 asl
 sta $02,x
 lda $05,x
 ldy $03,x
 sty $05,x
 rol
 sta $03,x
 lda #$10
 sta $7a
P073b
 rol $04,x
 rol $05,x
 sec
 lda $04,x
 sbc $00,x
 tay
 lda $05,x
 sbc $01,x
 bcc $074f
 sty $04,x
 sta $05,x
 rol $02,x
 rol $03,x
 dec $7a
 bne P073b
 jmp POP

;~~~
L075a .byt 3 | bit7
 .asc "AN","D"|bit7
 .word L071e
ANDD
 .word *+2
 lda $00,x
 and $02,x
 pha
 lda $01,x
 and $03,x
 inx
 inx
 jmp PUT

;~~~
L0770 .byt 2 | bit7
 .asc "O","R"|bit7
 .word L075a
OR
 .word *+2
 lda $00,x
 ora $02,x
 pha
 lda $01,x
 ora $03,x
 inx
 inx
 jmp PUT

;~~~
L0785 .byt 3 | bit7
 .asc "XO","R"|bit7
 .word L0770
XOR
 .word *+2
 lda $00,x
 eor $02,x
 pha
 lda $01,x
 eor $03,x
 inx
 inx
 jmp PUT

;~~~
L079b .byt 3 | bit7
 .asc "SP","@"|bit7
 .word L0785
SPFETCH
 .word *+2
 txa
PUSHOA
 pha
 lda #$00
 jmp PUSH

;~~~
L07aa .byt 3 | bit7
 .asc "SP","!"|bit7
 .word L079b
SPSTORE
 .word *+2
 ldy #$06
 lda ($8a),y
 tax
 JMP NEXT

;~~~
L07ba .byt 3 | bit7
 .asc "RP","!"|bit7
 .word L07aa
RPSTORE
 .word *+2
 stx stash
 ldy #$08
 lda ($8a),y
 tax
 txs
 ldx stash
 JMP NEXT

;~~~
L07cf .byt 2 | bit7
 .asc ";","S"|bit7
 .word L07ba
SEMIS
 .word *+2
 pla
 sta ip
 pla
 sta ip+1
 JMP NEXT

;~~~
L07df .byt 5 | bit7
 .asc "LEAV","E"|bit7
 .word L07cf
LEAVE
 .word *+2
 stx stash
 tsx
 lda $0101,x
 sta $0103,x
 lda $0102,x
 sta $0104,x
 ldx stash
 JMP NEXT

;~~~
L07fd .byt 2 | bit7
 .asc ">","R"|bit7
 .word L07df
TOR
 .word *+2
 lda $01,x
 pha
 lda $00,x
 pha
 inx
 inx
 JMP NEXT

;~~~
L080f .byt 2 | bit7
 .byt "R",">"|bit7
 .word L07fd
RFROM .word *+2
 dex
 dex
 pla
 sta $00,x
 pla
 sta $01,x
 jmp NEXT

;~~~
L0821 .byt 1 | bit7
 .asc "R"|bit7
 .word L080f
RFETCH .word *+2
 stx stash
 tsx
 lda $0101,x
 pha
 lda $0102,x
 ldx stash
 jmp PUSH

;~~~
L0836 .byt 2 | bit7
 .asc "0","="|bit7
 .word L0821
ZEQ .word *+2
 lda $00,x
 ora $01,x
 sty $01,x
 bne $0846
 iny
 sty $00,x
 jmp NEXT

;~~~
L084b .byt 2 | bit7
 .asc "0","<"|bit7
 .word L0836
ZLT .word *+2
 asl $01,x
 tya
 rol
 sty $01,x
 sta $00,x
 JMP NEXT

;~~~
L085d .byt 1 | bit7
 .asc "+"|bit7
 .word L084b
PLUS .word *+2
 clc
 lda $00,x
 adc $02,x
 sta $02,x
 lda $01,x
 adc $03,x
 sta $03,x
 inx
 inx
 jmp NEXT

;~~~
L0875 .byt 2 | bit7
 .asc "D","+"|bit7
 .word L085d
DPLUS .word *+2
 clc
 lda $02,x
 adc $06,x
 sta $06,x
 lda $03,x
 adc $07,x
 sta $07,x
 lda $00,x
 adc $04,x
 sta $04,x
 lda $01,x
 adc $05,x
 sta $05,x
 jmp POPTWO

;~~~
L0898 .byt 5 | bit7
 .asc "MINU","S"|bit7
 .word L0875
MINUS
 .word *+2
 sec
P08a3
 tya
 sbc $00,x
 sta $00,x
 tya
 sbc $01,x
 sta $01,x
 JMP NEXT

;~~~
L08b0 .byt 6 | bit7
 .byt "DMINU","S"|bit7
 .word L0898
DMINUS
 .word *+2
 sec
 tya
 sbc $02,x
 sta $02,x
 tya
 sbc $03,x
 sta $03,x
 jmp P08a3

;~~~
L08c9 .byt 4 | bit7
 .asc "OVE","R"|bit7
 .word L08b0
OVER
 .word *+2
 lda $02,x
 pha
 lda $03,x
 jmp PUSH

;~~~
L08da .byt 4 | bit7
 .asc "DRO","P"|bit7
 .word L08c9
DROP
 .word POP

;~~~
L08e3 .byt 4 | bit7
 .asc "SWA","P"|bit7
 .word L08da
SWAP
 .word *+2
 lda $02,x
 pha
 lda $00,x
 sta $02,x
 lda $03,x
 ldy $01,x
 sty $03,x
 jmp PUT

;~~~
L08fc .byt 3 | bit7
 .asc "DU","P"|bit7
 .word L08e3
DUP
 .word *+2
 lda $00,x
 pha
 lda $01,x
 jmp PUSH

;~~~
L090c .byt 2 | bit7
 .asc "+","!"|bit7
 .word L08fc
PSTORE .word *+2
 clc
 lda ($00,x)
 adc $02,x
 sta ($00,x)
 inc $00,x
 bne $0920
 inc $01,x
 lda ($00,x)
 adc $03,x
 sta ($00,x)
 jmp POPTWO

;~~~
L0929 .byt 6 | bit7
 .asc "TOGGL","E"|bit7
 .word L090c
TOGGLE .word *+2
 lda ($02,x)
 eor $00,x
 sta ($02,x)
 jmp POPTWO

;~~~
L093d .byt 1 | bit7
 .asc "@"|bit7
 .word L0929
FETCH .word *+2
 lda ($00,x)
 pha
 inc $00,x
 bne $094c
 inc $01,x
 lda ($00,x)
 jmp PUT

;~~~
L0951 .byt 2 | bit7
 .asc "C","@"|bit7
 .word L093d
CFETCH
 .word *+2
 lda ($00,x)
 sta $00,x
 sty $01,x
 JMP NEXT

;~~~
L0961 .byt 1 | bit7
 .asc "!"|bit7
 .word L0951
STORE
 .word *+2
 lda $02,x
 sta ($00,x)
 inc $00,x
 bne $0971
 inc $01,x
 lda $03,x
 sta ($00,x)
 jmp POPTWO

;~~~
L0978 .byt 2 | bit7
 .asc "C","!"|bit7
 .word L0961
CSTORE
 .word *+2
 lda $02,x
 sta ($00,x)
 jmp POPTWO

;~~~
L0986 .byt 1 | bit7 | bit6
 .byt ":"|bit7
 .word L0978
COLON
 .word DOCOL
 .word QEXEC
 .word STORECSP
 .word CURRENT
 .word FETCH
 .word CONTEXT
 .word STORE
 .word CREATE
 .word RBRACK
 .word PSCODE
DOCOL
 lda ip+1
 pha
 lda ip
 pha
 clc
 lda w
 adc #$02
 sta ip
 tya
 adc w+1
 sta ip+1
 jmp NEXT

;~~~
L09b3 .byt 1 | bit7 | bit6
 .byt ";"|bit7
 .word L0986
SEMI
 .word DOCOL
 .word QCSP
 .word COMPILE
 .word SEMIS
 .word SMUDGE
 .word LBRACK
 .word SEMIS

;~~~
L09c5 .byt 8 | bit7
 .asc "CONSTAN","T"|bit7
 .word L09b3
CONST
 .word DOCOL
 .word CREATE
 .word SMUDGE
 .word COMMA
 .word PSCODE
DOCONST
 ldy #$02
 lda (w),y
 pha
 iny
 lda (w),y
 jmp PUSH

;~~~
L09e5 .byt 8 | bit7
 .asc "VARIABL","E"|bit7
 .word L09c5
VARIABLE
 .word DOCOL
 .word CONST
 .word PSCODE
DOVAR
 CLC
 LDA w
 ADC #$02
 PHA
 TYA
 ADC w+1
 JMP PUSH

;~~~
L0a02 .byt 4 | bit7
 .asc "USE","R"|bit7
 .word L09e5
USER
 .word DOCOL
 .word CONST
 .word PSCODE
DOUSER
 ldy #$02
 clc
 lda (w),y
 adc $8a
 pha
 lda #$00
 adc $8b
 jmp PUSH

;~~~
L0a1e .byt 1 | bit7
 .asc "0"|bit7
 .word L0a02
ZERO
 .word DOCONST
 .word 0

;~~~
L0a26 .byt 1 | bit7
 .asc "1"|bit7
 .word L0a1e
ONE
 .word DOCONST
 .word 1

;~~~
L0a2e .byt 1 | bit7
 .asc "2"|bit7
 .word L0a26
TWO
 .word DOCONST
 .word 2

;~~~
L0a36 .byt 1 | bit7
 .asc "3"|bit7
 .word L0a2e
THREE
 .word DOCONST
 .word 3

;~~~
L0a3e .byt 2 | bit7
 .asc "B","L"|bit7
 .word L0a36
BL
 .word DOCONST
 .word $20

;~~~
L0a47 .byt 3 | bit7
 .asc "C/","L"|bit7
 .word L0a3e
CL
 .word DOCONST
 .word 64

;~~~
L0a51 .byt 5 | bit7
 .asc "FIRS","T"|bit7
 .word L0a47
FIRST ; address of lowest block buffer
 .word DOCONST
 .word $7b70

;~~~
L0a5d .byt 5 | bit7
 .asc "LIMI","T"|bit7
 .word L0a51
LIMIT ; top of disk buffers
 .word DOCONST
 .word $7f80

;~~~
L0a69 .byt 5 | bit7
 .asc "B/BU","F"|bit7
 .word L0a5d
BBUF
 .word DOCONST
 .word $100

;~~~
L0a75 .byt 5 | bit7
 .asc "B/SC","R"|bit7
 .word L0a69
BSCR
 .word DOCONST
 .word 4

;~~~
L0a81 .byt 7 | bit7
 .asc "+ORIGI","N"|bit7
 .word L0a75
ORIGIN
 .word DOCOL
 .word LIT
 .word 1028
 .word PLUS
 .word SEMIS

;~~~
L0a95 .byt 3 | bit7
 .asc "TI","B"|bit7
 .word L0a81
TIB
 .word DOUSER
 .byt 10

;~~~
L0a9e .byt 5 | bit7
 .asc "WIDT","H"|bit7
 .word L0a95
WIDTH
 .word DOUSER
 .byt 12

;~~~
L0aa9 .byt 7 | bit7
 .asc "WARNIN","G"|bit7
 .word L0a9e
WARNING
 .word DOUSER
 .byt 14

;~~~
L0ab6 .byt 5 | bit7
 .asc "FENC","E"|bit7
 .word L0aa9
FENCE
 .word DOUSER
 .byt 16

;~~~
L0ac1 .byt 2 | bit7
 .asc "D","P"|bit7
 .word L0ab6
DP
 .word DOUSER
 .byt 18

;~~~
L0ac9 .byt 8 | bit7
 .asc "VOC-LIN","K"|bit7
 .word L0ac1
VOCLINK
 .word DOUSER
 .byt 20

;~~~
L0ad7 .byt 3 | bit7
 .asc "BL","K"|bit7
 .word L0ac9
BLK
 .word DOUSER
 .byt 22

;~~~
L0ae0 .byt 2 | bit7
 .asc "I","N"|bit7
 .word L0ad7
IN
 .word DOUSER
 .byt 24

;~~~
L0ae8 .byt 3 | bit7
 .asc "OU","T"|bit7
 .word L0ae0
OUT
 .word DOUSER
 .byt 26

;~~~
L0af1 .byt 3 | bit7
 .asc "SC","R"|bit7
 .word L0ae8
SCR
 .word DOUSER
 .byt 28

;~~~
L0afa .byt 6 | bit7
 .asc "OFFSE","T"|bit7
 .word L0af1
OFFSET
 .word DOUSER
 .byt 30

;~~~
L0b06 .byt 7 | bit7
 .asc "CONTEX","T"|bit7
 .word L0afa
CONTEXT
 .word DOUSER
 .byt 32

;~~~
L0b13 .byt 7 | bit7
 .asc "CURREN","T"|bit7
 .word L0b06
CURRENT
 .word DOUSER
 .byt 34

;~~~
L0b20 .byt 5 | bit7
 .asc "STAT","E"|bit7
 .word L0b13
STATE
 .word DOUSER
 .byt 36

;~~~
L0b2b .byt 4 | bit7
 .asc "BAS","E"|bit7
 .word L0b20
BASE
 .word DOUSER
 .byt 38

;~~~
L0b35 .byt 3 | bit7
 .asc "DP","L"|bit7
 .word L0b2b
DPL
 .word DOUSER
 .byt 40

;~~~
L0b3e .byt 3 | bit7
 .asc "FL","D"|bit7
 .word L0b35
FLD
 .word DOUSER
 .byt 42

;~~~
L0b47 .byt 3 | bit7
 .asc "CS","P"|bit7
 .word L0b3e
CSP
 .word DOUSER
 .byt 44

;~~~
L0b50 .byt 2 | bit7
 .asc "R","#"|bit7
 .word L0b47
RSHARP
 .word DOUSER
 .byt 46

;~~~
L0b58 .byt 3 | bit7
 .asc "HL","D"|bit7
 .word L0b50
HLD
 .word DOUSER
 .byt 48

;~~~
L0b61 .byt 2 | bit7
 .asc "1","+"|bit7
 .word L0b58
ONEP
 .word DOCOL
 .word ONE
 .word PLUS
 .word SEMIS

;~~~
L0b6e .byt 2 | bit7
 .asc "2","+"|bit7
 .word L0b61
TWOP
 .word DOCOL
 .word TWO
 .word PLUS
 .word SEMIS

;~~~
L0b7b .byt 4 | bit7
 .asc "HER","E"|bit7
 .word L0b6e
HERE
 .word DOCOL
 .word DP
 .word FETCH
 .word SEMIS

;~~~
L0b8a .byt 5 | bit7
 .asc "ALLO","T"|bit7
 .word L0b7b
ALLOT
 .word DOCOL
 .word DP
 .word PSTORE
 .word SEMIS

;~~~
L0b9a .byt 1 | bit7
 .asc ","|bit7
 .word L0b8a
COMMA
 .word DOCOL
 .word HERE
 .word STORE
 .word TWO
 .word ALLOT
 .word SEMIS

;~~~
L0baa .byt 2 | bit7
 .asc "C",","|bit7
 .word L0b9a
CCOMMA
 .word DOCOL
 .word HERE
 .word CSTORE
 .word ONE
 .word ALLOT
 .word SEMIS

;~~~
L0bbb .byt 1 | bit7
 .asc "-"|bit7
 .word L0baa
NEGATE
 .word DOCOL
 .word MINUS
 .word PLUS
 .word SEMIS

;~~~
L0bc7 .byt 1 | bit7
 .asc "="|bit7
 .word L0bbb
EQUAL
 .word DOCOL
 .word NEGATE
 .word ZEQ
 .word SEMIS

;~~~
L0bd3 .byt 2 | bit7
 .asc "U","<"|bit7
 .word L0bc7
ULT
 .word DOCOL
 .word NEGATE
 .word ZLT
 .word SEMIS

L0be0 .byt 1 | bit7
 .byt "<"|bit7
 .word L0bd3
LT
 .word *+2
 sec
 lda $02,x
 sbc $00,x
 lda $03,x
 sbc $01,x
 sty $03,x
 bvc $0bf5
 eor #$80
 bpl $0bf8
 iny
 sty $02,x
 jmp POP

;~~~
L0bfd .byt 1 | bit7
 .asc ">"|bit7
 .word L0be0
GT
 .word DOCOL
 .word SWAP
 .word LT
 .word SEMIS

;~~~
L0c09 .byt 3 | bit7
 .asc "RO","T"|bit7
 .word L0bfd
ROT
 .word DOCOL
 .word TOR
 .word SWAP
 .word RFROM
 .word SWAP
 .word SEMIS

;~~~
L0c1b .byt 5 | bit7
 .asc "SPAC","E"|bit7
 .word L0c09
SPACE
 .word DOCOL
 .word BL
 .word EMIT
 .word SEMIS

;~~~
L0c2b .byt 4 | bit7
 .asc "-DU","P"|bit7
 .word L0c1b
DASHDUP
 .word DOCOL
 .word DUP
 .word ZBRAN
 .word P0c3c-*
 .word DUP
P0c3c
 .word SEMIS

;~~~
L0c3e .byt 8 | bit7
 .asc "TRAVERS","E"|bit7
 .word L0c2b
TRAVERSE
 .word DOCOL
 .word SWAP
P0c4d
 .word OVER
 .word PLUS
 .word CLIT
 .byt 127
 .word OVER
 .word CFETCH
 .word LT
 .word ZBRAN
 .word P0c4d-*
 .word SWAP
 .word DROP
 .word SEMIS

;~~~
L0c64 .byt 6 | bit7
 .asc "LATES","T"|bit7
 .word L0c3e
LATEST
 .word DOCOL
 .word CURRENT
 .word FETCH
 .word FETCH
 .word SEMIS

;~~~
L0c77 .byt 3 | bit7
 .asc "LF","A"|bit7
 .word L0c64
LFA
 .word DOCOL
 .word CLIT
 .byt 4
 .word NEGATE
 .word SEMIS

;~~~
L0c86 .byt 3 | bit7
 .asc "CF","A"|bit7
 .word L0c77
CFA
 .word DOCOL
 .word TWO
 .word NEGATE
 .word SEMIS

;~~~
L0c94 .byt 3 | bit7
 .asc "NF","A"|bit7
 .word L0c86
NFA
 .word DOCOL
 .word CLIT
 .byt 5
 .word NEGATE
 .word LIT
 .word -1
 .word TRAVERSE
 .word SEMIS

;~~~
L0ca9 .byt 3 | bit7
 .asc "PF","A"|bit7
 .word L0c94
PFA
 .word DOCOL
 .word ONE
 .word TRAVERSE
 .word CLIT
 .byt 5
 .word PLUS
 .word SEMIS

;~~~
L0cbc .byt 4 | bit7
 .asc "!CS","P"|bit7
 .word L0ca9
STORECSP
 .word DOCOL
 .word SPFETCH
 .word CSP
 .word STORE
 .word SEMIS

;~~~
L0ccd .byt 6 | bit7
 .asc "?ERRO","R"|bit7
 .word L0cbc
QERROR ; ( flag message# -- ) print an error message and abort if flag is true
 .word DOCOL
 .word SWAP
 .word ZBRAN
 .word 8
 .word ERROR
 .word BRANCH
 .word 4
 .word DROP
 .word SEMIS

;~~~
L0ce8 .byt 5 | bit7
 .asc "?COM","P"|bit7
 .word L0ccd
QCOMP
 .word DOCOL
 .word STATE
 .word FETCH
 .word ZEQ
 .word CLIT
 .byt 17
 .word QERROR
 .word SEMIS

;~~~
L0cff .byt 5 | bit7
 .asc "?EXE","C"|bit7
 .word L0ce8
QEXEC
 .word DOCOL
 .word STATE
 .word FETCH
 .word CLIT
 .byt 18
 .word QERROR
 .word SEMIS

;~~~
L0d14 .byt 6 | bit7
 .asc "?PAIR","S"|bit7
 .word L0cff
QPAIRS
 .word DOCOL
 .word NEGATE
 .word CLIT
 .byt 19
 .word QERROR
 .word SEMIS

;~~~
L0d28 .byt 4 | bit7
 .asc "?CS","P"|bit7
 .word L0d14
QCSP
 .word DOCOL
 .word SPFETCH
 .word CSP
 .word FETCH
 .word NEGATE
 .word CLIT
 .byt 20
 .word QERROR
 .word SEMIS

L0d40 .byt 8 | bit7
 .asc "?LOADIN","G"|bit7
 .word L0d28
QLOADING
 .word DOCOL
 .word BLK
 .word FETCH
 .word ZEQ
 .word CLIT
 .byt 22
 .word QERROR
 .word SEMIS

;~~~
L0d5a .byt 7 | bit7
 .asc "COMPIL","E"|bit7
 .word L0d40
COMPILE
 .word DOCOL
 .word QCOMP
 .word RFROM
 .word DUP
 .word TWOP
 .word TOR
 .word FETCH
 .word COMMA
 .word SEMIS

;~~~
L0d76 .byt 1 | bit7 | bit6
 .asc "["|bit7
 .word L0d5a
LBRACK
 .word DOCOL
 .word ZERO
 .word STATE
 .word STORE
 .word SEMIS

;~~~
L0d84 .byt 1 | bit7
 .asc "]"|bit7
 .word L0d76
RBRACK
 .word DOCOL
 .word CLIT
 .byt bit7 | bit6
 .word STATE
 .word STORE
 .word SEMIS

;~~~
L0d93 .byt 6 | bit7
 .asc "SMUDG","E"|bit7
 .word L0d84
SMUDGE
 .word DOCOL
 .word LATEST
 .word CLIT
 .byt 32
 .word TOGGLE
 .word SEMIS

;~~~
L0da7 .byt 3 | bit7
 .asc "HE","X"|bit7
 .word L0d93
HEX
 .word DOCOL
 .word CLIT
 .byt 16
 .word BASE
 .word STORE
 .word SEMIS

;~~~
L0db8 .byt 7 | bit7
 .asc "DECIMA","L"|bit7
 .word L0da7
DECIMAL
 .word DOCOL
 .word CLIT
 .byt 10
 .word BASE
 .word STORE
 .word SEMIS

;~~~
L0dcd .byt 7 | bit7
 .asc "(;CODE",")"|bit7
 .word L0db8
PSCODE
 .word DOCOL
 .word RFROM
 .word LATEST
 .word PFA
 .word CFA
 .word STORE
 .word SEMIS

;~~~
L0de5 .byt 5 | bit7 | bit6
 .byt ";COD","E"|bit7
 .word L0dcd
SCODE
 .word DOCOL
 .word QCSP
 .word COMPILE
 .word PSCODE
 .word LBRACK
 .word SMUDGE
 .word SEMIS
 .word SEMIS

;~~~
L0dfd .byt 7 | bit7
 .asc "<BUILD","S"|bit7
 .word L0de5
BUILDS
 .word DOCOL
 .word ZERO
 .word CONST
 .word SEMIS

;~~~
L0e0f .byt 5 | bit7
 .asc "DOES",">"|bit7
 .word L0dfd
DOES
 .word DOCOL
 .word RFROM
 .word LATEST
 .word PFA
 .word STORE
 .word PSCODE
DODOES
 lda ip+1
 pha
 lda ip
 pha
 ldy #$02
 lda (w),y
 sta ip
 iny
 lda (w),y
 sta ip+1
 clc
 lda w
 adc #$04
 pha
 lda w+1
 adc #$00
 jmp PUSH

;~~~
L0e41 .byt 5 | bit7
 .asc "COUN","T"|bit7
 .word L0e0f
COUNT
 .word DOCOL
 .word DUP
 .word ONEP
 .word SWAP
 .word CFETCH
 .word SEMIS

;~~~
L0e55 .byt 4 | bit7
 .asc "TYP","E"|bit7
 .word L0e41
TYPE
 .word DOCOL
 .word DASHDUP
 .word ZBRAN
 .word 24
 .word OVER
 .word PLUS
 .word SWAP
 .word PDO
 .word I
 .word CFETCH
 .word EMIT
 .word PLOOP
 .word -8
 .word BRANCH
 .word 4
 .word DROP
 .word SEMIS

;~~~
L0e7e .byt 9 | bit7
 .asc "-TRAILIN","G"|bit7
 .word L0e55
DTRAIL
 .word DOCOL
 .word DUP
 .word ZERO
 .word PDO
 .word OVER
 .word OVER
 .word PLUS
 .word ONE
 .word NEGATE
 .word CFETCH
 .word BL
 .word NEGATE
 .word ZBRAN
 .word 8
 .word LEAVE
 .word BRANCH
 .word 6
 .word ONE
 .word NEGATE
 .word PLOOP
 .word -32
 .word SEMIS

;~~~
L0eb6 .byt 4 | bit7
 .asc "(.",'"',")"|bit7
 .word L0e7e
PDOTQ
 .word DOCOL
 .word RFETCH
 .word COUNT
 .word DUP
 .word ONEP
 .word RFROM
 .word PLUS
 .word TOR
 .word TYPE
 .word SEMIS

;~~~
L0ed1 .byt 2 | bit7 | bit6
 .asc ".",'"'|bit7
 .word L0eb6
DOTQ
 .word DOCOL
 .word CLIT
 .byt 34
 .word STATE
 .word FETCH
 .word ZBRAN
 .word 20
 .word COMPILE
 .word PDOTQ
 .word WORD
 .word HERE
 .word CFETCH
 .word ONEP
 .word ALLOT
 .word BRANCH
 .word 10
 .word WORD
 .word HERE
 .word COUNT
 .word TYPE
 .word SEMIS

;~~~
L0eff .byt 6 | bit7
 .asc "EXPEC","T"|bit7
 .word L0ed1
EXPECT
 .word DOCOL
 .word OVER
 .word PLUS
 .word OVER
 .word PDO
 .word KEY
 .word DUP
 .word CLIT
 .byt 14
 .word ORIGIN
 .word FETCH
 .word EQUAL
 .word ZBRAN
 .word 31
 .word DROP
 .word CLIT
 .byt 8
 .word OVER
 .word I
 .word EQUAL
 .word DUP
 .word RFROM
 .word TWO
 .word NEGATE
 .word PLUS
 .word TOR
 .word NEGATE
 .word BRANCH
 .word 39
 .word DUP
 .word CLIT
 .byt 13
 .word EQUAL
 .word ZBRAN
 .word 14
 .word LEAVE
 .word DROP
 .word BL
 .word ZERO
 .word BRANCH
 .word 4
 .word DUP
 .word I
 .word CSTORE
 .word ZERO
 .word I
 .word ONEP
 .word STORE
 .word DROP
 .word PLOOP
 .word -87
 .word DROP
 .word CR
 .word SEMIS

;~~~
L0f71 .byt 5 | bit7
 .asc "QUER","Y"|bit7
 .word L0eff
QUERY
 .word DOCOL
 .word TIB
 .word FETCH
 .word CLIT
 .byt 80
 .word EXPECT
 .word ZERO
 .word IN
 .word STORE
 .word SEMIS

;~~~
L0f8c .byt 1 | bit7 | bit6
 .byt 0|bit7
 .word L0f71
NULLWORD ; what is this?
 .word DOCOL
 .word BLK
 .word FETCH
 .word ZBRAN
 .word 42
 .word ONE
 .word BLK
 .word PSTORE
 .word ZERO
 .word IN
 .word STORE
 .word BLK
 .word FETCH
 .word ZERO
 .word BSCR
 .word USLASH
 .word DROP
 .word ZEQ
 .word ZBRAN
 .word 8
 .word QEXEC
 .word RFROM
 .word DROP
 .word BRANCH
 .word 6
 .word RFROM
 .word DROP
 .word SEMIS

;~~~
L0fc8 .byt 4 | bit7
 .asc "FIL","L"|bit7
 .word L0f8c
FILL
 .word DOCOL
 .word SWAP
 .word TOR
 .word OVER
 .word CSTORE
 .word DUP
 .word ONEP
 .word RFROM
 .word ONE
 .word NEGATE
 .word CMOVE
 .word SEMIS

;~~~
L0fe7 .byt 5 | bit7
 .asc "ERAS","E"|bit7
 .word L0fc8
ERASE
 .word DOCOL
 .word ZERO
 .word FILL
 .word SEMIS

;~~~
L0ff7 .byt 6 | bit7
 .asc "BLANK","S"|bit7
 .word L0fe7
BLANKS
 .word DOCOL
 .word BL
 .word FILL
 .word SEMIS

;~~~
L1008 .byt 4 | bit7
 .asc "HOL","D"|bit7
 .word L0ff7
HOLD
 .word DOCOL
 .word LIT
 .word -1
 .word HLD
 .word PSTORE
 .word HLD
 .word FETCH
 .word CSTORE
 .word SEMIS

;~~~
L1021 .byt 3 | bit7
 .asc "PA","D"|bit7
 .word L1008
PAD
 .word DOCOL
 .word HERE
 .word CLIT
 .byt 68 ; should change this to 84
 .word PLUS
 .word SEMIS

;~~~
L1032 .byt 4 | bit7
 .asc "WOR","D"|bit7
 .word L1021
WORD
 .word DOCOL
 .word BLK
 .word FETCH
 .word ZBRAN
 .word 12
 .word BLK
 .word FETCH
 .word BLOCK
 .word BRANCH
 .word 6
 .word TIB
 .word FETCH
 .word IN
 .word FETCH
 .word PLUS
 .word SWAP
 .word ENCLOSE
 .word HERE
 .word CLIT
 .byt 34
 .word $1000
 .word IN
 .word PSTORE
 .word OVER
 .word NEGATE
 .word TOR
 .word RFETCH
 .word HERE
 .word CSTORE
 .word PLUS
 .word HERE
 .word ONEP
 .word RFROM
 .word CMOVE
 .word SEMIS

;~~~
L107e .byt 5 | bit7
 .asc "UPPE","R"|bit7
 .word L1032
UPPER
 .word DOCOL
 .word OVER
 .word PLUS
 .word SWAP
 .word PDO
 .word I
 .word CFETCH
 .word CLIT
 .byt 127
 .word GT
 .word ZBRAN
 .word 9
 .word I
 .word CLIT
 .byt 128
 .word TOGGLE
 .word PLOOP
 .word -22
 .word SEMIS

;~~~
L10aa .byt 8 | bit7
 .asc "(NUMBER",")"|bit7
 .word L107e
PNUMBER
 .word DOCOL
 .word ONEP
 .word DUP
 .word TOR
 .word CFETCH
 .word BASE
 .word FETCH
 .word DIGIT
 .word ZBRAN
 .word 44
 .word SWAP
 .word BASE
 .word FETCH
 .word USTAR
 .word DROP
 .word ROT
 .word BASE
 .word FETCH
 .word USTAR
 .word DPLUS
 .word DPL
 .word FETCH
 .word ONEP
 .word ZBRAN
 .word 8
 .word ONE
 .word DPL
 .word PSTORE
 .word RFROM
 .word BRANCH
 .word -58
 .word RFROM
 .word SEMIS

;~~~
L10f7 .byt 6 | bit7
 .asc "NUMBE","R"|bit7
 .word L10aa
NUMBER
 .word DOCOL
 .word ZERO
 .word ZERO
 .word ROT
 .word DUP
 .word ONEP
 .word CFETCH
 .word CLIT
 .asc "-"
 .word EQUAL
 .word DUP
 .word TOR
 .word PLUS
 .word LIT
 .word -1
 .word DPL
 .word STORE
 .word PNUMBER
 .word DUP
 .word CFETCH
 .word BL
 .word NEGATE
 .word ZBRAN
 .word 21
 .word DUP
 .word CFETCH
 .word CLIT
 .asc "."
 .word NEGATE
 .word ZERO
 .word QERROR
 .word ZERO
 .word BRANCH
 .word -35
 .word DROP
 .word RFROM
 .word ZBRAN
 .word 4
 .word DMINUS
 .word SEMIS

;~~~
L114e .byt 5 | bit7
 .asc "-FIN","D"|bit7
 .word L10f7
DASHFIND
 .word DOCOL
 .word BL
 .word WORD
 .word HERE
 .word COUNT
 .word UPPER
 .word HERE
 .word CONTEXT
 .word FETCH
 .word FETCH
 .word PFIND
 .word DUP
 .word ZEQ
 .word ZBRAN
 .word 10
 .word DROP
 .word HERE
 .word LATEST
 .word PFIND
 .word SEMIS

;~~~
L117e .byt 7 | bit7
 .asc "(ABORT",")"|bit7
 .word L114e
PABORTQ
 .word DOCOL
 .word ABORT
 .word SEMIS

;~~~
L118e .byt 5 | bit7
 .asc "ERRO","R"|bit7
 .word L117e
ERROR
 .word DOCOL
 .word WARNING
 .word FETCH
 .word ZLT
 .word ZBRAN
 .word 4
 .word PABORTQ
ERRENTRY
 .word HERE
 .word COUNT
 .word TYPE
 .word PDOTQ
 .byt 4
 .byt " "," ? "
 .word MESSAGE
 .word SPSTORE
 .word BRANCH
 .word 10
 .word IN
 .word FETCH
 .word BLK
 .word FETCH
 .word QUIT
 .word SEMIS

;~~~
L11c5 .byt 3 | bit7
 .asc "ID","."|bit7
 .word L118e
IDDOT
 .word DOCOL
 .word PAD
 .word CLIT
 .asc " "
 .word CLIT
 .byt 95
 .word FILL
 .word DUP
 .word PFA
 .word LFA
 .word OVER
 .word NEGATE
 .word PAD
 .word SWAP
 .word CMOVE
 .word PAD
 .word COUNT
 .word CLIT
 .byt $1f
 .word ANDD
 .word MTYPE
 .word SPACE
 .word SEMIS

;~~~
L11f6 .byt 6 | bit7
 .asc "CREAT","E"|bit7
 .word L11c5
CREATE
 .word DOCOL
 .word TIB
 .word HERE
 .word CLIT
 .byt 160
 .word PLUS
 .word ULT
 .word TWO
 .word QERROR
 .word DASHFIND
 .word ZBRAN
 .word 15
 .word DROP
 .word NFA
 .word IDDOT
 .word CLIT
 .byt 4
 .word MESSAGE
 .word SPACE
 .word HERE
 .word DUP
 .word CFETCH
 .word WIDTH
 .word FETCH
 .word MIN
 .word ONEP
 .word ALLOT
 .word DUP
 .word CLIT
 .byt bit7 | bit5
 .word TOGGLE
 .word HERE
 .word ONE
 .word NEGATE
 .word CLIT
 .byt bit7
 .word TOGGLE
 .word LATEST
 .word COMMA
 .word CURRENT
 .word FETCH
 .word STORE
 .word HERE
 .word TWOP
 .word COMMA
 .word SEMIS

;~~~
L1257 .byt 9 | bit7 | bit6
 .asc "[COMPILE","]"|bit7
 .word L11f6
BRCOMP
 .word DOCOL
 .word DASHFIND
 .word ZEQ
 .word ZERO
 .word QERROR
 .word DROP
 .word CFA
 .word COMMA
 .word SEMIS

;~~~
L1275 .byt 7 | bit7 | bit6
 .asc "LITERA","L"|bit7
 .word L1257
LITERAL
 .word DOCOL
 .word STATE
 .word FETCH
 .word ZBRAN
 .word 8
 .word COMPILE
 .word LIT
 .word COMMA
 .word SEMIS

;~~~
L1291 .byt 8 | bit7 | bit6
 .asc "DLITERA","L"|bit7
 .word L1275
DLIT
 .word DOCOL
 .word STATE
 .word FETCH
 .word ZBRAN
 .word 8
 .word SWAP
 .word LITERAL
 .word LITERAL
 .word SEMIS

;~~~
L12ae .byt 6 | bit7
 .asc "?STAC","K"|bit7
 .word L1291
QSTACK
 .word DOCOL
 .word CLIT
 .byt 114
 .word SPFETCH
 .word ULT
 .word ONE
 .word QERROR
 .word SPFETCH
 .word CLIT
 .byt 17
 .word ULT
 .word CLIT
 .byt 7
 .word QERROR
 .word SEMIS

;~~~
L12d2 .byt 9 | bit7
 .asc "INTERPRE","T"|bit7
 .word L12ae
INTERPRET
 .word DOCOL
 .word DASHFIND ;-62
 .word ZBRAN
 .word 30
 .word STATE
 .word FETCH
 .word LT
 .word ZBRAN
 .word 10
 .word CFA
 .word COMMA
 .word BRANCH
 .word 6
 .word CFA ;10
 .word EXECUTE
 .word QSTACK
 .word BRANCH
 .word 28
 .word HERE ;30
 .word NUMBER
 .word DPL
 .word FETCH
 .word ONEP
 .word ZBRAN
 .word 8
 .word DLIT
 .word BRANCH
 .word 6
 .word DROP ;8
 .word LITERAL
 .word QSTACK ;6
 .word BRANCH
 .word -62

;~~~
L1320 .byt 9 | bit7
 .asc "IMMEDIAT","E"|bit7
 .word L12d2
IMMEDIATE
 .word DOCOL
 .word LATEST
 .word CLIT
 .byt bit6
 .word TOGGLE
 .word SEMIS

;~~~
L1337 .byt 10 | bit7
 .asc "VOCABULAR","Y"|bit7
 .word L1320
VOCABULARY
 .word DOCOL
 .word BUILDS
 .word LIT
 .word $a081
 .word COMMA
 .word CURRENT
 .word FETCH
 .word CFA
 .word COMMA
 .word HERE
 .word VOCLINK
 .word FETCH
 .word COMMA
 .word VOCLINK
 .word STORE
 .word DOES
DOVOC
 .word TWOP
 .word CONTEXT
 .word STORE
 .word SEMIS

;~~~
L136c .byt 5 | bit7 | bit6
 .asc "FORT","H"|bit7
 .word L1337
FORTH
 .word DODOES
 .word DOVOC

ROOTVOCAB
 .byt 1 | bit7
 .asc " " | bit7
 .word TOPLINK
V137c
 .word 0

;~~~
L137e .byt 11 | bit7
 .asc "DEFINITION","S"|bit7
 .word L136c
DEFINITIONS
 .word DOCOL
 .word CONTEXT
 .word FETCH
 .word CURRENT
 .word STORE
 .word SEMIS

;~~~
L1398 .byt 1 | bit7 | bit6
 .asc "("|bit7
 .word L137e
PAREN
 .word DOCOL
 .word CLIT
 .byt ")"
 .word WORD
 .word SEMIS

;~~~
L13a5 .byt 4 | bit7
 .asc "QUI","T"|bit7
 .word L1398
QUIT
 .word DOCOL
QUITENTRY
 .word ZERO
 .word BLK
 .word STORE
 .word LBRACK
 .word RPSTORE
 .word CR ; -25
 .word QUERY
 .word INTERPRET
 .word STATE
 .word FETCH
 .word ZEQ
 .word ZBRAN
 .word 7
 .word PDOTQ
 .byt 2
 .byt 0," "
 .word BRANCH
 .word -25
 .word SEMIS ; 7

;~~~
L13d3 .byt 5 | bit7
 .asc "ABOR","T"|bit7
 .word L13a5
ABORT
 .word DOCOL
 .word SPSTORE
 .word DECIMAL
 .word DR0
 .word CR
 .word PDOTQ
 .byt 14
 .asc "FIG-FORTH "
 .asc " 1.0"
 .word FORTH
 .word DEFINITIONS
 .word QUIT

ICE
 ldx #$7d ; stash BASIC?
L13FE
 lda $0f,x
 sta ZPBUF,x
 dex
 bpl L13FE
 bmi DOCOLD

;~~~
L1408 .byt 4 | bit7
 .asc "COL","D"|bit7
 .word L13d3

COLD .word *+2
DOCOLD
 lda UAREA
 sta $137a
 lda UAREA+1
 sta $137b
 ldy #$15
 bne P1423
 ldy #$0f
P1423
 lda UAREA+4
 sta $8a
 lda UAREA+5
 sta $8b
P142d
 lda UAREA,y
 sta ($8a),y
 dey
 bpl P142d
 lda #$13
 sta ip+1
 lda #$dd
 sta ip
 cld
 lda #$6c
 sta $87
 lda #$4c
 sta $84
 jmp $07c2

;~~~
L1449 .byt 4 | bit7
 .asc "S->","D"|bit7
 .word L1408
S2D
 .word DOCOL
 .word DUP
 .word ZLT
 .word MINUS
 .word SEMIS

;~~~
L145a .byt 2 | bit7
 .asc "+","-"|bit7
 .word L1449
PLUSMINUS
 .word DOCOL
 .word ZLT
 .word ZBRAN
 .word 4
 .word MINUS
 .word SEMIS

;~~~
L146b .byt 3 | bit7
 .asc "D+","-"|bit7
 .word L145a
DPLUSMINUS
 .word DOCOL
 .word ZLT
 .word ZBRAN
 .word 4
 .word DMINUS
 .word SEMIS

;~~~
L147d .byt 3 | bit7
 .asc "AB","S"|bit7
 .word L146b
ABS
 .word DOCOL
 .word DUP
 .word PLUSMINUS
 .word SEMIS

;~~~
L148b .byt 4 | bit7
 .asc "DAB","S"|bit7
 .word L147d
DABS
 .word DOCOL
 .word DUP
 .word DPLUSMINUS
 .word SEMIS

;~~~
L149a .byt 3 | bit7
 .asc "MI","N"|bit7
 .word L148b
MIN
 .word DOCOL
 .word OVER
 .word OVER
 .word GT
 .word ZBRAN
 .word 4
 .word SWAP
 .word DROP
 .word SEMIS

;~~~
L14b2 .byt 3 | bit7
 .asc "MA","X"|bit7
 .word L149a
MAX
 .word DOCOL
 .word OVER
 .word OVER
 .word LT
 .word ZBRAN
 .word 4
 .word SWAP
 .word DROP
 .word SEMIS

;~~~
L14ca .byt 2 | bit7
 .asc "M","*"|bit7
 .word L14b2
MSTAR
 .word DOCOL
 .word OVER
 .word OVER
 .word XOR
 .word TOR
 .word ABS
 .word SWAP
 .word ABS
 .word USTAR
 .word RFROM
 .word DPLUSMINUS
 .word SEMIS

;~~~
L14e7 .byt 2 | bit7
 .asc "M","/"|bit7
 .word L14ca
MSLASH
 .word DOCOL
 .word OVER
 .word TOR
 .word TOR
 .word DABS
 .word RFETCH
 .word ABS
 .word USLASH
 .word RFROM
 .word RFETCH
 .word XOR
 .word PLUSMINUS
 .word SWAP
 .word RFROM
 .word PLUSMINUS
 .word SWAP
 .word SEMIS

;~~~
L150e .byt 1 | bit7
 .asc "*"|bit7
 .word L14e7
STAR
 .word DOCOL
 .word USTAR
 .word DROP
 .word SEMIS

;~~~
L151a .byt 4 | bit7
 .asc "/MO","D"|bit7
 .word L150e
SLMOD
 .word DOCOL
 .word TOR
 .word S2D
 .word RFROM
 .word MSLASH
 .word SEMIS

;~~~
L152d .byt 1 | bit7
 .asc "/"|bit7
 .word L151a
SLASH
 .word DOCOL
 .word SLMOD
 .word SWAP
 .word DROP
 .word SEMIS

;~~~
L153b .byt 3 | bit7
 .asc "MO","D"|bit7
 .word L152d
MOD
 .word DOCOL
 .word SLMOD
 .word DROP
 .word SEMIS

;~~~
L1549 .byt 5 | bit7
 .asc "*/MO","D"|bit7
 .word L153b
STSLMOD
 .word DOCOL
 .word TOR
 .word MSTAR
 .word RFROM
 .word MSLASH
 .word SEMIS

;~~~
L155d .byt 2 | bit7
 .asc "*","/"|bit7
 .word L1549
STSL
 .word DOCOL
 .word STSLMOD
 .word SWAP
 .word DROP
 .word SEMIS

;~~~
L156c .byt 5 | bit7
 .asc "M/MO","D"|bit7
 .word L155d
MSLMOD
 .word DOCOL
 .word TOR
 .word ZERO
 .word RFETCH
 .word USLASH
 .word RFROM
 .word SWAP
 .word TOR
 .word USLASH
 .word RFROM
 .word SEMIS

;~~~
L158a .byt 3 | bit7
 .asc "US","E"|bit7
 .word L156c
USE
 .word DOVAR
 .word $7b70

;~~~
L1594 .byt 4 | bit7
 .asc "PRE","V"|bit7
 .word L158a
PREV
 .word DOVAR
 .word $7b70

;~~~
L159f .byt 4 | bit7
 .asc "+BU","F"|bit7
 .word L1594
PLBUF
 .word DOCOL
 .word LIT
 .word $0104
 .word PLUS
 .word DUP
 .word LIMIT
 .word EQUAL
 .word ZBRAN
 .word 6
 .word DROP
 .word FIRST
 .word DUP
 .word PREV
 .word FETCH
 .word NEGATE
 .word SEMIS

;~~~
L15c6 .byt 6 | bit7
 .asc "UPDAT","E"|bit7
 .word L159f
UPDATE
 .word DOCOL
 .word PREV
 .word FETCH
 .word FETCH
 .word LIT
 .word $8000
 .word OR
 .word PREV
 .word FETCH
 .word STORE
 .word SEMIS

;~~~
L15e5 .byt 13 | bit7
 .asc "EMPTY-BUFFER","S"|bit7
 .word L15c6
EMPBUF
 .word DOCOL
 .word FIRST
 .word LIMIT
 .word OVER
 .word NEGATE
 .word ERASE
 .word SEMIS

;~~~
L1603 .byt 3 | bit7
 .asc "DR","0"|bit7
 .word L15e5
DR0
 .word DOCOL
 .word ZERO
 .word OFFSET
 .word STORE
 .word SEMIS

;~~~
L1613 .byt 3 | bit7
 .asc "DR","1"|bit7
 .word L1603
DR1
 .word DOCOL
 .word LIT
 .word $0400
 .word OFFSET
 .word STORE
 .word SEMIS

;~~~
L1625 .byt 6 | bit7
 .asc "BUFFE","R"|bit7
 .word L1613
BUFFER
 .word DOCOL
 .word USE
 .word FETCH
 .word DUP
 .word TOR
 .word PLBUF
 .word ZBRAN
 .word -4
 .word USE
 .word STORE
 .word RFETCH
 .word FETCH
 .word ZLT
 .word ZBRAN
 .word 20
 .word RFETCH
 .word TWOP
 .word RFETCH
 .word FETCH
 .word LIT
 .word $7fff
 .word ANDD
 .word ZERO
 .word RSLASHW
 .word RFETCH
 .word STORE
 .word RFETCH
 .word PREV
 .word STORE
 .word RFROM
 .word TWOP
 .word SEMIS

;~~~
L166e .byt 5 | bit7
 .asc "BLOC","K"|bit7
 .word L1625
BLOCK
 .word DOCOL
 .word OFFSET
 .word FETCH
 .word PLUS
 .word TOR
 .word PREV
 .word FETCH
 .word DUP
 .word FETCH
 .word RFETCH
 .word NEGATE
 .word DUP
 .word PLUS
 .word ZBRAN
 .word 52
 .word PLBUF
 .word ZEQ
 .word ZBRAN
 .word 20
 .word DROP
 .word RFETCH
 .word BUFFER
 .word DUP
 .word RFETCH
 .word ONE
 .word RSLASHW
 .word TWO
 .word NEGATE
 .word DUP
 .word FETCH
 .word RFETCH
 .word NEGATE
 .word DUP
 .word PLUS
 .word ZEQ
 .word ZBRAN
 .word -42
 .word DUP
 .word PREV
 .word STORE
 .word RFROM
 .word DROP
 .word TWOP
 .word SEMIS

;~~~
L16ce .byt 5 | bit7
 .asc "FLUS","H"|bit7
 .word L166e
FLUSH
 .word DOCOL
 .word LIMIT
 .word FIRST
 .word NEGATE
 .word BBUF
 .word CLIT
 .byt 4
 .word PLUS
 .word SLASH
 .word ONEP
 .word ZERO
 .word PDO
 .word LIT
 .word $7fff
 .word BUFFER
 .word DROP
 .word PLOOP
 .word -10
 .word SEMIS

;~~~
L16fb .byt 6 | bit7
 .asc "(LINE",")"|bit7
 .word L16ce
PLINE
 .word DOCOL
 .word TOR
 .word CL
 .word BBUF
 .word STSLMOD
 .word RFROM
 .word BSCR
 .word STAR
 .word PLUS
 .word BLOCK
 .word PLUS
 .word CL
 .word SEMIS

;~~~
L171e .byt 5 | bit7
 .asc ".LIN","E"|bit7
 .word L16fb
DOTLINE
 .word DOCOL
 .word PLINE
 .word DTRAIL
 .word TYPE
 .word SEMIS

;~~~
L1730 .byt 5 | bit7
 .asc "ARRA","Y"|bit7
 .word L171e
ARRAY
 .word DOCOL
 .word BUILDS
 .word ONEP
 .word ZERO
 .word PDO
 .word ZERO
 .word COMMA
 .word PLOOP
 .word -6
 .word DOES
ARRAYDO
 .word SWAP
 .word TWO
 .word STAR
 .word PLUS
 .word SEMIS

;~~~
L1756 .byt 6 | bit7
 .asc "PERRO","R"|bit7
 .word L1730
PERROR
 .word DODOES
 .word ARRAYDO
 .word MUNDEF
 .word MEMPTY
 .word MDICFUL
 .word 0
 .word MISNTUNIQ
 .word MCASLOAD
 .word 0
 .word MFULLSTACK
 .word 0, 0, 0, 0, 0, 0, 0, 0, 0
 .word MCOMPONLY
 .word MEXECONLY
 .word MCONDUNPAIR
 .word MDEFUNFIN
 .word MPROTWORD
 .word 0
 .word MOFFSCR
 .word MDECLVOC
 .word 0

;~~~
L1797 .byt 5 | bit7
 .asc "MTYP","E"|bit7
 .word L1756
MTYPE
 .word DOCOL
 .word DASHDUP
 .word ZBRAN
 .word 29
 .word OVER
 .word PLUS
 .word SWAP
 .word PDO
 .word I
 .word CFETCH
 .word CLIT
 .byt 127
 .word ANDD
 .word EMIT
 .word PLOOP
 .word -13
 .word BRANCH
 .word 4
 .word DROP
 .word SEMIS

;~~~
L17c6 .byt 3 | bit7
 .asc "BY","E"|bit7
 .word L1797
BYE
 .word *+2
 jsr restorezp
 ldx #$ff
 txs
 jmp $b3ff	; prints [cr]READY.

;~~~tape
L17d7 .byt 5 | bit7
 .asc "CASL","O"|bit7
 .word L17c6
CASLO
 .word *+2
 STX stash
 JSR restorezp
; $F536 Load a BASIC program or other RAM image. This is not the
;BASIC entry point; this routine is called after the parameters
;have been input, and before the pointers are set after the
;load. It handles the process of fetching data into memory.
;(In BASIC 1 it is not fully separate from LOAD, but later
;BASICs have it as a separate subroutine). The device number
;as input with the parameters (e.g. LOAD "HELLO", 2 sets the
;device number parameter to 2, Le. cassette #2) determines
;the course of this routine
 JSR $F356
 LDA $96 ;Status byte ST. from which ST is computed
 AND #$10
 NOP
 PHP
 jsr storezp
 LDX stash
 PLP
 BNE P17FA
 JMP NEXT
P17FA
 LDA #$05 ; "CASLOAD ERROR"
 JMP ABEND
 NOP
 NOP
 NOP

;~~~tape
L1802 .byt 5 | bit7
 .asc "CASS","A"|bit7
 .word L17d7
CASSA
 .word *+2
 STX stash
 JSR restorezp

; $D744 T2T2. Exchange contents of ($FB) with ($FD).
 JSR $D744

;$F6DD  Perform SAVE. $FFDS from CBM's 'kernel' jumps here. This
;routine first inputs the parameters from BASIC by calling
;F433/F43E/F47D. This stores the string and its pointers, the
;device number, and the secondary address. Then BASIC's
;start address and end address pointers are transferred to
;the SAVE start and end pointer addresses. AlI the parameters
;are now set up for SAVEing .
; $F6E0 This is the next entry point, which is used by the monitor
;"and may be part of a user routine: aIl that 's required is
;the parameters for device number, bottom and top address,
;pointer to name, length of name, and secondary address to
;be set, as though the previous two subroutines had been
;called. Note that the topmost address is not saved; with
;BASIC this doesn't matter, but machine-code dumps from RAM
;may very weIl crash if they're truncated by a byte. 
 JSR $F6E3
 JSR storezp
 LDX stash
 JMP NEXT
 NOP
 NOP

;~~~tape
L1821 .byt 5 | bit7
 .asc "CASF","X"|bit7
 .word L1802
CASFX
 .word *+2
 STX stash
;($FB) 251-252 Pointer for MLM, start of tape address with . S
;($FD) 253-254 Pointer for MLM, others
; $D744 T2T2. Exchange contents of ($FB) with ($FD).
 JSR $D744
 LDX stash
 JMP NEXT

;~~~
L1835 .byt 7 | bit7
 .asc "MESSAG","E"|bit7
 .word L1821
MESSAGE
 .word DOCOL
 .word WARNING
 .word FETCH
 .word ZBRAN
 .word 27
 .word DASHDUP
 .word ZBRAN
 .word 17
 .word CLIT
 .byt 4
 .word OFFSET
 .word FETCH
 .word BSCR
 .word SLASH
 .word NEGATE
 .word DOTLINE
 .word BRANCH
 .word 20
 .word DUP
 .word PERROR
 .word FETCH
 .word ZBRAN
 .word 14
 .word PERROR
 .word FETCH
 .word COUNT
 .word TYPE
 .word BRANCH
 .word 13
 .word PDOTQ
 .byt 6
 .asc "MSG # "
 .word DOT
 .word SEMIS

;~~~
L1885 .byt 4 | bit7
 .asc "LOA","D"|bit7
 .word L1835
LOAD
 .word DOCOL
 .word DASHDUP
 .word ZBRAN
 .word 42
 .word BLK
 .word FETCH
 .word TOR
 .word IN
 .word FETCH
 .word TOR
 .word ZERO
 .word IN
 .word STORE
 .word BSCR
 .word STAR
 .word BLK
 .word STORE
 .word INTERPRET
 .word RFROM
 .word IN
 .word STORE
 .word RFROM
 .word BLK
 .word STORE
 .word SEMIS

;~~~disk
L18be .byt 3 | bit7 | bit6
 .byt "--",">"|bit7
 .word L1885
DASHDASHGT
 .word DOCOL
 .word QLOADING
 .word ZERO
 .word IN
 .word STORE
 .word BSCR
 .word BLK
 .word FETCH
 .word OVER
 .word MOD
 .word NEGATE
 .word BLK
 .word PSTORE
 .word SEMIS

DOEMIT
l18e0 tya
 sec
 ldy #$1a
 adc ($8a),y
 sta ($8a),y
 iny
 lda #$00
 adc ($8a),y
 sta ($8a),y
 lda $00,x
; $FFD2 CHROUT
 jsr $ffd2
 jmp POP

DOKEY
 stx stash
; $FFCF CHRIN
 jsr $ffcf
 ldx stash
 jmp PUSHOA

DOQTERM
 lda $e812
 cmp #$ef
 bne $190c
 lda #$01
 bne $190e
 lda #$00
 jmp PUSHOA

DOCR
 lda #$0d
 dex
 dex
 sta $00,x
 lda #$00
 sta $01,x
 lda #$9f
 dex
 dex
 sta $00,x
 lda #$06
 sta $01,x
 jmp $04a7

;~~~
; what is this?
 .byt 2 | bit7
 .asc "L","L"|bit7
 .word L366f ; not where a link should go
LL
 .word DOCOL
 .word LIT
 .byt 33 ; should be a two-byte literal

;~~~
L1932 .byt 3 | bit7
 .asc "R/","W"|bit7
 .word L18be
RSLASHW
 .word DOCOL
 .word DRSLASHW
 .word SEMIS
 .byt 5 ; wut?

;~~~
L193f .byt 1 | bit7 | bit6
 .byt "'"|bit7
 .word L1932
TICK
 .word DOCOL
 .word DASHFIND
 .word ZEQ
 .word ZERO
 .word QERROR
 .word DROP
 .word LITERAL
 .word SEMIS

;~~~
L1953 .byt 6 | bit7
 .asc "FORGE","T"|bit7
 .word L193f
FORGET
 .word DOCOL
 .word TICK
 .word NFA
 .word DUP
 .word FENCE
 .word FETCH
 .word ULT
 .word CLIT
 .byt 21
 .word QERROR
 .word TOR
 .word VOCLINK
 .word FETCH
 .word RFETCH
 .word OVER
 .word ULT
 .word ZBRAN
 .word 18
 .word FORTH
 .word DEFINITIONS
 .word FETCH
 .word DUP
 .word VOCLINK
 .word STORE
 .word BRANCH
 .word -24
 .word DUP
 .word CLIT
 .byt 4
 .word NEGATE
 .word PFA
 .word LFA
 .word FETCH
 .word DUP
 .word RFETCH
 .word ULT
 .word ZBRAN
 .word -14
 .word OVER
 .word TWO
 .word NEGATE
 .word STORE
 .word FETCH
 .word DASHDUP
 .word ZEQ
 .word ZBRAN
 .word -39
 .word RFROM
 .word DP
 .word STORE
 .word SEMIS

;~~~
L19c0 .byt 4 | bit7
 .byt "BAC","K"|bit7
 .word L1953
BACK
 .word DOCOL
 .word HERE
 .word NEGATE
 .word COMMA
 .word SEMIS

;~~~
L19d1 .byt 5 | bit7 | bit6
 .asc "BEGI","N"|bit7
 .word L19c0
BEGIN
 .word DOCOL
 .word QCOMP
 .word HERE
 .word ONE
 .word SEMIS

;~~~
L19e3 .byt 5 | bit7 | bit6
 .asc "ENDI","F"|bit7
 .word L19d1
ENDIF
 .word DOCOL
 .word QCOMP
 .word TWO
 .word QPAIRS
 .word HERE
 .word OVER
 .word NEGATE
 .word SWAP
 .word STORE
 .word SEMIS

;~~~
L19ff .byt 4 | bit7 | bit6
 .asc "THE","N"|bit7
 .word L19e3
THEN
 .word DOCOL
 .word ENDIF
 .word SEMIS

;~~~
L1a0c .byt 2 | bit7 | bit6
 .asc "D","O"|bit7
 .word L19ff
DO
 .word DOCOL
 .word COMPILE
 .word PDO
 .word HERE
 .word THREE
 .word SEMIS

;~~~
L1a1d .byt 4 | bit7 | bit6
 .asc "LOO","P"|bit7
 .word L1a0c
LOOP
 .word DOCOL
 .word THREE
 .word QPAIRS
 .word COMPILE
 .word PLOOP
 .word BACK
 .word SEMIS

;~~~
L1a32 .byt 5 | bit7 | bit6
 .asc "+LOO","P"|bit7
 .word L1a1d
PLUSLOOP
 .word DOCOL
 .word THREE
 .word QPAIRS
 .word COMPILE
 .word PPLOOP
 .word BACK
 .word SEMIS

;~~~
L1a48 .byt 5 | bit7 | bit6
 .asc "UNTI","L"|bit7
 .word L1a32
UNTIL
 .word DOCOL
 .word ONE
 .word QPAIRS
 .word COMPILE
 .word ZBRAN
 .word BACK
 .word SEMIS

;~~~
L1a5e .byt 3 | bit7 | bit6
 .asc "EN","D"|bit7
 .word L1a48
END
 .word DOCOL
 .word UNTIL
 .word SEMIS

;~~~
L1a6a .byt 5 | bit7 | bit6
 .byt "AGAI","N"|bit7
 .word L1a5e
AGAIN
 .word DOCOL
 .word ONE
 .word QPAIRS
 .word COMPILE
 .word BRANCH
 .word BACK
 .word SEMIS

;~~~
L1a80 .byt 6 | bit7 | bit6
 .byt "REPEA","T"|bit7
 .word L1a6a
REPEAT
 .word DOCOL
 .word TOR
 .word TOR
 .word AGAIN
 .word RFROM
 .word RFROM
 .word TWO
 .word NEGATE
 .word ENDIF
 .word SEMIS

;~~~
L1a9d .byt 2 | bit7 | bit6
 .byt "I","F"|bit7
 .word L1a80
IF
 .word DOCOL
 .word COMPILE
 .word ZBRAN
 .word HERE
 .word ZERO
 .word COMMA
 .word TWO
 .word SEMIS

;~~~
L1ab2 .byt 4 | bit7 | bit6
 .asc "ELS","E"|bit7
 .word L1a9d
ELSE
 .word DOCOL
 .word TWO
 .word QPAIRS
 .word COMPILE
 .word BRANCH
 .word HERE
 .word ZERO
 .word COMMA
 .word SWAP
 .word TWO
 .word ENDIF
 .word TWO
 .word SEMIS

;~~~
L1ad3 .byt 5 | bit7 | bit6
 .asc "WHIL","E"|bit7
 .word L1ab2
WHILE
 .word DOCOL
 .word IF
 .word TWOP
 .word SEMIS

;~~~
L1ae3 .byt 6 | bit7
 .asc "SPACE","S"|bit7
 .word L1ad3
SPACES
 .word DOCOL
 .word ZERO
 .word MAX
 .word DASHDUP
 .word ZBRAN
 .word 12
 .word ZERO
 .word PDO
 .word SPACE
 .word PLOOP
 .word -4
 .word SEMIS

;~~~
L1b04 .byt 2 | bit7
 .asc "<","#"|bit7
 .word L1ae3
LTSHARP
 .word DOCOL
 .word PAD
 .word HLD
 .word STORE
 .word SEMIS

;~~~
L1b13 .byt 2 | bit7
 .asc "#",">"|bit7
 .word L1b04
SHARPGT
 .word DOCOL
 .word DROP
 .word DROP
 .word HLD
 .word FETCH
 .word PAD
 .word OVER
 .word NEGATE
 .word SEMIS

;~~~
L1b2a .byt 4 | bit7
 .asc "SIG","N"|bit7
 .word L1b13
SIGN
 .word DOCOL
 .word ROT
 .word ZLT
 .word ZBRAN
 .word 7
 .word CLIT
 .byt 45
 .word HOLD
 .word SEMIS

;~~~
L1b42 .byt 1 | bit7
 .asc "#"|bit7
 .word L1b2a
SHARP
 .word DOCOL
 .word BASE
 .word FETCH
 .word MSLMOD
 .word ROT
 .word CLIT
 .byt 9
 .word OVER
 .word LT
 .word ZBRAN
 .word 7
 .word CLIT
 .byt 7
 .word PLUS
 .word CLIT
 .byt "0"
 .word PLUS
 .word HOLD
 .word SEMIS

;~~~
L1b69 .byt 2 | bit7
 .asc "#","S"|bit7
 .word L1b42
SHARPS
 .word DOCOL
 .word SHARP
 .word OVER
 .word OVER
 .word OR
 .word ZEQ
 .word ZBRAN
 .word -12
 .word SEMIS

;~~~
L1b80 .byt 3 | bit7
 .byt "D.","R"|bit7
 .word L1b69
DDOTR
 .word DOCOL
 .word TOR
 .word SWAP
 .word OVER
 .word DABS
 .word LTSHARP
 .word SHARPS
 .word SIGN
 .word SHARPGT
 .word RFROM
 .word OVER
 .word NEGATE
 .word SPACES
 .word TYPE
 .word SEMIS

;~~~
L1ba4 .byt 2 | bit7
 .asc "D","."|bit7
 .word L1b80
DDOT
 .word DOCOL
 .word ZERO
 .word DDOTR
 .word SPACE
 .word SEMIS

;~~~
L1bb3 .byt 2 | bit7
 .asc ".","R"|bit7
 .word L1ba4
DOTR
 .word DOCOL
 .word TOR
 .word S2D
 .word RFROM
 .word DDOTR
 .word SEMIS

;~~~
L1bc4 .byt 1 | bit7
 .asc "."|bit7
 .word L1bb3
DOT
 .word DOCOL
 .word S2D
 .word DDOT
 .word SEMIS

;~~~
L1bd0 .byt 1 | bit7
 .byt "?"|bit7
 .word L1bc4
QUES
 .word DOCOL
 .word FETCH
 .word DOT
 .word SEMIS

;~~~
L1bdc .byt 4 | bit7
 .asc "LIS","T"|bit7
 .word L1bd0
LIST
 .word DOCOL
 .word DECIMAL
 .word CR
 .word DUP
 .word SCR
 .word STORE
 .word PDOTQ
 .byt 6
 .asc "SCR # "
 .word DOT
 .word CLIT
 .byt 16
 .word ZERO
 .word PDO
 .word CR
 .word I
 .word THREE
 .word DOTR
 .word SPACE
 .word I
 .word SCR
 .word FETCH
 .word DOTLINE
 .word PLOOP
 .word -20
 .word CR
 .word SEMIS

;~~~
L1c1b .byt 5 | bit7
 .asc "INDE","X"|bit7
 .word L1bdc
INDEX
 .word DOCOL
 .word CR
 .word ONEP
 .word SWAP
 .word PDO
 .word CR
 .word I
 .word THREE
 .word DOTR
 .word SPACE
 .word ZERO
 .word I
 .word DOTLINE
 .word QTERM
 .word ZBRAN
 .word 4
 .word LEAVE
 .word PLOOP
 .word -26
 .word CLIT
 .byt 13
 .word EMIT
 .word SEMIS

;~~~
L1c50 .byt 5 | bit7
 .asc "TRIA","D"|bit7
 .word L1c1b
TRIAD
 .word DOCOL
 .word THREE
 .word SLASH
 .word THREE
 .word STAR
 .word THREE
 .word OVER
 .word PLUS
 .word SWAP
 .word PDO
 .word CR
 .word I
 .word LIST
 .word PLOOP
 .word -8
 .word CR
 .word CLIT
 .byt 15
 .word MESSAGE
 .word CR
 .word CLIT
 .byt 13
 .word EMIT
 .word SEMIS

storezp
 stx stash
 ldx #$7d
 lda ZPBUF,x
 pha
 lda $0f,x
 sta ZPBUF,x
 pla
 sta $0f,x
 dex
 bpl $1c8a
 rts

restorezp
 ldx #$7d
 lda $0f,x
 pha
 lda ZPBUF,x
 sta $0f,x
 pla
 sta ZPBUF,x
 dex
 bpl $1c9c
 ldx stash
 rts

;~~~
L1cae .byt 3 | bit7
 .asc "MO","N"|bit7
 .word L1c50
MON
 .word *+2
 jsr storezp
 brk
 nop
 nop
 jsr restorezp
 JMP NEXT

 ; this is the buffer for BASIC's zero page used by ICE, restorezp, storezp
 ; 000f..008b <--> $1cc2..1d3f
ZPBUF
 .byt $7f,$00,$0d,$04,$16,$13,$00,$08,$12,$b3,$01,$cd,$1f,$00
 .byt $2a,$40,$40,$b2,$e9,$ce,$58,$00,$03,$00,$40,$01,$04,$4c,$3a,$4c
 .byt $3a,$4c,$3a,$ff,$7f,$fd,$7f,$ff,$7f,$0a,$00,$0a,$00,$00,$04,$c0
 .byt $7f,$00,$04,$00,$02,$44,$4c,$24,$0c,$04,$0c,$ff,$06,$00,$ff,$1f
 .byt $16,$00,$25,$03,$4c,$22,$00,$82,$00,$0f,$4e,$1e,$00,$00,$00,$00
 .byt $00,$8b,$00,$ff,$ff,$21,$00,$4c,$3a,$99,$7f,$4b,$3a,$fc,$00,$ca
 .byt $00,$4c,$3a,$01,$00,$d0,$02,$e6,$78,$ad,$0a,$04,$06,$0d,$ff,$4c
 .byt $3a,$08,$01,$ef,$38,$c0,$20,$4c,$e9,$d0,$6c,$0a,$18,$80,$7f,$70

;~~~
L1d40 .byt 3 | bit7
 .byt "RV","S"|bit7
 .word L1cae
RVS
 .word DOCOL
 .word LIT
 .word 18
 .word EMIT
 .word SEMIS

;~~~
L1d50 .byt 4 | bit7
 .byt "-RV","S"|bit7
 .word L1d40
DASHRVS
 .word DOCOL
 .word LIT
 .word $92
 .word EMIT
 .word SEMIS

;~~~
L1d61 .byt 5 | bit7
 .asc "VLIS","T"|bit7
 .word L1d50
VLIST
 .word DOCOL
 .word CLIT
 .byt bit7
 .word OUT
 .word STORE
 .word CONTEXT
 .word FETCH
 .word FETCH
 .word OUT
 .word FETCH
 .word CL
 .word GT
 .word ZBRAN
 .word 10
 .word CR
 .word ZERO
 .word OUT
 .word STORE
 .word DUP
 .word DUP
 .word CFETCH
 .word LIT
 .word 64
 .word ANDD
 .word ZBRAN
 .word 4
 .word RVS
 .word IDDOT
 .word DASHRVS
 .word TWO
 .word SPACES
 .word PFA
 .word LFA
 .word FETCH
 .word DUP
 .word ZEQ
 .word QTERM
 .word OR
 .word ZBRAN
 .word -62
 .word DROP
 .word SEMIS

;~~~
L1dbc .byt 4 | bit7
 .asc "DUM","P"|bit7
 .word L1d61
DUMP
 .word DOCOL
 .word CR
 .word OVER
 .word PLUS
 .word SWAP
 .word LIT
 .word -1
 .word ROT
 .word ROT
 .word PDO
 .word ONEP
 .word DUP
 .word LIT
 .word 8
 .word MOD
 .word ZEQ
 .word ZBRAN
 .word 14
 .word CR
 .word I
 .word ZERO
 .word LIT
 .word 5
 .word DDOTR
 .word I
 .word CFETCH
 .word LIT
 .word 4
 .word DOTR
 .word PLOOP
 .word -40
 .word CR
 .word SEMIS

;~~~
L1e05 .byt 3 | bit7
 .asc "SY","S"|bit7
 .word L1dbc
SYS
 .word DOCOL
 .word VOCLINK
 .word FETCH
 .word LIT
 .word 32
 .word ORIGIN
 .word STORE
 .word HERE
 .word LIT
 .word 30
 .word ORIGIN
 .word STORE
 .word FORTH
 .word DEFINITIONS
 .word LATEST
 .word LIT
 .word 12
 .word ORIGIN
 .word STORE
 .word SEMIS

;~~~
L1e33 .byt 7 | bit7
 .asc "DEVICE","#"|bit7
 .word L1e05
DEVSHARP
 .word DOVAR
 .word 8

;~~~tape
; ?? load the next file from cassette
L1e41 .byt 4 | bit7 | bit6
 .byt "-C-",">"|bit7
 .word L1e33
DASHCDASHGT
 .word DOCOL
 .word QLOADING
 .word ZERO
 .word LIT
 .word $d1 ; Length of file name; O=no name
 .word CSTORE
 .word ZERO
 .word LIT
 .word $9d ; Flag for LOAD or VERIFY #O=LOAD. #1=VERIFY
 .word CSTORE
 .word DEVSHARP
 .word FETCH
 .word LIT
 .word $d4 ; Current device number #O=keyboard, #1-2=tape, 
 ; #3=screen, #4 typically printer, #8 typically disk drives
 .word CSTORE
 .word CASLO
 .word ZERO
 .word IN
 .word STORE
 .word BSCR
 .word BLK
 .word FETCH
 .word OVER
 .word MOD
 .word NEGATE
 .word BLK
 .word PSTORE
 .word SEMIS

L1e80 .byt 5 | bit7
 .byt "DIM(",")"|bit7
 .word L1e41
DIM
 .word DOCOL
 .word BUILDS
 .word ONEP
 .word OVER
 .word ONEP
 .word STAR
 .word SWAP
 .word COMMA
 .word ZERO
 .word PDO
 .word ZERO
 .word COMMA
 .word PLOOP
 .word -6
 .word DOES
 .word DUP
 .word FETCH
 .word ROT
 .word TWO
 .word STAR
 .word ROT
 .word PLUS
 .word ROT
 .word ROT
 .word STAR
 .word TWO
 .word STAR
 .word PLUS
 .word TWOP
 .word SEMIS

;~~~
;
; $VARIABLE   ( char[len]...char[1] len -- ) 
; creates a new word
;
L1ec4 .byt 9 | bit7
 .asc "$VARIABL","E"|bit7
 .word L1e80
DVARIABLE
 .word DOCOL
 .word BUILDS
 .word DUP
 .word CCOMMA ; allocation
 .word ZERO
 .word CCOMMA ; 
 .word ZERO
 .word PDO
 .word ZERO ;-6
 .word CCOMMA
 .word PLOOP
 .word -6
 .word DOES
STROUT
 .word SWAP
 .word ZEQ
 .word ZBRAN
 .word 34
 .word LIT
 .word $22 
 .word WORD
 .word HERE
 .word CFETCH
 .word OVER
 .word CFETCH
 .word MIN
 .word HERE
 .word ROT
 .word ONEP
 .word ROT
 .word ONEP
 .word CMOVE
 .word BRANCH
 .word 4
 .word ONEP ;34
 .word SEMIS ;4

;~~~
L1f16 .byt 4 | bit7
 .asc "SCR","#"|bit7
 .word L1ec4
SCRSHARP
 .word DODOES
 .word STROUT
 .byt 8
 .byt 8
 .byt "0:SCR145"

;~~~
;
; STR$   ( n -- "digit[len]"..."digit[1]" len )
; convert a number to string, pushing each character on the stack
; with length at TOS
;
L1f2b .byt 4 | bit7
 .asc "STR","$"|bit7
 .word L1f16
STRD
 .word DOCOL
 .word S2D
 .word LTSHARP
 .word SHARPS
 .word SHARPGT
 .word DUP
 .word TOR
 .word SWAP
 .word ONE
 .word NEGATE
 .word DUP
 .word ROT
 .word PLUS
 .word PDO
 .word I ;-10
 .word CFETCH
 .word LIT
 .word -1
 .word PPLOOP
 .word -10
 .word RFROM
 .word SEMIS

;~~~tape/disk
L1f5e .byt 6 | bit7
 .asc "NAMSE","T"|bit7
 .word L1f2b
NAMSET
 .word DOCOL
 .word DECIMAL
 .word STRD
 .word TOR
 .word ONE
 .word SCRSHARP
 .word LIT
 .word 6
 .word PLUS
 .word RFETCH
 .word ZERO
 .word PDO
 .word I ;-14
 .word OVER
 .word PLUS
 .word ROT
 .word SWAP
 .word CSTORE
 .word PLOOP
 .word -14
 .word LIT
 .word 3
 .word RFROM
 .word NEGATE
 .word DASHDUP
 .word ZBRAN
 .word 28
 .word ZERO
 .word PDO
 .word TWO ;-20
 .word I
 .word NEGATE
 .word OVER
 .word PLUS
 .word LIT
 .word " "
 .word SWAP
 .word CSTORE
 .word PLOOP
 .word -20
 .word DROP
 .word SEMIS ;28

;~~~tape/disk
L1fbb .byt 7 | bit7
 .asc "NAMIEE","E"|bit7
 .word L1f5e
NAMIEEE ; ( 0 -- )
 .word DOCOL
 .word DASHDUP
 .word ZEQ
 .word ZBRAN
 .word 14
 .word ZERO
 .word LIT
 .word $d1 ; Length of file name; O=no name
 .word CSTORE
 .word BRANCH
 .word 26
 .word NAMSET
 .word ONE
 .word SCRSHARP
 .word DUP
 .word CFETCH
 .word LIT
 .word $d1 ; Length of file name; O=no name
 .word STORE
 .word ONEP
 .word LIT
 .word $da ; Pointer to start of file name
 .word STORE
 .word SEMIS

;~~~
L1ff5 .byt 10 | bit7
 .asc "SETDEVICE","#"|bit7
 .word L1fbb
SETDEV ; ( -- )
 .word DOCOL
 .word DEVSHARP
 .word FETCH
 .word LIT
 .word $d4 ; Current device number
 .word CSTORE
 .word SEMIS

;~~~tape
L2010 .byt 8 | bit7
 .asc "CASSLOA","D"|bit7
 .word L1ff5
CASSLOAD
 .word DOCOL
 .word NAMIEEE
 .word SETDEV
 .word ZERO
 .word LIT
 .word $9d ; Flag for LOAD or VERIFY #O=LOAD. #1=VERIFY
 .word CSTORE
 .word CASLO
 .word FIRST
 .word FETCH
 .word LIT
 .word $7fff
 .word ANDD
 .word BSCR
 .word SLASH
 .word SCR
 .word STORE
 .word SEMIS

;~~~tape
L203f .byt 6 | bit7
 .asc "MEMSE","T"|bit7
 .word L2010
MEMSET
 .word DOCOL
 .word SWAP
 .word LIT
 .word $fb ; Pointer for MLM, start of tape address with . S
 .word STORE
 .word CASFX
 .word LIT
 .word $c9 ; End address for tape LOAD
 .word STORE
 .word SEMIS

;~~~tape
L205c .byt 7 | bit7
 .asc "CASSAV","E"|bit7
 .word L203f
CASSAVE
 .word DOCOL
 .word SETDEV
 .word ZERO
 .word LIT
 .word $9d ; load/verify flag
 .word CSTORE
 .word SCR
 .word FETCH
 .word NAMIEEE
 .word FIRST
 .word LIMIT
 .word MEMSET
 .word CASSA
 .word SEMIS

;~~~
L2082 .byt 7 | bit7
 .asc "SYSSAV","E"|bit7
 .word L205c
SYSSAVE
 .word DOCOL
 .word ZERO
 .word LIT
 .word $9d ; Flag for LOAD or VERIFY #O=LOAD. #1=VERIFY
 .word CSTORE
 .word LIT
 .word 32
 .word WORD
 .word HERE
 .word CFETCH
 .word LIT
 .word $d1 ; Length of file name; O=no name
 .word CSTORE
 .word HERE
 .word ONEP
 .word LIT
 .word $da
 .word STORE
 .word SETDEV
 .word SYS
 .word LIT
 .word ANFANG
 .word HERE
 .word ONEP
 .word MEMSET
 .word CASSA
 .word SEMIS

;~~~
L20c2 .byt 6 | bit7
 .asc "VERIF","Y"|bit7
 .word L2082
VERIFY
 .word DOCOL
 .word ONE
 .word LIT
 .word $9d ; Flag for LOAD or VERIFY #O=LOAD. #1=VERIFY
 .word CSTORE
 .word NAMIEEE
 .word SETDEV
 .word CASLO
 .word SEMIS

;~~~
L20dd .byt 5 | bit7
 .asc "CASS","1"|bit7
 .word L20c2
CASS1
 .word DOCOL
 .word ONE
 .word DEVSHARP
 .word STORE
 .word SEMIS

;~~~
L20ef .byt 5 | bit7
 .asc "CASS","2"|bit7
 .word L20dd
CASS2
 .word DOCOL
 .word TWO
 .word DEVSHARP
 .word STORE
 .word SEMIS

;~~~
L2101 .byt 7 | bit7
 .asc "SYSSIZ","E"|bit7
 .word L20ef
SYSSIZE
 .word DOCOL
 .word SYS
 .word LIT
 .word 1024
 .word STAR
 .word LIT
 .word 128
 .word NEGATE
 .word DUP
 .word LIT
 .word LIMIT+2
 .word STORE
 .word DUP
 .word LIT
 .word 16
 .word ORIGIN
 .word STORE
 .word LIT
 .word 1040
 .word NEGATE
 .word DUP
 .word DUP
 .word LIT
 .word FIRST+2
 .word STORE
 .word LIT
 .word PREV+2
 .word STORE
 .word LIT
 .word USE+2
 .word STORE
 .word SYS
 .word SEMIS

;~~~
L214d .byt 4 | bit7
 .asc "DTY","P"|bit7
 .word L2101
DTYP
 .word DOVAR
 .word 2

;~~~
L2158 .byt 4 | bit7 | bit6
 .asc "DIS","K"|bit7
 .word L214d
DISK
 .word DODOES
 .word DOVOC
 .word $a081
 .word L2480
V2167
 .word V137c

DTAB
 .byt $12,$12,$26
 .byt $13,$13,$28
 .byt $19,$19,$36
 .byt $1f,$1f,$41
 .byt $24,$24,$4e
DTAB2
 .byt $15,$15,$1d
 .byt $00,$00,$00
 .byt $14,$13,$1b
 .byt $12,$12,$19
 .byt $11,$11,$17
DTAB3
 ldy DTYP+2
 cmp DTAB,y
 bcc $2195
 iny
 iny
 iny
 jmp $218a
 lda DTAB2,y
 rts

L2199 .byt 5 | bit7
 .byt "B->T","S"|bit7
 .word ROOTVOCAB
B2TS
 .word *+2
 lda #$01
 stx stash
 jsr P048a
 ldx #$00
 inx
 txa
 jsr DTAB3
 sta $7c
 sec
 lda $7a
 sbc $7c
 sta $7a
 bcs $21be
 dec $7b
 lda $7b
 bpl $21ac
 stx $7d
 lda $7c
 ldx stash
 clc
 adc $7a
 sta $00,x
 lda #$00
 sta $01,x
 lda $7d
 jmp PUSHOA

L21d6 .byt 3 | bit7
 .byt "CH","D"|bit7
 .word L2199
CHD
 .word DOCOL
 .word ZERO
 .word LIT
 .word 174
 .word CFETCH
 .word DASHDUP
 .word ZBRAN
 .word 34
 .word LIT
 .word 593
 .word PLUS
 .word LIT
 .word 593
 .word PDO
 .word I
 .word CFETCH
 .word LIT
 .word 5
 .word EQUAL
 .word ZBRAN
 .word 4
 .word ONEP
 .word PLOOP
 .word -18
 .word SEMIS

L220e .byt 7 | bit7
 .byt "READBL","K"|bit7
 .word L21d6
READBLK
 .word *+2
 lda #$01
 jsr P048a
 stx stash
 ldx #$05
; $FFC6 CHKIN set input device
 jsr $ffc6
 ldy #$ff
 dey
 tya
 pha
; $FFE4 GETIN Read byte from default input. (If not keyboard, must call OPEN and CHKIN beforehands.)
 jsr $ffe4
 tax
 pla
 tay
 txa
 sta ($7a),y
 cpy #$00
 bne $2228
 dey
 lda #$20
 sta ($7a),y
 lda $e840
 and #$fb
 sta $e840
 ldx #$05
; $FFCC CLRCHN Close default input/output files (for serial bus, send UNTALK and/or UNLISTEN); restore default input/output to keyboard/screen.
 jsr $ffcc
 ldx stash
 JMP NEXT

L224f .byt 7 | bit7
 .byt "WRITBL","K"|bit7
 .word L220e
WRITBLK
 .word *+2
 lda #$01
 jsr P048a
 stx stash
 ldx #$05
; $FFC9 CHKOUT Define file as default output. (Must call OPEN beforehands.)
 jsr $ffc9
 ldy #$ff
 dey
 lda ($7a),y
; $FFD2 CHROUT
 jsr $ffd2
 cpy #$00
 bne $2269
; $FFCC CLRCHN
 jsr $ffcc
 ldx stash
 JMP NEXT

;~~~
L227b .byt 3 | bit7
 .asc "B-","P"|bit7
 .word L224f
BDASHP
 .word DODOES
 .word STROUT
 .byt 6
 .byt 6
 .asc "B-P4 1"

;~~~
L228d .byt 3 | bit7
 .byt "B-","R"|bit7
 .word L227b
BDASHR
 .word DODOES
 .word STROUT
 .byt 6
 .byt 6
 .asc "U1:4 1"

;~~~
L229f .byt 4 | bit7
 .byt "SR/","W"|bit7
 .word L228d
SRSLASHW
 .word DOCOL
 .word DUP
 .word ZBRAN
 .word 10
 .word LIT
 .word $31
 .word BRANCH
 .word 6
 .word LIT
 .word $32
 .word ONE
 .word BDASHR
 .word TWOP
 .word CSTORE
 .word SEMIS

;~~~
L22c4 .byt 6 | bit7
 .byt "SNDCO","M"|bit7
 .word L229f
SNDCOM
 .word *+2
 stx stash
 lda $1e3f
 sta $d4
 lda #$6f
 sta $d3
; $F0D5 Send Listen on IEEE
 jsr $f0d5
 lda $d3
; $F143 Send one character and c1ear ATN. This is typicaUy used to
;send IEEE commands (such as the secondary address, #$60 +
;0-15) when ATN is true and one command only is wanted. It is
;used by loading A with the character, then calling this sub-
;routine, which stores A in the IEEE buffer, caUs the routine
;immediately before this one, then sets attention high (false).
 jsr $f143
 lda #$01
 ldx stash
 jsr P048a
 stx stash
 ldy #$00
 lda ($7a),y
 sta $79
 iny
 tya
 pha
 lda ($7a),y
; $F19E Send IEEE character. If the buffer contains a character at
;present, that character is output, and the contents of A put
;in the buffer. Otherwise, the contents of A are put into the
;buffer, and the output flag reset from #0 ta #FF. In either
;case, on exit flag $AO holds #FF, and buffer $A5 holds A.
;"(BASIC 1: $021D and $0222 respectively).
 jsr $f19e
 pla
 tay
 cpy $79
 bne $22f1
; $F1B9 Send 'Unlisten'. AU ROMs function identically.
 jsr $f1b9
 ldx stash
 JMP NEXT

;~~~
L2307 .byt 6 | bit7
 .byt "APPEN","D"|bit7
 .word L22c4
APPEND
 .word DOCOL
 .word SWAP
 .word OVER
 .word COUNT
 .word PLUS
 .word CSTORE
 .word ONE
 .word SWAP
 .word PSTORE
 .word SEMIS

;~~~
L2324 .byt 2 | bit7
 .byt "$","A"|bit7
 .word L2307
DOLLARA
 .word DOCOL
 .word SWAP
 .word COUNT
 .word OVER
 .word PLUS
 .word SWAP
 .word PDO
 .word I
 .word CFETCH
 .word OVER
 .word APPEND
 .word PLOOP
 .word -10
 .word DROP
 .word SEMIS

;~~~
L2347 .byt 4 | bit7
 .byt "COM","$"|bit7
 .word L2324
COMD
 .word DODOES
 .word STROUT
 .byt 53,11
 .asc "U1:4 1,14,60EENS,01"
 .word 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

;~~~
L2389 .byt 5 | bit7
 .byt "SNSE","C"|bit7
 .word L2347
SNSEC
 .word DOCOL
 .word BASE
 .word FETCH
 .word DECIMAL
 .word SWAP
 .word B2TS
 .word STRD
 .word LIT
 .word $2c
 .word ONE
 .word COMD
 .word APPEND
 .word ZERO
 .word PDO
 .word ONE
 .word COMD
 .word APPEND
 .word PLOOP
 .word -8
 .word LIT
 .word $2c
 .word ONE
 .word COMD
 .word APPEND
 .word STRD
 .word ZERO
 .word PDO
 .word ONE
 .word COMD
 .word APPEND
 .word PLOOP
 .word -8
 .word BASE
 .word STORE
 .word SEMIS

;~~~
L23d7 .byt 5 | bit7
 .byt "S-B-","P"|bit7
 .word L2389
SBP
 .word DOCOL
 .word ONE
 .word BDASHP
 .word SNDCOM
 .word SEMIS

;~~~
L23e9 .byt 5 | bit7
 .byt "$SR/","W"|bit7
 .word L23d7
DSRW
 .word DOCOL
 .word ZERO
 .word ONE
 .word COMD
 .word CSTORE
 .word SRSLASHW
 .word ONE
 .word BDASHR
 .word ONE
 .word COMD
 .word DOLLARA
 .word SEMIS

;~~~
L2409 .byt 4 | bit7
 .byt "REA","D"|bit7
 .word L23e9
READ
 .word DOCOL
 .word ONE
 .word COMD
 .word SNDCOM
 .word SBP
 .word READBLK
 .word SEMIS

;~~~
L241e .byt 6 | bit7
 .byt "CLOSE","#"|bit7
 .word L2409
CLOSEP
 .word *+2
 stx stash
 lda $00,x
 sta $d2
; $F2DD
; Perform CLOSE. $FFC3 in the 'kernel' jump address table
;cornes here. The start of this routine fetches the parameters
;used with CLOSE and stores the logical file number, device
;number and secondary address in $D2-$D4. lt uses the pre-
;vious routines for this.
 jsr $f2e0
 ldx stash
 jmp POP

;~~~
L2437 .byt 5 | bit7
 .byt "WRIT","E"|bit7
 .word L241e
WRITE
 .word DOCOL
 .word SBP
 .word WRITBLK
 .word ONE
 .word COMD
 .word SNDCOM
 .word SEMIS

;~~~
L244d .byt 3 | bit7
 .byt "CD","C"|bit7
 .word L2437
CDC
 .word DOCOL
 .word LIT
 .word 5
 .word CLOSEP
 .word SEMIS

 ;~~~
L245d .byt 4 | bit7
 .byt "DR/","W"|bit7
 .word L244d
DRSLASHW
 .word DOCOL
 .word CHD
 .word ZBRAN
 .word 20
 .word DSRW
 .word SWAP
 .word SNSEC
 .word ZBRAN
 .word 8
 .word READ
 .word BRANCH
 .word 4
 .word WRITE
 .word SEMIS

L2480
 .byt 5 | bit7
 .byt "DOPE","N"|bit7
 .word L245d
DOPEN
 .word *+2
 stx stash
; $F560
;Perform OPEN. $FFC 0 in the 'kernel' jump table cornes here.
;This routine first uses the subroutine at F433/F4CE/F50D to
;fetch and store the parameters. If the file number is zero,
 jsr $f563
 ldx stash
 JMP NEXT

;~~~
L2494 .byt 7 | bit7
 .asc "DISKCO","M"|bit7
 .word L2158
DISKCOM
 .word DOCOL
 .word ZERO
 .word COMD
 .word ONE
 .word COMD
 .word SNDCOM
 .word SEMIS

;~~~
L24ac .byt 5 | bit7
 .asc "DFNA","$"|bit7
 .word L2494
DFNAD
 .word DODOES
 .word STROUT
 .byt 2
 .byt 2
 .asc "#4"

;~~~
L24bc .byt 7 | bit7
 .asc "DATAIN","T"|bit7
 .word L24ac
DATAINT
 .word DOCOL
 .word CHD
 .word ZBRAN
 .word 4
 .word CDC
 .word ONE
 .word DFNAD
 .word COUNT
 .word LIT
 .word $d1 ; Length of file name; O=no name
 .word CSTORE
 .word LIT
 .word $da
 .word STORE
 .word LIT
 .word 5
 .word LIT
 .word $d2
 .word CSTORE
 .word LIT
 .word 4
 .word LIT
 .word $d3
 .word CSTORE
 .word DEVSHARP
 .word FETCH
 .word LIT
 .word $d4
 .word CSTORE
 .word DOPEN
 .word SEMIS

;~~~
L2504 .byt 7 | bit7
 .asc "DSELEC","T"|bit7
 .word L24bc
DSELECT
 .word DOCOL
 .word LIT
 .word $48
 .word PLUS
 .word ONE
 .word BDASHR
 .word LIT
 .word 6
 .word PLUS
 .word CSTORE
 .word SEMIS

;~~~
L2524 .byt 7 | bit7
 .asc "SETDIS","K"|bit7
 .word L2504
SETDISK
 .word DOCOL
 .word DEVSHARP
 .word FETCH
 .word LIT
 .word $fa
 .word CSTORE
 .word SEMIS

;~~~
L253c .byt 4 | bit7
 .asc "TAL","K"|bit7
 .word L2524
TALK
 .word *+2
;$FOD2 Send 'Talk' on IEEE-4S8 bus.
 jsr $f0d2
 JMP NEXT

;~~~
L254b .byt 7 | bit7
 .asc "SECADR","S"|bit7
 .word L253c
SECADRS
 .word *+2
 lda $00,x
 ora #$60
 sta $d3
; $F143 Send one character and c1ear ATN.
 jsr $f143
 jmp POP

;~~~
L2563 .byt 8 | bit7
 .asc "DISKCHA","R"|bit7
 .word L254b
DISKCHAR
 .word *+2
; $F1CO Get one character from the IEEE-488 bus. The byte is return-
;ed in A. This routine uses the identical timing subroutine used
;ta output a character; BASIC 4 again has the option of over-
;riding the time out. ST=2 if this is not done and the device
;fails ta return a byte within 65 milliseconds. The sequence of
;"events is: (i) Sets NDAC (not data accepted) true, and NRFD
;(not ready for data) false. (ü) Waits until DAY (data valid)
;has been set true. ST is set =2 if the wait exceeds 65 millisec-
;onds (but the timer can be overridden in BASIC 4, by poking
;$03FC (1020 decimal) with a 'negative' number) . (Hi) Sets
;NRFD true, (iv) Checks EOI; if found, ST is set to #40 (64
;decimal) to indicate end-of-file. (v) Takes the byte, reverses
;it, and saves this value on the stack. (vi) Sends NDAC false,
;to indicate that the data was accepted, then waits for DAV to
;become true; finally, NDAC is set true again, and the byte is
;recovered from the stack and placed into A.
 jsr $f1c0
 jmp PUSHOA

;~~~
L2576 .byt 6 | bit7
 .asc "UNTAL","K"|bit7
 .word L2563
UNTALK
 .word *+2
; $F1AE Send 'Untalk'. BASIC 4, unlike BASIC<4, sets ATN true 
; before entering F0BC/F0BC/F0D7. This corrects a bug; see
; Chapter 14.
 jsr $f1ae
 jmp NEXT

;~~~
L2587 .byt 7 | bit7
 .asc "DISKER","R"|bit7
 .word L2576
DISKERR
 .word DOCOL
 .word SETDISK
 .word TALK
 .word LIT
 .word 15
 .word SECADRS
 .word DISKCHAR
 .word DUP
 .word EMIT
 .word LIT
 .word 13
 .word EQUAL
 .word ZBRAN
 .word -14
 .word UNTALK
 .word SEMIS

;~~~
L25b1 .byt 8 | bit7
 .asc "DISKSAV","E"|bit7
 .word L2587
DISKSAVE
 .word DOCOL
 .word CASSAVE
 .word SEMIS

;~~~
L25c2 .byt 7 | bit7
 .asc "DISKVE","R"|bit7
 .word L25b1
DISKVER
 .word DOCOL
 .word ZERO
 .word LIT
 .word $96
 .word CSTORE
 .word VERIFY
 .word SEMIS

;~~~
L25da .byt 3 | bit7
 .asc "SD","0"|bit7
 .word L25c2
SD0
 .word DOCOL
 .word LIT
 .word $30
 .word ONE
 .word BDASHR
 .word LIT
 .word 6
 .word PLUS
 .word CSTORE
 .word SEMIS

;~~~
L25f4 .byt 3 | bit7
 .asc "SD","1"|bit7
 .word L25da
SD1
 .word DOCOL
 .word LIT
 .word $31
 .word ONE
 .word BDASHR
 .word LIT
 .word 6
 .word PLUS
 .word CSTORE
 .word SEMIS

;~~~
L260e .byt 8 | bit7
 .asc "DISKLOA","D"|bit7
 .word L25f4
DISKLOAD
 .word DOCOL
 .word ZERO
 .word LIT
 .word $96
 .word CSTORE
 .word CASSLOAD
 .word SEMIS

;~~~
L2627 .byt 5 | bit7
 .asc "XEMI","T"|bit7
 .word L260e
XEMIT
 .word DOCONST
 .word DOEMIT

;~~~
L2633 .byt 8 | bit7
 .asc "PRINTER","#"|bit7
 .word L2627
PRINTERNUM
 .word DOVAR
 .word 4

;~~~
L2642 .byt 4 | bit7
 .asc "PSE","C"|bit7
 .word L2633
PSEC
 .word DOVAR
 .word $ff

;~~~
L264d .byt 5 | bit7
 .asc "PPRE","L"|bit7
 .word L2642
 .word *+2 ; another fake primitive, use JSR
PPREL
 stx stash
 ldx #$04
 ; $FFC9 CHKOUT
 jsr $ffc9
 ldx stash
 lda $00,x
 stx stash
 cmp #$0d
 bne $266f
 lda #$0a
 ; $FFD2 CHROUT
 jsr $ffd2
 lda #$0d
 ; $FFD2 CHROUT
 jsr $ffd2
 ; $FFCC CLRCHN
 jsr $ffcc
 ldx stash
 jmp $18e0

;~~~
L267a .byt 7 | bit7
 .asc "PRINTE","R"|bit7
 .word L264d
PRINTER
 .word DOCOL
 .word ZERO
 .word LIT
 .word $d1 ; Length of file name; O=no name
 .word CSTORE
 .word LIT
 .word 4
 .word LIT
 .word $d2
 .word CSTORE
 .word PSEC
 .word FETCH
 .word LIT
 .word $d3
 .word CSTORE
 .word PRINTERNUM
 .word FETCH
 .word LIT
 .word $d4
 .word CSTORE
 .word DOPEN
 .word LIT
 .word PPREL
 .word LIT
 .word L06a1 ; LFA of "KEY"
 .word CFA
 .word STORE
 .word SEMIS

;~~~
L26bc .byt 8 | bit7
 .asc "PRINTOF","F"|bit7
 .word L267a
PRINTOFF
 .word DOCOL
 .word XEMIT
 .word LIT
 .word L06a1
 .word CFA
 .word STORE
 .word LIT
 .word 4
 .word CLOSEP
 .word SEMIS

;~~~
L26db .byt 5 | bit7
 .asc "STAC","K"|bit7
 .word L26bc
STACK
 .word DOCOL
 .word BUILDS
 .word ZERO
 .word COMMA
 .word DUP
 .word COMMA
 .word TWO
 .word STAR
 .word ALLOT
 .word DOES
STACKEX
 .word SEMIS

;~~~
L26f9 .byt 4 | bit7
 .asc "PUS","H"|bit7
 .word L26db
PUSHB
 .word DOCOL
 .word TOR
 .word RFETCH
 .word FETCH
 .word RFETCH
 .word TWOP
 .word FETCH
 .word GT
 .word LIT
 .word 14
 .word QERROR
 .word RFETCH
 .word FETCH
 .word TWO
 .word STAR
 .word LIT
 .word 4
 .word PLUS
 .word RFETCH
 .word PLUS
 .word STORE
 .word ONE
 .word RFROM
 .word PSTORE
 .word SEMIS

;~~~
L2732 .byt 3 | bit7
 .asc "PO","P"|bit7
 .word L26f9
POPB
 .word DOCOL
 .word TOR
 .word RFETCH
 .word FETCH
 .word DASHDUP
 .word ZEQ
 .word LIT
 .word 15
 .word QERROR
 .word ONE
 .word NEGATE
 .word TWO
 .word STAR
 .word LIT
 .word 4
 .word PLUS
 .word RFETCH
 .word PLUS
 .word FETCH
 .word LIT
 .word -1
 .word RFROM
 .word PSTORE
 .word SEMIS

;~~~
L2768 .byt 11 | bit7
 .asc "CLEAR-STAC","K"|bit7
 .word L2732
CLSTK
 .word DOCOL
 .word ZERO
 .word SWAP
 .word STORE
 .word SEMIS

;~~~
L2780 .byt 6 | bit7
 .byt "VRANG","E"|bit7
 .word L2768
VRANGE
 .word DOCOL
 .word FETCH
 .word DUP
 .word ROT
 .word LT
 .word ROT
 .word ROT
 .word LT
 .word ANDD
 .word SEMIS

;~~~
L279d .byt 7 | bit7
 .asc "AVOKPU","T"|bit7
 .word L2780
AVOKPUT
 .word DOCOL
 .word DUP
 .word FETCH
 .word SWAP
 .word TWOP
 .word FETCH
 .word VOCLINK
 .word VRANGE
 .word ZBRAN
 .word 12
 .word VOCLINK
 .word FETCH
 .word FETCH
 .word VOCLINK
 .word STORE
 .word SEMIS

;~~~
L27c7 .byt 3 | bit7
 .asc "TD","F"|bit7
 .word L279d
TDF
 .word DODOES
 .word STACKEX
 .word 0
 .word 10
 .word L29f2
 .byt $20,$20,$20,$20,$20,$20,$20,$20,$20
 .byt $20,$20,$20,$20,$20,$20,$20,$20,$20

;~~~
L27e9 .byt 18 | bit7
 .asc "DEFINE-APPLICATIO","N"|bit7
 .word L27c7
DEFAPP
 .word DOCOL
 .word BUILDS
 .word OVER
 .word PLUS
 .word SWAP
 .word COMMA
 .word COMMA
 .word LIT
 .word $20
 .word WORD
 .word HERE
 .word CFETCH
 .word ONEP
 .word ALLOT
 .word DOES
DEFAPPEX
 .word SEMIS

;~~~
L281e .byt 17 | bit7
 .asc "BEGIN-APPLICATIO","N"|bit7
 .word L27e9
BEGINAPP
 .word DOCOL
 .word FORTH
 .word DEFINITIONS
 .word HERE
 .word TDF
 .word PUSHB
 .word FETCH
 .word DP
 .word STORE
 .word SEMIS

;~~~
L2846 .byt 15 | bit7
 .asc "END-APPLICATIO","N"|bit7
 .word L281e
ENDAPP
 .word DOCOL
 .word FORTH
 .word DEFINITIONS
 .word LATEST
 .word OVER
 .word TWOP
 .word FETCH
 .word TWO
 .word NEGATE
 .word STORE
 .word LATEST
 .word OVER
 .word FETCH
 .word PFA
 .word LFA
 .word FETCH
 .word CURRENT
 .word FETCH
 .word STORE
 .word OVER
 .word FETCH
 .word PFA
 .word LFA
 .word FENCE
 .word FETCH
 .word PFA
 .word LFA
 .word FETCH
 .word SWAP
 .word STORE
 .word FENCE
 .word FETCH
 .word PFA
 .word LFA
 .word STORE
 .word TDF
 .word POPB
 .word DP
 .word STORE
 .word AVOKPUT
 .word SEMIS

;~~~
L28aa .byt 6 | bit7
 .asc "APSAV","E"|bit7
 .word L2846
APSAVE
 .word DOCOL
 .word SETDEV
 .word ZERO
 .word LIT
 .word $9d ; Flag for LOAD or VERIFY #O=LOAD. #1=VERIFY
 .word STORE
 .word DUP
 .word LIT
 .word 4
 .word PLUS
 .word COUNT
 .word LIT
 .word $d1 ; Length of file name; O=no name
 .word CSTORE
 .word LIT
 .word $da
 .word STORE
 .word DUP
 .word FETCH
 .word SWAP
 .word TWOP
 .word FETCH
 .word ONEP
 .word MEMSET
 .word CASSA
 .word SEMIS

;~~~
L28e7 .byt 6 | bit7
 .asc "KILLA","P"|bit7
 .word L28aa
KILLAP
 .word DOCOL
 .word DUP
 .word TWOP
 .word FETCH
 .word TWO
 .word NEGATE
 .word FETCH
 .word FENCE
 .word FETCH
 .word PFA
 .word LFA
 .word DUP
 .word FETCH
 .word ROT
 .word TOR
 .word RFETCH
 .word ROT
 .word ROT
 .word RFROM
 .word EQUAL
 .word ZEQ
 .word ZBRAN
 .word 8
 .word FETCH
 .word BRANCH
 .word -32
 .word SWAP
 .word DROP
 .word OVER
 .word FETCH
 .word PFA
 .word LFA
 .word FETCH
 .word SWAP
 .word STORE
 .word DROP
 .word FORTH
 .word SEMIS

;~~~
L293c .byt 5 | bit7
 .asc "APGE","T"|bit7
 .word L28e7
APGET
 .word DOCOL
 .word DUP
 .word LIT
 .word 4
 .word PLUS
 .word COUNT
 .word LIT
 .word $d1 ; Length of file name; O=no name
 .word CSTORE
 .word LIT
 .word $da
 .word STORE
 .word SETDEV
 .word ZERO
 .word LIT
 .word $9d ; Flag for LOAD or VERIFY #O=LOAD. #1=VERIFY
 .word CSTORE
 .word ZERO
 .word LIT
 .word $96
 .word CSTORE
 .word CASLO
 .word FENCE
 .word FETCH
 .word PFA
 .word LFA
 .word FETCH
 .word OVER
 .word TWOP
 .word FETCH
 .word TWO
 .word NEGATE
 .word FETCH
 .word FENCE
 .word FETCH
 .word PFA
 .word LFA
 .word STORE
 .word SWAP
 .word FETCH
 .word PFA
 .word LFA
 .word STORE
 .word SEMIS

;~~~
L299c .byt 6 | bit7
 .asc "EDITA","P"|bit7
 .word L293c
EDITAP
 .word DODOES
 .word DEFAPPEX
 .word $7788
 .word $7b6e
 .byt 6
 .asc "0:EDIT"

;~~~
L29b4 .byt 5 | bit7
 .asc "EDIT","G"|bit7
 .word L299c
EDITG
 .word DOCOL
 .word EDITAP
 .word APGET
 .word $77d1
 .word SEMIS

;~~~
L29c6 .byt 5 | bit7
 .asc "EDIT","K"|bit7
 .word L29b4
EDITK
 .word DOCOL
 .word EDITAP
 .word KILLAP
 .word FORTH
 .word SEMIS

;~~~
L29d8 .byt 7 | bit7
 .asc "ASSEMA","P"|bit7
 .word L29c6
ASSEMAP
 .word DODOES
 .word DEFAPPEX
 .word $6e8c
 .word $7722
 .byt 7
 .asc "0:ASSEM"

;~~~
L29f2 .byt 6 | bit7
 .asc "ASSEM","G"|bit7
 .word L29d8
ASSEMG
 .word DOCOL
 .word ASSEMAP
 .word APGET
 .word $6e98
 .word SEMIS

;~~~
L2a05 .byt 6 | bit7
 .asc "ASSEM","K"|bit7
 .word L29f2
ASSEMK
 .word DOCOL
 .word ASSEMAP
 .word KILLAP
 .word FORTH
 .word SEMIS

;~~~
L2a18 .byt 7 | bit7
 .asc "$STRIN","G"|bit7
 .word L2a05
DSTRING
 .word DOCOL
 .word BUILDS
 .word ZERO
 .word COMMA
 .word ALLOT
 .word DOES
DODSTR
 .word DUP
 .word TWOP
 .word SWAP
 .word FETCH
 .word SEMIS

;~~~
L2a38 .byt 8 | bit7
 .asc "$POINTE","R"|bit7
 .word L2a18
DPOINTER
 .word DOCOL
 .word BUILDS
 .word COMMA
 .word COMMA
 .word DOES
DPTR
 .word DUP
 .word TWOP
 .word FETCH
 .word SWAP
 .word FETCH
 .word SEMIS

;~~~
L2a59 .byt 4 | bit7
 .asc "MID","$"|bit7
 .word L2a38
MIDD
 .word DOCOL
 .word ROT
 .word DASHDUP
 .word ZEQ
 .word ZBRAN
 .word 12
 .word DROP
 .word DROP
 .word ZERO
 .word BRANCH
 .word 72
 .word ROT
 .word ROT
 .word TOR
 .word DUP
 .word ZEQ
 .word PLUS
 .word OVER
 .word OVER
 .word LT
 .word ZBRAN
 .word 16
 .word DROP
 .word DROP
 .word RFROM
 .word DROP
 .word ZERO
 .word BRANCH
 .word 36
 .word OVER
 .word MIN
 .word SWAP
 .word OVER
 .word NEGATE
 .word SWAP
 .word ROT
 .word PLUS
 .word ONE
 .word NEGATE
 .word SWAP
 .word ONEP
 .word RFROM
 .word DASHDUP
 .word ZBRAN
 .word 4
 .word MIN
 .word SEMIS

;~~~
L2abe .byt 5 | bit7
 .asc "RROT","$"|bit7
 .word L2a59
RROTD
 .word DOCOL
 .word DUP
 .word ZBRAN
 .word 58
 .word OVER
 .word OVER
 .word PLUS
 .word ONE
 .word NEGATE
 .word DUP
 .word CFETCH
 .word ROT
 .word TOR
 .word TOR
 .word OVER
 .word SWAP
 .word PDO
 .word I
 .word ONE
 .word NEGATE
 .word CFETCH
 .word I
 .word CSTORE
 .word LIT
 .word -1
 .word PPLOOP
 .word -18
 .word DUP
 .word RFROM
 .word SWAP
 .word CSTORE
 .word RFROM
 .word SEMIS

;~~~
L2b08 .byt 5 | bit7
 .asc "LROT","$"|bit7
 .word L2abe
LROTD
 .word DOCOL
 .word DUP
 .word ZBRAN
 .word 52
 .word OVER
 .word OVER
 .word PLUS
 .word ONE
 .word NEGATE
 .word SWAP
 .word TOR
 .word OVER
 .word CFETCH
 .word TOR
 .word OVER
 .word OVER
 .word SWAP
 .word PDO
 .word I
 .word ONEP
 .word CFETCH
 .word I
 .word CSTORE
 .word PLOOP
 .word -12
 .word RFROM
 .word SWAP
 .word CSTORE
 .word RFROM
 .word SEMIS

;~~~
L2b4c .byt 3 | bit7
 .asc "CH","R"|bit7
 .word L2b08
CHR
 .word DOVAR
 .word 0

;~~~
L2b56 .byt 4 | bit7
 .asc "CHR","$"|bit7
 .word L2b4c
CHRD
 .word DOCOL
 .word CHR
 .word STORE
 .word CHR
 .word ONE
 .word SEMIS

;~~~
L2b69 .byt 6 | bit7
 .asc "RIGHT","$"|bit7
 .word L2b56
RIGHTD
 .word DOCOL
 .word OVER
 .word OVER
 .word NEGATE
 .word ONEP
 .word ZERO
 .word MAX
 .word SWAP
 .word MIDD
 .word SEMIS

;~~~
L2b86 .byt 5 | bit7
 .asc "LEFT","$"|bit7
 .word L2b69
LEFT
 .word DOCOL
 .word MIN
 .word SEMIS

;~~~
L2b94 .byt 3 | bit7
 .asc "EQ","$"|bit7
 .word L2b86
EQD
 .word DOCOL
 .word ROT
 .word OVER
 .word EQUAL
 .word ZBRAN
 .word 82
 .word DASHDUP
 .word ZEQ
 .word ZBRAN
 .word 12
 .word DROP
 .word DROP
 .word ONE
 .word BRANCH
 .word 60
 .word ZERO
 .word PDO
 .word DUP
 .word I
 .word PLUS
 .word CFETCH
 .word ROT
 .word DUP
 .word I
 .word PLUS
 .word CFETCH
 .word ROT
 .word EQUAL
 .word ZEQ
 .word ZBRAN
 .word 12
 .word DROP
 .word DROP
 .word ZERO
 .word ZERO
 .word LEAVE
 .word PLOOP
 .word -40
 .word ZEQ
 .word ZEQ
 .word ZBRAN
 .word 6
 .word ZEQ
 .word ZEQ
 .word BRANCH
 .word 10
 .word DROP
 .word DROP
 .word DROP
 .word ZERO
 .WORD SEMIS

;~~~
L2c00 .byt 2 | bit7
 .byt "M","1"|bit7
 .word L2b94
M1
 .word DODOES
M1DO
 .word DPTR
 .word 0, 0

;~~~
L2c0d .byt 2 | bit7
 .asc "M","2"|bit7
 .word L2c00
M2
 .word DODOES
M2DO
 .word DPTR
 .word 0, 0

;~~~
L2c1a .byt 4 | bit7
 .asc "($_",")"|bit7
 .word L2c0d
PDUND
 .word DOCOL
 .word TWOP
 .word SWAP
 .word OVER
 .word STORE
 .word TWOP
 .word STORE
 .word SEMIS

;~~~
L2c31 .byt 2 | bit7 | bit6
 .byt "$","_"|bit7
 .word L2c1a
DUND
 .word DOCOL
 .word TICK
 .word STATE
 .word FETCH
 .word ZBRAN
 .word 10
 .word COMPILE
 .word PDUND
 .word BRANCH
 .word 4
 .word PDUND
 .word SEMIS

;~~~
L2c4e .byt 2 | bit7
 .asc "M","3"|bit7
 .word L2c31
M3
 .word DOVAR
 .word 0

;~~~
L2c57 .byt 6 | bit7
 .asc "MATCH","$"|bit7
 .word L2c4e
MATCHD
 .word DOCOL
 .word ZERO
 .word M3
 .word STORE
 .word LIT
 .word M1DO
 .word PDUND
 .word OVER
 .word OVER
 .word ONE
 .word M1
 .word SWAP
 .word DROP
 .word MIDD
 .word LIT
 .word M2DO
 .word PDUND
 .word M1
 .word SWAP
 .word DROP
 .word OVER
 .word GT
 .word ZBRAN
 .word 12
 .word DROP
 .word DROP
 .word ZERO
 .word BRANCH
 .word 50
 .word DUP
 .word ZERO
 .word PDO
 .word M1
 .word M2
 .word EQD
 .word ZEQ
 .word M3
 .word FETCH
 .word PLUS
 .word ZEQ
 .word ZBRAN
 .word 10
 .word I
 .word ONEP
 .word M3
 .word STORE
 .word LROTD
 .word PLOOP
 .word -32
 .word DROP
 .word DROP
 .word M3
 .word FETCH
 .word SEMIS

;~~~
L2ccc .byt 2 | bit7
 .asc "$","!"|bit7
 .word L2c57
DSTORE
 .word DOCOL
 .word DROP
 .word OVER
 .word OVER
 .word TWO
 .word NEGATE
 .word STORE
 .word SWAP
 .word ZERO
 .word PDO
 .word OVER
 .word OVER
 .word SWAP
 .word I
 .word PLUS
 .word CFETCH
 .word SWAP
 .word I
 .word PLUS
 .word CSTORE
 .word PLOOP
 .word -22
 .word DROP
 .word DROP
 .word SEMIS

;~~~
L2d03 .byt 7 | bit7
 .asc "(INPUT",")"|bit7
 .word L2ccc
PINPUT
 .word *+2
 ; $FFCC CLRCHN
	JSR $FFCF
	JMP PUSHOA

;~~~
L2d15 .byt 6 | bit7
 .asc "INPUT","$"|bit7
 .word L2d03
INPUT
 .word DOCOL
 .word DROP
 .word ZERO
 .word PINPUT
 .word DUP
 .word LIT
 .word $0d
 .word EQUAL
 .word ZBRAN
 .word 10
 .word DROP
 .word ONE
 .word BRANCH
 .word 20
 .word TOR
 .word OVER
 .word OVER
 .word PLUS
 .word RFROM
 .word SWAP
 .word CSTORE
 .word ONEP
 .word ZERO
 .word ZBRAN
 .word -42
 .word SWAP
 .word TWO
 .word NEGATE
 .word STORE
 .word SEMIS

;~~~
L2d5a .byt 10 | bit7
 .asc "NEXT-MATC","H"|bit7
 .word L2d15
NXTMATCH
 .word DOCOL
 .word M3
 .word FETCH
 .word NEGATE
 .word M3
 .word FETCH
 .word ROT
 .word OVER
 .word PLUS
 .word ROT
 .word M1
 .word MATCHD
 .word DASHDUP
 .word ZEQ
 .word ZBRAN
 .word 12
 .word SWAP
 .word DROP
 .word ZERO
 .word BRANCH
 .word 4
 .word PLUS
 .word DUP
 .word M3
 .word STORE
 .word SEMIS

;~~~
L2d9b .byt 2 | bit7
 .asc "P","1"|bit7
 .word L2d5a
P1
 .word DODOES
P1DO
 .word DPTR
 .word 0, 0

;~~~
L2da8 .byt 8 | bit7
 .asc "MATCHES","$"|bit7
 .word L2d9b
MATCHESD
 .word DOCOL
 .word TOR
 .word TOR
 .word LIT
 .word P1DO
 .word PDUND
 .word ZERO
 .word P1
 .word RFROM
 .word RFROM
 .word MATCHD
 .word DASHDUP
 .word ZBRAN
 .word 14
 .word P1
 .word NXTMATCH
 .word DASHDUP
 .word ZEQ
 .word ZBRAN
 .word -10
 .word SEMIS

;~~~
L2ddd .byt 3 | bit7
 .asc '"',"!",'"'|bit7
 .word L2da8
QSTOREQ
 .word DOCOL
 .word TOR
 .word ROT
 .word ROT
 .word RFROM
 .word ROT
 .word ROT
 .word DSTORE
 .word SEMIS

;~~~
L2df5 .byt 4 | bit7
 .asc "(",'"',"!",")"|bit7
 .word L2ddd
PQSTORE
 .word DOCOL
 .word RFETCH
 .word COUNT
 .word DUP
 .word ONEP
 .word RFROM
 .word PLUS
 .word TOR
 .word QSTOREQ
 .word SEMIS

L2e10 .byt 2 | bit7 | bit6
 .byt '"',"!"|bit7
 .word L2df5
QSTORE
 .word DOCOL
 .word LIT
 .word $22
 .word STATE
 .word FETCH
 .word ZBRAN
 .word 20
 .word COMPILE
 .word PQSTORE
 .word WORD
 .word HERE
 .word CFETCH
 .word ONEP
 .word ALLOT
 .word BRANCH
 .word 10
 .word WORD
 .word HERE
 .word COUNT
 .word QSTOREQ
 .word SEMIS

;~~~
L2e3f .byt 8 | bit7
 .byt "REPLACE","$"|bit7
 .word L2e10
REPLACED
 .word DOCOL
 .word ROT
 .word MIN
 .word DASHDUP
 .word ZBRAN
 .word 28
 .word ZERO
 .word PDO
 .word OVER
 .word OVER
 .word SWAP
 .word I
 .word PLUS
 .word CFETCH
 .word SWAP
 .word I
 .word PLUS
 .word PLOOP
 .word -20
 .word DROP
 .word DROP
 .word SEMIS

;~~~
L2e76 .byt 2 | bit7
 .asc "$","+"|bit7
 .word L2e3f
DOLPLUS
 .word DOCOL
 .word SWAP
 .word TOR
 .word TOR
 .word RFETCH
 .word OVER
 .word PLUS
 .word ROT
 .word SWAP
 .word OVER
 .word TWO
 .word NEGATE
 .word STORE
 .word PLUS
 .word RFROM
 .word RFROM
 .word SWAP
 .word DASHDUP
 .word ZBRAN
 .word 28
 .word ZERO
 .word PDO
 .word OVER
 .word OVER
 .word I
 .word PLUS
 .word CFETCH
 .word SWAP
 .word I
 .word PLUS
 .word CSTORE
 .word PLOOP
 .word -20
 .word DROP
 .word DROP
 .word SEMIS

;~~~
L2ec3 .byt 6 | bit7
 .asc "ASCII","$"|bit7
 .word L2e76
ASCIID
 .word DODOES
 .word DODSTR
 .word 0
 .byt $20,$20,$20,$20,$20,$20,$20,$20,$20,$20
 .byt $20,$20,$20,$20,$20,$20,$20,$20,$20
 .byt $aa,$aa,$aa,$aa,$aa,$aa,$aa,$aa
 .byt $aa,$aa,$aa,$aa,$aa,$aa,$aa,$aa
 .byt $aa,$aa,$aa,$aa,$aa,$aa,$aa,$aa
 .byt $aa,$aa,$aa,$aa,$aa
 .asc "11911"

 .byt 7 | bit7
 .asc "DATAIN","T"|bit7
 .asc "___________________"

;~~~
L2f22 .byt 7 | bit7
 .asc "NOSPAC","E"|bit7
 .word L2ec3
NOSPACE
 .word DOCOL
 .word DUP
 .word ZBRAN
 .word 48
 .word OVER
 .word CFETCH
 .word BL
 .word EQUAL
 .word ZBRAN
 .word 30
 .word ONE
 .word NEGATE
 .word DUP
 .word ZBRAN
 .word 14
 .word SWAP
 .word ONEP
 .word SWAP
 .word ZERO
 .word BRANCH
 .word 4
 .word ONE
 .word BRANCH
 .word 4
 .word ONE
 .word ZBRAN
 .word -44
 .word SEMIS

;~~~
L2f64 .byt 6 | bit7
 .asc "FDIGI","T"|bit7
 .word L2f22
FDIGIT
 .word DOCOL
 .word DUP
 .word ZBRAN
 .word 54
 .word OVER
 .word CFETCH
 .word LIT
 .word 10
 .word DIGIT
 .word ZEQ
 .word ZBRAN
 .word 30
 .word ONE
 .word NEGATE
 .word DUP
 .word ZBRAN
 .word 14
 .word SWAP
 .word ONEP
 .word SWAP
 .word ZERO
 .word BRANCH
 .word 4
 .word ONE
 .word BRANCH
 .word 6
 .word DROP
 .word ONE
 .word ZBRAN
 .word -50
 .word SEMIS

;~~~
L2fab .byt 7 | bit7
 .asc "NUMBER","$"|bit7
 .word L2f64
NUMBERD
 .word DOCOL
 .word FDIGIT
 .word DASHDUP
 .word ZBRAN
 .word 112
 .word TOR
 .word ZERO
 .word ZERO
 .word ROT
 .word RFETCH
 .word ZEQ
 .word ZBRAN
 .word 10
 .word TOR
 .word ZERO
 .word BRANCH
 .word 38
 .word DUP
 .word TOR
 .word CFETCH
 .word LIT
 .word 10
 .word DIGIT
 .word DASHDUP
 .word ZEQ
 .word ZBRAN
 .word 18
 .word RFROM
 .word RFROM
 .word ONE
 .word NEGATE
 .word TOR
 .word ONEP
 .word TOR
 .word ZERO
 .word ZBRAN
 .word 38
 .word SWAP
 .word LIT
 .word 10
 .word USTAR
 .word DROP
 .word ROT
 .word LIT
 .word 10
 .word USTAR
 .word DPLUS
 .word RFROM
 .word ONEP
 .word RFROM
 .word ONE
 .word NEGATE
 .word TOR
 .word BRANCH
 .word -90
 .word RFROM
 .word RFROM
 .word ONE
 .word BRANCH
 .word 4
 .word ZERO
 .word SEMIS

;~~~
L3031 .byt 7 | bit7
 .asc "GETSTR","$"|bit7
 .word L2fab
GETSTRD
 .word DOCOL
 .word ASCIID
 .word INPUT
 .word ASCIID
 .word NOSPACE
 .word ASCIID
 .word DSTORE
 .word ASCIID
 .word SEMIS

;~~~
L304d .byt 9 | bit7
 .asc "DOUBLEIN","P"|bit7
 .word L3031
DOUBLEINP
 .word DOCOL
 .word GETSTRD
 .word DASHDUP
 .word ZBRAN
 .word 24
 .word NUMBERD
 .word ZBRAN
 .word 10
 .word DROP
 .word DROP
 .word BRANCH
 .word 6
 .word ZEQ
 .word ZERO
 .word BRANCH
 .word 6
 .word ZEQ
 .word ZERO
 .word SEMIS

;~~~
L307f .byt 9 | bit7
 .byt "SINGLEIN","P"|bit7
 .word L304d
SINGLEINP
 .word DOCOL
 .word DOUBLEINP
 .word DROP
 .word SEMIS

;~~~
L3093 .byt 3 | bit7
 .asc "FP","!"|bit7
 .word L307f
FPSTORE
 .word *+2
 lda #$01
 jsr P048a
 inx
 lda $00,x
 inx
 sta ($7a),y
 iny
 cpy #$05
 bne $30a1
 jmp NEXT

;~~~
L30ae .byt 3 | bit7
 .asc "FP","@"|bit7
 .word L3093
FPFETCH
 .word *+2
 lda #$01
 jsr P048a
 ldy #$05
 dey
 lda ($7a),y
 dex
 dex
 sta $01,x
 dey
 bmi $30ce
 lda ($7a),y
 sta $00,x
 jmp $30bd
 lda #$00
 sta $00,x
 JMP NEXT

;~~~
L30d5 .byt 4 | bit7
 .asc "VAR","%"|bit7
 .word L30ae
VARPCT
 .word DOCOL
 .word BUILDS
 .word LIT
 .word 5
 .word ALLOT
 .word DOES
VAREX
 .word SEMIS

;~~~
L30ea .byt 4 | bit7
 .asc "ACC","1"|bit7
 .word L30d5
ACC1
 .word DODOES
 .word VAREX
 .byt $91,$43,$50,$00,$00

;~~~
L30fa .byt 4 | bit7
 .asc "ACC","2"|bit7
 .word L30ea
ACC2
 .word DODOES
 .word VAREX
 .byt $93,$74,$24,$00,$00

;~~~
L310a .byt 4 | bit7
 .asc "ACC","3"|bit7
 .word L30fa
ACC3
 .word DODOES
 .word VAREX
 .byt $83,$00,$00,$00,$05

;~~~
L311a .byt 6 | bit7
 .asc "FPSWA","P"|bit7
 .word L310a
FPSWAP
 .word DOCOL
 .word ACC1
 .word FPSTORE
 .word ACC2
 .word FPSTORE
 .word ACC1
 .word FPFETCH
 .word ACC2
 .word FPFETCH
 .word SEMIS

;~~~
L3137 .byt 5 | bit7
 .asc "FPRO","T"|bit7
 .word L311a
FPROT
 .word DOCOL
 .word ACC3
 .word FPSTORE
 .word FPSWAP
 .word ACC3
 .word FPFETCH
 .word FPSWAP
 .word SEMIS

;~~~
L314f .byt 5 | bit7
 .asc "FPDU","P"|bit7
 .word L3137
FPDUP
 .word DOCOL
 .word ACC1
 .word FPSTORE
 .word ACC1
 .word FPFETCH
 .word ACC1
 .word FPFETCH
 .word SEMIS

;~~~
L3167 .byt 3 | bit7
 .asc "FP","T"|bit7
 .word L314f
FPT
 .word DOVAR
 .word $3105

;~~~
L3171 .byt 4 | bit7
 .asc "(FP",")"|bit7
 .word L3167
PFP
 .word *+2
 stx stash
 jsr storezp ; bug?
 lda $316f
 sta $77
 lda $3170
 sta $78
 jsr $0076
; $CE29 Convert an ASCII string into a numeral in FPAcc. #1, VAL
;and other routines use this to evaluate a numeral which is
;in string form. GETCHR should point to this string before
;entering this routine; then JSR 0070/ JSR CE29 (or what-
;ever other values apply for BASICs 1 and 2) scans the
;string and puts the result in floating-point accumulator #1.
;E . + - and leading and other spaces are speciaHy checked;
;the routine to multiply by 10 adds together consecutive digits
;as they are encountered.
 jsr $ce29
 ldx #$15
 ldy #$31
; $CCFD Store Floating-point accumulator #1 into memory.
; $CD0A Finally, this entry point is the one to select when the X and
;Y values have to be set explicitly and don't correspond to
;those cast in the silicon of ROM.
 jsr $cd0a
 jsr storezp
 ldx stash
 jmp NEXT

;~~~
L319e .byt 3 | bit7
 .asc "FP","%"|bit7
 .word L3171
FPPCT
 .word DOCOL
 .word LIT
 .word 32
 .word WORD
 .word ZERO
 .word HERE
 .word CFETCH
 .word HERE
 .word ONEP
 .word PLUS
 .word CSTORE
 .word HERE
 .word ONEP
 .word FPT
 .word STORE
 .word PFP
 .word ACC3
 .word FPFETCH
 .word SEMIS

;~~~
L31ca .byt 7 | bit7
 .asc "(FPLIT",")"|bit7
 .word L319e
PFPLIT
 .word *+2
 dex
 dex
 dex
 dex
 dex
 lda (ip),y
 sta $00,x
 iny
 cpy #$05
 beq $31e8
 inx
 jmp $31db
 dex
 dex
 dex
 dex
 dex
 lda #$00
 sta $00,x
 clc
 lda ip
 adc #$05
 sta ip
 bcc $31fc
 inc ip+1
 JMP NEXT

;~~~
L31ff .byt 2 | bit7 | bit6
 .asc "F","P"|bit7
 .word L31ca
FP
 .word DOCOL
 .word FPPCT
 .word STATE
 .word FETCH
 .word ZBRAN
 .word 18
 .word COMPILE
 .word PFPLIT
 .word LIT
 .word 256
 .word SLASH
 .word CCOMMA
 .word COMMA
 .word COMMA
 .word SEMIS

;~~~
L3222 .byt 3 | bit7
 .asc "S>","P"|bit7
 .word L31ff
 .word *+2 ; this word is not really a primitive
S2P
 lda #$01
 jsr P048a
 ldy #$00
 inx
 lda $00,x
 sta ($7a),y
 inx
 iny
 cpy #$05
 bne $3232
 stx stash
 jsr storezp
 lda $1d2d
 ldy $1d2e
; $CCD8 Load Floating-point accumulator from memory. This routine
;takes a value held as a 5-byte floating-point number and
;puts it into floating-point accumulator #1. In the process it
;unpacks the sign byte and stores this separately. The bytes
;are taken from the memory locations pointed at by A (low)
;and Y (high). See, for an example, the routine starting at
;D9DO/DAOA/GC34 which loads 10 into floating-point accumul-
;ator #1 then divides this into FPAcc. #2. The locations used
;are $5E (exponent) ,$5F-$62 (mantissa), and $63 (sign).
;Note that zero sign bit means plus, #FF means minus.
 jsr $ccd8
 rts

;~~~
L324b .byt 5 | bit7
 .asc "(FP.",")"|bit7
 .word L3222
PFPDOT
 .word *+2
 jsr S2P
 ldx #$0f
 lda $0100,x
 pha
 dex
 bpl $325a
; $CF93 Convert contents of Floating-point accumulator #1 into ASCII
;string starting at $0 1 ua. On exit, A and Y hold #0 and #1,
;pointing to $0100, so that the print routine CA27/CA1C/BBlD
;can print the result as a string. Note that the buffer is at
;the lowest end of the stack, inaccessible to BASIC. Chapter
;2 has a table showing how this fomatting process works in
;practice. Note the zero terminating byte, and the special-
;case processing for zero. PRINT USING, in Chapter 5,
;demonstrates how this routine may be adapted to get other
;output formats.
;Note that FPAcc. Hl is changed when this routine has been
;run. The tables of constants following this routine are used
;in the comparison / conversion process. The later ones deal
;with TI$. And the three values tabled before this routine
;are used to decide when scientific format should be used.
 jsr $cf93
 ldx #$00
 lda $0100,x
 beq $3272
; $FFD2 CHROUT
 jsr $ffd2
 inx
 jmp $3266
 ldx #$00
 pla
 sta $0100,x
 inx
 cpx #$10
 bne $3274
 jsr storezp
 ldx stash
 JMP NEXT

;~~~
L3285 .byt 3 | bit7
 .asc "FP","."|bit7
 .word L324b
FPDOT
 .word DOCOL
 .word ACC3
 .word PFPDOT
 .word SEMIS

;~~~
L3293 .byt 6 | bit7
 .asc "(JMPV",")"|bit7
 .word L3285
 .word *+2
PJMPV
 jmp $cc45

;~~~
L32a1 .byt 6 | bit7
 .asc "JMPVE","C"|bit7
 .word L3293
JMPVEC
 .word DOCONST
 .word PJMPV+1

;~~~
L32ae .byt 3 | bit7
 .asc "(N",")"|bit7
 .word L32a1
PN ; someplace in zero page backup
 .word DOCONST
 .word $1d2d

;~~~
L32b8 .byt 3 | bit7
 .asc "2P","F"|bit7
 .word L32ae
N2PF
 .word *+2
 jsr S2P
 lda $316f
 ldy $3170
 jsr PJMPV
 ldx $1d2d
 ldy $1d2e
; $CCFD Store Floating-point accumulator #1 into memory.
; $CD0A Finally, this entry point stores the value in the location which
;($46) points to (or ($98) in BASIC 1). This is used by LET
;and by the FOR-NEXT loop to store an evaluated quantity 
;in a variable's storage after a BASIC program.
 jsr $cd0d
 jsr storezp
 ldx stash
 JMP NEXT

;~~~
L32dd .byt 3 | bit7
 .asc "2O","P"|bit7
 .word L32b8
N2OP
 .word DOCOL
 .word BUILDS
 .word COMMA
 .word DOES
N2DO
 .word FETCH
 .word JMPVEC
 .word STORE
 .word FPSWAP
 .word ACC2
 .word FPSTORE
 .word ACC3
 .word ACC2
 .word FPT
 .word STORE
 .word N2PF
 .word ACC3
 .word FPFETCH
 .word SEMIS

;~~~
L3307 .byt 2 | bit7
 .asc "F","*"|bit7
 .word L32dd
FSTAR
 .word DODOES
 .word N2DO
 .word $cb5e

;~~~
L3312 .byt 2 | bit7
 .asc "F","+"|bit7
 .word L3307
FPLUS
 .word DODOES
 .word N2DO
 .word $c99d

;~~~
L331d .byt 2 | bit7
 .asc "F","-"|bit7
 .word L3312
FMINUS
 .word DODOES
 .word N2DO
 .word $c986

;~~~
L3328 .byt 2 | bit7
 .asc "F","/"|bit7
 .word L331d
FSLASH
 .word DODOES
 .word N2DO
 .word $cc45

;~~~
L3333 .byt 3 | bit7
 .asc "1O","P"|bit7
 .word L3328
N1OP
 .word DOCOL
 .word BUILDS
 .word COMMA
 .word DOES
FP1OPDO
 .word FETCH
 .word JMPVEC
 .word STORE
 .word ACC3
 .word N2PF
 .word ACC3
 .word FPFETCH
 .word SEMIS

;~~~
L3351 .byt 4 | bit7
 .asc "LOG","("|bit7
 .word L3333
LOG
 .word DODOES
 .word FP1OPDO
 .word $cb20

;~~~
L335e .byt 4 | bit7
 .asc "SQR","("|bit7
 .word L3351
FSQR
 .word DODOES
 .word FP1OPDO
 .word $d108

;~~~
L336b .byt 4 | bit7
 .asc "ABS","("|bit7
 .word L335e
FABS
 .word DODOES
 .word FP1OPDO
 .word $cd8e

;~~~
L3378 .byt 4 | bit7
 .asc "INT","("|bit7
 .word L336b
INT
 .word DODOES
 .word FP1OPDO
 .word $ce02

;~~~
L3385 .byt 4 | bit7
 .asc "EXP","("|bit7
 .word L3378
EXP
 .word DODOES
 .word FP1OPDO
 .word $d184

;~~~
L3392 .byt 4 | bit7
 .asc "COS","("|bit7
 .word L3385
 .word DODOES
 .word FP1OPDO
 .word $d282

;~~~
L339f .byt 4 | bit7
 .byt "SIN","("|bit7
 .word L3392
SIN
 .word DODOES
 .word FP1OPDO
 .word $d289

;~~~
L33ac .byt 4 | bit7
 .asc "TAN","("|bit7
 .word L339f
TAN
 .word DODOES
 .word FP1OPDO
 .word $d2d2

;~~~
L33b9 .byt 4 | bit7
 .asc "ATN","("|bit7
 .word L33ac
ATN
 .word DODOES
 .word FP1OPDO
 .word $d32c

;~~~
L33c6 .byt 4 | bit7
 .asc "RND","("|bit7
 .word L33b9
RND
 .word DODOES
 .word FP1OPDO
 .word $d229

;~~~
L33d3 .byt 4 | bit7
 .asc "SGN","("|bit7
 .word L33c6
SGN
 .word DODOES
 .word FP1OPDO
 .word $cd6f

;~~~
L33e0 .byt 5 | bit7
 .asc "(EXP",")"|bit7
 .word L33d3
PEXP
 .word *+2
 jsr S2P
; $CD42 Round and copy accumulator #1 into accumulator #2. Calls the
;following routine, moves 6 bytes of the accumulator (more
;elegantly than the last routine! ), and zeroises the rounding
;byte. Each of the se short pieces of code therefore loses a
;little information.
 jsr $cd42
 lda $316f
 ldy $3170
 jsr $329e
 ldx $1d2d
 ldy $1d2e
; $CD0A Store Floating-point accumulator #1 into memory.
 jsr $cd0a
 jsr storezp
 ldx stash
 jmp NEXT

;~~~
L340a .byt 2 | bit7
 .asc "F",94 | bit7
 .word L33e0
FPOWER
 .word DOCOL
 .word LIT
 .word $d10f
 .word JMPVEC
 .word STORE
 .word ACC2
 .word FPSTORE
 .word ACC2
 .word FPT
 .word STORE
 .word ACC3
 .word PEXP
 .word ACC3
 .word FPFETCH
 .word SEMIS

;~~~
L342d .byt 5 | bit7
 .asc "FPCO","N"|bit7
 .word L340a
FPCON
 .word DOCOL
 .word BUILDS
 .word LIT
 .word 256
 .word SLASH
 .word CCOMMA
 .word COMMA
 .word COMMA
 .word DOES
 .word FPFETCH
 .word SEMIS

;~~~
L344b .byt 4 | bit7
 .asc "(<>",")"|bit7
 .word L342d
PNE
 .word *+2
 jsr $322a
 lda $316f
 ldy $3170
 ; $CD91 Compare Floating-point accumulator #1 with 5-byte floating-
;point number. A (low byte) and Y (high byte) point to the
;5-byte value in memory. On exit, the accumulator (A, not
;one of the floating-point variety) indicates the relative sizes:
;A=O means the values are equal.
;A=l means that accumulator #1 > memory.
;A=#FF means that accumulator #1 < memory.
 jsr $cd91
 sta $316f
 jsr storezp
 ldx stash
 lda $316f
 jmp PUSHOA

;~~~
L346e .byt 3 | bit7
 .asc "FP","?"|bit7
 .word L344b
FPQUES
 .word DOCOL
 .word ACC2
 .word FPSTORE
 .word ACC2
 .word FPT
 .word STORE
 .word ACC3
 .word PNE
 .word SEMIS

;~~~
L3486 .byt 2 | bit7
 .asc "F",">"|bit7
 .word L346e
FGT
 .word DOCOL
 .word FPQUES
 .word ONE
 .word EQUAL
 .word SEMIS

;~~~
L3495 .byt 2 | bit7
 .asc "F","<"|bit7
 .word L3486
FLT
 .word DOCOL
 .word FPQUES
 .word LIT
 .word $ff
 .word EQUAL
 .word SEMIS

;~~~
L34a6 .byt 2 | bit7
 .asc "F","="|bit7
 .word L3495
FEQ
 .word DOCOL
 .word FPQUES
 .word ZEQ
 .word SEMIS

;~~~
L34b3 .byt 3 | bit7
 .asc "F<",">"|bit7
 .word L34a6
FNE
 .word DOCOL
 .word FPQUES
 .word ZEQ
 .word ZEQ
 .word SEMIS

;~~~
L34c3 .byt 6 | bit7
 .asc "FPDRO","P"|bit7
 .word L34b3
FPDROP
 .word DOCOL
 .word ACC3
 .word FPSTORE
 .word SEMIS

;~~~
L34d4 .byt 4 | bit7
 .asc "SQR","("|bit7
 .word L34c3
SQR
 .word DOCOL
 .word FABS
 .word FSQR
 .word SEMIS

;~~~
L34e3 .byt 2 | bit7
 .asc "F","/"|bit7
 .word L34d4
FDIV
 .word DOCOL
 .word DUP
 .word ZEQ
 .word ZBRAN
 .word 10
 .word FPSWAP
 .word FPDROP
 .word BRANCH
 .word 4
 .word FSLASH
 .word SEMIS

;~~~
L34fe .byt 7 | bit7
 .asc "FPARRA","Y"|bit7
 .word L34e3
FPARRAY
 .word DOCOL
 .word BUILDS
 .word LIT
 .word 5
 .word STAR
 .word ALLOT
 .word DOES
 .word SWAP
 .word LIT
 .word 5
 .word STAR
 .word PLUS
 .word SEMIS

;~~~
L3522 .byt 7 | bit7
 .asc "(FLOAT",")"|bit7
 .word L34fe
PFLOAT
 .word *+2
 stx stash
 jsr storezp
 ldy $3115
 lda $3116
; $C4BC Convert 2-byte integer into floating-point. On entry,
;y holds the low byte and A the high byte of an integer
;in the range 0-65535. This routine converts it into floating-
;point form, leaving it in FPAcc. #1 (i.e. $5E holds the
;exponent, $5F-$62 hold the mantissa, and $63 is the sign.)
 jsr $c4bc
 ldx #$15
 ldy #$31
; $CD0A Store Floating-point accumulator #1 into memory.
 jsr $cd0a
 jsr storezp
 ldx stash
 JMP NEXT

;~~~
L354b .byt 5 | bit7
 .asc "FLOA","T"|bit7
 .word L3522
FLOAT
 .word DOCOL
 .word ACC3
 .word STORE
 .word PFLOAT
 .word ACC3
 .word FPFETCH
 .word SEMIS

;~~~
L3561 .byt 7 | bit7
 .asc "(INTEG",")"|bit7
 .word L354b
PINTEG
 .word *+2
 jsr S2P
; $CDD1 Convert Floating-point #1 into integer, within FPAcc.#1.
;This routine is called by D6DA/D6D2/C92D which, however,
;also treats the fixed-point number as an address, which it
;stores in ($11), or, with BASIC 1, in ($08).
 jsr $cdd1
 ldx $1d2d
 ldy $1d2e
; $CD0A Store Floating-point accumulator #1 into memory.
 jsr $cd0a
 jsr storezp
 ldx stash
 JMP NEXT

;~~~
L3584 .byt 7 | bit7
 .asc "INTEGE","R"|bit7
 .word L3561
INTEGER
 .word DOCOL
 .word ACC3
 .word PINTEG
 .word ACC3
 .word THREE
 .word PLUS
 .word CFETCH
 .word LIT
 .word 256
 .word STAR
 .word ACC3
 .word LIT
 .word 4
 .word PLUS
 .word CFETCH
 .word PLUS
 .word SEMIS

;~~~
L35b0 .byt 8 | bit7
 .byt "DINTEGE","R"|bit7
 .word L3584
DINTEGER
 .word DOCOL
 .word INTEGER
 .word ACC3
 .word ONEP
 .word CFETCH
 .word LIT
 .word $100
 .word STAR
 .word ACC3
 .word TWOP
 .word CFETCH
 .word PLUS
 .word SEMIS

;~~~
L35d5 .byt 4 | bit7
 .asc "DSA","V"|bit7
 .word L35b0
DSAV
 .word DOVAR
 .word 1

;~~~
L35e0 .byt 6 | bit7
 .asc "DFLOA","T"|bit7
 .word L35d5
DFLOAT
 .word DOCOL
 .word DUP
 .word ZLT
 .word DUP
 .word TOR
 .word PLUS
 .word DSAV
 .word STORE
 .word DUP
 .word ZLT
 .word RFETCH
 .word XOR
 .word RFROM
 .word SWAP
 .word ZBRAN
 .word 34
 .word ZBRAN
 .word 15
 .word FLOAT
 .word PFPLIT
 .byt $91,$80,$00,$00,$00
 .word BRANCH
 .word 11
 .word FLOAT
 .word PFPLIT
 .byt $91,$00,$00,$00,$00
 .word FPLUS
 .word BRANCH
 .word 6
 .word DROP
 .word FLOAT
 .word DSAV
 .word FETCH
 .word FLOAT
 .word PFPLIT
 .byt $91,$00,$00,$00,$00
 .word FSTAR
 .word FPLUS
 .word SEMIS

;~~~
L3640 .byt 6 | bit7 | bit6
 .asc "?????","?"|bit7
 .word L35e0
QQQ6
 .word DODOES
 .word DOVOC
 .word $a081
 .word L37d4
V3651
 .word V2167


L3653 .byt 4 | bit7
 .byt "ERR","0"|bit7
 .word ROOTVOCAB
ERR0
 .word DODOES
 .word STROUT
 .byt 14
MUNDEF
 .byt 14
 .asc "UNDEFINED WORD"

L366e .byt 4 | bit7
L366f .asc "ERR","1"|bit7
 .word L3653
ERR1
 .word DODOES
 .word STROUT
 .byt 11
MEMPTY
 .byt 11
 .asc "EMPTY STACK"


L3686 .byt 4 | bit7
 .asc "ERR","2"|bit7
 .word L366e
ERR2
 .word DODOES
 .word STROUT
 .byt 15
MDICFUL
 .byt 15
 .asc "DICTIONARY FULL"


L36a2 .byt 4 | bit7
 .asc "ERR","4"|bit7
 .word L3686
ERR4
 .word DODOES
 .word STROUT
 .byt 12
MISNTUNIQ
 .byt 12
 .asc "ISN'T UNIQUE"


L36bb .byt 4 | bit7
 .asc "ERR","5"|bit7
 .word L36a2
ERR5
 .word DODOES
 .word STROUT
 .byt 13
MCASLOAD
 .byt 13
 .asc "CASLOAD ERROR"

L36d5 .byt 4 | bit7
 .asc "ERR","7"|bit7
 .word L36bb
ERR7
 .word DODOES
 .word STROUT
 .byt 10
MFULLSTACK
 .byt 10
 .asc "FULL STACK"

L36ec .byt 5 | bit7
 .asc "ERR1","7"|bit7
 .word L36d5
ERR17
 .word DODOES
 .word STROUT
 .byt 16
MCOMPONLY
 .byt 16
 .asc "COMPILATION ONLY"

L370a .byt 5 | bit7
 .byt "ERR1","8"|bit7
 .word L36ec
ERR18
 .word DODOES
 .word STROUT
 .byt 14
MEXECONLY
 .byt 14
 .asc "EXECUTION ONLY"

L3726 .byt 5 | bit7
 .byt "ERR1","9"|bit7
 .word L370a
ERR19
 .word DODOES
 .word STROUT
 .byt 23
MCONDUNPAIR
 .byt 23
 .asc "CONDITIONALS NOT PAIRED"

L374b .byt 5 | bit7
 .byt "ERR2","0"|bit7
 .word L3726
ERR20
 .word DODOES
 .word STROUT
 .byt 23
MDEFUNFIN
 .byt 23
 .asc "DEFINITION NOT FINISHED"

L3770 .byt 5 | bit7
 .asc "ERR2","1"|bit7
 .word L374b
ERR21
 .word DODOES
 .word STROUT
 .byt 14
MPROTWORD
 .byt 14
 .asc "PROTECTED WORD"

L378c .byt 5 | bit7
 .asc "ERR2","3"|bit7
 .word L3770
ERR23
 .word DODOES
 .word STROUT
 .byt 26
MOFFSCR
 .byt 26
 .asc "OFF CURRENT EDITING SCREEN"

L37b4 .byt 5 | bit7
 .asc "ERR2","4"|bit7
 .word L378c
ERR24
 .word DODOES
 .word STROUT
 .byt 18
MDECLVOC
 .byt 18
 .asc "DECLARE VOCABULARY"

L37d4
 .byt 11 | bit7
 .byt "CLEAR-ERRO","R"|bit7
 .word L37b4
CLERR
 .word DOCOL
 .word LIT
 .word 26
 .word ZERO
 .word PDO
P37EC
 .word ZERO
 .word I
 .word PERROR
 .word STORE
 .word PLOOP
 .word P37EC-*
 .word SEMIS

;~~~
L37fa .byt 7 | bit7
 .asc "FNUMBE","R"|bit7
 .word L3640
FNUMBER
 .word DOCOL
 .word FPT
 .word STORE
 .word PFP
 .word ACC3
 .word FPFETCH
 .word SEMIS

;~~~
L3812 .byt 3 | bit7
 .asc "CH","F"|bit7
 .word L37fa
CHF
 .word DOCOL
 .word ZERO
 .word SWAP
 .word COUNT
 .word OVER
 .word PLUS
 .word SWAP
 .word PDO
 .word I
 .word CFETCH
 .word LIT
 .word 46
 .word EQUAL
 .word ZBRAN
 .word 4
 .word ONEP
 .word PLOOP
 .word -18
 .word SEMIS

;~~~
L383e .byt 5 | bit7
 .asc "TRAN","S"|bit7
 .word L3812
TRANS
 .word DOCOL
 .word DUP
 .word CHF
 .word ZBRAN
 .word 16
 .word ONEP
 .word FNUMBER
 .word ONE
 .word DPL
 .word STORE
 .word BRANCH
 .word 4
 .word NUMBER
 .word SEMIS

;~~~
L3862 .byt 8 | bit7 | bit6
 .asc "FLITERA","L"|bit7
 .word L383e
FLITERAL
 .word DOCOL
 .word STATE
 .word FETCH
 .word ZBRAN
 .word P3887-*
 .word COMPILE
 .word PFPLIT
 .word LIT
 .word $100
 .word SLASH
 .word CCOMMA
 .word COMMA
 .word COMMA
P3887
 .word SEMIS

;~~~
L3889 .byt 8 | bit7 | bit6
 .asc "SETFLOA","T"|bit7
 .word L3862
SETFLOAT
 .word DOCOL
 .word LIT
 .word $386f
 .word TWO
 .word NEGATE
 .word LIT
 .word $12e0
 .word LIT
 .word 48
 .word PLUS
 .word STORE
 .word LIT
 .word $3848
 .word TWO
 .word NEGATE
 .word LIT
 .word $12e0
 .word LIT
 .word 36
 .word PLUS
 .word STORE
 .word SEMIS

 .byt 9 | bit7 | bit6
 .asc "SETDOUBL","E"|bit7
L38c0 .word L3889
SETDOUBLE
 .word DOCOL
 .word LIT
 .word $129e
 .word TWO
 .word NEGATE
 .word LIT
 .word $12e0
 .word LIT
 .word 48
 .word PLUS
 .word STORE
 .word LIT
 .word $1102
 .word TWO
 .word NEGATE
 .word LIT
 .word $12e0
 .word LIT
 .word 36
 .word PLUS
 .word STORE ; why not +! ?
 .word SEMIS

;~~~
L38f8 .byt 10 | bit7
 .asc "CLEAR-DIS","K"|bit7
 .word L38c0-9-1
CLRDISK
 .word DOCOL
 .word SD1
 .word LIT
 .word 165
 .word ONE
 .word PDO
P3911
 .word I
 .word $791c ; wut?
 .word I ; wut?
 .word DOT
 .word PDOTQ
 .byt 5
 .asc "CLEAR"
 .word CR
 .word PLOOP
 .word P3911-*
 .word CR
 .word PDOTQ
 .byt 4
 .asc "DONE"
 .word SEMIS

;~~~
L3932 .byt 5 | bit7
 .asc "D0>D","1"|bit7
 .word L38f8
D0TOD1
 .word DOCOL
 .word ONEP
 .word SWAP
 .word PDO
P3942
 .word I
 .word DISKLOAD
 .word I ; wut?
 .word I ; wut?
 .word $793b ; wut?
 .word PLOOP
 .word P3942-*
 .word SEMIS

;~~~
L3952 .byt 16 | bit7
 .asc "TRANSFER-SCREEN","S"|bit7
 .word L3932
XFERSCN
 .word DOCOL
 .word ONE
 .word LIT
 .word 27
 .word D0TOD1
 .word LIT
 .word 36
 .word LIT
 .word 39
 .word D0TOD1
 .word LIT
 .word 43
 .word LIT
 .word 54
 .word D0TOD1
 .word LIT
 .word 89
 .word LIT
 .word 98
 .word D0TOD1
 .word LIT
 .word 65
 .word LIT
 .word 65
 .word D0TOD1
 .word LIT
 .word 33
 .word LIT
 .word 33
 .word D0TOD1
 .word LIT
 .word 69
 .word LIT
 .word 76
 .word D0TOD1
 .word LIT
 .word 121
 .word LIT
 .word 121
 .word D0TOD1
 .word LIT
 .word 136
 .word LIT
 .word 145
 .word D0TOD1
 .word SEMIS

L39c1 .byt 5 | bit7
 .asc "D1>D","0"|bit7
 .word L3952
D1TOD0
 .word DOCOL
 .word ONEP
 .word SWAP
 .word PDO
P39d2
 .word I
 .word LIST
 .word DISKSAVE
 .word PLOOP
 .word P39d2-*
 .word SEMIS

TOPLINK
 .byt 15 | bit7
 .asc "ARCHIVE-SCREEN","S"|bit7
 .word L39c1
ARCHSCRN .word DOCOL
 .word ONE
 .word LIT
 .word 27
 .word D1TOD0
 .word LIT
 .word 33
 .word LIT
 .word 33
 .word D1TOD0
 .word LIT
 .word 36
 .word LIT
 .word 39
 .word D1TOD0
 .word LIT
 .word 43
 .word LIT
 .word 54
 .word D1TOD0
 .word LIT
 .word 69
 .word LIT
 .word 76
 .word D1TOD0
 .word LIT
 .word 89
 .word LIT
 .word 98
 .word D1TOD0
 .word LIT
 .word 136
 .word LIT
 .word 145
 .word D1TOD0
 .word LIT
 .word 65
 .word LIT
 .word 65
 .word D1TOD0
 .word LIT
 .word 121
 .word LIT
 .word 121
 .word D1TOD0
 .word SEMIS


 .byt 13
