; *** ERROR: Descending address: 000D-000F	4: Disk Status DS$ descriptor (length/ptr) ***

; *** ERROR: Descending address: 03e9		4.40 ***

; *** ERROR: Descending address: 03ea		4.40 ***

; *** ERROR: Descending address: 03eb		4.40 ***

; *** ERROR: Descending address: 03ec		4.40: Chime Time ***

; *** ERROR: Descending address: 03ed		4.40: Counter to speed TI by 6/5 ***

; *** ERROR: Descending address: e1aa		? ***



; 3: free space for 4K EPROM\stmdsp	BASIC Command Vectors			WORD

;	Commodore PET 8032 ROM Memory Map
;	V1.3	20 May 1995
;
; BASIC 4.0 Interpreter ROM ($B000 - $DFFF)
;
;  BASIC 4.0 Interpreter
;  Machine Language Monitor
;

 B000	sB000	.word B7C7 B6DD BD18 B882 BBA3 BBBD C120 BC01
 B010		.word B92F B82F B807 B8B2 B7B6 B812 B85C B8C5
 B020		.word B7C5 B8D5 C962 FFD4 FFD7 FFDA C4DB C959
 B030		.word BA87 BAA7 B7ED B62F B5ED BA8D FFDD FFBF
 B040		.word FFC2 BB79 B5D1 B7AB FF92 FF95 FF98 FF9B
 B050		.word FF9E FFA1 FFA4 FFA7 FFAA FFAD FFB0 FFB3
 B060		.word FFB6 FFB9 FFB3


; fundsp	BASIC Function Vectors			WORD

 B066		.word CD6F CE02 CD8E 0000 C4A8 C4C9 D108 D229
 B076		.word CB20 D184 D282 D289 D2D2 D32C C943 C8B2
 B086		.word C58E C8E3 C8C1 C822 C836 C862 C86D


; optab	BASIC Operator Vectors			DATA

; Each Operator Vector is preceded by a priority code.

 B094	sB094	.byte 79                       ;Y
 B095	sB095	.byte 9F                       ;.
 B096	sB096	.byte C9 79 88 C9 7B 60 CB 7B  ;IY.I{`K{
 B09E		.byte 47 CC 7F 11 D1 50 88 C0  ;gL..Qp..
 B0A6		.byte 46 85 C0 7D 4A D1 5A CB  ;f..}jQzK
 B0AE		.byte BE 64 B5 C0              ;.D..


; reslst	BASIC Command Keyword Table		DATA

 B0B2		.byte 45 4E C4 46 4F D2 4E 45  ;enDfoRne
 B0BA		.byte 58 D4 44 41 54 C1 49 4E  ;xTdatAin
 B0C2		.byte 50 55 54 A3 49 4E 50 55  ;put.inpu
 B0CA		.byte D4 44 49 CD 52 45 41 C4  ;TdiMreaD
 B0D2		.byte 4C 45 D4 47 4F 54 CF 52  ;leTgotOr
 B0DA		.byte 55 CE 49 C6 52 45 53 54  ;uNiFrest
 B0E2		.byte 4F 52 C5 47 4F 53 55 C2  ;orEgosuB
 B0EA		.byte 52 45 54 55 52 CE 52 45  ;returNre
 B0F2		.byte CD 53 54 4F D0 4F CE 57  ;MstoPoNw
 B0FA		.byte 41 49 D4 4C 4F 41 C4 53  ;aiTloaDs
 B102		.byte 41 56 C5 56 45 52 49 46  ;avEverif
 B10A		.byte D9 44 45 C6 50 4F 4B C5  ;YdeFpokE
 B112		.byte 50 52 49 4E 54 A3 50 52  ;print.pr
 B11A		.byte 49 4E D4 43 4F 4E D4 4C  ;inTconTl
 B122		.byte 49 53 D4 43 4C D2 43 4D  ;isTclRcm
 B12A		.byte C4 53 59 D3 4F 50 45 CE  ;DsySopeN
 B132		.byte 43 4C 4F 53 C5 47 45 D4  ;closEgeT
 B13A		.byte 4E 45 D7                 ;neW


; msclst	BASIC Misc. Keyword Table		DATA

 B13D		.byte 54 41 42 A8 54 CF 46 CE  ;tab.tOfN
 B145		.byte 53 50 43 A8 54 48 45 CE  ;spc.theN
 B14D		.byte 4E 4F D4 53 54 45 D0     ;noTsteP


; oplist	BASIC Operator Keyword Table		DATA

 B154		.byte AB AD AA AF DE 41 4E C4  ;.....anD
 B15C		.byte 4F D2 BE BD BC           ;oR...


; funlst	BASIC Function Keyword Table		DATA

 B161		.byte 53 47 CE 49 4E D4 41 42  ;sgNinTab
 B169		.byte D3 55 53 D2 46 52 C5 50  ;SusRfrEp
 B171		.byte 4F D3 53 51 D2 52 4E C4  ;oSsqRrnD
 B179		.byte 4C 4F C7 45 58 D0 43 4F  ;loGexPco
 B181		.byte D3 53 49 CE 54 41 CE 41  ;SsiNtaNa
 B189		.byte 54 CE 50 45 45 CB 4C 45  ;tNpeeKle
 B191		.byte CE 53 54 52 A4 56 41 CC  ;Nstr.vaL
 B199		.byte 41 53 C3 43 48 52 A4 4C  ;asCchr.l
 B1A1		.byte 45 46 54 A4 52 49 47 48  ;eft.righ
 B1A9		.byte 54 A4 4D 49 44 A4 47 CF  ;t.mid.gO


; -	Additional Action Keywords		DATA

 B1B1		.byte 43 4F 4E 43 41 D4 44 4F  ;concaTdo
 B1B9		.byte 50 45 CE 44 43 4C 4F 53  ;peNdclos
 B1C1		.byte C5 52 45 43 4F 52 C4 48  ;ErecorDh
 B1C9		.byte 45 41 44 45 D2 43 4F 4C  ;eadeRcol
 B1D1		.byte 4C 45 43 D4 42 41 43 4B  ;lecTback
 B1D9		.byte 55 D0 43 4F 50 D9 41 50  ;uPcopYap
 B1E1		.byte 50 45 4E C4 44 53 41 56  ;penDdsav
 B1E9		.byte C5 44 4C 4F 41 C4 43 41  ;EdloaDca
 B1F1		.byte 54 41 4C 4F C7 52 45 4E  ;taloGren
 B1F9		.byte 41 4D C5 53 43 52 41 54  ;amEscrat
 B201		.byte 43 C8 44 49 52 45 43 54  ;cHdirect
 B209		.byte 4F 52 D9 00              ;orY.


; errtab	Error Message Table			DATA

 B20D	sB20D	.byte 4E 45 58 54 20 57 49 54  ;next wit
 B215		.byte 48 4F 55 54 20 46 4F D2  ;hout foR
 B21D		.byte 53 59 4E 54 41 D8 52 45  ;syntaXre
 B225		.byte 54 55 52 4E 20 57 49 54  ;turn wit
 B22D		.byte 48 4F 55 54 20 47 4F 53  ;hout gos
 B235		.byte 55 C2 4F 55 54 20 4F 46  ;uBout of
 B23D		.byte 20 44 41 54 C1 49 4C 4C  ; datAill
 B245		.byte 45 47 41 4C 20 51 55 41  ;egal qua
 B24D		.byte 4E 54 49 54 D9 4F 56 45  ;ntitYove
 B255		.byte 52 46 4C 4F D7 4F 55 54  ;rfloWout
 B25D		.byte 20 4F 46 20 4D 45 4D 4F  ; of memo
 B265		.byte 52 D9 55 4E 44 45 46 27  ;rYundef'
 B26D		.byte 44 20 53 54 41 54 45 4D  ;d statem
 B275		.byte 45 4E D4 42 41 44 20 53  ;enTbad s
 B27D		.byte 55 42 53 43 52 49 50 D4  ;ubscripT
 B285		.byte 52 45 44 49 4D 27 44 20  ;redim'd 
 B28D		.byte 41 52 52 41 D9 44 49 56  ;arraYdiv
 B295		.byte 49 53 49 4F 4E 20 42 59  ;ision by
 B29D		.byte 20 5A 45 52 CF 49 4C 4C  ; zerOill
 B2A5		.byte 45 47 41 4C 20 44 49 52  ;egal dir
 B2AD		.byte 45 43 D4 54 59 50 45 20  ;ecTtype 
 B2B5		.byte 4D 49 53 4D 41 54 43 C8  ;mismatcH
 B2BD		.byte 53 54 52 49 4E 47 20 54  ;string t
 B2C5		.byte 4F 4F 20 4C 4F 4E C7 46  ;oo lonGf
 B2CD		.byte 49 4C 45 20 44 41 54 C1  ;ile datA
 B2D5		.byte 46 4F 52 4D 55 4C 41 20  ;formula 
 B2DD		.byte 54 4F 4F 20 43 4F 4D 50  ;too comp
 B2E5		.byte 4C 45 D8 43 41 4E 27 54  ;leXcan't
 B2ED		.byte 20 43 4F 4E 54 49 4E 55  ; continu
 B2F5		.byte C5 55 4E 44 45 46 27 44  ;Eundef'd
 B2FD		.byte 20 46 55 4E 43 54 49 4F  ; functio
 B305		.byte CE                       ;N


; okk	Misc. Messages				DATA

 B306		.byte 20 45 52 52 4F 52 00 20  ; error. 
 B30E		.byte 49 4E 20 00 0D 52 45 41  ;in ..rea
 B316		.byte 44 59 2E 0D 00 0D 42 52  ;dy....br
 B31E		.byte 45 41 4B 00              ;eak.


; fndfor	Find FOR/GOSUB Entry on Stack

 B322	iB322	TSX
 B323		INX
 B324		INX
 B325		INX
 B326		INX
 B327	iB327	LDA $0101,X
 B32A		CMP #$81
 B32C		BNE $B34F
 B32E		LDA $47
 B330		BNE $B33C
 B332		LDA $0102,X
 B335		STA $46		; Pointer: Index Variable for FOR/NEXT
 B337		LDA $0103,X
 B33A		STA $47
 B33C	iB33C	CMP $0103,X
 B33F		BNE $B348
 B341		LDA $46		; Pointer: Index Variable for FOR/NEXT
 B343		CMP $0102,X
 B346		BEQ $B34F
 B348	iB348	TXA
 B349		CLC
 B34A		ADC #$12
 B34C		TAX
 B34D		BNE $B327
 B34F	iB34F	RTS


; bltu	Open Space in Memory

 B350	iB350	JSR $B3A0	; reason	Check Memory Overlap
 B353		STA $2E		; Pointer End of BASIC Arrays (+1)
 B355		STY $2F
 B357		SEC
 B358		LDA $57
 B35A		SBC $5C
 B35C		STA $1F		; Utility Pointer Area
 B35E		TAY
 B35F		LDA $58
 B361		SBC $5D
 B363		TAX
 B364		INX
 B365		TYA
 B366		BEQ $B38B
 B368		LDA $57
 B36A		SEC
 B36B		SBC $1F		; Utility Pointer Area
 B36D		STA $57
 B36F		BCS $B374
 B371		DEC $58
 B373		SEC
 B374	iB374	LDA $55
 B376		SBC $1F		; Utility Pointer Area
 B378		STA $55
 B37A		BCS $B384
 B37C		DEC $56
 B37E		BCC $B384
 B380	iB380	LDA ($57),Y
 B382		STA ($55),Y
 B384	iB384	DEY
 B385		BNE $B380
 B387		LDA ($57),Y
 B389		STA ($55),Y
 B38B	iB38B	DEC $58
 B38D		DEC $56
 B38F		DEX
 B390		BNE $B384
 B392		RTS


; getstk	Check Stack Depth

 B393	iB393	ASL
 B394		ADC #$3E
 B396		BCS $B3CD	; omerr	Output ?OUT OF MEMORY Error
 B398		STA $1F		; Utility Pointer Area
 B39A		TSX
 B39B		CPX $1F		; Utility Pointer Area
 B39D		BCC $B3CD	; omerr	Output ?OUT OF MEMORY Error
 B39F		RTS


; reason	Check Memory Overlap

 B3A0	iB3A0	CPY $31
 B3A2		BCC $B3CC
 B3A4		BNE $B3AA
 B3A6		CMP $30		; Pointer: Bottom of String Storage
 B3A8		BCC $B3CC
 B3AA	iB3AA	PHA
 B3AB		LDX #$09
 B3AD		TYA
 B3AE	iB3AE	PHA
 B3AF		LDA $54,X	; Temporary storage for FLPT value.
 B3B1		DEX
 B3B2		BPL $B3AE
 B3B4		JSR $C66A	; garbag	Garbage Collection
 B3B7		LDX #$F7
 B3B9	iB3B9	PLA
 B3BA		STA $5E,X	; Floating-Point Accumulator #1: Exponent
 B3BC		INX
 B3BD		BMI $B3B9
 B3BF		PLA
 B3C0		TAY
 B3C1		PLA
 B3C2		CPY $31
 B3C4		BCC $B3CC
 B3C6		BNE $B3CD	; omerr	Output ?OUT OF MEMORY Error
 B3C8		CMP $30		; Pointer: Bottom of String Storage
 B3CA		BCS $B3CD	; omerr	Output ?OUT OF MEMORY Error
 B3CC	iB3CC	RTS


; omerr	Output ?OUT OF MEMORY Error

 B3CD	iB3CD	LDX #$4D


; error	Error Routine

 B3CF	iB3CF	LDA $10		; 3: width of source (unused - from TTY)
 B3D1		BEQ $B3DA
 B3D3		JSR $FFCC	; clrch	Restore I/O Vector
 B3D6		LDA #$00
 B3D8		STA $10		; 3: width of source (unused - from TTY)
 B3DA	iB3DA	JSR $BADF	; crdo	Output CR/LF
 B3DD		JSR $BB44	; -Print '?'
 B3E0	iB3E0	LDA $B20D,X	; errtab	Error Message Table			DATA
 B3E3		PHA
 B3E4		AND #$7F
 B3E6		JSR $BB46	; -	Output Character in A
 B3E9		INX
 B3EA		PLA
 B3EB		BPL $B3E0
 B3ED	iB3ED	JSR $B60E
 B3F0		LDA #$06
 B3F2		LDY #$B3


; errfin	Break Entry

 B3F4	iB3F4	JSR $BB1D	; strout	Output String
 B3F7		LDY $37
 B3F9		INY
 B3FA		BEQ $B3FF	; ready	Restart BASIC
 B3FC		JSR $CF78	; inprt	Output 'IN' and Line Number


; ready	Restart BASIC

 B3FF	iB3FF	LDA #$12
 B401		LDY #$B3
 B403		JSR $BB1D	; strout	Output String


; main	Input & Identify BASIC Line

 B406	iB406	JSR $B4E2	; inlin	Input Line Into Buffer
 B409		STX $77		; Pointer: Current Byte of BASIC Text
 B40B		STY $78
 B40D		JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 B410		TAX
 B411		BEQ $B406	; main	Input & Identify BASIC Line
 B413		LDX #$FF
 B415		STX $37
 B417		BCC $B41F	; main1	Get Line Number & Tokenise Text
 B419		JSR $B4FB	; crunch	Tokenise Input Buffer
 B41C		JMP $B77C	; gone	Prepare to execute statement


; main1	Get Line Number & Tokenise Text

 B41F	iB41F	JSR $B8F6	; linget	Fetch linnum From BASIC
 B422		JSR $B4FB	; crunch	Tokenise Input Buffer


; inslin	Insert BASIC Text

 B425		STY $05		; Input Buffer Pointer / No. of Subscripts
 B427		JSR $B5A3	; fndlin	Search for Line Number
 B42A		BCC $B470
 B42C		LDY #$01
 B42E		LDA ($5C),Y
 B430		STA $20
 B432		LDA $2A		; Pointer: Start of BASIC Variables
 B434		STA $1F		; Utility Pointer Area
 B436		LDA $5D
 B438		STA $22
 B43A		LDA $5C
 B43C		DEY
 B43D		SBC ($5C),Y
 B43F		CLC
 B440		ADC $2A		; Pointer: Start of BASIC Variables
 B442		STA $2A		; Pointer: Start of BASIC Variables
 B444		STA $21
 B446		LDA $2B
 B448		ADC #$FF
 B44A		STA $2B
 B44C		SBC $5D
 B44E		TAX
 B44F		SEC
 B450		LDA $5C
 B452		SBC $2A		; Pointer: Start of BASIC Variables
 B454		TAY
 B455		BCS $B45A
 B457		INX
 B458		DEC $22
 B45A	iB45A	CLC
 B45B		ADC $1F		; Utility Pointer Area
 B45D		BCC $B462
 B45F		DEC $20
 B461		CLC
 B462	iB462	LDA ($1F),Y	; Utility Pointer Area
 B464		STA ($21),Y
 B466		INY
 B467		BNE $B462
 B469		INC $20
 B46B		INC $22
 B46D		DEX
 B46E		BNE $B462
 B470	iB470	JSR $B5E9
 B473		JSR $B4B6	; linkprg	Rechain Lines
 B476		LDA $0200	; System INPUT Buffer
 B479		BEQ $B406	; main	Input & Identify BASIC Line
 B47B		CLC
 B47C		LDA $2A		; Pointer: Start of BASIC Variables
 B47E		STA $57
 B480		ADC $05		; Input Buffer Pointer / No. of Subscripts
 B482		STA $55
 B484		LDY $2B
 B486		STY $58
 B488		BCC $B48B
 B48A		INY
 B48B	iB48B	STY $56
 B48D		JSR $B350	; bltu	Open Space in Memory
 B490		LDA $11		; Temp: Integer Value
 B492		LDY $12
 B494		STA $01FE
 B497		STY $01FF
 B49A		LDA $2E		; Pointer End of BASIC Arrays (+1)
 B49C		LDY $2F
 B49E		STA $2A		; Pointer: Start of BASIC Variables
 B4A0		STY $2B
 B4A2		LDY $05		; Input Buffer Pointer / No. of Subscripts
 B4A4		DEY
 B4A5	iB4A5	LDA $01FC,Y
 B4A8		STA ($5C),Y
 B4AA		DEY
 B4AB		BPL $B4A5
 B4AD	iB4AD	JSR $B5E9
 B4B0		JSR $B4B6	; linkprg	Rechain Lines
 B4B3		JMP $B406	; main	Input & Identify BASIC Line


; linkprg	Rechain Lines

 B4B6	iB4B6	LDA $28		; Pointer: Start of BASIC Text [0401]
 B4B8		LDY $29
 B4BA		STA $1F		; Utility Pointer Area
 B4BC		STY $20
 B4BE		CLC
 B4BF	iB4BF	LDY #$01
 B4C1		LDA ($1F),Y	; Utility Pointer Area
 B4C3		BEQ $B4E1
 B4C5		LDY #$04
 B4C7	iB4C7	INY
 B4C8		LDA ($1F),Y	; Utility Pointer Area
 B4CA		BNE $B4C7
 B4CC		INY
 B4CD		TYA
 B4CE		ADC $1F		; Utility Pointer Area
 B4D0		TAX
 B4D1		LDY #$00
 B4D3		STA ($1F),Y	; Utility Pointer Area
 B4D5		TYA
 B4D6		ADC $20
 B4D8		INY
 B4D9		STA ($1F),Y	; Utility Pointer Area
 B4DB		STX $1F		; Utility Pointer Area
 B4DD		STA $20
 B4DF		BCC $B4BF
 B4E1	iB4E1	RTS


; inlin	Input Line Into Buffer

 B4E2	iB4E2	LDX #$00
 B4E4	iB4E4	JSR $FFCF	; chrin	Input Vector, chrin
 B4E7		CMP #$0D
 B4E9		BEQ $B4F8
 B4EB		STA $0200,X	; System INPUT Buffer
 B4EE		INX
 B4EF		CPX #$51
 B4F1		BNE $B4E4
 B4F3		LDX #$B0
 B4F5		JMP $B3CF	; error	Error Routine
 B4F8	iB4F8	JMP $BAD2	; -	Add zero terminator to string


; crunch	Tokenise Input Buffer

 B4FB	iB4FB	LDX $77		; Pointer: Current Byte of BASIC Text
 B4FD		LDY #$04
 B4FF		STY $09		; Flag: DATA scan/LlST quote/Garbage Coll
 B501	iB501	LDA $0200,X	; System INPUT Buffer
 B504		BPL $B50D
 B506		CMP #$FF
 B508		BEQ $B554
 B50A		INX
 B50B		BNE $B501
 B50D	iB50D	CMP #$20
 B50F		BEQ $B554
 B511		STA $04		; Flag: Scan for Quote at End of String
 B513		CMP #$22
 B515		BEQ $B579
 B517		BIT $09
 B519		BVS $B554
 B51B		CMP #$3F
 B51D		BNE $B523
 B51F		LDA #$99
 B521		BNE $B554
 B523	iB523	CMP #$30
 B525		BCC $B52B
 B527		CMP #$3C
 B529		BCC $B554
 B52B	iB52B	STY $6E		; Pointer: Cassette Buffer
 B52D		LDY #$00
 B52F		STY $05		; Input Buffer Pointer / No. of Subscripts
 B531		STX $77		; Pointer: Current Byte of BASIC Text
 B533		LDA #$B0
 B535		STA $20
 B537		LDA #$B2
 B539		STA $1F		; Utility Pointer Area
 B53B		BNE $B544
 B53D	iB53D	INX
 B53E		INC $1F		; Utility Pointer Area
 B540		BNE $B544
 B542		INC $20
 B544	iB544	LDA $0200,X	; System INPUT Buffer
 B547		SEC
 B548		SBC ($1F),Y	; Utility Pointer Area
 B54A		BEQ $B53D
 B54C		CMP #$80
 B54E		BNE $B580
 B550		ORA $05		; Input Buffer Pointer / No. of Subscripts
 B552	iB552	LDY $6E		; Pointer: Cassette Buffer
 B554	iB554	INX
 B555		INY
 B556		STA $01FB,Y
 B559		LDA $01FB,Y
 B55C		BEQ $B599
 B55E		SEC
 B55F		SBC #$3A
 B561		BEQ $B567
 B563		CMP #$49
 B565		BNE $B569
 B567	iB567	STA $09		; Flag: DATA scan/LlST quote/Garbage Coll
 B569	iB569	SEC
 B56A		SBC #$55
 B56C		BNE $B501
 B56E		STA $04		; Flag: Scan for Quote at End of String
 B570	iB570	LDA $0200,X	; System INPUT Buffer
 B573		BEQ $B554
 B575		CMP $04		; Flag: Scan for Quote at End of String
 B577		BEQ $B554
 B579	iB579	INY
 B57A		STA $01FB,Y
 B57D		INX
 B57E		BNE $B570
 B580	iB580	LDX $77		; Pointer: Current Byte of BASIC Text
 B582		INC $05		; Input Buffer Pointer / No. of Subscripts
 B584	iB584	LDA ($1F),Y	; Utility Pointer Area
 B586		PHP
 B587		INC $1F		; Utility Pointer Area
 B589		BNE $B58D
 B58B		INC $20
 B58D	iB58D	PLP
 B58E		BPL $B584
 B590		LDA ($1F),Y	; Utility Pointer Area
 B592		BNE $B544
 B594		LDA $0200,X	; System INPUT Buffer
 B597		BPL $B552
 B599	iB599	STA $01FD,Y
 B59C		DEC $78
 B59E		LDA #$FF
 B5A0		STA $77		; Pointer: Current Byte of BASIC Text
 B5A2		RTS


; fndlin	Search for Line Number

 B5A3	iB5A3	LDA $28		; Pointer: Start of BASIC Text [0401]
 B5A5		LDX $29
 B5A7	iB5A7	LDY #$01
 B5A9		STA $5C
 B5AB		STX $5D
 B5AD		LDA ($5C),Y
 B5AF		BEQ $B5D0
 B5B1		INY
 B5B2		INY
 B5B3		LDA $12
 B5B5		CMP ($5C),Y
 B5B7		BCC $B5D1
 B5B9		BEQ $B5BE
 B5BB		DEY
 B5BC		BNE $B5C7
 B5BE	iB5BE	LDA $11		; Temp: Integer Value
 B5C0		DEY
 B5C1		CMP ($5C),Y
 B5C3		BCC $B5D1
 B5C5		BEQ $B5D1
 B5C7	iB5C7	DEY
 B5C8		LDA ($5C),Y
 B5CA		TAX
 B5CB		DEY
 B5CC		LDA ($5C),Y
 B5CE		BCS $B5A7
 B5D0	iB5D0	CLC
 B5D1	iB5D1	RTS


; scrtch	Perform [new]

 B5D2		BNE $B5D1
 B5D4	iB5D4	LDA #$00
 B5D6		TAY
 B5D7		STA ($28),Y	; Pointer: Start of BASIC Text [0401]
 B5D9		INY
 B5DA		STA ($28),Y	; Pointer: Start of BASIC Text [0401]
 B5DC		LDA $28		; Pointer: Start of BASIC Text [0401]
 B5DE		CLC
 B5DF		ADC #$02
 B5E1		STA $2A		; Pointer: Start of BASIC Variables
 B5E3		LDA $29
 B5E5		ADC #$00
 B5E7		STA $2B
 B5E9	iB5E9	JSR $B622	; stxpt	Reset TXTPTR
 B5EC		LDA #$00


; clear	Perform [clr]

 B5EE		BNE $B621
 B5F0	iB5F0	LDA $34		; Pointer: Highest Address Used by BASIC
 B5F2		LDY $35
 B5F4		STA $30		; Pointer: Bottom of String Storage
 B5F6		STY $31
 B5F8		LDA #$00
 B5FA		STA $0D		; 3: Flag to suppress PRINT or PRINT# when -ve
 B5FC		JSR $FFE7	; jmp $f2a2	clall	Close All Channels And Files
 B5FF		LDA $2A		; Pointer: Start of BASIC Variables
 B601		LDY $2B
 B603		STA $2C		; Pointer: Start of BASIC Arrays
 B605		STY $2D
 B607		STA $2E		; Pointer End of BASIC Arrays (+1)
 B609		STY $2F
 B60B	iB60B	JSR $B7B7	; restor	Perform [restore]
 B60E	iB60E	LDX #$16
 B610		STX $13		; Pointer Temporary String
 B612		PLA
 B613		TAY
 B614		PLA
 B615		LDX #$FA
 B617		TXS
 B618		PHA
 B619		TYA
 B61A		PHA
 B61B		LDA #$00
 B61D		STA $3B
 B61F		STA $0A		; Flag: Subscript Ref / User Function Call
 B621	iB621	RTS


; stxpt	Reset TXTPTR

 B622	iB622	CLC
 B623		LDA $28		; Pointer: Start of BASIC Text [0401]
 B625		ADC #$FF
 B627		STA $77		; Pointer: Current Byte of BASIC Text
 B629		LDA $29
 B62B		ADC #$FF
 B62D		STA $78
 B62F		RTS


; list	Perform [list]

 B630		BCC $B638
 B632		BEQ $B638
 B634		CMP #$AB
 B636		BNE $B621
 B638	iB638	JSR $B8F6	; linget	Fetch linnum From BASIC
 B63B		JSR $B5A3	; fndlin	Search for Line Number
 B63E		JSR $0076	; Entry to Get Same Byte of Text Again
 B641		BEQ $B64F
 B643		CMP #$AB
 B645		BNE $B5D1
 B647		JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 B64A		JSR $B8F6	; linget	Fetch linnum From BASIC
 B64D		BNE $B5D1
 B64F	iB64F	PLA
 B650		PLA
 B651		LDA $11		; Temp: Integer Value
 B653		ORA $12
 B655		BNE $B65D
 B657		LDA #$FF
 B659		STA $11		; Temp: Integer Value
 B65B		STA $12
 B65D	iB65D	LDY #$01
 B65F		STY $09		; Flag: DATA scan/LlST quote/Garbage Coll
 B661		LDA ($5C),Y
 B663		BEQ $B6A8
 B665		JSR $FFE1	; jmp $f343	stop	Test-Stop
 B668		JSR $BADF	; crdo	Output CR/LF
 B66B		INY
 B66C		LDA ($5C),Y
 B66E		TAX
 B66F		INY
 B670		LDA ($5C),Y
 B672		CMP $12
 B674		BNE $B67A
 B676		CPX $11		; Temp: Integer Value
 B678		BEQ $B67C
 B67A	iB67A	BCS $B6A8
 B67C	iB67C	STY $46		; Pointer: Index Variable for FOR/NEXT
 B67E		JSR $CF83
 B681		LDA #$20
 B683	iB683	LDY $46		; Pointer: Index Variable for FOR/NEXT
 B685		AND #$7F
 B687	iB687	JSR $BB46	; -	Output Character in A
 B68A		CMP #$22
 B68C		BNE $B694
 B68E		LDA $09		; Flag: DATA scan/LlST quote/Garbage Coll
 B690		EOR #$FF
 B692		STA $09		; Flag: DATA scan/LlST quote/Garbage Coll
 B694	iB694	INY
 B695		BEQ $B6A8
 B697		LDA ($5C),Y
 B699		BNE $B6AB	; qplop	Handle LIST Character
 B69B		TAY
 B69C		LDA ($5C),Y
 B69E		TAX
 B69F		INY
 B6A0		LDA ($5C),Y
 B6A2		STX $5C
 B6A4		STA $5D
 B6A6		BNE $B65D
 B6A8	iB6A8	JMP $B3FF	; ready	Restart BASIC


; qplop	Handle LIST Character

 B6AB	iB6AB	BPL $B687
 B6AD		CMP #$FF
 B6AF		BEQ $B687
 B6B1		BIT $09
 B6B3		BMI $B687
 B6B5		TAX
 B6B6		STY $46		; Pointer: Index Variable for FOR/NEXT
 B6B8		LDY #$B0
 B6BA		STY $20
 B6BC		LDY #$B2
 B6BE		STY $1F		; Utility Pointer Area
 B6C0		LDY #$00
 B6C2		ASL
 B6C3		BEQ $B6D5
 B6C5	iB6C5	DEX
 B6C6		BPL $B6D4
 B6C8	iB6C8	INC $1F		; Utility Pointer Area
 B6CA		BNE $B6CE
 B6CC		INC $20
 B6CE	iB6CE	LDA ($1F),Y	; Utility Pointer Area
 B6D0		BPL $B6C8
 B6D2		BMI $B6C5
 B6D4	iB6D4	INY
 B6D5	iB6D5	LDA ($1F),Y	; Utility Pointer Area
 B6D7		BMI $B683
 B6D9		JSR $BB46	; -	Output Character in A
 B6DC		BNE $B6D4


; for	Perform [for]

 B6DE		LDA #$80
 B6E0		STA $0A		; Flag: Subscript Ref / User Function Call
 B6E2		JSR $B930	; let	Perform [let]
 B6E5		JSR $B322	; fndfor	Find FOR/GOSUB Entry on Stack
 B6E8		BNE $B6EF
 B6EA		TXA
 B6EB		ADC #$0F
 B6ED		TAX
 B6EE		TXS
 B6EF	iB6EF	PLA
 B6F0		PLA
 B6F1		LDA #$09
 B6F3		JSR $B393	; getstk	Check Stack Depth
 B6F6		JSR $B891	; datan	Search for Next Statement / Line
 B6F9		CLC
 B6FA		TYA
 B6FB		ADC $77		; Pointer: Current Byte of BASIC Text
 B6FD		PHA
 B6FE		LDA $78
 B700		ADC #$00
 B702		PHA
 B703		LDA $37
 B705		PHA
 B706		LDA $36		; Current BASIC Line Number
 B708		PHA
 B709		LDA #$A4
 B70B		JSR $BEF7	; -Confirm Character in A
 B70E		JSR $BD87	; -Confirm numeric mode
 B711		JSR $BD84	; frmnum	Confirm Result
 B714		LDA $63		; Floating Accum. #1: Sign
 B716		ORA #$7F
 B718		AND $5F		; Floating Accum. #1: Mantissa
 B71A		STA $5F		; Floating Accum. #1: Mantissa
 B71C		LDA #$27
 B71E		LDY #$B7
 B720		STA $1F		; Utility Pointer Area
 B722		STY $20
 B724		JMP $BE41

 B727		LDA #$F2
 B729		LDY #$CA
 B72B		JSR $CCD8	; movfm	Load FAC#1 From Memory
 B72E		JSR $0076	; Entry to Get Same Byte of Text Again
 B731		CMP #$A9
 B733		BNE $B73B
 B735		JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 B738		JSR $BD84	; frmnum	Confirm Result
 B73B	iB73B	JSR $CD61	; sign	Check Sign of FAC#1
 B73E		JSR $BE32
 B741		LDA $47
 B743		PHA
 B744		LDA $46		; Pointer: Index Variable for FOR/NEXT
 B746		PHA
 B747		LDA #$81
 B749		PHA


; newstt	BASIC Warm Start

 B74A	iB74A	JSR $FFE1	; jmp $f343	stop	Test-Stop
 B74D		LDA $77		; Pointer: Current Byte of BASIC Text
 B74F		LDY $78
 B751		CPY #$02
 B753		BEQ $B759
 B755		STA $3A		; Pointer: BASIC Statement for CONT
 B757		STY $3B
 B759	iB759	LDY #$00
 B75B		LDA ($77),Y	; Pointer: Current Byte of BASIC Text
 B75D		BNE $B7A5


; ckeol	Check End of Program

 B75F		LDY #$02
 B761		LDA ($77),Y	; Pointer: Current Byte of BASIC Text
 B763		CLC
 B764		BNE $B769
 B766		JMP $B7E2
 B769	iB769	INY
 B76A		LDA ($77),Y	; Pointer: Current Byte of BASIC Text
 B76C		STA $36		; Current BASIC Line Number
 B76E		INY
 B76F		LDA ($77),Y	; Pointer: Current Byte of BASIC Text
 B771		STA $37
 B773		TYA
 B774		ADC $77		; Pointer: Current Byte of BASIC Text
 B776		STA $77		; Pointer: Current Byte of BASIC Text
 B778		BCC $B77C	; gone	Prepare to execute statement
 B77A		INC $78


; gone	Prepare to execute statement

 B77C	iB77C	JSR $BF21	; ?
 B77F		JSR $B785	; gone3	Perform BASIC Keyword
 B782		JMP $B74A	; newstt	BASIC Warm Start


; gone3	Perform BASIC Keyword

 B785	iB785	BEQ $B7C5
 B787	iB787	SBC #$80
 B789		BCC $B7A2
 B78B		CMP #$23
 B78D		BCC $B795
 B78F		CMP #$4B
 B791		BCC $B7A9
 B793		SBC #$28
 B795	iB795	ASL
 B796		TAY
 B797		LDA $B001,Y
 B79A		PHA
 B79B		LDA $B000,Y	; 3: free space for 4K EPROM
 B79E		PHA
 B79F		JMP $0070	; Subroutine: Get Next Byte of BASIC Text
 B7A2	iB7A2	JMP $B930	; let	Perform [let]
 B7A5	iB7A5	CMP #$3A


; -	Perform [go]

 B7A7		BEQ $B77C	; gone	Prepare to execute statement
 B7A9	iB7A9	JMP $BF00	; synerr	Output ?SYNTAX Error
 B7AC		JSR $0076	; Entry to Get Same Byte of Text Again
 B7AF		LDA #$A4
 B7B1		JSR $BEF7	; -Confirm Character in A
 B7B4		JMP $B830	; goto	Perform [goto]


; restor	Perform [restore]

 B7B7	iB7B7	SEC
 B7B8		LDA $28		; Pointer: Start of BASIC Text [0401]
 B7BA		SBC #$01
 B7BC		LDY $29
 B7BE		BCS $B7C1
 B7C0		DEY
 B7C1	iB7C1	STA $3E		; Pointer: Current DATA Item Address
 B7C3		STY $3F
 B7C5	iB7C5	RTS


; stop	Perform [stop], [end], break

 B7C6	iB7C6	BCS $B7C9
 B7C8		CLC
 B7C9	iB7C9	BNE $B807
 B7CB		LDA $77		; Pointer: Current Byte of BASIC Text
 B7CD		LDY $78
 B7CF		LDX $37
 B7D1		INX
 B7D2		BEQ $B7E0
 B7D4		STA $3A		; Pointer: BASIC Statement for CONT
 B7D6		STY $3B
 B7D8	iB7D8	LDA $36		; Current BASIC Line Number
 B7DA		LDY $37
 B7DC		STA $38		; Previous BASIC Line Number
 B7DE		STY $39
 B7E0	iB7E0	PLA
 B7E1		PLA
 B7E2	iB7E2	LDA #$1B
 B7E4		LDY #$B3
 B7E6		BCC $B7EB
 B7E8		JMP $B3F4	; errfin	Break Entry
 B7EB	iB7EB	JMP $B3FF	; ready	Restart BASIC


; cont	Perform [cont]

 B7EE		BNE $B807
 B7F0		LDX #$DB
 B7F2		LDY $3B
 B7F4		BNE $B7F9
 B7F6		JMP $B3CF	; error	Error Routine
 B7F9	iB7F9	LDA $3A		; Pointer: BASIC Statement for CONT
 B7FB		STA $77		; Pointer: Current Byte of BASIC Text
 B7FD		STY $78
 B7FF		LDA $38		; Previous BASIC Line Number
 B801		LDY $39
 B803		STA $36		; Current BASIC Line Number
 B805		STY $37
 B807	iB807	RTS


; run	Perform [run]

 B808		BNE $B80D
 B80A		JMP $B5E9
 B80D	iB80D	JSR $B5F0
 B810		JMP $B827


; gosub	Perform [gosub]

 B813		LDA #$03
 B815		JSR $B393	; getstk	Check Stack Depth
 B818		LDA $78
 B81A		PHA
 B81B		LDA $77		; Pointer: Current Byte of BASIC Text
 B81D		PHA
 B81E		LDA $37
 B820		PHA
 B821		LDA $36		; Current BASIC Line Number
 B823		PHA
 B824		LDA #$8D
 B826		PHA
 B827	iB827	JSR $0076	; Entry to Get Same Byte of Text Again
 B82A		JSR $B830	; goto	Perform [goto]
 B82D		JMP $B74A	; newstt	BASIC Warm Start


; goto	Perform [goto]

 B830	iB830	JSR $B8F6	; linget	Fetch linnum From BASIC
 B833		JSR $B894
 B836		LDA $37
 B838		CMP $12
 B83A		BCS $B847
 B83C		TYA
 B83D		SEC
 B83E		ADC $77		; Pointer: Current Byte of BASIC Text
 B840		LDX $78
 B842		BCC $B84B
 B844		INX
 B845		BCS $B84B
 B847	iB847	LDA $28		; Pointer: Start of BASIC Text [0401]
 B849		LDX $29
 B84B	iB84B	JSR $B5A7
 B84E		BCC $B86E
 B850		LDA $5C
 B852		SBC #$01
 B854		STA $77		; Pointer: Current Byte of BASIC Text
 B856		LDA $5D
 B858		SBC #$00
 B85A		STA $78
 B85C	iB85C	RTS


; return	Perform [return]

 B85D		BNE $B85C
 B85F		LDA #$FF
 B861		STA $47
 B863		JSR $B322	; fndfor	Find FOR/GOSUB Entry on Stack
 B866		TXS
 B867		CMP #$8D
 B869		BEQ $B876
 B86B		LDX #$16
 B86D		BIT $5AA2
; *** B86D: ADDRESS DIFFER. This may indicate misassembly ***
 B870		JMP $B3CF	; error	Error Routine
 B873	iB873	JMP $BF00	; synerr	Output ?SYNTAX Error
 B876	iB876	PLA
 B877		PLA
 B878		STA $36		; Current BASIC Line Number
 B87A		PLA
 B87B		STA $37
 B87D		PLA
 B87E		STA $77		; Pointer: Current Byte of BASIC Text
 B880		PLA
 B881		STA $78


; data	Perform [data]

 B883	iB883	JSR $B891	; datan	Search for Next Statement / Line
 B886	iB886	TYA
 B887		CLC
 B888		ADC $77		; Pointer: Current Byte of BASIC Text
 B88A		STA $77		; Pointer: Current Byte of BASIC Text
 B88C		BCC $B890
 B88E		INC $78
 B890	iB890	RTS


; datan	Search for Next Statement / Line

 B891	iB891	LDX #$3A
 B893		BIT $00A2
; *** B893: ADDRESS DIFFER. This may indicate misassembly ***
 B896		STX $03		; Search Character
 B898		LDY #$00
 B89A		STY $04		; Flag: Scan for Quote at End of String
 B89C	iB89C	LDA $04		; Flag: Scan for Quote at End of String
 B89E		LDX $03		; Search Character
 B8A0		STA $03		; Search Character
 B8A2		STX $04		; Flag: Scan for Quote at End of String
 B8A4	iB8A4	LDA ($77),Y	; Pointer: Current Byte of BASIC Text
 B8A6		BEQ $B890
 B8A8		CMP $04		; Flag: Scan for Quote at End of String
 B8AA		BEQ $B890
 B8AC		INY
 B8AD		CMP #$22
 B8AF		BNE $B8A4
 B8B1		BEQ $B89C


; if	Perform [if]

 B8B3		JSR $BD98	; frmevl	Evaluate Expression in Text
 B8B6		JSR $0076	; Entry to Get Same Byte of Text Again
 B8B9		CMP #$89
 B8BB		BEQ $B8C2
 B8BD		LDA #$A7
 B8BF		JSR $BEF7	; -Confirm Character in A
 B8C2	iB8C2	LDA $5E		; Floating-Point Accumulator #1: Exponent
 B8C4		BNE $B8CB


; rem	Perform [rem]

 B8C6		JSR $B894
 B8C9		BEQ $B886
 B8CB	iB8CB	JSR $0076	; Entry to Get Same Byte of Text Again
 B8CE		BCS $B8D3
 B8D0		JMP $B830	; goto	Perform [goto]
 B8D3	iB8D3	JMP $B785	; gone3	Perform BASIC Keyword


; ongoto	Perform [on]

 B8D6		JSR $C8D4	; -Eval Byte Parameter
 B8D9		PHA
 B8DA		CMP #$8D
 B8DC		BEQ $B8E2
 B8DE	iB8DE	CMP #$89
 B8E0		BNE $B873
 B8E2	iB8E2	DEC $62
 B8E4		BNE $B8EA
 B8E6		PLA
 B8E7		JMP $B787
 B8EA	iB8EA	JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 B8ED		JSR $B8F6	; linget	Fetch linnum From BASIC
 B8F0		CMP #$2C
 B8F2		BEQ $B8E2
 B8F4		PLA
 B8F5	iB8F5	RTS


; linget	Fetch linnum From BASIC

 B8F6	iB8F6	LDX #$00
 B8F8		STX $11		; Temp: Integer Value
 B8FA		STX $12
 B8FC	iB8FC	BCS $B8F5
 B8FE		SBC #$2F
 B900		STA $03		; Search Character
 B902		LDA $12
 B904		STA $1F		; Utility Pointer Area
 B906		CMP #$19
 B908		BCS $B8DE
 B90A		LDA $11		; Temp: Integer Value
 B90C		ASL
 B90D		ROL $1F		; Utility Pointer Area
 B90F		ASL
 B910		ROL $1F		; Utility Pointer Area
 B912		ADC $11		; Temp: Integer Value
 B914		STA $11		; Temp: Integer Value
 B916		LDA $1F		; Utility Pointer Area
 B918		ADC $12
 B91A		STA $12
 B91C		ASL $11		; Temp: Integer Value
 B91E		ROL $12
 B920		LDA $11		; Temp: Integer Value
 B922		ADC $03		; Search Character
 B924		STA $11		; Temp: Integer Value
 B926		BCC $B92A
 B928		INC $12
 B92A	iB92A	JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 B92D		JMP $B8FC


; let	Perform [let]

 B930	iB930	JSR $C12B	; ptrget	Identify Variable
 B933		STA $46		; Pointer: Index Variable for FOR/NEXT
 B935		STY $47
 B937		LDA #$B2
 B939		JSR $BEF7	; -Confirm Character in A
 B93C		LDA $08		; Data Type: $80 = Integer, $00 = Floating
 B93E		PHA
 B93F		LDA $07		; Data Type: $FF = String, $00 = Numeric
 B941		PHA
 B942		JSR $BD98	; frmevl	Evaluate Expression in Text
 B945		PLA
 B946		ROL
 B947		JSR $BD8A
 B94A		BNE $B964	; putstr	Assign String
 B94C		PLA
 B94D	iB94D	BPL $B961	; ptflpt	Assign Floating Point


; putint	Assign Integer

 B94F		JSR $CD51	; round	Round FAC#1
 B952		JSR $C2EA	; ayint	FAC#1 to Positive Integer
 B955		LDY #$00
 B957		LDA $61
 B959		STA ($46),Y	; Pointer: Index Variable for FOR/NEXT
 B95B		INY
 B95C		LDA $62
 B95E		STA ($46),Y	; Pointer: Index Variable for FOR/NEXT
 B960		RTS


; ptflpt	Assign Floating Point

 B961	iB961	JMP $CD06


; putstr	Assign String

 B964	iB964	PLA
 B965	iB965	LDY $47
 B967		CPY #$D0
 B969		BNE $B9BA	; getspt	Add Digit to FAC#1
 B96B		JSR $C7B8


; puttim	Assign TI$

 B96E		CMP #$06
 B970		BNE $B9B2
 B972		LDY #$00
 B974		STY $5E		; Floating-Point Accumulator #1: Exponent
 B976		STY $63		; Floating Accum. #1: Sign
 B978	iB978	STY $6E		; Pointer: Cassette Buffer
 B97A		JSR $B9AB	; -get character string
 B97D		JSR $CC18	; mul10	Multiply FAC#1 by 10
 B980		INC $6E		; Pointer: Cassette Buffer
 B982		LDY $6E		; Pointer: Cassette Buffer
 B984		JSR $B9AB	; -get character string
 B987		JSR $CD42	; movaf	Copy FAC#1 into FAC#2
 B98A		TAX
 B98B		BEQ $B992
 B98D		INX
 B98E		TXA
 B98F		JSR $CC23
 B992	iB992	LDY $6E		; Pointer: Cassette Buffer
 B994		INY
 B995		CPY #$06
 B997		BNE $B978
 B999		JSR $CC18	; mul10	Multiply FAC#1 by 10
 B99C		JSR $CDD1	; qint	Convert FAC#1 to Integer
 B99F		LDX #$02
 B9A1		SEI
 B9A2	iB9A2	LDA $60,X
 B9A4		STA $8D,X	; Real-Time Jiffy Clock (approx) 1/60 Sec
 B9A6		DEX
 B9A7		BPL $B9A2
 B9A9		CLI
 B9AA		RTS


; -get character string

 B9AB	iB9AB	LDA ($1F),Y	; Utility Pointer Area
 B9AD		JSR $007D
 B9B0		BCC $B9B5
 B9B2	iB9B2	JMP $C373	; -	?ILLEGAL QUANTITY
 B9B5	iB9B5	SBC #$2F
 B9B7		JMP $CEB4


; getspt	Add Digit to FAC#1

 B9BA	iB9BA	LDY #$02
 B9BC		LDA ($61),Y
 B9BE		CMP $0F		; 3: terminal width (unused-carried over from TTY)
 B9C0		BNE $B9D4
 B9C2		PHA
 B9C3		DEY
 B9C4		LDA $0D		; 3: Flag to suppress PRINT or PRINT# when -ve
 B9C6		BEQ $B9D2
 B9C8		LDA ($61),Y
 B9CA		CMP $0E		; 3: File# of current I/O device (as 0010)
 B9CC		BNE $B9D2
 B9CE		PLA
 B9CF		JMP $B9F6
 B9D2	iB9D2	PLA
 B9D3		INY
 B9D4	iB9D4	CMP $31
 B9D6		BCC $B9EF
 B9D8		BNE $B9E1
 B9DA		DEY
 B9DB		LDA ($61),Y
 B9DD		CMP $30		; Pointer: Bottom of String Storage
 B9DF		BCC $B9EF
 B9E1	iB9E1	LDY $62
 B9E3		CPY $2B
 B9E5		BCC $B9EF
 B9E7		BNE $B9F6
 B9E9		LDA $61
 B9EB		CMP $2A		; Pointer: Start of BASIC Variables
 B9ED		BCS $B9F6
 B9EF	iB9EF	LDA $61
 B9F1		LDY $62
 B9F3		JMP $BA13
 B9F6	iB9F6	LDY #$00
 B9F8		LDA ($61),Y
 B9FA		JSR $C59E
 B9FD		LDA $4D		; Pointer to string, length and garbage collect constant
 B9FF		LDY $4E
 BA01		STA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 BA03		STY $6D		; Floating Accum. #1. Low-Order (Rounding)
 BA05		JSR $C78C	; movins	Store String in High RAM
 BA08		LDA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 BA0A		LDY $6D		; Floating Accum. #1. Low-Order (Rounding)
 BA0C		JSR $C811	; frefac	Clean Descriptor Stack
 BA0F		LDA #$5E
 BA11		LDY #$00
 BA13	iBA13	STA $4D		; Pointer to string, length and garbage collect constant
 BA15		STY $4E
 BA17		STA $1F		; Utility Pointer Area
 BA19		STY $20
 BA1B		JSR $C811	; frefac	Clean Descriptor Stack
 BA1E		JSR $BA4E	; ?
 BA21		BCC $BA2E
 BA23		LDY #$00
 BA25		LDA $46		; Pointer: Index Variable for FOR/NEXT
 BA27		STA ($1F),Y	; Utility Pointer Area
 BA29		INY
 BA2A		LDA $47
 BA2C		STA ($1F),Y	; Utility Pointer Area
 BA2E	iBA2E	LDA $46		; Pointer: Index Variable for FOR/NEXT
 BA30		STA $1F		; Utility Pointer Area
 BA32		LDA $47
 BA34		STA $20
 BA36		JSR $BA4E	; ?
 BA39		BCC $BA44
 BA3B		DEY
 BA3C		LDA #$FF
 BA3E		STA ($1F),Y	; Utility Pointer Area
 BA40		DEY
 BA41		TXA
 BA42		STA ($1F),Y	; Utility Pointer Area
 BA44	iBA44	LDY #$02
 BA46	iBA46	LDA ($4D),Y	; Pointer to string, length and garbage collect constant
 BA48		STA ($46),Y	; Pointer: Index Variable for FOR/NEXT
 BA4A		DEY
 BA4B		BPL $BA46
 BA4D		RTS


; ?

 BA4E	iBA4E	LDY #$00
 BA50		LDA ($1F),Y	; Utility Pointer Area
 BA52		PHA
 BA53		BEQ $BA85
 BA55		INY
 BA56		LDA ($1F),Y	; Utility Pointer Area
 BA58		TAX
 BA59		INY
 BA5A		LDA ($1F),Y	; Utility Pointer Area
 BA5C		BMI $BA85
 BA5E		CMP #$B0
 BA60		BCS $BA85
 BA62		CMP $31
 BA64		BCC $BA85
 BA66		BNE $BA6C
 BA68		CPX $30		; Pointer: Bottom of String Storage
 BA6A		BCC $BA85
 BA6C	iBA6C	JMP $BF10
 BA6F		NOP
 BA70	iBA70	CPX $0E		; 3: File# of current I/O device (as 0010)
 BA72		BEQ $BA85
 BA74	iBA74	STX $1F		; Utility Pointer Area
 BA76		STA $20
 BA78		PLA
 BA79		TAX
 BA7A		CLC
 BA7B		ADC $1F		; Utility Pointer Area
 BA7D		STA $1F		; Utility Pointer Area
 BA7F		BCC $BA83
 BA81		INC $20
 BA83	iBA83	SEC
 BA84		RTS
 BA85	iBA85	PLA
 BA86		CLC
 BA87		RTS


; printn	Perform [print#]

 BA88		JSR $BA8E	; cmd	Perform [cmd]
 BA8B		JMP $BBB4


; cmd	Perform [cmd]

 BA8E	iBA8E	JSR $C8D4	; -Eval Byte Parameter
 BA91		BEQ $BA98
 BA93		LDA #$2C
 BA95		JSR $BEF7	; -Confirm Character in A
 BA98	iBA98	PHP
 BA99		JSR $FFC9	; chkout	Set Output
 BA9C		STX $10		; 3: width of source (unused - from TTY)
 BA9E		PLP
 BA9F		JMP $BAA8	; print	Perform [print]


; strdon	Print String From Memory

 BAA2	iBAA2	JSR $BB20
 BAA5	iBAA5	JSR $0076	; Entry to Get Same Byte of Text Again


; print	Perform [print]

 BAA8	iBAA8	BEQ $BADF	; crdo	Output CR/LF
 BAAA	iBAAA	BEQ $BAEF
 BAAC		CMP #$A3
 BAAE		BEQ $BAFD
 BAB0		CMP #$A6
 BAB2		CLC
 BAB3		BEQ $BAFD
 BAB5		CMP #$2C
 BAB7		BEQ $BAF0	; comprt	Handle comma, TAB(, SPC(
 BAB9		CMP #$3B
 BABB		BEQ $BB12
 BABD		JSR $BD98	; frmevl	Evaluate Expression in Text


; varop	Output Variable

 BAC0		BIT $07
 BAC2		BMI $BAA2	; strdon	Print String From Memory
 BAC4		JSR $CF93	; fout	Convert FAC#1 to ASCII String
 BAC7		JSR $C5B0	; strlit	Set Up String
 BACA		JSR $BB20
 BACD		JSR $BB3A	; outspc	Output Format Character
 BAD0		BNE $BAA5


; -	Add zero terminator to string

 BAD2	iBAD2	LDA #$00
 BAD4		STA $0200,X	; System INPUT Buffer
 BAD7		LDX #$FF
 BAD9		LDY #$01
 BADB		LDA $10		; 3: width of source (unused - from TTY)
 BADD		BNE $BAEF


; crdo	Output CR/LF

 BADF	iBADF	LDA #$0D
 BAE1		JSR $BB46	; -	Output Character in A
 BAE4		LDA $10		; 3: width of source (unused - from TTY)
 BAE6		BPL $BAED
 BAE8		LDA #$0A
 BAEA		JSR $BB46	; -	Output Character in A
 BAED	iBAED	EOR #$FF
 BAEF	iBAEF	RTS


; comprt	Handle comma, TAB(, SPC(

 BAF0	iBAF0	LDA $C6		; Cursor Column on Current Line
 BAF2		SEC
 BAF3	iBAF3	SBC #$0A
 BAF5		BCS $BAF3
 BAF7		EOR #$FF
 BAF9		ADC #$01
 BAFB		BNE $BB0D
 BAFD	iBAFD	PHP
 BAFE		JSR $C8D1	; gtbytc	Evaluate Text to 1 Byte in XR
 BB01		CMP #$29
 BB03		BNE $BB5E
 BB05		PLP
 BB06		BCC $BB0E
 BB08		TXA
 BB09		SBC $C6		; Cursor Column on Current Line
 BB0B		BCC $BB12
 BB0D	iBB0D	TAX
 BB0E	iBB0E	INX
 BB0F	iBB0F	DEX
 BB10		BNE $BB18
 BB12	iBB12	JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 BB15		JMP $BAAA
 BB18	iBB18	JSR $BB3A	; outspc	Output Format Character
 BB1B		BNE $BB0F


; strout	Output String

 BB1D	iBB1D	JSR $C5B0	; strlit	Set Up String
 BB20	iBB20	JSR $C7B8
 BB23		TAX
 BB24		LDY #$00
 BB26		INX
 BB27	iBB27	DEX
 BB28		BEQ $BAEF
 BB2A		LDA ($1F),Y	; Utility Pointer Area
 BB2C		JSR $BB46	; -	Output Character in A
 BB2F		INY
 BB30		CMP #$0D
 BB32		BNE $BB27
 BB34		JSR $BAED
 BB37		JMP $BB27


; outspc	Output Format Character

 BB3A	iBB3A	LDA $10		; 3: width of source (unused - from TTY)
 BB3C		BEQ $BB41	; -Print '<cursor right>'
 BB3E		LDA #$20
 BB40		BIT $1DA9

; *** Resyncing ***

; -Print '<cursor right>'

 BB41	iBB41	LDA #$1D
 BB43		BIT $3FA9

; *** Resyncing ***

; -Print '?'

 BB44	iBB44	LDA #$3F


; -	Output Character in A

 BB46	iBB46	JSR $FFD2	; chrout	Output Vector, chrout
 BB49		AND #$FF
 BB4B		RTS


; doagin	Handle Bad Data

 BB4C	iBB4C	LDA $0B		; Flag: $00 = INPUT, $40 = GET, $98 = READ
 BB4E		BEQ $BB61
 BB50		BMI $BB56
 BB52		LDY #$FF
 BB54		BNE $BB5A
 BB56	iBB56	LDA $3C		; Current DATA Line Number
 BB58		LDY $3D
 BB5A	iBB5A	STA $36		; Current BASIC Line Number
 BB5C		STY $37
 BB5E	iBB5E	JMP $BF00	; synerr	Output ?SYNTAX Error
 BB61	iBB61	LDA $10		; 3: width of source (unused - from TTY)
 BB63		BEQ $BB6A
 BB65		LDX #$BF
 BB67		JMP $B3CF	; error	Error Routine
 BB6A	iBB6A	LDA #$07
 BB6C		LDY #$BD
 BB6E		JSR $BB1D	; strout	Output String
 BB71		LDA $3A		; Pointer: BASIC Statement for CONT
 BB73		LDY $3B
 BB75		STA $77		; Pointer: Current Byte of BASIC Text
 BB77		STY $78
 BB79		RTS


; get	Perform [get]

 BB7A		JSR $C4CF	; errdir	Confirm Program Mode
 BB7D		CMP #$23
 BB7F		BNE $BB91
 BB81		JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 BB84		JSR $C8D4	; -Eval Byte Parameter
 BB87		LDA #$2C
 BB89		JSR $BEF7	; -Confirm Character in A
 BB8C		JSR $FFC6	; chkin	Set Input
 BB8F		STX $10		; 3: width of source (unused - from TTY)
 BB91	iBB91	LDX #$01
 BB93		LDY #$02
 BB95		LDA #$00
 BB97		STA $0201
 BB9A		LDA #$40
 BB9C		JSR $BC0B
 BB9F		LDX $10		; 3: width of source (unused - from TTY)
 BBA1		BNE $BBB6
 BBA3		RTS


; inputn	Perform [input#]

 BBA4		JSR $C8D4	; -Eval Byte Parameter
 BBA7		LDA #$2C
 BBA9		JSR $BEF7	; -Confirm Character in A
 BBAC		JSR $FFC6	; chkin	Set Input
 BBAF		STX $10		; 3: width of source (unused - from TTY)
 BBB1		JSR $BBCD
 BBB4	iBBB4	LDA $10		; 3: width of source (unused - from TTY)
 BBB6	iBBB6	JSR $FFCC	; clrch	Restore I/O Vector
 BBB9		LDX #$00
 BBBB		STX $10		; 3: width of source (unused - from TTY)
 BBBD		RTS


; input	Perform [input]

 BBBE		CMP #$22
 BBC0		BNE $BBCD
 BBC2		JSR $BEB5
 BBC5		LDA #$3B
 BBC7		JSR $BEF7	; -Confirm Character in A
 BBCA		JSR $BB20
 BBCD	iBBCD	JSR $C4CF	; errdir	Confirm Program Mode
 BBD0		LDA #$2C
 BBD2		STA $01FF
 BBD5	iBBD5	JSR $BBF5	; qinlin	Do Input Prompt
 BBD8		LDA $10		; 3: width of source (unused - from TTY)
 BBDA		BEQ $BBE8	; bufful	Read Input Buffer
 BBDC		LDA $96		; Kernal I/O Status Word: ST
 BBDE		AND #$03
 BBE0		BEQ $BBE8	; bufful	Read Input Buffer
 BBE2		JSR $BBB4
 BBE5		JMP $B883	; data	Perform [data]


; bufful	Read Input Buffer

; Bufful scans for a null input and calls DATA to skip to the next statement
; On old PETs, END was called, thereby crashing the program.

 BBE8	iBBE8	LDA $0200	; System INPUT Buffer
 BBEB		BNE $BC09
 BBED		JMP $BF2E	; Patch for [input]
 BBF0		NOP
 BBF1	iBBF1	CLC
 BBF2		JMP $B7D8


; qinlin	Do Input Prompt

 BBF5	iBBF5	LDA $10		; 3: width of source (unused - from TTY)
 BBF7		BNE $BBFF
 BBF9		JSR $BB44	; -Print '?'
 BBFC		JSR $BB3A	; outspc	Output Format Character
 BBFF	iBBFF	JMP $B4E2	; inlin	Input Line Into Buffer


; read	Perform [read]

 BC02		LDX $3E		; Pointer: Current DATA Item Address
 BC04		LDY $3F
 BC06		LDA #$98
 BC08		BIT $00A9
; *** BC08: ADDRESS DIFFER. This may indicate misassembly ***
 BC0B	iBC0B	STA $0B		; Flag: $00 = INPUT, $40 = GET, $98 = READ
 BC0D		STX $40		; INPUT, READ and GET vector to save CHRGET
 BC0F		STY $41
 BC11	iBC11	JSR $C12B	; ptrget	Identify Variable
 BC14		STA $46		; Pointer: Index Variable for FOR/NEXT
 BC16		STY $47
 BC18		LDA $77		; Pointer: Current Byte of BASIC Text
 BC1A		LDY $78
 BC1C		STA $48		; Y-save; op-save; Temporary storage for TXTPTR
 BC1E		STY $49
 BC20		LDX $40		; INPUT, READ and GET vector to save CHRGET
 BC22		LDY $41
 BC24		STX $77		; Pointer: Current Byte of BASIC Text
 BC26		STY $78
 BC28		JSR $0076	; Entry to Get Same Byte of Text Again
 BC2B		BNE $BC4D
 BC2D		BIT $0B
 BC2F		BVC $BC3D


; rdget	General Purpose Read Routine

 BC31		JSR $FFE4	; jmp $f205	getin	Get From Keyboad
 BC34		STA $0200	; System INPUT Buffer
 BC37		LDX #$FF
 BC39		LDY #$01
 BC3B		BNE $BC49
 BC3D	iBC3D	BMI $BCB4
 BC3F		LDA $10		; 3: width of source (unused - from TTY)
 BC41		BNE $BC46
 BC43		JSR $BB44	; -Print '?'
 BC46	iBC46	JSR $BBF5	; qinlin	Do Input Prompt
 BC49	iBC49	STX $77		; Pointer: Current Byte of BASIC Text
 BC4B		STY $78
 BC4D	iBC4D	JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 BC50		BIT $07
 BC52		BPL $BC85
 BC54		BIT $0B
 BC56		BVC $BC61
 BC58		INX
 BC59		STX $77		; Pointer: Current Byte of BASIC Text
 BC5B		LDA #$00
 BC5D		STA $03		; Search Character
 BC5F		BEQ $BC6D
 BC61	iBC61	STA $03		; Search Character
 BC63		CMP #$22
 BC65		BEQ $BC6E
 BC67		LDA #$3A
 BC69		STA $03		; Search Character
 BC6B		LDA #$2C
 BC6D	iBC6D	CLC
 BC6E	iBC6E	STA $04		; Flag: Scan for Quote at End of String
 BC70		LDA $77		; Pointer: Current Byte of BASIC Text
 BC72		LDY $78
 BC74		ADC #$00
 BC76		BCC $BC79
 BC78		INY
 BC79	iBC79	JSR $C5B6
 BC7C		JSR $C918
 BC7F		JSR $B965
 BC82		JMP $BC8D
 BC85	iBC85	JSR $CE29	; fin	Convert ASCII String to a Number in FAC#1
 BC88		LDA $08		; Data Type: $80 = Integer, $00 = Floating
 BC8A		JSR $B94D
 BC8D	iBC8D	JSR $0076	; Entry to Get Same Byte of Text Again
 BC90		BEQ $BC99
 BC92		CMP #$2C
 BC94		BEQ $BC99
 BC96		JMP $BB4C	; doagin	Handle Bad Data
 BC99	iBC99	LDA $77		; Pointer: Current Byte of BASIC Text
 BC9B		LDY $78
 BC9D		STA $40		; INPUT, READ and GET vector to save CHRGET
 BC9F		STY $41
 BCA1		LDA $48		; Y-save; op-save; Temporary storage for TXTPTR
 BCA3		LDY $49
 BCA5		STA $77		; Pointer: Current Byte of BASIC Text
 BCA7		STY $78
 BCA9		JSR $0076	; Entry to Get Same Byte of Text Again
 BCAC		BEQ $BCDA
 BCAE		JSR $BEF5	; -Test comma-
 BCB1		JMP $BC11
 BCB4	iBCB4	JSR $B891	; datan	Search for Next Statement / Line
 BCB7		INY
 BCB8		TAX
 BCB9		BNE $BCCD
 BCBB		LDX #$2A
 BCBD		INY
 BCBE		LDA ($77),Y	; Pointer: Current Byte of BASIC Text
 BCC0		BEQ $BD2D
 BCC2		INY
 BCC3		LDA ($77),Y	; Pointer: Current Byte of BASIC Text
 BCC5		STA $3C		; Current DATA Line Number
 BCC7		INY
 BCC8		LDA ($77),Y	; Pointer: Current Byte of BASIC Text
 BCCA		INY
 BCCB		STA $3D
 BCCD	iBCCD	LDA ($77),Y	; Pointer: Current Byte of BASIC Text
 BCCF		TAX
 BCD0		JSR $B886
 BCD3		CPX #$83
 BCD5		BNE $BCB4
 BCD7		JMP $BC4D
 BCDA	iBCDA	LDA $40		; INPUT, READ and GET vector to save CHRGET
 BCDC		LDY $41
 BCDE		LDX $0B		; Flag: $00 = INPUT, $40 = GET, $98 = READ
 BCE0		BPL $BCE5
 BCE2		JMP $B7C1
 BCE5	iBCE5	LDY #$00
 BCE7		LDA ($40),Y	; INPUT, READ and GET vector to save CHRGET
 BCE9		BEQ $BCF6	; exint	Input Error Messages			DATA
 BCEB		LDA $10		; 3: width of source (unused - from TTY)
 BCED		BNE $BCF6	; exint	Input Error Messages			DATA
 BCEF		LDA #$F7
 BCF1		LDY #$BC
 BCF3		JMP $BB1D	; strout	Output String


; exint	Input Error Messages			DATA

 BCF6		.byte 60 3F 45 58 54 52 41 20  ;`?extra 
 BCFE		.byte 49 47 4E 4F 52 45 44 0D  ;ignored.
 BD06		.byte 00 3F 52 45 44 4F 20 46  ;.?redo f
 BD0E		.byte 52 4F 4D 20 53 54 41 52  ;rom star
 BD16		.byte 54 0D 00                 ;t..


; next	Perform [next]

 BD19		BNE $BD1F
 BD1B		LDY #$00
 BD1D		BEQ $BD22
 BD1F	iBD1F	JSR $C12B	; ptrget	Identify Variable
 BD22	iBD22	STA $46		; Pointer: Index Variable for FOR/NEXT
 BD24		STY $47
 BD26		JSR $B322	; fndfor	Find FOR/GOSUB Entry on Stack
 BD29		BEQ $BD2F
 BD2B		LDX #$00
 BD2D	iBD2D	BEQ $BD95
 BD2F	iBD2F	TXS
 BD30		TXA
 BD31		CLC
 BD32		ADC #$04
 BD34		PHA
 BD35		ADC #$06
 BD37		STA $21
 BD39		PLA
 BD3A		LDY #$01
 BD3C		JSR $CCD8	; movfm	Load FAC#1 From Memory
 BD3F		TSX
 BD40		LDA $0109,X
 BD43		STA $63		; Floating Accum. #1: Sign
 BD45		LDA $46		; Pointer: Index Variable for FOR/NEXT
 BD47		LDY $47
 BD49		JSR $C99D	; fadd	Perform Addition
 BD4C		JSR $CD06
 BD4F		LDY #$01
 BD51		JSR $CD93
 BD54		TSX
 BD55		SEC
 BD56		SBC $0109,X
 BD59		BEQ $BD72


; donext	Check Valid Loop

 BD5B		LDA $010F,X
 BD5E		STA $36		; Current BASIC Line Number
 BD60		LDA $0110,X
 BD63		STA $37
 BD65		LDA $0112,X
 BD68		STA $77		; Pointer: Current Byte of BASIC Text
 BD6A		LDA $0111,X
 BD6D		STA $78
 BD6F	iBD6F	JMP $B74A	; newstt	BASIC Warm Start
 BD72	iBD72	TXA
 BD73		ADC #$11
 BD75		TAX
 BD76		TXS
 BD77		JSR $0076	; Entry to Get Same Byte of Text Again
 BD7A		CMP #$2C
 BD7C		BNE $BD6F
 BD7E		JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 BD81		JSR $BD1F


; frmnum	Confirm Result

 BD84	iBD84	JSR $BD98	; frmevl	Evaluate Expression in Text


; -Confirm numeric mode

 BD87	iBD87	CLC
 BD88		BIT $38

; *** Resyncing ***

; -Confirm string mode

 BD89	iBD89	SEC
 BD8A	iBD8A	BIT $07
 BD8C		BMI $BD91
 BD8E		BCS $BD93
 BD90	iBD90	RTS
 BD91	iBD91	BCS $BD90
 BD93	iBD93	LDX #$A3
 BD95	iBD95	JMP $B3CF	; error	Error Routine


; frmevl	Evaluate Expression in Text

 BD98	iBD98	LDX $77		; Pointer: Current Byte of BASIC Text
 BD9A		BNE $BD9E
 BD9C		DEC $78
 BD9E	iBD9E	DEC $77		; Pointer: Current Byte of BASIC Text
 BDA0		LDX #$00
 BDA2		BIT $48
; *** BDA2: ADDRESS DIFFER. This may indicate misassembly ***
 BDA4		TXA
 BDA5		PHA
 BDA6		LDA #$01
 BDA8		JSR $B393	; getstk	Check Stack Depth
 BDAB		JSR $BE81	; eval	Evaluate Single Term
 BDAE		LDA #$00
 BDB0		STA $4A		; Comparison symbol accumulator: bits 0,1,2 are <, =, >.
 BDB2	iBDB2	JSR $0076	; Entry to Get Same Byte of Text Again
 BDB5	iBDB5	SEC
 BDB6		SBC #$B1
 BDB8		BCC $BDD1
 BDBA		CMP #$03
 BDBC		BCS $BDD1
 BDBE		CMP #$01
 BDC0		ROL
 BDC1		EOR #$01
 BDC3		EOR $4A		; Comparison symbol accumulator: bits 0,1,2 are <, =, >.
 BDC5		CMP $4A		; Comparison symbol accumulator: bits 0,1,2 are <, =, >.
 BDC7		BCC $BE2A
 BDC9		STA $4A		; Comparison symbol accumulator: bits 0,1,2 are <, =, >.
 BDCB		JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 BDCE		JMP $BDB5
 BDD1	iBDD1	LDX $4A		; Comparison symbol accumulator: bits 0,1,2 are <, =, >.
 BDD3		BNE $BE01
 BDD5		BCS $BE56
 BDD7		ADC #$07
 BDD9		BCC $BE56
 BDDB		ADC $07		; Data Type: $FF = String, $00 = Numeric
 BDDD		BNE $BDE2
 BDDF		JMP $C74F	; cat	Concatenate Two Strings
 BDE2	iBDE2	ADC #$FF
 BDE4		STA $1F		; Utility Pointer Area
 BDE6		ASL
 BDE7		ADC $1F		; Utility Pointer Area
 BDE9		TAY
 BDEA	iBDEA	PLA
 BDEB		CMP $B094,Y	; optab	BASIC Operator Vectors			DATA
 BDEE		BCS $BE5B
 BDF0		JSR $BD87	; -Confirm numeric mode
 BDF3	iBDF3	PHA
 BDF4	iBDF4	JSR $BE1A
 BDF7		PLA
 BDF8		LDY $48		; Y-save; op-save; Temporary storage for TXTPTR
 BDFA		BPL $BE13
 BDFC		TAX
 BDFD		BEQ $BE59
 BDFF		BNE $BE64
 BE01	iBE01	LSR $07		; Data Type: $FF = String, $00 = Numeric
 BE03		TXA
 BE04		ROL
 BE05		LDX $77		; Pointer: Current Byte of BASIC Text
 BE07		BNE $BE0B
 BE09		DEC $78
 BE0B	iBE0B	DEC $77		; Pointer: Current Byte of BASIC Text
 BE0D		LDY #$1B
 BE0F		STA $4A		; Comparison symbol accumulator: bits 0,1,2 are <, =, >.
 BE11		BNE $BDEA
 BE13	iBE13	CMP $B094,Y	; optab	BASIC Operator Vectors			DATA
 BE16		BCS $BE64
 BE18		BCC $BDF3
 BE1A	iBE1A	LDA $B096,Y
 BE1D		PHA
 BE1E		LDA $B095,Y
 BE21		PHA
 BE22		JSR $BE2D
 BE25		LDA $4A		; Comparison symbol accumulator: bits 0,1,2 are <, =, >.
 BE27		JMP $BDA3
 BE2A	iBE2A	JMP $BF00	; synerr	Output ?SYNTAX Error
 BE2D	iBE2D	LDA $63		; Floating Accum. #1: Sign
 BE2F		LDX $B094,Y	; optab	BASIC Operator Vectors			DATA
 BE32	iBE32	TAY
 BE33		PLA
 BE34		STA $1F		; Utility Pointer Area
 BE36		PLA
 BE37		STA $20
 BE39		TYA
 BE3A		PHA
 BE3B		INC $1F		; Utility Pointer Area
 BE3D		BNE $BE41
 BE3F		INC $20
 BE41	iBE41	JSR $CD51	; round	Round FAC#1
 BE44		LDA $62
 BE46		PHA
 BE47		LDA $61
 BE49		PHA
 BE4A		LDA $60
 BE4C		PHA
 BE4D		LDA $5F		; Floating Accum. #1: Mantissa
 BE4F		PHA
 BE50		LDA $5E		; Floating-Point Accumulator #1: Exponent
 BE52		PHA
 BE53		JMP ($001F)	; Utility Pointer Area
 BE56	iBE56	LDY #$FF
 BE58		PLA
 BE59	iBE59	BEQ $BE7E
 BE5B	iBE5B	CMP #$64
 BE5D		BEQ $BE62
 BE5F		JSR $BD87	; -Confirm numeric mode
 BE62	iBE62	STY $48		; Y-save; op-save; Temporary storage for TXTPTR
 BE64	iBE64	PLA
 BE65		LSR
 BE66		STA $0C		; Flag TAN sign / Comparison Result
 BE68		PLA
 BE69		STA $66		; Floating-Point Accumulator #2: Exponent
 BE6B		PLA
 BE6C		STA $67		; Floating Accum. #2: Mantissa
 BE6E		PLA
 BE6F		STA $68
 BE71		PLA
 BE72		STA $69
 BE74		PLA
 BE75		STA $6A
 BE77		PLA
 BE78		STA $6B		; Floating Accum. #2: Sign
 BE7A		EOR $63		; Floating Accum. #1: Sign
 BE7C		STA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 BE7E	iBE7E	LDA $5E		; Floating-Point Accumulator #1: Exponent
 BE80		RTS


; eval	Evaluate Single Term

 BE81	iBE81	LDA #$00
 BE83		STA $07		; Data Type: $FF = String, $00 = Numeric
 BE85	iBE85	JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 BE88		BCS $BE8D
 BE8A	iBE8A	JMP $CE29	; fin	Convert ASCII String to a Number in FAC#1
 BE8D	iBE8D	JSR $C1B6	; isletc	Does A hold an alphabetic character?
 BE90		BCS $BF0D
 BE92		CMP #$FF
 BE94		BNE $BEA5	; qdot	Continue Expression
 BE96		LDA #$A0
 BE98		LDY #$BE
 BE9A		JSR $CCD8	; movfm	Load FAC#1 From Memory
 BE9D		JMP $0070	; Subroutine: Get Next Byte of BASIC Text


; pival	Constant - PI				DATA

 BEA0		.byte 82 49 0F DA A1           ;.i.Z.


; qdot	Continue Expression

 BEA5	iBEA5	CMP #$2E
 BEA7		BEQ $BE8A
 BEA9		CMP #$AB
 BEAB		BEQ $BF05	; domin	Set up NOT Function
 BEAD		CMP #$AA
 BEAF		BEQ $BE85
 BEB1		CMP #$22
 BEB3		BNE $BEC4
 BEB5	iBEB5	LDA $77		; Pointer: Current Byte of BASIC Text
 BEB7		LDY $78
 BEB9		ADC #$00
 BEBB		BCC $BEBE
 BEBD		INY
 BEBE	iBEBE	JSR $C5B0	; strlit	Set Up String
 BEC1		JMP $C918
 BEC4	iBEC4	CMP #$A8
 BEC6		BNE $BEDB
 BEC8		LDY #$18
 BECA		BNE $BF07


; -	Evaluate <equal>

 BECC		JSR $C2EA	; ayint	FAC#1 to Positive Integer
 BECF		LDA $62
 BED1		EOR #$FF
 BED3		TAY
 BED4		LDA $61
 BED6		EOR #$FF
 BED8		JMP $C4BC	; givayf	Convert Integer in (AC/YR) to Flpt
 BEDB	iBEDB	CMP #$A5
 BEDD		BNE $BEE2
 BEDF		JMP $C51D	; fndoer	Perform [fn]
 BEE2	iBEE2	CMP #$B4
 BEE4		BCC $BEE9	; parchk	Expression in Brackets
 BEE6		JMP $C047	; isfun	Identify Function Type


; parchk	Expression in Brackets

 BEE9	iBEE9	JSR $BEF2	; -Test '('-
 BEEC		JSR $BD98	; frmevl	Evaluate Expression in Text


; chkcls	Confirm Character\-Test ')'-

 BEEF	iBEEF	LDA #$29
 BEF1		BIT $28A9

; *** Resyncing ***

; -Test '('-

 BEF2	iBEF2	LDA #$28
 BEF4		BIT $2CA9

; *** Resyncing ***

; -Test comma-

 BEF5	iBEF5	LDA #$2C


; -Confirm Character in A

 BEF7	iBEF7	LDY #$00
 BEF9		CMP ($77),Y	; Pointer: Current Byte of BASIC Text
 BEFB		BNE $BF00	; synerr	Output ?SYNTAX Error
 BEFD		JMP $0070	; Subroutine: Get Next Byte of BASIC Text


; synerr	Output ?SYNTAX Error

 BF00	iBF00	LDX #$10
 BF02		JMP $B3CF	; error	Error Routine


; domin	Set up NOT Function

 BF05	iBF05	LDY #$15
 BF07	iBF07	PLA
 BF08		PLA
 BF09		JMP $BDF4


; Patch for getspt

 BF0C		CLV
 BF0D	iBF0D	JMP $BF8C	; isvar	Search for Variable

 BF10	iBF10	PHA
 BF11		LDA $0D		; 3: Flag to suppress PRINT or PRINT# when -ve
 BF13		BEQ $BF1D
 BF15		PLA
 BF16		CMP $0F		; 3: terminal width (unused-carried over from TTY)
 BF18		BNE $BF1E
 BF1A		JMP $BA70
 BF1D	iBF1D	PLA
 BF1E	iBF1E	JMP $BA74


; ?

 BF21	iBF21	JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 BF24		CMP #$FF
 BF26		BNE $BF2B
 BF28		JMP $BF00	; synerr	Output ?SYNTAX Error
 BF2B	iBF2B	JMP $0076	; Entry to Get Same Byte of Text Again


; Patch for [input]

 BF2E	iBF2E	LDA $10		; 3: width of source (unused - from TTY)
 BF30		BNE $BF35
 BF32		JMP $BBF1
 BF35	iBF35	LDA $96		; Kernal I/O Status Word: ST
 BF37		AND #$40
 BF39		BNE $BF3E
 BF3B		JMP $BBD5
 BF3E	iBF3E	JMP $BC09


; Unused					EMPTY

 BF41		.byte AA AA AA AA AA AA AA AA  ;........
 BF49		.byte AA AA AA AA AA AA AA AA  ;........
 BF51		.byte AA AA AA AA AA AA AA AA  ;........
 BF59		.byte AA AA AA AA AA AA AA AA  ;........
 BF61		.byte AA AA AA AA AA AA AA AA  ;........
 BF69		.byte AA AA AA AA AA AA AA AA  ;........
 BF71		.byte AA AA AA AA AA AA AA AA  ;........
 BF79		.byte AA AA AA AA AA AA AA AA  ;........
 BF81		.byte AA AA AA AA AA AA AA AA  ;........
 BF89		.byte AA AA AA                 ;...


; isvar	Search for Variable

 BF8C	iBF8C	JSR $C12B	; ptrget	Identify Variable
 BF8F		STA $61
 BF91		STY $62
 BF93		LDA $42		; Current BASIC Variable Name
 BF95		LDY $43
 BF97		LDX $07		; Data Type: $FF = String, $00 = Numeric
 BF99		BEQ $BFD4
 BF9B		LDX #$00
 BF9D		STX $6D		; Floating Accum. #1. Low-Order (Rounding)
 BF9F		LDX $62
 BFA1		CPX #$8B
 BFA3		BCC $BFD3
 BFA5		CMP #$54
 BFA7		BNE $BFC1
 BFA9		CPY #$C9
 BFAB		BNE $BFC1


; tisasc	Convert TI to ASCII String

 BFAD		JSR $C003	; -read real time clock
 BFB0		STY $5B
 BFB2		DEY
 BFB3		STY $6E		; Pointer: Cassette Buffer
 BFB5		LDY #$06
 BFB7		STY $5A
 BFB9		LDY #$24
 BFBB		JSR $D01E	; foutim	Convert TI to String
 BFBE		JMP $C598
 BFC1	iBFC1	CMP #$44
 BFC3		BNE $BFD3
 BFC5		CPY #$D3
 BFC7		BNE $BFD3
 BFC9		JSR $BFFC
 BFCC		LDA $0E		; 3: File# of current I/O device (as 0010)
 BFCE		LDY $0F		; 3: terminal width (unused-carried over from TTY)
 BFD0		JMP $C5B0	; strlit	Set Up String
 BFD3	iBFD3	RTS
 BFD4	iBFD4	LDX $08		; Data Type: $80 = Integer, $00 = Floating
 BFD6		BPL $BFE5
 BFD8		LDY #$00
 BFDA		LDA ($61),Y
 BFDC		TAX
 BFDD		INY
 BFDE		LDA ($61),Y
 BFE0		TAY
 BFE1		TXA
 BFE2		JMP $C4BC	; givayf	Convert Integer in (AC/YR) to Flpt
 BFE5	iBFE5	LDX $62
 BFE7		CPX #$8B
 BFE9		BCC $C040
 BFEB		CMP #$54
 BFED		BNE $C00F
 BFEF		CPY #$49
 BFF1		BNE $C040
 BFF3		JSR $C003	; -read real time clock
 BFF6		TYA
 BFF7		LDX #$A0
 BFF9		JMP $CD85
 BFFC	iBFFC	LDA $0D		; 3: Flag to suppress PRINT or PRINT# when -ve
 BFFE		BNE $BFD3
 C000		JMP $FFBD	; jmp $d995


; -read real time clock

 C003	iC003	LDA #$8B
 C005		LDY #$00
 C007		SEI
 C008		JSR $CCD8	; movfm	Load FAC#1 From Memory
 C00B		CLI
 C00C		STY $5F		; Floating Accum. #1: Mantissa
 C00E		RTS
 C00F	iC00F	CMP #$53
 C011		BNE $C01C
 C013		CPY #$54
 C015		BNE $C01C
 C017		LDA $96		; Kernal I/O Status Word: ST
 C019		JMP $CD72
 C01C	iC01C	CMP #$44
 C01E		BNE $C040
 C020		CPY #$53
 C022		BNE $C040
 C024		JSR $BFFC
 C027		LDY #$00
 C029		LDA ($0E),Y	; 3: File# of current I/O device (as 0010)
 C02B		AND #$0F
 C02D		ASL
 C02E		STA $09		; Flag: DATA scan/LlST quote/Garbage Coll
 C030		ASL
 C031		ASL
 C032		ADC $09		; Flag: DATA scan/LlST quote/Garbage Coll
 C034		STA $09		; Flag: DATA scan/LlST quote/Garbage Coll
 C036		INY
 C037		LDA ($0E),Y	; 3: File# of current I/O device (as 0010)
 C039		AND #$0F
 C03B		ADC $09		; Flag: DATA scan/LlST quote/Garbage Coll
 C03D		JMP $CD72
 C040	iC040	LDA $61
 C042		LDY $62
 C044		JMP $CCD8	; movfm	Load FAC#1 From Memory


; isfun	Identify Function Type

 C047	iC047	ASL
 C048		PHA
 C049		TAX
 C04A		JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 C04D		CPX #$8F
 C04F		BCC $C071	; numfun	Evaluate Numeric Function


; strfun	Evaluate String Function

 C051		JSR $BEF2	; -Test '('-
 C054		JSR $BD98	; frmevl	Evaluate Expression in Text
 C057		JSR $BEF5	; -Test comma-
 C05A		JSR $BD89	; -Confirm string mode
 C05D		PLA
 C05E		TAX
 C05F		LDA $62
 C061		PHA
 C062		LDA $61
 C064		PHA
 C065		TXA
 C066		PHA
 C067		JSR $C8D4	; -Eval Byte Parameter
 C06A		PLA
 C06B		TAY
 C06C		TXA
 C06D		PHA
 C06E		JMP $C076


; numfun	Evaluate Numeric Function

 C071	iC071	JSR $BEE9	; parchk	Expression in Brackets
 C074		PLA
 C075		TAY
 C076	iC076	LDA $AFFE,Y
 C079		STA $52
 C07B		LDA $AFFF,Y
 C07E		STA $53
 C080		JSR $0051
 C083		JMP $BD87	; -Confirm numeric mode


; orop	Evaluate <or>

 C086		LDY #$FF
 C088		BIT $00A0

; *** Resyncing ***

; -	Evaluate <and>

 C089		LDY #$00
 C08B		STY $05		; Input Buffer Pointer / No. of Subscripts
 C08D		JSR $C2EA	; ayint	FAC#1 to Positive Integer
 C090		LDA $61
 C092		EOR $05		; Input Buffer Pointer / No. of Subscripts
 C094		STA $03		; Search Character
 C096		LDA $62
 C098		EOR $05		; Input Buffer Pointer / No. of Subscripts
 C09A		STA $04		; Flag: Scan for Quote at End of String
 C09C		JSR $CD32	; movfa	Copy FAC#2 into FAC#1
 C09F		JSR $C2EA	; ayint	FAC#1 to Positive Integer
 C0A2		LDA $62
 C0A4		EOR $05		; Input Buffer Pointer / No. of Subscripts
 C0A6		AND $04		; Flag: Scan for Quote at End of String
 C0A8		EOR $05		; Input Buffer Pointer / No. of Subscripts
 C0AA		TAY
 C0AB		LDA $61
 C0AD		EOR $05		; Input Buffer Pointer / No. of Subscripts
 C0AF		AND $03		; Search Character
 C0B1		EOR $05		; Input Buffer Pointer / No. of Subscripts
 C0B3		JMP $C4BC	; givayf	Convert Integer in (AC/YR) to Flpt


; dorel	Evaluate <less> (comparison)

 C0B6		JSR $BD8A
 C0B9		BCS $C0CE	; strrel	String Comparison


; numrel	Numeric Comparison

 C0BB		LDA $6B		; Floating Accum. #2: Sign
 C0BD		ORA #$7F
 C0BF		AND $67		; Floating Accum. #2: Mantissa
 C0C1		STA $67		; Floating Accum. #2: Mantissa
 C0C3		LDA #$66
 C0C5		LDY #$00
 C0C7		JSR $CD91	; fcomp	Compare FAC#1 With Memory
 C0CA		TAX
 C0CB		JMP $C101


; strrel	String Comparison

 C0CE	iC0CE	LDA #$00
 C0D0		STA $07		; Data Type: $FF = String, $00 = Numeric
 C0D2		DEC $4A		; Comparison symbol accumulator: bits 0,1,2 are <, =, >.
 C0D4		JSR $C7B8
 C0D7		STA $5E		; Floating-Point Accumulator #1: Exponent
 C0D9		STX $5F		; Floating Accum. #1: Mantissa
 C0DB		STY $60
 C0DD		LDA $69
 C0DF		LDY $6A
 C0E1		JSR $C7BC
 C0E4		STX $69
 C0E6		STY $6A
 C0E8		TAX
 C0E9		SEC
 C0EA		SBC $5E		; Floating-Point Accumulator #1: Exponent
 C0EC		BEQ $C0F6
 C0EE		LDA #$01
 C0F0		BCC $C0F6
 C0F2		LDX $5E		; Floating-Point Accumulator #1: Exponent
 C0F4		LDA #$FF
 C0F6	iC0F6	STA $63		; Floating Accum. #1: Sign
 C0F8		LDY #$FF
 C0FA		INX
 C0FB	iC0FB	INY
 C0FC		DEX
 C0FD		BNE $C106
 C0FF		LDX $63		; Floating Accum. #1: Sign
 C101	iC101	BMI $C112
 C103		CLC
 C104		BCC $C112
 C106	iC106	LDA ($69),Y
 C108		CMP ($5F),Y	; Floating Accum. #1: Mantissa
 C10A		BEQ $C0FB
 C10C		LDX #$FF
 C10E		BCS $C112
 C110		LDX #$01
 C112	iC112	INX
 C113		TXA
 C114		ROL
 C115		AND $0C		; Flag TAN sign / Comparison Result
 C117		BEQ $C11B
 C119		LDA #$FF
 C11B	iC11B	JMP $CD72


; dim	Perform [dim]

 C11E	iC11E	JSR $BEF5	; -Test comma-
 C121		TAX
 C122		JSR $C130
 C125		JSR $0076	; Entry to Get Same Byte of Text Again
 C128		BNE $C11E	; dim	Perform [dim]
 C12A		RTS


; ptrget	Identify Variable

 C12B	iC12B	LDX #$00
 C12D		JSR $0076	; Entry to Get Same Byte of Text Again
 C130	iC130	STX $06		; Flag: Default Array DiMension / array name initial / AND, OR flag
 C132	iC132	STA $42		; Current BASIC Variable Name
 C134		JSR $0076	; Entry to Get Same Byte of Text Again
 C137		JSR $C1B6	; isletc	Does A hold an alphabetic character?
 C13A		BCS $C13F
 C13C	iC13C	JMP $BF00	; synerr	Output ?SYNTAX Error
 C13F	iC13F	LDX #$00
 C141		STX $07		; Data Type: $FF = String, $00 = Numeric
 C143		STX $08		; Data Type: $80 = Integer, $00 = Floating
 C145		JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 C148		BCC $C14F
 C14A		JSR $C1B6	; isletc	Does A hold an alphabetic character?
 C14D		BCC $C15A
 C14F	iC14F	TAX
 C150	iC150	JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 C153		BCC $C150
 C155		JSR $C1B6	; isletc	Does A hold an alphabetic character?
 C158		BCS $C150
 C15A	iC15A	CMP #$24
 C15C		BNE $C164
 C15E		LDA #$FF
 C160		STA $07		; Data Type: $FF = String, $00 = Numeric
 C162		BNE $C174
 C164	iC164	CMP #$25
 C166		BNE $C17B
 C168		LDA $0A		; Flag: Subscript Ref / User Function Call
 C16A		BNE $C13C
 C16C		LDA #$80
 C16E		STA $08		; Data Type: $80 = Integer, $00 = Floating
 C170		ORA $42		; Current BASIC Variable Name
 C172		STA $42		; Current BASIC Variable Name
 C174	iC174	TXA
 C175		ORA #$80
 C177		TAX
 C178		JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 C17B	iC17B	STX $43
 C17D		SEC
 C17E		ORA $0A		; Flag: Subscript Ref / User Function Call
 C180		SBC #$28
 C182		BNE $C187	; ordvar	Locate Ordinary Variable
 C184		JMP $C2FC	; isary	Get Array Parameters


; ordvar	Locate Ordinary Variable

 C187	iC187	LDY #$00
 C189		STY $0A		; Flag: Subscript Ref / User Function Call
 C18B		LDA $2A		; Pointer: Start of BASIC Variables
 C18D		LDX $2B
 C18F	iC18F	STX $5D
 C191	iC191	STA $5C
 C193		CPX $2D
 C195		BNE $C19B
 C197		CMP $2C		; Pointer: Start of BASIC Arrays
 C199		BEQ $C1C0	; notfns	Create New Variable
 C19B	iC19B	LDA $42		; Current BASIC Variable Name
 C19D		CMP ($5C),Y
 C19F		BNE $C1AC
 C1A1		LDA $43
 C1A3		INY
 C1A4		CMP ($5C),Y
 C1A6		BNE $C1AB
 C1A8		JMP $C2B9
 C1AB	iC1AB	DEY
 C1AC	iC1AC	CLC
 C1AD		LDA $5C
 C1AF		ADC #$07
 C1B1		BCC $C191
 C1B3		INX
 C1B4		BNE $C18F


; isletc	Does A hold an alphabetic character?

 C1B6	iC1B6	CMP #$41
 C1B8		BCC $C1BF
 C1BA		SBC #$5B
 C1BC		SEC
 C1BD		SBC #$A5
 C1BF	iC1BF	RTS


; notfns	Create New Variable

 C1C0	iC1C0	PLA
 C1C1		PHA
 C1C2		CMP #$8E
 C1C4		BNE $C1CB	; notevl	Create Variable
 C1C6	iC1C6	LDA #$C9
 C1C8		LDY #$D0
 C1CA		RTS


; notevl	Create Variable

 C1CB	iC1CB	LDA $42		; Current BASIC Variable Name
 C1CD		LDY $43
 C1CF		CMP #$54
 C1D1		BNE $C1DE
 C1D3		CPY #$C9
 C1D5		BEQ $C1C6
 C1D7		CPY #$49
 C1D9		BNE $C1DE
 C1DB	iC1DB	JMP $BF00	; synerr	Output ?SYNTAX Error
 C1DE	iC1DE	CMP #$53
 C1E0		BNE $C1E6
 C1E2		CPY #$54
 C1E4		BEQ $C1DB
 C1E6	iC1E6	CMP #$44
 C1E8		BNE $C1F2
 C1EA		CPY #$53
 C1EC		BEQ $C1DB
 C1EE		CPY #$D3
 C1F0		BEQ $C1DB
 C1F2	iC1F2	LDA $2C		; Pointer: Start of BASIC Arrays
 C1F4		LDY $2D
 C1F6		STA $5C
 C1F8		STY $5D
 C1FA		LDA $2E		; Pointer End of BASIC Arrays (+1)
 C1FC		LDY $2F
 C1FE		STA $57
 C200		STY $58
 C202		CLC
 C203		ADC #$07
 C205		BCC $C208
 C207		INY
 C208	iC208	STA $55
 C20A		STY $56
 C20C		JSR $B350	; bltu	Open Space in Memory
 C20F		LDA $55
 C211		LDY $56
 C213		INY
 C214		STA $2C		; Pointer: Start of BASIC Arrays
 C216		STY $2D
 C218		STA $55
 C21A		STY $56
 C21C	iC21C	LDA $55
 C21E		LDX $56
 C220	iC220	CPX $2F
 C222		BNE $C228
 C224		CMP $2E		; Pointer End of BASIC Arrays (+1)
 C226		BEQ $C29D
 C228	iC228	STA $1F		; Utility Pointer Area
 C22A		STX $20
 C22C		LDY #$00
 C22E		LDA ($1F),Y	; Utility Pointer Area
 C230		TAX
 C231		INY
 C232		LDA ($1F),Y	; Utility Pointer Area
 C234		PHP
 C235		INY
 C236		LDA ($1F),Y	; Utility Pointer Area
 C238		ADC $55
 C23A		STA $55
 C23C		INY
 C23D		LDA ($1F),Y	; Utility Pointer Area
 C23F		ADC $56
 C241		STA $56
 C243		PLP
 C244		BPL $C21C
 C246		TXA
 C247		BMI $C21C
 C249		INY
 C24A		LDA ($1F),Y	; Utility Pointer Area
 C24C		LDY #$00
 C24E		ASL
 C24F		ADC #$05
 C251		ADC $1F		; Utility Pointer Area
 C253		STA $1F		; Utility Pointer Area
 C255		BCC $C259
 C257		INC $20
 C259	iC259	LDX $20
 C25B		CPX $56
 C25D		BNE $C263
 C25F		CMP $55
 C261		BEQ $C220
 C263	iC263	LDY #$00
 C265		LDA ($1F),Y	; Utility Pointer Area
 C267		BEQ $C290
 C269		INY
 C26A		CLC
 C26B		ADC ($1F),Y	; Utility Pointer Area
 C26D		STA $57
 C26F		TAX
 C270		INY
 C271		LDA ($1F),Y	; Utility Pointer Area
 C273		ADC #$00
 C275		STA $58
 C277		CMP $31
 C279		BCC $C290
 C27B		BNE $C281
 C27D		CPX $30		; Pointer: Bottom of String Storage
 C27F		BCC $C290
 C281	iC281	LDY #$00
 C283		LDA ($57),Y
 C285		ADC #$06
 C287		STA ($57),Y
 C289		INY
 C28A		LDA ($57),Y
 C28C		ADC #$00
 C28E		STA ($57),Y
 C290	iC290	LDA #$03
 C292		CLC
 C293		ADC $1F		; Utility Pointer Area
 C295		STA $1F		; Utility Pointer Area
 C297		BCC $C259
 C299		INC $20
 C29B		BNE $C259
 C29D	iC29D	LDY #$00
 C29F		LDA $42		; Current BASIC Variable Name
 C2A1		STA ($5C),Y
 C2A3		INY
 C2A4		LDA $43
 C2A6		STA ($5C),Y
 C2A8		LDA #$00
 C2AA		INY
 C2AB		STA ($5C),Y
 C2AD		INY
 C2AE		STA ($5C),Y
 C2B0		INY
 C2B1		STA ($5C),Y
 C2B3		INY
 C2B4		STA ($5C),Y
 C2B6		INY
 C2B7		STA ($5C),Y
 C2B9	iC2B9	LDA $5C
 C2BB		CLC
 C2BC		ADC #$02
 C2BE		LDY $5D
 C2C0		BCC $C2C3
 C2C2		INY
 C2C3	iC2C3	STA $44		; Pointer: Current BASIC Variable Data
 C2C5		STY $45
 C2C7		RTS


; aryget	Allocate Array Pointer Space

 C2C8	iC2C8	LDA $05		; Input Buffer Pointer / No. of Subscripts
 C2CA		ASL
 C2CB		ADC #$05
 C2CD		ADC $5C
 C2CF		LDY $5D
 C2D1		BCC $C2D4
 C2D3		INY
 C2D4	iC2D4	STA $55
 C2D6		STY $56
 C2D8		RTS


; n32768	Constant 32768 in Flpt			DATA

 C2D9		.byte 90 80 00 00              ;....


; intidx	Evaluate Text for Integer

 C2DD	iC2DD	JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 C2E0		JSR $BD98	; frmevl	Evaluate Expression in Text
 C2E3	iC2E3	JSR $BD87	; -Confirm numeric mode
 C2E6		LDA $63		; Floating Accum. #1: Sign
 C2E8		BMI $C2F7


; ayint	FAC#1 to Positive Integer

 C2EA	iC2EA	LDA $5E		; Floating-Point Accumulator #1: Exponent
 C2EC		CMP #$90
 C2EE		BCC $C2F9
 C2F0		LDA #$D9
 C2F2		LDY #$C2
 C2F4		JSR $CD91	; fcomp	Compare FAC#1 With Memory
 C2F7	iC2F7	BNE $C373	; -	?ILLEGAL QUANTITY
 C2F9	iC2F9	JMP $CDD1	; qint	Convert FAC#1 to Integer


; isary	Get Array Parameters

 C2FC	iC2FC	LDA $06		; Flag: Default Array DiMension / array name initial / AND, OR flag
 C2FE		ORA $08		; Data Type: $80 = Integer, $00 = Floating
 C300		PHA
 C301		LDA $07		; Data Type: $FF = String, $00 = Numeric
 C303		PHA
 C304		LDY #$00
 C306	iC306	TYA
 C307		PHA
 C308		LDA $43
 C30A		PHA
 C30B		LDA $42		; Current BASIC Variable Name
 C30D		PHA
 C30E		JSR $C2DD	; intidx	Evaluate Text for Integer
 C311		PLA
 C312		STA $42		; Current BASIC Variable Name
 C314		PLA
 C315		STA $43
 C317		PLA
 C318		TAY
 C319		TSX
 C31A		LDA $0102,X
 C31D		PHA
 C31E		LDA $0101,X
 C321		PHA
 C322		LDA $61
 C324		STA $0102,X
 C327		LDA $62
 C329		STA $0101,X
 C32C		INY
 C32D		JSR $0076	; Entry to Get Same Byte of Text Again
 C330		CMP #$2C
 C332		BEQ $C306
 C334		STY $05		; Input Buffer Pointer / No. of Subscripts
 C336		JSR $BEEF	; chkcls	Confirm Character
 C339		PLA
 C33A		STA $07		; Data Type: $FF = String, $00 = Numeric
 C33C		PLA
 C33D		STA $08		; Data Type: $80 = Integer, $00 = Floating
 C33F		AND #$7F
 C341		STA $06		; Flag: Default Array DiMension / array name initial / AND, OR flag


; fndary	Find Array

 C343		LDX $2C		; Pointer: Start of BASIC Arrays
 C345		LDA $2D
 C347	iC347	STX $5C
 C349		STA $5D
 C34B		CMP $2F
 C34D		BNE $C353
 C34F		CPX $2E		; Pointer End of BASIC Arrays (+1)
 C351		BEQ $C38C	; notfdd	Create Array
 C353	iC353	LDY #$00
 C355		LDA ($5C),Y
 C357		INY
 C358		CMP $42		; Current BASIC Variable Name
 C35A		BNE $C362
 C35C		LDA $43
 C35E		CMP ($5C),Y
 C360		BEQ $C378	; -	?REDIM'D ARRAY
 C362	iC362	INY
 C363		LDA ($5C),Y
 C365		CLC
 C366		ADC $5C
 C368		TAX
 C369		INY
 C36A		LDA ($5C),Y
 C36C		ADC $5D
 C36E		BCC $C347


; bserr	?BAD SUBSCRIPT

 C370	iC370	LDX #$6B
 C372		BIT $35A2

; *** Resyncing ***

; -	?ILLEGAL QUANTITY

 C373	iC373	LDX #$35
 C375	iC375	JMP $B3CF	; error	Error Routine


; -	?REDIM'D ARRAY

 C378	iC378	LDX #$78
 C37A		LDA $06		; Flag: Default Array DiMension / array name initial / AND, OR flag
 C37C		BNE $C375
 C37E		JSR $C2C8	; aryget	Allocate Array Pointer Space
 C381		LDA $05		; Input Buffer Pointer / No. of Subscripts
 C383		LDY #$04
 C385		CMP ($5C),Y
 C387		BNE $C370	; bserr	?BAD SUBSCRIPT
 C389		JMP $C415


; notfdd	Create Array

 C38C	iC38C	JSR $C2C8	; aryget	Allocate Array Pointer Space
 C38F		JSR $B3A0	; reason	Check Memory Overlap
 C392		LDY #$00
 C394		STY $6F
 C396		LDX #$05
 C398		LDA $42		; Current BASIC Variable Name
 C39A		STA ($5C),Y
 C39C		BPL $C39F
 C39E		DEX
 C39F	iC39F	INY
 C3A0		LDA $43
 C3A2		STA ($5C),Y
 C3A4		BPL $C3A8
 C3A6		DEX
 C3A7		DEX
 C3A8	iC3A8	STX $6E		; Pointer: Cassette Buffer
 C3AA		LDA $05		; Input Buffer Pointer / No. of Subscripts
 C3AC		INY
 C3AD		INY
 C3AE		INY
 C3AF		STA ($5C),Y
 C3B1	iC3B1	LDX #$0B
 C3B3		LDA #$00
 C3B5		BIT $06
 C3B7		BVC $C3C1
 C3B9		PLA
 C3BA		CLC
 C3BB		ADC #$01
 C3BD		TAX
 C3BE		PLA
 C3BF		ADC #$00
 C3C1	iC3C1	INY
 C3C2		STA ($5C),Y
 C3C4		INY
 C3C5		TXA
 C3C6		STA ($5C),Y
 C3C8		JSR $C477	; umult	Number of Bytes in Subscript
 C3CB		STX $6E		; Pointer: Cassette Buffer
 C3CD		STA $6F
 C3CF		LDY $1F		; Utility Pointer Area
 C3D1		DEC $05		; Input Buffer Pointer / No. of Subscripts
 C3D3		BNE $C3B1
 C3D5		ADC $56
 C3D7		BCS $C436
 C3D9		STA $56
 C3DB		TAY
 C3DC		TXA
 C3DD		ADC $55
 C3DF		BCC $C3E4
 C3E1		INY
 C3E2		BEQ $C436
 C3E4	iC3E4	JSR $B3A0	; reason	Check Memory Overlap
 C3E7		STA $2E		; Pointer End of BASIC Arrays (+1)
 C3E9		STY $2F
 C3EB		LDA #$00
 C3ED		INC $6F
 C3EF		LDY $6E		; Pointer: Cassette Buffer
 C3F1		BEQ $C3F8
 C3F3	iC3F3	DEY
 C3F4		STA ($55),Y
 C3F6		BNE $C3F3
 C3F8	iC3F8	DEC $56
 C3FA		DEC $6F
 C3FC		BNE $C3F3
 C3FE		INC $56
 C400		SEC
 C401		LDA $2E		; Pointer End of BASIC Arrays (+1)
 C403		SBC $5C
 C405		LDY #$02
 C407		STA ($5C),Y
 C409		LDA $2F
 C40B		INY
 C40C		SBC $5D
 C40E		STA ($5C),Y
 C410		LDA $06		; Flag: Default Array DiMension / array name initial / AND, OR flag
 C412		BNE $C476
 C414		INY
 C415	iC415	LDA ($5C),Y
 C417		STA $05		; Input Buffer Pointer / No. of Subscripts
 C419		LDA #$00
 C41B		STA $6E		; Pointer: Cassette Buffer
 C41D	iC41D	STA $6F
 C41F		INY
 C420		PLA
 C421		TAX
 C422		STA $61
 C424		PLA
 C425		STA $62
 C427		CMP ($5C),Y
 C429		BCC $C439	; inlpn2	Locate Element in Array
 C42B		BNE $C433
 C42D		INY
 C42E		TXA
 C42F		CMP ($5C),Y
 C431		BCC $C43A
 C433	iC433	JMP $C370	; bserr	?BAD SUBSCRIPT
 C436	iC436	JMP $B3CD	; omerr	Output ?OUT OF MEMORY Error


; inlpn2	Locate Element in Array

 C439	iC439	INY
 C43A	iC43A	LDA $6F
 C43C		ORA $6E		; Pointer: Cassette Buffer
 C43E		CLC
 C43F		BEQ $C44B
 C441		JSR $C477	; umult	Number of Bytes in Subscript
 C444		TXA
 C445		ADC $61
 C447		TAX
 C448		TYA
 C449		LDY $1F		; Utility Pointer Area
 C44B	iC44B	ADC $62
 C44D		STX $6E		; Pointer: Cassette Buffer
 C44F		DEC $05		; Input Buffer Pointer / No. of Subscripts
 C451		BNE $C41D
 C453		STA $6F
 C455		LDX #$05
 C457		LDA $42		; Current BASIC Variable Name
 C459		BPL $C45C
 C45B		DEX
 C45C	iC45C	LDA $43
 C45E		BPL $C462
 C460		DEX
 C461		DEX
 C462	iC462	STX $25
 C464		LDA #$00
 C466		JSR $C480
 C469		TXA
 C46A		ADC $55
 C46C		STA $44		; Pointer: Current BASIC Variable Data
 C46E		TYA
 C46F		ADC $56
 C471		STA $45
 C473		TAY
 C474		LDA $44		; Pointer: Current BASIC Variable Data
 C476	iC476	RTS


; umult	Number of Bytes in Subscript

 C477	iC477	STY $1F		; Utility Pointer Area
 C479		LDA ($5C),Y
 C47B		STA $25
 C47D		DEY
 C47E		LDA ($5C),Y
 C480	iC480	STA $26
 C482		LDA #$10
 C484		STA $5A
 C486		LDX #$00
 C488		LDY #$00
 C48A	iC48A	TXA
 C48B		ASL
 C48C		TAX
 C48D		TYA
 C48E		ROL
 C48F		TAY
 C490		BCS $C436
 C492		ASL $6E		; Pointer: Cassette Buffer
 C494		ROL $6F
 C496		BCC $C4A3
 C498		CLC
 C499		TXA
 C49A		ADC $25
 C49C		TAX
 C49D		TYA
 C49E		ADC $26
 C4A0		TAY
 C4A1		BCS $C436
 C4A3	iC4A3	DEC $5A
 C4A5		BNE $C48A
 C4A7		RTS


; fre	Evaluate <fre>

 C4A8		LDA $07		; Data Type: $FF = String, $00 = Numeric
 C4AA		BEQ $C4AF
 C4AC		JSR $C7B8
 C4AF	iC4AF	JSR $C66A	; garbag	Garbage Collection
 C4B2		SEC
 C4B3		LDA $30		; Pointer: Bottom of String Storage
 C4B5		SBC $2E		; Pointer End of BASIC Arrays (+1)
 C4B7		TAY
 C4B8		LDA $31
 C4BA		SBC $2F


; givayf	Convert Integer in (AC/YR) to Flpt

 C4BC	iC4BC	LDX #$00
 C4BE		STX $07		; Data Type: $FF = String, $00 = Numeric
 C4C0		STA $5F		; Floating Accum. #1: Mantissa
 C4C2		STY $60
 C4C4		LDX #$90
 C4C6		JMP $CD7A


; pos	Evaluate <pos>

 C4C9		LDY $C6		; Cursor Column on Current Line
 C4CB	iC4CB	LDA #$00
 C4CD		BEQ $C4BC	; givayf	Convert Integer in (AC/YR) to Flpt


; errdir	Confirm Program Mode

 C4CF	iC4CF	LDX $37
 C4D1		INX
 C4D2		BNE $C476
 C4D4		LDX #$95
 C4D6		BIT $E9A2

; *** Resyncing ***

; -	?UNDEF'D FUNCTION

 C4D7	iC4D7	LDX #$E9
 C4D9		JMP $B3CF	; error	Error Routine


; -	Perform [def]

 C4DC		JSR $C50A	; getfnm	Check Syntax of FN
 C4DF		JSR $C4CF	; errdir	Confirm Program Mode
 C4E2		JSR $BEF2	; -Test '('-
 C4E5		LDA #$80
 C4E7		STA $0A		; Flag: Subscript Ref / User Function Call
 C4E9		JSR $C12B	; ptrget	Identify Variable
 C4EC		JSR $BD87	; -Confirm numeric mode
 C4EF		JSR $BEEF	; chkcls	Confirm Character
 C4F2		LDA #$B2
 C4F4		JSR $BEF7	; -Confirm Character in A
 C4F7		PHA
 C4F8		LDA $45
 C4FA		PHA
 C4FB		LDA $44		; Pointer: Current BASIC Variable Data
 C4FD		PHA
 C4FE		LDA $78
 C500		PHA
 C501		LDA $77		; Pointer: Current Byte of BASIC Text
 C503		PHA
 C504		JSR $B883	; data	Perform [data]
 C507		JMP $C578


; getfnm	Check Syntax of FN

 C50A	iC50A	LDA #$A5
 C50C		JSR $BEF7	; -Confirm Character in A
 C50F		ORA #$80
 C511		STA $0A		; Flag: Subscript Ref / User Function Call
 C513		JSR $C132
 C516		STA $4B		; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C518		STY $4C
 C51A		JMP $BD87	; -Confirm numeric mode


; fndoer	Perform [fn]

 C51D	iC51D	JSR $C50A	; getfnm	Check Syntax of FN
 C520		LDA $4C
 C522		PHA
 C523		LDA $4B		; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C525		PHA
 C526		JSR $BEE9	; parchk	Expression in Brackets
 C529		JSR $BD87	; -Confirm numeric mode
 C52C		PLA
 C52D		STA $4B		; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C52F		PLA
 C530		STA $4C
 C532		LDY #$02
 C534		LDA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C536		STA $44		; Pointer: Current BASIC Variable Data
 C538		TAX
 C539		INY
 C53A		LDA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C53C		BEQ $C4D7	; -	?UNDEF'D FUNCTION
 C53E		STA $45
 C540		INY
 C541	iC541	LDA ($44),Y	; Pointer: Current BASIC Variable Data
 C543		PHA
 C544		DEY
 C545		BPL $C541
 C547		LDY $45
 C549		JSR $CD0A	; -	Store FAC#1 at (AC/YR)
 C54C		LDA $78
 C54E		PHA
 C54F		LDA $77		; Pointer: Current Byte of BASIC Text
 C551		PHA
 C552		LDA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C554		STA $77		; Pointer: Current Byte of BASIC Text
 C556		INY
 C557		LDA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C559		STA $78
 C55B		LDA $45
 C55D		PHA
 C55E		LDA $44		; Pointer: Current BASIC Variable Data
 C560		PHA
 C561		JSR $BD84	; frmnum	Confirm Result
 C564		PLA
 C565		STA $4B		; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C567		PLA
 C568		STA $4C
 C56A		JSR $0076	; Entry to Get Same Byte of Text Again
 C56D		BEQ $C572
 C56F		JMP $BF00	; synerr	Output ?SYNTAX Error
 C572	iC572	PLA
 C573		STA $77		; Pointer: Current Byte of BASIC Text
 C575		PLA
 C576		STA $78
 C578	iC578	LDY #$00
 C57A		PLA
 C57B		STA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C57D		PLA
 C57E		INY
 C57F		STA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C581		PLA
 C582		INY
 C583		STA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C585		PLA
 C586		INY
 C587		STA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C589		PLA
 C58A		INY
 C58B		STA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C58D		RTS


; strd	Evaluate <str$>

 C58E		JSR $BD87	; -Confirm numeric mode
 C591		LDY #$00
 C593		JSR $CF95
 C596		PLA
 C597		PLA
 C598	iC598	LDA #$FF
 C59A		LDY #$00
 C59C		BEQ $C5B0	; strlit	Set Up String
 C59E	iC59E	LDX $61
 C5A0		LDY $62
 C5A2		STX $4D		; Pointer to string, length and garbage collect constant
 C5A4		STY $4E
 C5A6	iC5A6	JSR $C61D	; getspa	Allocate Space for String
 C5A9		STX $5F		; Floating Accum. #1: Mantissa
 C5AB		STY $60
 C5AD		STA $5E		; Floating-Point Accumulator #1: Exponent
 C5AF		RTS


; strlit	Set Up String

 C5B0	iC5B0	LDX #$22
 C5B2		STX $03		; Search Character
 C5B4		STX $04		; Flag: Scan for Quote at End of String
 C5B6	iC5B6	STA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 C5B8		STY $6D		; Floating Accum. #1. Low-Order (Rounding)
 C5BA		STA $5F		; Floating Accum. #1: Mantissa
 C5BC		STY $60
 C5BE		LDY #$FF
 C5C0	iC5C0	INY
 C5C1		LDA ($6C),Y	; Sign Comparison Result: Accum. # 1 vs #2
 C5C3		BEQ $C5D1
 C5C5		CMP $03		; Search Character
 C5C7		BEQ $C5CD
 C5C9		CMP $04		; Flag: Scan for Quote at End of String
 C5CB		BNE $C5C0
 C5CD	iC5CD	CMP #$22
 C5CF		BEQ $C5D2
 C5D1	iC5D1	CLC
 C5D2	iC5D2	STY $5E		; Floating-Point Accumulator #1: Exponent
 C5D4		TYA
 C5D5		ADC $6C		; Sign Comparison Result: Accum. # 1 vs #2
 C5D7		STA $6E		; Pointer: Cassette Buffer
 C5D9		LDX $6D		; Floating Accum. #1. Low-Order (Rounding)
 C5DB		BCC $C5DE
 C5DD		INX
 C5DE	iC5DE	STX $6F
 C5E0		LDA $6D		; Floating Accum. #1. Low-Order (Rounding)
 C5E2		BEQ $C5E8
 C5E4		CMP #$02
 C5E6		BNE $C5F3
 C5E8	iC5E8	TYA
 C5E9		JSR $C59E
 C5EC		LDX $6C		; Sign Comparison Result: Accum. # 1 vs #2
 C5EE		LDY $6D		; Floating Accum. #1. Low-Order (Rounding)
 C5F0		JSR $C79A
 C5F3	iC5F3	LDX $13		; Pointer Temporary String
 C5F5		CPX #$1F
 C5F7		BNE $C5FE	; putnw1	Save String Descriptor
 C5F9		LDX #$C8
 C5FB	iC5FB	JMP $B3CF	; error	Error Routine


; putnw1	Save String Descriptor

 C5FE	iC5FE	LDA $5E		; Floating-Point Accumulator #1: Exponent
 C600		STA $00,X	; USR Function Jump Instr (4C)
 C602		LDA $5F		; Floating Accum. #1: Mantissa
 C604		STA $01,X	; USR Address [4: C373]
 C606		LDA $60
 C608		STA $02,X
 C60A		LDY #$00
 C60C		STX $61
 C60E		STY $62
 C610		STY $6D		; Floating Accum. #1. Low-Order (Rounding)
 C612		DEY
 C613		STY $07		; Data Type: $FF = String, $00 = Numeric
 C615		STX $14		; Last Temp String Address
 C617		INX
 C618		INX
 C619		INX
 C61A		STX $13		; Pointer Temporary String
 C61C		RTS


; getspa	Allocate Space for String

 C61D	iC61D	LSR $09		; Flag: DATA scan/LlST quote/Garbage Coll
 C61F	iC61F	TAX
 C620		BEQ $C65A
 C622		PHA
 C623		LDA $30		; Pointer: Bottom of String Storage
 C625		SEC
 C626		SBC #$02
 C628		LDY $31
 C62A		BCS $C62D
 C62C		DEY
 C62D	iC62D	STA $1F		; Utility Pointer Area
 C62F		STY $20
 C631		TXA
 C632		EOR #$FF
 C634		SEC
 C635		ADC $1F		; Utility Pointer Area
 C637		BCS $C63A
 C639		DEY
 C63A	iC63A	CPY $2F
 C63C		BCC $C65B
 C63E		BNE $C644
 C640		CMP $2E		; Pointer End of BASIC Arrays (+1)
 C642		BCC $C65B
 C644	iC644	STA $32		; Utility String Pointer
 C646		STY $33
 C648		LDY #$01
 C64A		LDA #$FF
 C64C		STA ($1F),Y	; Utility Pointer Area
 C64E		DEY
 C64F		PLA
 C650		STA ($1F),Y	; Utility Pointer Area
 C652		LDX $32		; Utility String Pointer
 C654		LDY $33
 C656		STX $30		; Pointer: Bottom of String Storage
 C658		STY $31
 C65A	iC65A	RTS
 C65B	iC65B	LDX #$4D
 C65D		LDA $09		; Flag: DATA scan/LlST quote/Garbage Coll
 C65F		BMI $C5FB
 C661		JSR $C66A	; garbag	Garbage Collection
 C664		SEC
 C665		ROR $09		; Flag: DATA scan/LlST quote/Garbage Coll
 C667		PLA
 C668		BNE $C61F


; garbag	Garbage Collection

 C66A	iC66A	LDY #$00
 C66C		STY $55
 C66E		LDA $34		; Pointer: Highest Address Used by BASIC
 C670		LDY $35
 C672		STA $5C
 C674		STA $4B		; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C676		STA $32		; Utility String Pointer
 C678		STY $5D
 C67A		STY $4C
 C67C		STY $33
 C67E	iC67E	CPY $31
 C680		BCC $C700
 C682		BNE $C68A
 C684		CMP $30		; Pointer: Bottom of String Storage
 C686		BEQ $C700
 C688		BCC $C700
 C68A	iC68A	LDX $55
 C68C		BMI $C693
 C68E		LDA #$02
 C690		JSR $C735
 C693	iC693	JSR $C724
 C696		LDY #$01
 C698		LDA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C69A		CMP #$FF
 C69C		BNE $C6A9
 C69E	iC69E	DEY
 C69F		LDA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C6A1		JSR $C726
 C6A4		SEC
 C6A5		ROR $55
 C6A7		BNE $C67E
 C6A9	iC6A9	JSR $C744
 C6AC		LDX $55
 C6AE		BPL $C703
 C6B0		LSR $55
 C6B2	iC6B2	LDY #$00
 C6B4		LDA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C6B6		STA ($5C),Y
 C6B8		INY
 C6B9		LDA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C6BB		STA ($5C),Y
 C6BD		DEY
 C6BE		LDA ($1F),Y	; Utility Pointer Area
 C6C0		TAX
 C6C1		JSR $C735
 C6C4		STA $32		; Utility String Pointer
 C6C6		STY $33
 C6C8		TXA
 C6C9		JSR $C726
 C6CC		TXA
 C6CD		TAY
 C6CE	iC6CE	DEY
 C6CF		LDA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C6D1		STA ($5C),Y
 C6D3		DEX
 C6D4		BNE $C6CE
 C6D6		LDY #$02
 C6D8	iC6D8	LDA $005B,Y
 C6DB		STA ($1F),Y	; Utility Pointer Area
 C6DD		DEY
 C6DE		BNE $C6D8
 C6E0		LDA $4B		; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C6E2		LDY $4C
 C6E4		CPY $31
 C6E6		BCC $C700
 C6E8		BNE $C6F0
 C6EA		CMP $30		; Pointer: Bottom of String Storage
 C6EC		BEQ $C700
 C6EE		BCC $C700
 C6F0	iC6F0	JSR $C71F
 C6F3		LDY #$01
 C6F5		LDA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C6F7		CMP #$FF
 C6F9		BEQ $C69E
 C6FB		JSR $C744
 C6FE		BMI $C6B2
 C700	iC700	JMP $C716
 C703	iC703	LDY #$00
 C705		LDA ($1F),Y	; Utility Pointer Area
 C707		TAX
 C708		JSR $C735
 C70B		STA $32		; Utility String Pointer
 C70D		STY $33
 C70F		TXA
 C710		JSR $C726
 C713		JMP $C67E

 C716	iC716	LDA $32		; Utility String Pointer
 C718		LDY $33
 C71A		STA $30		; Pointer: Bottom of String Storage
 C71C		STY $31
 C71E		RTS

 C71F	iC71F	LDA #$02
 C721		JSR $C735
 C724	iC724	LDA #$02
 C726	iC726	EOR #$FF
 C728		SEC
 C729		ADC $4B		; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C72B		LDY $4C
 C72D		BCS $C730
 C72F		DEY
 C730	iC730	STA $4B		; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C732		STY $4C
 C734		RTS

 C735	iC735	EOR #$FF
 C737		SEC
 C738		ADC $5C
 C73A		LDY $5D
 C73C		BCS $C73F
 C73E		DEY
 C73F	iC73F	STA $5C
 C741		STY $5D
 C743		RTS

 C744	iC744	LDY #$01
 C746	iC746	LDA ($4B),Y	; Pointer to temp storage in RAM for FN DEF, TAN, &c
 C748		STA $001F,Y	; Utility Pointer Area
 C74B		DEY
 C74C		BPL $C746
 C74E		RTS


; cat	Concatenate Two Strings

 C74F	iC74F	LDA $62
 C751		PHA
 C752		LDA $61
 C754		PHA
 C755		JSR $BE81	; eval	Evaluate Single Term
 C758		JSR $BD89	; -Confirm string mode
 C75B		PLA
 C75C		STA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 C75E		PLA
 C75F		STA $6D		; Floating Accum. #1. Low-Order (Rounding)
 C761		LDY #$00
 C763		LDA ($6C),Y	; Sign Comparison Result: Accum. # 1 vs #2
 C765		CLC
 C766		ADC ($61),Y
 C768		BCC $C76F
 C76A		LDX #$B0
 C76C		JMP $B3CF	; error	Error Routine
 C76F	iC76F	JSR $C59E
 C772		JSR $C78C	; movins	Store String in High RAM
 C775		LDA $4D		; Pointer to string, length and garbage collect constant
 C777		LDY $4E
 C779		JSR $C7BC
 C77C		JSR $C79E
 C77F		LDA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 C781		LDY $6D		; Floating Accum. #1. Low-Order (Rounding)
 C783		JSR $C7BC
 C786		JSR $C5F3
 C789		JMP $BDB2


; movins	Store String in High RAM

 C78C	iC78C	LDY #$00
 C78E		LDA ($6C),Y	; Sign Comparison Result: Accum. # 1 vs #2
 C790		PHA
 C791		INY
 C792		LDA ($6C),Y	; Sign Comparison Result: Accum. # 1 vs #2
 C794		TAX
 C795		INY
 C796		LDA ($6C),Y	; Sign Comparison Result: Accum. # 1 vs #2
 C798		TAY
 C799		PLA
 C79A	iC79A	STX $1F		; Utility Pointer Area
 C79C		STY $20
 C79E	iC79E	TAY
 C79F		BEQ $C7AB
 C7A1		PHA
 C7A2	iC7A2	DEY
 C7A3		LDA ($1F),Y	; Utility Pointer Area
 C7A5		STA ($32),Y	; Utility String Pointer
 C7A7		TYA
 C7A8		BNE $C7A2
 C7AA		PLA
 C7AB	iC7AB	CLC
 C7AC		ADC $32		; Utility String Pointer
 C7AE		STA $32		; Utility String Pointer
 C7B0		BCC $C7B4
 C7B2		INC $33
 C7B4	iC7B4	RTS


; frestr	Perform String Housekeeping

 C7B5	iC7B5	JSR $BD89	; -Confirm string mode
 C7B8	iC7B8	LDA $61
 C7BA		LDY $62
 C7BC	iC7BC	STA $1F		; Utility Pointer Area
 C7BE		STY $20
 C7C0		JSR $C811	; frefac	Clean Descriptor Stack
 C7C3		BNE $C7FE
 C7C5		JSR $BA4E	; ?
 C7C8		BCC $C7FE
 C7CA		DEY
 C7CB		LDA #$FF
 C7CD		STA ($1F),Y	; Utility Pointer Area
 C7CF		DEY
 C7D0		TXA
 C7D1		STA ($1F),Y	; Utility Pointer Area
 C7D3		PHA
 C7D4		EOR #$FF
 C7D6		SEC
 C7D7		ADC $1F		; Utility Pointer Area
 C7D9		LDY $20
 C7DB		BCS $C7DE
 C7DD		DEY
 C7DE	iC7DE	STA $1F		; Utility Pointer Area
 C7E0		STY $20
 C7E2		TAX
 C7E3		PLA
 C7E4		CPY $31
 C7E6		BNE $C821
 C7E8		CPX $30		; Pointer: Bottom of String Storage
 C7EA		BNE $C821
 C7EC		PHA
 C7ED		SEC
 C7EE		ADC $30		; Pointer: Bottom of String Storage
 C7F0		STA $30		; Pointer: Bottom of String Storage
 C7F2		BCC $C7F6
 C7F4		INC $31
 C7F6	iC7F6	INC $30		; Pointer: Bottom of String Storage
 C7F8		BNE $C7FC
 C7FA		INC $31
 C7FC	iC7FC	PLA
 C7FD		RTS
 C7FE	iC7FE	LDY #$00
 C800		LDA ($1F),Y	; Utility Pointer Area
 C802		PHA
 C803		INY
 C804		LDA ($1F),Y	; Utility Pointer Area
 C806		TAX
 C807		INY
 C808		LDA ($1F),Y	; Utility Pointer Area
 C80A		TAY
 C80B		STX $1F		; Utility Pointer Area
 C80D		STY $20
 C80F		PLA
 C810		RTS


; frefac	Clean Descriptor Stack

 C811	iC811	CPY $15
 C813		BNE $C821
 C815		CMP $14		; Last Temp String Address
 C817		BNE $C821
 C819		STA $13		; Pointer Temporary String
 C81B		SBC #$03
 C81D		STA $14		; Last Temp String Address
 C81F		LDY #$00
 C821	iC821	RTS


; chrd	Evaluate <chr$>

 C822		JSR $C8D7
 C825		TXA
 C826		PHA
 C827		LDA #$01
 C829		JSR $C5A6
 C82C		PLA
 C82D		LDY #$00
 C82F		STA ($5F),Y	; Floating Accum. #1: Mantissa
 C831		PLA
 C832		PLA
 C833		JMP $C5F3


; leftd	Evaluate <left$>

 C836		JSR $C897	; pream	Pull String Parameters
 C839		CMP ($4D),Y	; Pointer to string, length and garbage collect constant
 C83B		TYA
 C83C	iC83C	BCC $C842
 C83E		LDA ($4D),Y	; Pointer to string, length and garbage collect constant
 C840		TAX
 C841		TYA
 C842	iC842	PHA
 C843	iC843	TXA
 C844	iC844	PHA
 C845		JSR $C5A6
 C848		LDA $4D		; Pointer to string, length and garbage collect constant
 C84A		LDY $4E
 C84C		JSR $C7BC
 C84F		PLA
 C850		TAY
 C851		PLA
 C852		CLC
 C853		ADC $1F		; Utility Pointer Area
 C855		STA $1F		; Utility Pointer Area
 C857		BCC $C85B
 C859		INC $20
 C85B	iC85B	TYA
 C85C		JSR $C79E
 C85F		JMP $C5F3


; rightd	Evaluate <right$>

 C862		JSR $C897	; pream	Pull String Parameters
 C865		CLC
 C866		SBC ($4D),Y	; Pointer to string, length and garbage collect constant
 C868		EOR #$FF
 C86A		JMP $C83C


; midd	Evaluate <mid$>

 C86D		LDA #$FF
 C86F		STA $62
 C871		JSR $0076	; Entry to Get Same Byte of Text Again
 C874		CMP #$29
 C876		BEQ $C87E
 C878		JSR $BEF5	; -Test comma-
 C87B		JSR $C8D4	; -Eval Byte Parameter
 C87E	iC87E	JSR $C897	; pream	Pull String Parameters
 C881		BEQ $C8CE
 C883		DEX
 C884		TXA
 C885		PHA
 C886		CLC
 C887		LDX #$00
 C889		SBC ($4D),Y	; Pointer to string, length and garbage collect constant
 C88B		BCS $C843
 C88D		EOR #$FF
 C88F		CMP $62
 C891		BCC $C844
 C893		LDA $62
 C895		BCS $C844


; pream	Pull String Parameters

 C897	iC897	JSR $BEEF	; chkcls	Confirm Character
 C89A		PLA
 C89B		TAY
 C89C		PLA
 C89D		STA $52
 C89F		PLA
 C8A0		PLA
 C8A1		PLA
 C8A2		TAX
 C8A3		PLA
 C8A4		STA $4D		; Pointer to string, length and garbage collect constant
 C8A6		PLA
 C8A7		STA $4E
 C8A9		LDA $52
 C8AB		PHA
 C8AC		TYA
 C8AD		PHA
 C8AE		LDY #$00
 C8B0		TXA
 C8B1		RTS


; len	Evaluate <len>

 C8B2		JSR $C8B8	; len1	Exit String Mode
 C8B5		JMP $C4CB


; len1	Exit String Mode

 C8B8	iC8B8	JSR $C7B5	; frestr	Perform String Housekeeping
 C8BB		LDX #$00
 C8BD		STX $07		; Data Type: $FF = String, $00 = Numeric
 C8BF		TAY
 C8C0		RTS


; asc	Evaluate <asc>

 C8C1		JSR $C8B8	; len1	Exit String Mode
 C8C4		BEQ $C8CE
 C8C6		LDY #$00
 C8C8		LDA ($1F),Y	; Utility Pointer Area
 C8CA		TAY
 C8CB		JMP $C4CB
 C8CE	iC8CE	JMP $C373	; -	?ILLEGAL QUANTITY


; gtbytc	Evaluate Text to 1 Byte in XR

 C8D1	iC8D1	JSR $0070	; Subroutine: Get Next Byte of BASIC Text


; -Eval Byte Parameter

 C8D4	iC8D4	JSR $BD84	; frmnum	Confirm Result
 C8D7	iC8D7	JSR $C2E3
 C8DA		LDX $61
 C8DC		BNE $C8CE
 C8DE		LDX $62
 C8E0		JMP $0076	; Entry to Get Same Byte of Text Again


; val	Evaluate <val>

 C8E3		JSR $C8B8	; len1	Exit String Mode
 C8E6		BNE $C8EB	; strval	Convert ASCII String to Flpt
 C8E8		JMP $CA2D


; strval	Convert ASCII String to Flpt

 C8EB	iC8EB	LDX $77		; Pointer: Current Byte of BASIC Text
 C8ED		LDY $78
 C8EF		STX $6E		; Pointer: Cassette Buffer
 C8F1		STY $6F
 C8F3		LDX $1F		; Utility Pointer Area
 C8F5		STX $77		; Pointer: Current Byte of BASIC Text
 C8F7		CLC
 C8F8		ADC $1F		; Utility Pointer Area
 C8FA		STA $21
 C8FC		LDX $20
 C8FE		STX $78
 C900		BCC $C903
 C902		INX
 C903	iC903	STX $22
 C905		LDY #$00
 C907		LDA ($21),Y
 C909		PHA
 C90A		TYA
 C90B		STA ($21),Y
 C90D		JSR $0076	; Entry to Get Same Byte of Text Again
 C910		JSR $CE29	; fin	Convert ASCII String to a Number in FAC#1
 C913		PLA
 C914		LDY #$00
 C916		STA ($21),Y
 C918	iC918	LDX $6E		; Pointer: Cassette Buffer
 C91A		LDY $6F
 C91C		STX $77		; Pointer: Current Byte of BASIC Text
 C91E		STY $78
 C920		RTS


; getnum	Get parameters for POKE/WAIT

 C921	iC921	JSR $BD84	; frmnum	Confirm Result
 C924		JSR $C92D	; getadr	Convert FAC#1 to Integer in LINNUM
 C927	iC927	JSR $BEF5	; -Test comma-
 C92A		JMP $C8D4	; -Eval Byte Parameter


; getadr	Convert FAC#1 to Integer in LINNUM

 C92D	iC92D	LDA $63		; Floating Accum. #1: Sign
 C92F		BMI $C8CE
 C931		LDA $5E		; Floating-Point Accumulator #1: Exponent
 C933		CMP #$91
 C935		BCS $C8CE
 C937		JSR $CDD1	; qint	Convert FAC#1 to Integer
 C93A		LDA $61
 C93C		LDY $62
 C93E		STY $11		; Temp: Integer Value
 C940		STA $12
 C942		RTS


; peek	Evaluate <peek>

 C943		LDA $12
 C945		PHA
 C946		LDA $11		; Temp: Integer Value
 C948		PHA
 C949		JSR $C92D	; getadr	Convert FAC#1 to Integer in LINNUM
 C94C		LDY #$00
 C94E		LDA ($11),Y	; Temp: Integer Value
 C950		TAY
 C951		PLA
 C952		STA $11		; Temp: Integer Value
 C954		PLA
 C955		STA $12
 C957		JMP $C4CB


; poke	Perform [poke]

 C95A		JSR $C921	; getnum	Get parameters for POKE/WAIT
 C95D		TXA
 C95E		LDY #$00
 C960		STA ($11),Y	; Temp: Integer Value
 C962		RTS


; wait	Perform [wait]

 C963		JSR $C921	; getnum	Get parameters for POKE/WAIT
 C966		STX $46		; Pointer: Index Variable for FOR/NEXT
 C968		LDX #$00
 C96A		JSR $0076	; Entry to Get Same Byte of Text Again
 C96D		BEQ $C972
 C96F		JSR $C927
 C972	iC972	STX $47
 C974		LDY #$00
 C976	iC976	LDA ($11),Y	; Temp: Integer Value
 C978		EOR $47
 C97A		AND $46		; Pointer: Index Variable for FOR/NEXT
 C97C		BEQ $C976
 C97E	iC97E	RTS


; faddh	Add 0.5 to FAC#1

 C97F	iC97F	LDA #$C7
 C981		LDY #$D0
 C983		JMP $C99D	; fadd	Perform Addition


; fsub	Perform Subtraction

 C986	iC986	JSR $CBC2	; conupk	Load FAC#2 From Memory


; -	Evaluate <subtract>

 C989	iC989	LDA $63		; Floating Accum. #1: Sign
 C98B		EOR #$FF
 C98D		STA $63		; Floating Accum. #1: Sign
 C98F		EOR $6B		; Floating Accum. #2: Sign
 C991		STA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 C993		LDA $5E		; Floating-Point Accumulator #1: Exponent
 C995		JMP $C9A0	; -	Evaluate <add>


; fadd5	Normalise Addition

 C998	iC998	JSR $CACF
 C99B		BCC $C9D9


; fadd	Perform Addition

 C99D	iC99D	JSR $CBC2	; conupk	Load FAC#2 From Memory


; -	Evaluate <add>

 C9A0	iC9A0	BNE $C9A5
 C9A2		JMP $CD32	; movfa	Copy FAC#2 into FAC#1
 C9A5	iC9A5	LDX $6D		; Floating Accum. #1. Low-Order (Rounding)
 C9A7		STX $53
 C9A9		LDX #$66
 C9AB		LDA $66		; Floating-Point Accumulator #2: Exponent
 C9AD	iC9AD	TAY
 C9AE		BEQ $C97E
 C9B0		SEC
 C9B1		SBC $5E		; Floating-Point Accumulator #1: Exponent
 C9B3		BEQ $C9D9
 C9B5		BCC $C9C9
 C9B7		STY $5E		; Floating-Point Accumulator #1: Exponent
 C9B9		LDY $6B		; Floating Accum. #2: Sign
 C9BB		STY $63		; Floating Accum. #1: Sign
 C9BD		EOR #$FF
 C9BF		ADC #$00
 C9C1		LDY #$00
 C9C3		STY $53
 C9C5		LDX #$5E
 C9C7		BNE $C9CD
 C9C9	iC9C9	LDY #$00
 C9CB		STY $6D		; Floating Accum. #1. Low-Order (Rounding)
 C9CD	iC9CD	CMP #$F9
 C9CF		BMI $C998	; fadd5	Normalise Addition
 C9D1		TAY
 C9D2		LDA $6D		; Floating Accum. #1. Low-Order (Rounding)
 C9D4		LSR $01,X	; USR Address [4: C373]
 C9D6		JSR $CAE6
 C9D9	iC9D9	BIT $6C
 C9DB		BPL $CA34
 C9DD		LDY #$5E
 C9DF		CPX #$66
 C9E1		BEQ $C9E5
 C9E3		LDY #$66
 C9E5	iC9E5	SEC
 C9E6		EOR #$FF
 C9E8		ADC $53
 C9EA		STA $6D		; Floating Accum. #1. Low-Order (Rounding)
 C9EC		LDA $0004,Y	; Flag: Scan for Quote at End of String
 C9EF		SBC $04,X	; Flag: Scan for Quote at End of String
 C9F1		STA $62
 C9F3		LDA $0003,Y	; Search Character
 C9F6		SBC $03,X	; Search Character
 C9F8		STA $61
 C9FA		LDA $0002,Y
 C9FD		SBC $02,X
 C9FF		STA $60
 CA01		LDA $0001,Y	; USR Address [4: C373]
 CA04		SBC $01,X	; USR Address [4: C373]
 CA06		STA $5F		; Floating Accum. #1: Mantissa
 CA08	iCA08	BCS $CA0D
 CA0A		JSR $CA7D	; negfac	2's Complement FAC#1
 CA0D	iCA0D	LDY #$00
 CA0F		TYA
 CA10		CLC
 CA11	iCA11	LDX $5F		; Floating Accum. #1: Mantissa
 CA13		BNE $CA5F
 CA15		LDX $60
 CA17		STX $5F		; Floating Accum. #1: Mantissa
 CA19		LDX $61
 CA1B		STX $60
 CA1D		LDX $62
 CA1F		STX $61
 CA21		LDX $6D		; Floating Accum. #1. Low-Order (Rounding)
 CA23		STX $62
 CA25		STY $6D		; Floating Accum. #1. Low-Order (Rounding)
 CA27		ADC #$08
 CA29		CMP #$20
 CA2B		BNE $CA11
 CA2D	iCA2D	LDA #$00
 CA2F	iCA2F	STA $5E		; Floating-Point Accumulator #1: Exponent
 CA31	iCA31	STA $63		; Floating Accum. #1: Sign
 CA33		RTS
 CA34	iCA34	ADC $53
 CA36		STA $6D		; Floating Accum. #1. Low-Order (Rounding)
 CA38		LDA $62
 CA3A		ADC $6A
 CA3C		STA $62
 CA3E		LDA $61
 CA40		ADC $69
 CA42		STA $61
 CA44		LDA $60
 CA46		ADC $68
 CA48		STA $60
 CA4A		LDA $5F		; Floating Accum. #1: Mantissa
 CA4C		ADC $67		; Floating Accum. #2: Mantissa
 CA4E		STA $5F		; Floating Accum. #1: Mantissa
 CA50		JMP $CA6C
 CA53	iCA53	ADC #$01
 CA55		ASL $6D		; Floating Accum. #1. Low-Order (Rounding)
 CA57		ROL $62
 CA59		ROL $61
 CA5B		ROL $60
 CA5D		ROL $5F		; Floating Accum. #1: Mantissa
 CA5F	iCA5F	BPL $CA53
 CA61		SEC
 CA62		SBC $5E		; Floating-Point Accumulator #1: Exponent
 CA64		BCS $CA2D
 CA66		EOR #$FF
 CA68		ADC #$01
 CA6A		STA $5E		; Floating-Point Accumulator #1: Exponent
 CA6C	iCA6C	BCC $CA7C
 CA6E	iCA6E	INC $5E		; Floating-Point Accumulator #1: Exponent
 CA70		BEQ $CAB4	; overr	Output ?OVERFLOW Error
 CA72		ROR $5F		; Floating Accum. #1: Mantissa
 CA74		ROR $60
 CA76		ROR $61
 CA78		ROR $62
 CA7A		ROR $6D		; Floating Accum. #1. Low-Order (Rounding)
 CA7C	iCA7C	RTS


; negfac	2's Complement FAC#1

 CA7D	iCA7D	LDA $63		; Floating Accum. #1: Sign
 CA7F		EOR #$FF
 CA81		STA $63		; Floating Accum. #1: Sign
 CA83	iCA83	LDA $5F		; Floating Accum. #1: Mantissa
 CA85		EOR #$FF
 CA87		STA $5F		; Floating Accum. #1: Mantissa
 CA89		LDA $60
 CA8B		EOR #$FF
 CA8D		STA $60
 CA8F		LDA $61
 CA91		EOR #$FF
 CA93		STA $61
 CA95		LDA $62
 CA97		EOR #$FF
 CA99		STA $62
 CA9B		LDA $6D		; Floating Accum. #1. Low-Order (Rounding)
 CA9D		EOR #$FF
 CA9F		STA $6D		; Floating Accum. #1. Low-Order (Rounding)
 CAA1		INC $6D		; Floating Accum. #1. Low-Order (Rounding)
 CAA3		BNE $CAB3
 CAA5	iCAA5	INC $62
 CAA7		BNE $CAB3
 CAA9		INC $61
 CAAB		BNE $CAB3
 CAAD		INC $60
 CAAF		BNE $CAB3
 CAB1		INC $5F		; Floating Accum. #1: Mantissa
 CAB3	iCAB3	RTS


; overr	Output ?OVERFLOW Error

 CAB4	iCAB4	LDX #$45
 CAB6		JMP $B3CF	; error	Error Routine


; mulshf	Multiply by Zero Byte

 CAB9	iCAB9	LDX #$22
 CABB	iCABB	LDY $04,X	; Flag: Scan for Quote at End of String
 CABD		STY $6D		; Floating Accum. #1. Low-Order (Rounding)
 CABF		LDY $03,X	; Search Character
 CAC1		STY $04,X	; Flag: Scan for Quote at End of String
 CAC3		LDY $02,X
 CAC5		STY $03,X	; Search Character
 CAC7		LDY $01,X	; USR Address [4: C373]
 CAC9		STY $02,X
 CACB		LDY $65		; Floating -accum. #1: Overflow Digit
 CACD		STY $01,X	; USR Address [4: C373]
 CACF	iCACF	ADC #$08
 CAD1		BMI $CABB
 CAD3		BEQ $CABB
 CAD5		SBC #$08
 CAD7		TAY
 CAD8		LDA $6D		; Floating Accum. #1. Low-Order (Rounding)
 CADA		BCS $CAF0
 CADC	iCADC	ASL $01,X	; USR Address [4: C373]
 CADE		BCC $CAE2
 CAE0		INC $01,X	; USR Address [4: C373]
 CAE2	iCAE2	ROR $01,X	; USR Address [4: C373]
 CAE4		ROR $01,X	; USR Address [4: C373]
 CAE6	iCAE6	ROR $02,X
 CAE8		ROR $03,X	; Search Character
 CAEA		ROR $04,X	; Flag: Scan for Quote at End of String
 CAEC		ROR
 CAED		INY
 CAEE		BNE $CADC
 CAF0	iCAF0	CLC
 CAF1		RTS


; fone	Table of Flpt Constants			DATA

;caf2	1.00
;caf7	#03		(counter)
;caf8	0.434255942
;cafd	0.57658454
;cb02	0.961800759
;cb07	2.885390073
;cb0c	0.707106781	SQR(0.5)
;cb11	1.41421356	SRQ(2)
;cb16	-0.5
;cb1b	0.693147181	LOG(2)
;

 CAF2		.byte 81 00 00 00 00 03 7F 5E  ;.......^
 CAFA		.byte 56 CB 79 80 13 9B 0B 64  ;vKY....D
 CB02		.byte 80 76 38 93 16 82 38 AA  ;.V8...8.
 CB0A		.byte 3B 20 80 35 04 F3 34 81  ;; .5..4.
 CB12		.byte 35 04 F3 34 80 80 00 00  ;5..4....
 CB1A		.byte 00 80 31 72 17 F8        ;..1R..


; log	Evaluate <log>

 CB20	iCB20	JSR $CD61	; sign	Check Sign of FAC#1
 CB23		BEQ $CB27
 CB25		BPL $CB2A
 CB27	iCB27	JMP $C373	; -	?ILLEGAL QUANTITY
 CB2A	iCB2A	LDA $5E		; Floating-Point Accumulator #1: Exponent
 CB2C		SBC #$7F
 CB2E		PHA
 CB2F		LDA #$80
 CB31		STA $5E		; Floating-Point Accumulator #1: Exponent
 CB33		LDA #$0C
 CB35		LDY #$CB
 CB37		JSR $C99D	; fadd	Perform Addition
 CB3A		LDA #$11
 CB3C		LDY #$CB
 CB3E		JSR $CC45	; fdivt	Divide FAC#2 by FAC#1
 CB41		LDA #$F2
 CB43		LDY #$CA
 CB45		JSR $C986	; fsub	Perform Subtraction
 CB48		LDA #$F7
 CB4A		LDY #$CA
 CB4C		JSR $D1D7	; polyx	Series Evaluation
 CB4F		LDA #$16
 CB51		LDY #$CB
 CB53		JSR $C99D	; fadd	Perform Addition
 CB56		PLA
 CB57		JSR $CEB4
 CB5A		LDA #$1B
 CB5C		LDY #$CB


; fmult	Perform Multiply

 CB5E	iCB5E	JSR $CBC2	; conupk	Load FAC#2 From Memory


; -	Evaluate <multiply>

 CB61		BNE $CB66
 CB63		JMP $CBC1
 CB66	iCB66	JSR $CBED	; muldiv	Test Both Accumulators
 CB69		LDA #$00
 CB6B		STA $23		; Floating-Point Product of Multiply
 CB6D		STA $24
 CB6F		STA $25
 CB71		STA $26
 CB73		LDA $6D		; Floating Accum. #1. Low-Order (Rounding)
 CB75		JSR $CB8F	; mulply	Multiply by a Byte
 CB78		LDA $62
 CB7A		JSR $CB8F	; mulply	Multiply by a Byte
 CB7D		LDA $61
 CB7F		JSR $CB8F	; mulply	Multiply by a Byte
 CB82		LDA $60
 CB84		JSR $CB8F	; mulply	Multiply by a Byte
 CB87		LDA $5F		; Floating Accum. #1: Mantissa
 CB89		JSR $CB94
 CB8C		JMP $CCC5


; mulply	Multiply by a Byte

 CB8F	iCB8F	BNE $CB94
 CB91		JMP $CAB9	; mulshf	Multiply by Zero Byte
 CB94	iCB94	LSR
 CB95		ORA #$80
 CB97	iCB97	TAY
 CB98		BCC $CBB3
 CB9A		CLC
 CB9B		LDA $26
 CB9D		ADC $6A
 CB9F		STA $26
 CBA1		LDA $25
 CBA3		ADC $69
 CBA5		STA $25
 CBA7		LDA $24
 CBA9		ADC $68
 CBAB		STA $24
 CBAD		LDA $23		; Floating-Point Product of Multiply
 CBAF		ADC $67		; Floating Accum. #2: Mantissa
 CBB1		STA $23		; Floating-Point Product of Multiply
 CBB3	iCBB3	ROR $23		; Floating-Point Product of Multiply
 CBB5		ROR $24
 CBB7		ROR $25
 CBB9		ROR $26
 CBBB		ROR $6D		; Floating Accum. #1. Low-Order (Rounding)
 CBBD		TYA
 CBBE		LSR
 CBBF		BNE $CB97
 CBC1	iCBC1	RTS


; conupk	Load FAC#2 From Memory

 CBC2	iCBC2	STA $1F		; Utility Pointer Area
 CBC4		STY $20
 CBC6		LDY #$04
 CBC8		LDA ($1F),Y	; Utility Pointer Area
 CBCA		STA $6A
 CBCC		DEY
 CBCD		LDA ($1F),Y	; Utility Pointer Area
 CBCF		STA $69
 CBD1		DEY
 CBD2		LDA ($1F),Y	; Utility Pointer Area
 CBD4		STA $68
 CBD6		DEY
 CBD7		LDA ($1F),Y	; Utility Pointer Area
 CBD9		STA $6B		; Floating Accum. #2: Sign
 CBDB		EOR $63		; Floating Accum. #1: Sign
 CBDD		STA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 CBDF		LDA $6B		; Floating Accum. #2: Sign
 CBE1		ORA #$80
 CBE3		STA $67		; Floating Accum. #2: Mantissa
 CBE5		DEY
 CBE6		LDA ($1F),Y	; Utility Pointer Area
 CBE8		STA $66		; Floating-Point Accumulator #2: Exponent
 CBEA		LDA $5E		; Floating-Point Accumulator #1: Exponent
 CBEC		RTS


; muldiv	Test Both Accumulators

 CBED	iCBED	LDA $66		; Floating-Point Accumulator #2: Exponent
 CBEF	iCBEF	BEQ $CC10
 CBF1		CLC
 CBF2		ADC $5E		; Floating-Point Accumulator #1: Exponent
 CBF4		BCC $CBFA
 CBF6		BMI $CC15
 CBF8		CLC
 CBF9		BIT $1410
; *** CBF9: ADDRESS DIFFER. This may indicate misassembly ***
 CBFC		ADC #$80
 CBFE		STA $5E		; Floating-Point Accumulator #1: Exponent
 CC00		BNE $CC05
 CC02		JMP $CA31
 CC05	iCC05	LDA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 CC07		STA $63		; Floating Accum. #1: Sign
 CC09		RTS


; mldvex	Overflow / Underflow

 CC0A	iCC0A	LDA $63		; Floating Accum. #1: Sign
 CC0C		EOR #$FF
 CC0E		BMI $CC15
 CC10	iCC10	PLA
 CC11		PLA
 CC12		JMP $CA2D
 CC15	iCC15	JMP $CAB4	; overr	Output ?OVERFLOW Error


; mul10	Multiply FAC#1 by 10

 CC18	iCC18	JSR $CD42	; movaf	Copy FAC#1 into FAC#2
 CC1B		TAX
 CC1C		BEQ $CC2E
 CC1E		CLC
 CC1F		ADC #$02
 CC21		BCS $CC15
 CC23	iCC23	LDX #$00
 CC25		STX $6C		; Sign Comparison Result: Accum. # 1 vs #2
 CC27		JSR $C9AD
 CC2A		INC $5E		; Floating-Point Accumulator #1: Exponent
 CC2C		BEQ $CC15
 CC2E	iCC2E	RTS


; tenc	Constant 10 in Flpt			DATA

 CC2F		.byte 84 20 00 00 00           ;. ...


; div10	Divide FAC#1 by 10

 CC34	iCC34	JSR $CD42	; movaf	Copy FAC#1 into FAC#2
 CC37		LDA #$2F
 CC39		LDY #$CC
 CC3B		LDX #$00


; fdiv	Divide FAC#2 by Flpt at (AC/YR)

 CC3D	iCC3D	STX $6C		; Sign Comparison Result: Accum. # 1 vs #2
 CC3F		JSR $CCD8	; movfm	Load FAC#1 From Memory
 CC42		JMP $CC48	; -	Evaluate <divide>


; fdivt	Divide FAC#2 by FAC#1

 CC45	iCC45	JSR $CBC2	; conupk	Load FAC#2 From Memory


; -	Evaluate <divide>

 CC48	iCC48	BEQ $CCC0
 CC4A		JSR $CD51	; round	Round FAC#1
 CC4D		LDA #$00
 CC4F		SEC
 CC50		SBC $5E		; Floating-Point Accumulator #1: Exponent
 CC52		STA $5E		; Floating-Point Accumulator #1: Exponent
 CC54		JSR $CBED	; muldiv	Test Both Accumulators
 CC57		INC $5E		; Floating-Point Accumulator #1: Exponent
 CC59		BEQ $CC15
 CC5B		LDX #$FC
 CC5D		LDA #$01
 CC5F	iCC5F	LDY $67		; Floating Accum. #2: Mantissa
 CC61		CPY $5F		; Floating Accum. #1: Mantissa
 CC63		BNE $CC75
 CC65		LDY $68
 CC67		CPY $60
 CC69		BNE $CC75
 CC6B		LDY $69
 CC6D		CPY $61
 CC6F		BNE $CC75
 CC71		LDY $6A
 CC73		CPY $62
 CC75	iCC75	PHP
 CC76		ROL
 CC77		BCC $CC82
 CC79		INX
 CC7A		STA $26,X
 CC7C		BEQ $CCB0
 CC7E		BPL $CCB4
 CC80		LDA #$01
 CC82	iCC82	PLP
 CC83		BCS $CC93
 CC85	iCC85	ASL $6A
 CC87		ROL $69
 CC89		ROL $68
 CC8B		ROL $67		; Floating Accum. #2: Mantissa
 CC8D		BCS $CC75
 CC8F		BMI $CC5F
 CC91		BPL $CC75
 CC93	iCC93	TAY
 CC94		LDA $6A
 CC96		SBC $62
 CC98		STA $6A
 CC9A		LDA $69
 CC9C		SBC $61
 CC9E		STA $69
 CCA0		LDA $68
 CCA2		SBC $60
 CCA4		STA $68
 CCA6		LDA $67		; Floating Accum. #2: Mantissa
 CCA8		SBC $5F		; Floating Accum. #1: Mantissa
 CCAA		STA $67		; Floating Accum. #2: Mantissa
 CCAC		TYA
 CCAD		JMP $CC85
 CCB0	iCCB0	LDA #$40
 CCB2		BNE $CC82
 CCB4	iCCB4	ASL
 CCB5		ASL
 CCB6		ASL
 CCB7		ASL
 CCB8		ASL
 CCB9		ASL
 CCBA		STA $6D		; Floating Accum. #1. Low-Order (Rounding)
 CCBC		PLP
 CCBD		JMP $CCC5
 CCC0	iCCC0	LDX #$85
 CCC2		JMP $B3CF	; error	Error Routine

 CCC5	iCCC5	LDA $23		; Floating-Point Product of Multiply
 CCC7		STA $5F		; Floating Accum. #1: Mantissa
 CCC9		LDA $24
 CCCB		STA $60
 CCCD		LDA $25
 CCCF		STA $61
 CCD1		LDA $26
 CCD3		STA $62
 CCD5		JMP $CA0D


; movfm	Load FAC#1 From Memory

 CCD8	iCCD8	STA $1F		; Utility Pointer Area
 CCDA		STY $20
 CCDC		LDY #$04
 CCDE		LDA ($1F),Y	; Utility Pointer Area
 CCE0		STA $62
 CCE2		DEY
 CCE3		LDA ($1F),Y	; Utility Pointer Area
 CCE5		STA $61
 CCE7		DEY
 CCE8		LDA ($1F),Y	; Utility Pointer Area
 CCEA		STA $60
 CCEC		DEY
 CCED		LDA ($1F),Y	; Utility Pointer Area
 CCEF		STA $63		; Floating Accum. #1: Sign
 CCF1		ORA #$80
 CCF3		STA $5F		; Floating Accum. #1: Mantissa
 CCF5		DEY
 CCF6		LDA ($1F),Y	; Utility Pointer Area
 CCF8		STA $5E		; Floating-Point Accumulator #1: Exponent
 CCFA		STY $6D		; Floating Accum. #1. Low-Order (Rounding)
 CCFC		RTS


; mov2f	Store FAC#1 in Memory

 CCFD	iCCFD	LDX #$59
 CCFF		BIT $54A2
; *** CCFF: ADDRESS DIFFER. This may indicate misassembly ***
 CD02		LDY #$00
 CD04		BEQ $CD0A	; -	Store FAC#1 at (AC/YR)
 CD06	iCD06	LDX $46		; Pointer: Index Variable for FOR/NEXT
 CD08		LDY $47


; -	Store FAC#1 at (AC/YR)

 CD0A	iCD0A	JSR $CD51	; round	Round FAC#1
 CD0D		STX $1F		; Utility Pointer Area
 CD0F		STY $20
 CD11		LDY #$04
 CD13		LDA $62
 CD15		STA ($1F),Y	; Utility Pointer Area
 CD17		DEY
 CD18		LDA $61
 CD1A		STA ($1F),Y	; Utility Pointer Area
 CD1C		DEY
 CD1D		LDA $60
 CD1F		STA ($1F),Y	; Utility Pointer Area
 CD21		DEY
 CD22		LDA $63		; Floating Accum. #1: Sign
 CD24		ORA #$7F
 CD26		AND $5F		; Floating Accum. #1: Mantissa
 CD28		STA ($1F),Y	; Utility Pointer Area
 CD2A		DEY
 CD2B		LDA $5E		; Floating-Point Accumulator #1: Exponent
 CD2D		STA ($1F),Y	; Utility Pointer Area
 CD2F		STY $6D		; Floating Accum. #1. Low-Order (Rounding)
 CD31		RTS


; movfa	Copy FAC#2 into FAC#1

 CD32	iCD32	LDA $6B		; Floating Accum. #2: Sign
 CD34	iCD34	STA $63		; Floating Accum. #1: Sign
 CD36		LDX #$05
 CD38	iCD38	LDA $65,X	; Floating -accum. #1: Overflow Digit
 CD3A		STA $5D,X
 CD3C		DEX
 CD3D		BNE $CD38
 CD3F		STX $6D		; Floating Accum. #1. Low-Order (Rounding)
 CD41		RTS


; movaf	Copy FAC#1 into FAC#2

 CD42	iCD42	JSR $CD51	; round	Round FAC#1
 CD45	iCD45	LDX #$06
 CD47	iCD47	LDA $5D,X
 CD49		STA $65,X	; Floating -accum. #1: Overflow Digit
 CD4B		DEX
 CD4C		BNE $CD47
 CD4E		STX $6D		; Floating Accum. #1. Low-Order (Rounding)
 CD50	iCD50	RTS


; round	Round FAC#1

 CD51	iCD51	LDA $5E		; Floating-Point Accumulator #1: Exponent
 CD53		BEQ $CD50
 CD55		ASL $6D		; Floating Accum. #1. Low-Order (Rounding)
 CD57		BCC $CD50
 CD59	iCD59	JSR $CAA5
 CD5C		BNE $CD50
 CD5E		JMP $CA6E


; sign	Check Sign of FAC#1

 CD61	iCD61	LDA $5E		; Floating-Point Accumulator #1: Exponent
 CD63		BEQ $CD6E
 CD65	iCD65	LDA $63		; Floating Accum. #1: Sign
 CD67	iCD67	ROL
 CD68		LDA #$FF
 CD6A		BCS $CD6E
 CD6C		LDA #$01
 CD6E	iCD6E	RTS


; sgn	Evaluate <sgn>

 CD6F		JSR $CD61	; sign	Check Sign of FAC#1
 CD72	iCD72	STA $5F		; Floating Accum. #1: Mantissa
 CD74		LDA #$00
 CD76		STA $60
 CD78		LDX #$88
 CD7A	iCD7A	LDA $5F		; Floating Accum. #1: Mantissa
 CD7C		EOR #$FF
 CD7E		ROL
 CD7F	iCD7F	LDA #$00
 CD81		STA $62
 CD83		STA $61
 CD85	iCD85	STX $5E		; Floating-Point Accumulator #1: Exponent
 CD87		STA $6D		; Floating Accum. #1. Low-Order (Rounding)
 CD89		STA $63		; Floating Accum. #1: Sign
 CD8B		JMP $CA08


; abs	Evaluate <abs>

 CD8E		LSR $63		; Floating Accum. #1: Sign
 CD90		RTS


; fcomp	Compare FAC#1 With Memory

 CD91	iCD91	STA $21
 CD93	iCD93	STY $22
 CD95		LDY #$00
 CD97		LDA ($21),Y
 CD99		INY
 CD9A		TAX
 CD9B		BEQ $CD61	; sign	Check Sign of FAC#1
 CD9D		LDA ($21),Y
 CD9F		EOR $63		; Floating Accum. #1: Sign
 CDA1		BMI $CD65
 CDA3		CPX $5E		; Floating-Point Accumulator #1: Exponent
 CDA5		BNE $CDC8
 CDA7		LDA ($21),Y
 CDA9		ORA #$80
 CDAB		CMP $5F		; Floating Accum. #1: Mantissa
 CDAD		BNE $CDC8
 CDAF		INY
 CDB0		LDA ($21),Y
 CDB2		CMP $60
 CDB4		BNE $CDC8
 CDB6		INY
 CDB7		LDA ($21),Y
 CDB9		CMP $61
 CDBB		BNE $CDC8
 CDBD		INY
 CDBE		LDA #$7F
 CDC0		CMP $6D		; Floating Accum. #1. Low-Order (Rounding)
 CDC2		LDA ($21),Y
 CDC4		SBC $62
 CDC6		BEQ $CDF0
 CDC8	iCDC8	LDA $63		; Floating Accum. #1: Sign
 CDCA		BCC $CDCE
 CDCC		EOR #$FF
 CDCE	iCDCE	JMP $CD67


; qint	Convert FAC#1 to Integer

 CDD1	iCDD1	LDA $5E		; Floating-Point Accumulator #1: Exponent
 CDD3		BEQ $CE1F
 CDD5		SEC
 CDD6		SBC #$A0
 CDD8		BIT $63
 CDDA		BPL $CDE5
 CDDC		TAX
 CDDD		LDA #$FF
 CDDF		STA $65		; Floating -accum. #1: Overflow Digit
 CDE1		JSR $CA83
 CDE4		TXA
 CDE5	iCDE5	LDX #$5E
 CDE7		CMP #$F9
 CDE9		BPL $CDF1
 CDEB		JSR $CACF
 CDEE		STY $65		; Floating -accum. #1: Overflow Digit
 CDF0	iCDF0	RTS
 CDF1	iCDF1	TAY
 CDF2		LDA $63		; Floating Accum. #1: Sign
 CDF4		AND #$80
 CDF6		LSR $5F		; Floating Accum. #1: Mantissa
 CDF8		ORA $5F		; Floating Accum. #1: Mantissa
 CDFA		STA $5F		; Floating Accum. #1: Mantissa
 CDFC		JSR $CAE6
 CDFF		STY $65		; Floating -accum. #1: Overflow Digit
 CE01		RTS


; int	Evaluate <int>

 CE02	iCE02	LDA $5E		; Floating-Point Accumulator #1: Exponent
 CE04		CMP #$A0
 CE06		BCS $CE28
 CE08		JSR $CDD1	; qint	Convert FAC#1 to Integer
 CE0B		STY $6D		; Floating Accum. #1. Low-Order (Rounding)
 CE0D		LDA $63		; Floating Accum. #1: Sign
 CE0F		STY $63		; Floating Accum. #1: Sign
 CE11		EOR #$80
 CE13		ROL
 CE14		LDA #$A0
 CE16		STA $5E		; Floating-Point Accumulator #1: Exponent
 CE18		LDA $62
 CE1A		STA $03		; Search Character
 CE1C		JMP $CA08
 CE1F	iCE1F	STA $5F		; Floating Accum. #1: Mantissa
 CE21		STA $60
 CE23		STA $61
 CE25		STA $62
 CE27		TAY
 CE28	iCE28	RTS


; fin	Convert ASCII String to a Number in FAC#1

 CE29	iCE29	LDY #$00
 CE2B		LDX #$0A
 CE2D	iCE2D	STY $5A,X
 CE2F		DEX
 CE30		BPL $CE2D
 CE32		BCC $CE43
 CE34		CMP #$2D
 CE36		BNE $CE3C
 CE38		STX $64		; Pointer: Series Evaluation Constant Pointer
 CE3A		BEQ $CE40
 CE3C	iCE3C	CMP #$2B
 CE3E		BNE $CE45
 CE40	iCE40	JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 CE43	iCE43	BCC $CEA0
 CE45	iCE45	CMP #$2E
 CE47		BEQ $CE77
 CE49		CMP #$45
 CE4B		BNE $CE7D
 CE4D		JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 CE50		BCC $CE69
 CE52		CMP #$AB
 CE54		BEQ $CE64
 CE56		CMP #$2D
 CE58		BEQ $CE64
 CE5A		CMP #$AA
 CE5C		BEQ $CE66
 CE5E		CMP #$2B
 CE60		BEQ $CE66
 CE62		BNE $CE6B
 CE64	iCE64	ROR $5D
 CE66	iCE66	JSR $0070	; Subroutine: Get Next Byte of BASIC Text
 CE69	iCE69	BCC $CEC7
 CE6B	iCE6B	BIT $5D
 CE6D		BPL $CE7D
 CE6F		LDA #$00
 CE71		SEC
 CE72		SBC $5B
 CE74		JMP $CE7F
 CE77	iCE77	ROR $5C
 CE79		BIT $5C
 CE7B		BVC $CE40
 CE7D	iCE7D	LDA $5B
 CE7F	iCE7F	SEC
 CE80		SBC $5A
 CE82		STA $5B
 CE84		BEQ $CE98
 CE86		BPL $CE91
 CE88	iCE88	JSR $CC34	; div10	Divide FAC#1 by 10
 CE8B		INC $5B
 CE8D		BNE $CE88
 CE8F		BEQ $CE98
 CE91	iCE91	JSR $CC18	; mul10	Multiply FAC#1 by 10
 CE94		DEC $5B
 CE96		BNE $CE91
 CE98	iCE98	LDA $64		; Pointer: Series Evaluation Constant Pointer
 CE9A		BMI $CE9D
 CE9C		RTS
 CE9D	iCE9D	JMP $D14B	; negop	Negate FAC#1
 CEA0	iCEA0	PHA
 CEA1		BIT $5C
 CEA3		BPL $CEA7
 CEA5		INC $5A
 CEA7	iCEA7	JSR $CC18	; mul10	Multiply FAC#1 by 10
 CEAA		PLA
 CEAB		SEC
 CEAC		SBC #$30
 CEAE		JSR $CEB4
 CEB1		JMP $CE40
 CEB4	iCEB4	PHA
 CEB5		JSR $CD42	; movaf	Copy FAC#1 into FAC#2
 CEB8		PLA
 CEB9		JSR $CD72
 CEBC		LDA $6B		; Floating Accum. #2: Sign
 CEBE		EOR $63		; Floating Accum. #1: Sign
 CEC0		STA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 CEC2		LDX $5E		; Floating-Point Accumulator #1: Exponent
 CEC4		JMP $C9A0	; -	Evaluate <add>
 CEC7	iCEC7	LDA $5B
 CEC9		CMP #$0A
 CECB		BCC $CED6
 CECD		LDA #$64
 CECF		BIT $5D
 CED1		BMI $CEE4
 CED3		JMP $CAB4	; overr	Output ?OVERFLOW Error
 CED6	iCED6	ASL
 CED7		ASL
 CED8		CLC
 CED9		ADC $5B
 CEDB		ASL
 CEDC		CLC
 CEDD		LDY #$00
 CEDF		ADC ($77),Y	; Pointer: Current Byte of BASIC Text
 CEE1		SEC
 CEE2		SBC #$30
 CEE4	iCEE4	STA $5B
 CEE6		JMP $CE66


; n0999	String Conversion Constants		DATA

;cee9	  99999999.9
;ceee	 999999999
;cef3	1000000000
;

 CEE9		.byte 9B 3E BC 1F FD 9E 6E 6B  ;.>....NK
 CEF1		.byte 27 FD 9E 6E 6B 28 00     ;'..NK(.


; Unused			EMPTY

 CEF8		.byte F9 AA AA AA AA AA AA AA  ;........
 CF00		.byte AA AA AA AA AA AA AA AA  ;........
 CF08		.byte AA AA AA AA AA AA AA AA  ;........
 CF10		.byte AA AA AA AA AA AA AA AA  ;........
 CF18		.byte AA AA AA AA AA AA AA AA  ;........
 CF20		.byte AA AA AA AA AA AA AA AA  ;........
 CF28		.byte AA AA AA AA AA AA AA AA  ;........
 CF30		.byte AA AA AA AA AA AA AA AA  ;........
 CF38		.byte AA AA AA AA AA AA AA AA  ;........
 CF40		.byte AA AA AA AA AA AA AA AA  ;........
 CF48		.byte AA AA AA AA AA AA AA AA  ;........
 CF50		.byte AA AA AA AA AA AA AA AA  ;........
 CF58		.byte AA AA AA AA AA AA AA AA  ;........
 CF60		.byte AA AA AA AA AA AA AA AA  ;........
 CF68		.byte AA AA AA AA AA AA AA AA  ;........
 CF70		.byte AA AA AA AA AA AA AA AA  ;........


; inprt	Output 'IN' and Line Number

 CF78	iCF78	LDA #$0D
 CF7A		LDY #$B3
 CF7C		JSR $CF90
 CF7F		LDA $37
 CF81		LDX $36		; Current BASIC Line Number
 CF83	iCF83	STA $5F		; Floating Accum. #1: Mantissa
 CF85		STX $60
 CF87		LDX #$90
 CF89		SEC
 CF8A		JSR $CD7F
 CF8D		JSR $CF93	; fout	Convert FAC#1 to ASCII String
 CF90	iCF90	JMP $BB1D	; strout	Output String


; fout	Convert FAC#1 to ASCII String

 CF93	iCF93	LDY #$01
 CF95	iCF95	LDA #$20
 CF97		BIT $63
 CF99		BPL $CF9D
 CF9B		LDA #$2D
 CF9D	iCF9D	STA $00FF,Y	; Not used
 CFA0		STA $63		; Floating Accum. #1: Sign
 CFA2		STY $6E		; Pointer: Cassette Buffer
 CFA4		INY
 CFA5		LDA #$30
 CFA7		LDX $5E		; Floating-Point Accumulator #1: Exponent
 CFA9		BNE $CFAE
 CFAB		JMP $D0BA
 CFAE	iCFAE	LDA #$00
 CFB0		CPX #$80
 CFB2		BEQ $CFB6
 CFB4		BCS $CFBF
 CFB6	iCFB6	LDA #$F3
 CFB8		LDY #$CE
 CFBA		JSR $CB5E	; fmult	Perform Multiply
 CFBD		LDA #$F7
 CFBF	iCFBF	STA $5A
 CFC1	iCFC1	LDA #$EE
 CFC3		LDY #$CE
 CFC5		JSR $CD91	; fcomp	Compare FAC#1 With Memory
 CFC8		BEQ $CFE8
 CFCA		BPL $CFDE
 CFCC	iCFCC	LDA #$E9
 CFCE		LDY #$CE
 CFD0		JSR $CD91	; fcomp	Compare FAC#1 With Memory
 CFD3		BEQ $CFD7
 CFD5		BPL $CFE5
 CFD7	iCFD7	JSR $CC18	; mul10	Multiply FAC#1 by 10
 CFDA		DEC $5A
 CFDC		BNE $CFCC
 CFDE	iCFDE	JSR $CC34	; div10	Divide FAC#1 by 10
 CFE1		INC $5A
 CFE3		BNE $CFC1
 CFE5	iCFE5	JSR $C97F	; faddh	Add 0.5 to FAC#1
 CFE8	iCFE8	JSR $CDD1	; qint	Convert FAC#1 to Integer
 CFEB		LDX #$01
 CFED		LDA $5A
 CFEF		CLC
 CFF0		ADC #$0A
 CFF2		BMI $CFFD
 CFF4		CMP #$0B
 CFF6		BCS $CFFE
 CFF8		ADC #$FF
 CFFA		TAX
 CFFB		LDA #$02
 CFFD	iCFFD	SEC
 CFFE	iCFFE	SBC #$02
 D000		STA $5B
 D002		STX $5A
 D004		TXA
 D005		BEQ $D009
 D007		BPL $D01C
 D009	iD009	LDY $6E		; Pointer: Cassette Buffer
 D00B		LDA #$2E
 D00D		INY
 D00E		STA $00FF,Y	; Not used
 D011		TXA
 D012		BEQ $D01A
 D014		LDA #$30
 D016		INY
 D017		STA $00FF,Y	; Not used
 D01A	iD01A	STY $6E		; Pointer: Cassette Buffer
 D01C	iD01C	LDY #$00


; foutim	Convert TI to String

 D01E	iD01E	LDX #$80
 D020	iD020	LDA $62
 D022		CLC
 D023		ADC $D0CF,Y
 D026		STA $62
 D028		LDA $61
 D02A		ADC $D0CE,Y
 D02D		STA $61
 D02F		LDA $60
 D031		ADC $D0CD,Y
 D034		STA $60
 D036		LDA $5F		; Floating Accum. #1: Mantissa
 D038		ADC $D0CC,Y
 D03B		STA $5F		; Floating Accum. #1: Mantissa
 D03D		INX
 D03E		BCS $D044
 D040		BPL $D020
 D042		BMI $D046
 D044	iD044	BMI $D020
 D046	iD046	TXA
 D047		BCC $D04D
 D049		EOR #$FF
 D04B		ADC #$0A
 D04D	iD04D	ADC #$2F
 D04F		INY
 D050		INY
 D051		INY
 D052		INY
 D053		STY $44		; Pointer: Current BASIC Variable Data
 D055		LDY $6E		; Pointer: Cassette Buffer
 D057		INY
 D058		TAX
 D059		AND #$7F
 D05B		STA $00FF,Y	; Not used
 D05E		DEC $5A
 D060		BNE $D068
 D062		LDA #$2E
 D064		INY
 D065		STA $00FF,Y	; Not used
 D068	iD068	STY $6E		; Pointer: Cassette Buffer
 D06A		LDY $44		; Pointer: Current BASIC Variable Data
 D06C		TXA
 D06D		EOR #$FF
 D06F		AND #$80
 D071		TAX
 D072		CPY #$24
 D074		BEQ $D07A
 D076		CPY #$3C
 D078		BNE $D020
 D07A	iD07A	LDY $6E		; Pointer: Cassette Buffer
 D07C	iD07C	LDA $00FF,Y	; Not used
 D07F		DEY
 D080		CMP #$30
 D082		BEQ $D07C
 D084		CMP #$2E
 D086		BEQ $D089
 D088		INY
 D089	iD089	LDA #$2B
 D08B		LDX $5B
 D08D		BEQ $D0BD
 D08F		BPL $D099
 D091		LDA #$00
 D093		SEC
 D094		SBC $5B
 D096		TAX
 D097		LDA #$2D
 D099	iD099	STA $0101,Y
 D09C		LDA #$45
 D09E		STA $0100,Y	; Micro-Processor System Stack Area
 D0A1		TXA
 D0A2		LDX #$2F
 D0A4		SEC
 D0A5	iD0A5	INX
 D0A6		SBC #$0A
 D0A8		BCS $D0A5
 D0AA		ADC #$3A
 D0AC		STA $0103,Y
 D0AF		TXA
 D0B0		STA $0102,Y
 D0B3		LDA #$00
 D0B5		STA $0104,Y
 D0B8		BEQ $D0C2
 D0BA	iD0BA	STA $00FF,Y	; Not used
 D0BD	iD0BD	LDA #$00
 D0BF		STA $0100,Y	; Micro-Processor System Stack Area
 D0C2	iD0C2	LDA #$00
 D0C4		LDY #$01
 D0C6		RTS


; fhalf	Table of Constants			DATA

;d0c7	0.5
; This table is used in converting numbers to ascii.
;d0cc	4-byte powers of 10
;d0f0	TI Constants
;

 D0C7		.byte 80 00 00 00 00           ;.....
 D0CC	sD0CC	.byte FA                       ;.
 D0CD	sD0CD	.byte 0A                       ;.
 D0CE	sD0CE	.byte 1F                       ;.
 D0CF	sD0CF	.byte 00 00 98 96 80 FF F0 BD  ;........
 D0D7		.byte C0 00 01 86 A0 FF FF D8  ;.......X
 D0DF		.byte F0 00 00 03 E8 FF FF FF  ;........
 D0E7		.byte 9C 00 00 00 0A FF FF FF  ;........
 D0EF		.byte FF FF DF 0A 80 00 03 4B  ;.......k
 D0F7		.byte C0 FF FF 73 60 00 00 0E  ;...S`...
 D0FF		.byte 10 FF FF FD A8 00 00 00  ;........
 D107		.byte 3C                       ;<


; sqr	Evaluate <sqr>

 D108		JSR $CD42	; movaf	Copy FAC#1 into FAC#2
 D10B		LDA #$C7
 D10D		LDY #$D0
 D10F		JSR $CCD8	; movfm	Load FAC#1 From Memory


; fpwrt	Evaluate <power>

 D112		BEQ $D184	; exp	Evaluate <exp>
 D114		LDA $66		; Floating-Point Accumulator #2: Exponent
 D116		BNE $D11B
 D118		JMP $CA2F
 D11B	iD11B	LDX #$4B
 D11D		LDY #$00
 D11F		JSR $CD0A	; -	Store FAC#1 at (AC/YR)
 D122		LDA $6B		; Floating Accum. #2: Sign
 D124		BPL $D135
 D126		JSR $CE02	; int	Evaluate <int>
 D129		LDA #$4B
 D12B		LDY #$00
 D12D		JSR $CD91	; fcomp	Compare FAC#1 With Memory
 D130		BNE $D135
 D132		TYA
 D133		LDY $03		; Search Character
 D135	iD135	JSR $CD34
 D138		TYA
 D139		PHA
 D13A		JSR $CB20	; log	Evaluate <log>
 D13D		LDA #$4B
 D13F		LDY #$00
 D141		JSR $CB5E	; fmult	Perform Multiply
 D144		JSR $D184	; exp	Evaluate <exp>
 D147		PLA
 D148		LSR
 D149		BCC $D155


; negop	Negate FAC#1\-	Evaluate <greater>

 D14B	iD14B	LDA $5E		; Floating-Point Accumulator #1: Exponent
 D14D		BEQ $D155
 D14F		LDA $63		; Floating Accum. #1: Sign
 D151		EOR #$FF
 D153		STA $63		; Floating Accum. #1: Sign
 D155	iD155	RTS


; logeb2	Table of Constants			DATA

;d156	1.44269504	(1/LOG to base 2 e)
;d15b	#07		(counter)
;d15c	2.149875 E-5
;d161	1.435231 E-4
;d166	1.342263 E-3
;d16b	9.6414017 E-3
;d170	5.550513 E-2
;d175	2.402263 E-4
;d17a	6.931471 E-1
;d17f	1.00
;

 D156		.byte 81 38 AA 3B 29 07 71 34  ;.8.;).Q4
 D15E		.byte 58 3E 56 74 16 7E B3 1B  ;x>vT.~..
 D166		.byte 77 2F EE E3 85 7A 1D 84  ;W/...Z..
 D16E		.byte 1C 2A 7C 63 59 58 0A 7E  ;.*|Cyx.~
 D176		.byte 75 FD E7 C6 80 31 72 18  ;U..F.1R.
 D17E		.byte 10 81 00 00 00 00        ;......


; exp	Evaluate <exp>

 D184	iD184	LDA #$56
 D186		LDY #$D1
 D188		JSR $CB5E	; fmult	Perform Multiply
 D18B		LDA $6D		; Floating Accum. #1. Low-Order (Rounding)
 D18D		ADC #$50
 D18F		BCC $D194
 D191		JSR $CD59
 D194	iD194	STA $53
 D196		JSR $CD45
 D199		LDA $5E		; Floating-Point Accumulator #1: Exponent
 D19B		CMP #$88
 D19D		BCC $D1A2
 D19F	iD19F	JSR $CC0A	; mldvex	Overflow / Underflow
 D1A2	iD1A2	JSR $CE02	; int	Evaluate <int>
 D1A5		LDA $03		; Search Character
 D1A7		CLC
 D1A8		ADC #$81
 D1AA		BEQ $D19F
 D1AC		SEC
 D1AD		SBC #$01
 D1AF		PHA
 D1B0		LDX #$05
 D1B2	iD1B2	LDA $66,X	; Floating-Point Accumulator #2: Exponent
 D1B4		LDY $5E,X	; Floating-Point Accumulator #1: Exponent
 D1B6		STA $5E,X	; Floating-Point Accumulator #1: Exponent
 D1B8		STY $66,X	; Floating-Point Accumulator #2: Exponent
 D1BA		DEX
 D1BB		BPL $D1B2
 D1BD		LDA $53
 D1BF		STA $6D		; Floating Accum. #1. Low-Order (Rounding)
 D1C1		JSR $C989	; -	Evaluate <subtract>
 D1C4		JSR $D14B	; negop	Negate FAC#1
 D1C7		LDA #$5B
 D1C9		LDY #$D1
 D1CB		JSR $D1ED
 D1CE		LDA #$00
 D1D0		STA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 D1D2		PLA
 D1D3		JSR $CBEF
 D1D6		RTS


; polyx	Series Evaluation

 D1D7	iD1D7	STA $6E		; Pointer: Cassette Buffer
 D1D9		STY $6F
 D1DB		JSR $CD00
 D1DE		LDA #$54
 D1E0		JSR $CB5E	; fmult	Perform Multiply
 D1E3		JSR $D1F1
 D1E6		LDA #$54
 D1E8		LDY #$00
 D1EA		JMP $CB5E	; fmult	Perform Multiply

 D1ED	iD1ED	STA $6E		; Pointer: Cassette Buffer
 D1EF		STY $6F
 D1F1	iD1F1	JSR $CCFD	; mov2f	Store FAC#1 in Memory
 D1F4		LDA ($6E),Y	; Pointer: Cassette Buffer
 D1F6		STA $64		; Pointer: Series Evaluation Constant Pointer
 D1F8		LDY $6E		; Pointer: Cassette Buffer
 D1FA		INY
 D1FB		TYA
 D1FC		BNE $D200
 D1FE		INC $6F
 D200	iD200	STA $6E		; Pointer: Cassette Buffer
 D202		LDY $6F
 D204	iD204	JSR $CB5E	; fmult	Perform Multiply
 D207		LDA $6E		; Pointer: Cassette Buffer
 D209		LDY $6F
 D20B		CLC
 D20C		ADC #$05
 D20E		BCC $D211
 D210		INY
 D211	iD211	STA $6E		; Pointer: Cassette Buffer
 D213		STY $6F
 D215		JSR $C99D	; fadd	Perform Addition
 D218		LDA #$59
 D21A		LDY #$00
 D21C		DEC $64		; Pointer: Series Evaluation Constant Pointer
 D21E		BNE $D204
 D220		RTS


; rmulc	Constants for RND			DATA

 D221		.byte 98 35 44 7A 68 28 B1 46  ;.5dZH(.f


; rnd	Evaluate <rnd>

 D229		JSR $CD61	; sign	Check Sign of FAC#1
 D22C		BMI $D25C
 D22E		BNE $D247
 D230		LDA $E844
 D233		STA $5F		; Floating Accum. #1: Mantissa
 D235		LDA $E848
 D238		STA $60
 D23A		LDA $E845
 D23D		STA $61
 D23F		LDA $E849
 D242		STA $62
 D244		JMP $D26C
 D247	iD247	LDA #$88
 D249		LDY #$00
 D24B		JSR $CCD8	; movfm	Load FAC#1 From Memory
 D24E		LDA #$21
 D250		LDY #$D2
 D252		JSR $CB5E	; fmult	Perform Multiply
 D255		LDA #$25
 D257		LDY #$D2
 D259		JSR $C99D	; fadd	Perform Addition
 D25C	iD25C	LDX $62
 D25E		LDA $5F		; Floating Accum. #1: Mantissa
 D260		STA $62
 D262		STX $5F		; Floating Accum. #1: Mantissa
 D264		LDX $60
 D266		LDA $61
 D268		STA $60
 D26A		STX $61
 D26C	iD26C	LDA #$00
 D26E		STA $63		; Floating Accum. #1: Sign
 D270		LDA $5E		; Floating-Point Accumulator #1: Exponent
 D272		STA $6D		; Floating Accum. #1. Low-Order (Rounding)
 D274		LDA #$80
 D276		STA $5E		; Floating-Point Accumulator #1: Exponent
 D278		JSR $CA0D
 D27B		LDX #$88
 D27D		LDY #$00
 D27F	iD27F	JMP $CD0A	; -	Store FAC#1 at (AC/YR)


; cos	Evaluate <cos>

 D282		LDA #$FE
 D284		LDY #$D2
 D286		JSR $C99D	; fadd	Perform Addition


; sin	Evaluate <sin>

 D289	iD289	JSR $CD42	; movaf	Copy FAC#1 into FAC#2
 D28C		LDA #$03
 D28E		LDY #$D3
 D290		LDX $6B		; Floating Accum. #2: Sign
 D292		JSR $CC3D	; fdiv	Divide FAC#2 by Flpt at (AC/YR)
 D295		JSR $CD42	; movaf	Copy FAC#1 into FAC#2
 D298		JSR $CE02	; int	Evaluate <int>
 D29B		LDA #$00
 D29D		STA $6C		; Sign Comparison Result: Accum. # 1 vs #2
 D29F		JSR $C989	; -	Evaluate <subtract>
 D2A2		LDA #$08
 D2A4		LDY #$D3
 D2A6		JSR $C986	; fsub	Perform Subtraction
 D2A9		LDA $63		; Floating Accum. #1: Sign
 D2AB		PHA
 D2AC		BPL $D2BB
 D2AE		JSR $C97F	; faddh	Add 0.5 to FAC#1
 D2B1		LDA $63		; Floating Accum. #1: Sign
 D2B3		BMI $D2BE
 D2B5		LDA $0C		; Flag TAN sign / Comparison Result
 D2B7		EOR #$FF
 D2B9		STA $0C		; Flag TAN sign / Comparison Result
 D2BB	iD2BB	JSR $D14B	; negop	Negate FAC#1
 D2BE	iD2BE	LDA #$08
 D2C0		LDY #$D3
 D2C2		JSR $C99D	; fadd	Perform Addition
 D2C5		PLA
 D2C6		BPL $D2CB
 D2C8		JSR $D14B	; negop	Negate FAC#1
 D2CB	iD2CB	LDA #$0D
 D2CD		LDY #$D3
 D2CF		JMP $D1D7	; polyx	Series Evaluation


; tan	Evaluate <tan>

 D2D2		JSR $CD00
 D2D5		LDA #$00
 D2D7		STA $0C		; Flag TAN sign / Comparison Result
 D2D9		JSR $D289	; sin	Evaluate <sin>
 D2DC		LDX #$4B
 D2DE		LDY #$00
 D2E0		JSR $D27F
 D2E3		LDA #$54
 D2E5		LDY #$00
 D2E7		JSR $CCD8	; movfm	Load FAC#1 From Memory
 D2EA		LDA #$00
 D2EC		STA $63		; Floating Accum. #1: Sign
 D2EE		LDA $0C		; Flag TAN sign / Comparison Result
 D2F0		JSR $D2FA
 D2F3		LDA #$4B
 D2F5		LDY #$00
 D2F7		JMP $CC45	; fdivt	Divide FAC#2 by FAC#1

 D2FA	iD2FA	PHA
 D2FB		JMP $D2BB


; pi2	Table of Trig Constants			DATA

;d2fe	1.570796327	pi/2
;d303	6.28318531	pi*2
;d308	0.25
;
;d30d	#05	(counter)
;d30e	-14.3813907
;d313	 42.0077971
;d318	-76.7041703
;d31d	 81.6052237
;d322	-41.3417021
;d327	 6.28318531
;

 D2FE		.byte 81 49 0F DA A2 83 49 0F  ;.i.Z..i.
 D306		.byte DA A2 7F 00 00 00 00 05  ;Z.......
 D30E		.byte 84 E6 1A 2D 1B 86 28 07  ;...-..(.
 D316		.byte FB F8 87 99 68 89 01 87  ;....H...
 D31E		.byte 23 35 DF E1 86 A5 5D E7  ;#5....].
 D326		.byte 28 83 49 0F DA A2        ;(.i.Z.


; atn	Evaluate <atn>

 D32C		LDA $63		; Floating Accum. #1: Sign
 D32E		PHA
 D32F		BPL $D334
 D331		JSR $D14B	; negop	Negate FAC#1
 D334	iD334	LDA $5E		; Floating-Point Accumulator #1: Exponent
 D336		PHA
 D337		CMP #$81
 D339		BCC $D342
 D33B		LDA #$F2
 D33D		LDY #$CA
 D33F		JSR $CC45	; fdivt	Divide FAC#2 by FAC#1
 D342	iD342	LDA #$5C
 D344		LDY #$D3
 D346		JSR $D1D7	; polyx	Series Evaluation
 D349		PLA
 D34A		CMP #$81
 D34C		BCC $D355
 D34E		LDA #$FE
 D350		LDY #$D2
 D352		JSR $C986	; fsub	Perform Subtraction
 D355	iD355	PLA
 D356		BPL $D35B
 D358		JMP $D14B	; negop	Negate FAC#1
 D35B	iD35B	RTS


; atncon	Table of ATN Constants			DATA

;d35c	#0b	(counter)
;d35d	-0.000684793912
;d362	 0.00485094216
;d367	-0.161117018
;d36c	 0.034209638
;d371	-0.0542791328
;d376	 0.0724571965
;d37b	-0.0898023954
;d380	 0.110932413
;d385	-0.142839808
;d38a	 0.19999912
;d38f	-0.333333316
;d394	 1.00
;

 D35C		.byte 0B 76 B3 83 BD D3 79 1E  ;.V...SY.
 D364		.byte F4 A6 F5 7B 83 FC B0 10  ;...{....
 D36C		.byte 7C 0C 1F 67 CA 7C DE 53  ;|..GJ|.s
 D374		.byte CB C1 7D 14 64 70 4C 7D  ;KA}.DPl}
 D37C		.byte B7 EA 51 7A 7D 63 30 88  ;..qZ}C0.
 D384		.byte 7E 7E 92 44 99 3A 7E 4C  ;~~.d.:~l
 D38C		.byte CC 91 C7 7F AA AA AA 13  ;L.G.....
 D394		.byte 81 00 00 00              ;....
 D398	sD398	.byte 00                       ;.


; initat	CHRGET For Zero-page

 D399	iD399	INC $77		; Pointer: Current Byte of BASIC Text
 D39B		BNE $D39F
 D39D		INC $78
 D39F	iD39F	LDA $EA60
 D3A2		CMP #$3A
 D3A4		BCS $D3B0
 D3A6		CMP #$20
 D3A8		BEQ $D399	; initat	CHRGET For Zero-page
 D3AA		SEC
 D3AB		SBC #$30
 D3AD		SEC
 D3AE		SBC #$D0
 D3B0	iD3B0	RTS


; rndsed	RND Seed For zero-page			DATA

;d3b1	0.811635157

 D3B1		.byte 80 4F C7 52 58           ;.oGrx


; initcz	Initialize BASIC RAM

 D3B6	iD3B6	LDX #$FB
 D3B8		TXS
 D3B9		LDA #$4C
 D3BB		STA $51
 D3BD		STA $00		; USR Function Jump Instr (4C)
 D3BF		LDA #$73
 D3C1		LDY #$C3
 D3C3		STA $01		; USR Address [4: C373]
 D3C5		STY $02
 D3C7		LDX #$1C
 D3C9	iD3C9	LDA $D398,X
 D3CC		STA $6F,X
 D3CE		DEX
 D3CF		BNE $D3C9
 D3D1		LDA #$03
 D3D3		STA $50
 D3D5		TXA
 D3D6		STA $65		; Floating -accum. #1: Overflow Digit
 D3D8		STA $10		; 3: width of source (unused - from TTY)
 D3DA		STA $15
 D3DC		STA $0D		; 3: Flag to suppress PRINT or PRINT# when -ve
 D3DE		PHA
 D3DF		INX
 D3E0		STX $01FD
 D3E3		STX $01FC
 D3E6		LDX #$16
 D3E8		STX $13		; Pointer Temporary String
 D3EA		LDY #$04
 D3EC		STA $28		; Pointer: Start of BASIC Text [0401]
 D3EE		STY $29
 D3F0		STA $11		; Temp: Integer Value
 D3F2		STY $12
 D3F4		TAY
 D3F5		LDA #$80
 D3F7		BNE $D400
 D3F9		LDA #$00
 D3FB		LDY #$B0
 D3FD		JMP $D41B
 D400	iD400	INC $11		; Temp: Integer Value
 D402		BNE $D408
 D404		INC $12
 D406		BMI $D417	; initms	Output Power-Up Message
 D408	iD408	LDA #$55
 D40A		STA ($11),Y	; Temp: Integer Value
 D40C		CMP ($11),Y	; Temp: Integer Value
 D40E		BNE $D417	; initms	Output Power-Up Message
 D410		ASL
 D411		STA ($11),Y	; Temp: Integer Value
 D413		CMP ($11),Y	; Temp: Integer Value
 D415		BEQ $D400


; initms	Output Power-Up Message

 D417	iD417	LDA $11		; Temp: Integer Value
 D419		LDY $12
 D41B	iD41B	STA $34		; Pointer: Highest Address Used by BASIC
 D41D		STY $35
 D41F		STA $30		; Pointer: Bottom of String Storage
 D421		STY $31
 D423		LDY #$00
 D425		TYA
 D426		STA ($28),Y	; Pointer: Start of BASIC Text [0401]
 D428		INC $28		; Pointer: Start of BASIC Text [0401]
 D42A		LDA #$A4
 D42C		LDY #$DE
 D42E		JSR $BB1D	; strout	Output String
 D431		LDA $34		; Pointer: Highest Address Used by BASIC
 D433		SEC
 D434		SBC $28		; Pointer: Start of BASIC Text [0401]
 D436		TAX
 D437		LDA $35
 D439		SBC $29
 D43B		JSR $CF83
 D43E		LDA #$4B
 D440		LDY #$D4
 D442		JSR $BB1D	; strout	Output String
 D445		JSR $B5D4
 D448		JMP $B3FF	; ready	Restart BASIC


; words	Power-Up Message			DATA

 D44B		.byte 20 42 59 54 45 53 20 46  ; bytes f
 D453		.byte 52 45 45 0D 00 23 23 23  ;ree..###
 D45B		.byte 20 43 4F 4D 4D 4F 44 4F  ; commodo
 D463		.byte 52 45 20 42 41 53 49 43  ;re basic
 D46B		.byte 20 23 23 23 0D 0D 00     ; ###...


; Perform [monitor]

 D472	iD472	LDA #$43
 D474		STA $B5
 D476		BNE $D491


; Break Entry

 D478		JSR $F2A6	; clrchn	Restore Default I/O
 D47B		LDA #$42
 D47D		STA $B5
 D47F		CLD
 D480		LSR
 D481		PLA
 D482		STA $0205
 D485		PLA
 D486		STA $0204
 D489		PLA
 D48A		STA $0203
 D48D		PLA
 D48E		STA $0202
 D491	iD491	PLA
 D492		ADC #$FF
 D494		STA $0201
 D497		PLA
 D498		ADC #$FF
 D49A		STA $0200	; System INPUT Buffer
 D49D		LDA $90		; Vector: Hardware Interrupt [3: E62E, 4: E455]
 D49F		STA $0208
 D4A2		LDA $91
 D4A4		STA $0207
 D4A7		TSX
 D4A8		STX $0206
 D4AB		CLI
 D4AC		JSR $D534	; New Line
 D4AF		LDX $B5
 D4B1		LDA #$2A
 D4B3		JSR $D731	; Output 2 Ascii Chars
 D4B6		LDA #$52
 D4B8		BNE $D4D4


; *Get Command

 D4BA	iD4BA	LDA #$02
 D4BC		STA $77		; Pointer: Current Byte of BASIC Text
 D4BE		LDA #$00
 D4C0		STA $DE		; Cassette Read / Write Block Count
 D4C2		LDX #$0D
 D4C4		LDA #$2E
 D4C6		JSR $D731	; Output 2 Ascii Chars
 D4C9	iD4C9	JSR $D798	; ?
 D4CC		CMP #$2E
 D4CE		BEQ $D4C9
 D4D0		CMP #$20
 D4D2		BEQ $D4C9
 D4D4	iD4D4	LDX #$07
 D4D6	iD4D6	CMP $D544,X	; Commands					DATA
 D4D9		BNE $D4E6
 D4DB		STX $B4
 D4DD		LDA $D54C,X	; Command Vectors					DATA
 D4E0		PHA
 D4E1		LDA $D554,X
 D4E4		PHA
 D4E5		RTS
 D4E6	iD4E6	DEX
 D4E7		BPL $D4D6
 D4E9		JMP ($03FA)	; Monitor extension vector [D7A4]

 D4EC	iD4EC	LDA $FB		; I/O Start Address
 D4EE		STA $0201
 D4F1		LDA $FC
 D4F3		STA $0200	; System INPUT Buffer
 D4F6		RTS


; Display Memory 

 D4F7	iD4F7	STA $B5
 D4F9		LDY #$00
 D4FB	iD4FB	JSR $D531	; Print Space
 D4FE		LDA ($FB),Y	; I/O Start Address
 D500		JSR $D722	; Output 2-digit Byte
 D503		JSR $D539	; Increment Pointer
 D506		DEC $B5
 D508		BNE $D4FB
 D50A		RTS


; ?

 D50B	iD50B	JSR $D763	; Input Hex Byte
 D50E		BCC $D51D
 D510		LDX #$00
 D512		STA ($FB,X)	; I/O Start Address
 D514		CMP ($FB,X)	; I/O Start Address
 D516		BEQ $D51D
 D518		PLA
 D519		PLA
 D51A		JMP $D7A4	; Print '?'
 D51D	iD51D	JSR $D539	; Increment Pointer
 D520		DEC $B5
 D522		RTS


; ?

 D523	iD523	LDA #$02
 D525		STA $FB		; I/O Start Address
 D527		LDA #$02
 D529		STA $FC
 D52B		LDA #$05
 D52D		RTS

 D52E	iD52E	JSR $D531	; Print Space


; Print Space

 D531	iD531	LDA #$20
 D533		BIT $0DA9

; *** Resyncing ***

; New Line

 D534	iD534	LDA #$0D
 D536		JMP $F266	; chrout	Output One Character


; Increment Pointer

 D539	iD539	INC $FB		; I/O Start Address
 D53B		BNE $D543
 D53D		INC $FC
 D53F		BNE $D543
 D541		INC $DE		; Cassette Read / Write Block Count
 D543	iD543	RTS


; Commands					DATA

 D544	sD544	.byte 3A 3B 52 4D 47 58 4C 53  ;:;rmgxls


; Command Vectors					DATA

 D54C	sD54C	.byte D6 D5 D5 D5 D6 D6 D6 D6  ;VUUUVVVV
 D554	sD554	.byte 1C FA 86 BB 32 6A 74 74  ;....2JTT


; '<cr>     pc  irq  sr ac xr yr sp'		DATA

 D55C	sD55C	.byte 0D 20 20 20 20 20 50 43  ;.     pc
 D564		.byte 20 20 49 52 51 20 20 53  ;  irq  s
 D56C		.byte 52 20 41 43 20 58 52 20  ;r ac xr 
 D574		.byte 59 52 20 53 50           ;yr sp


; Do New Line

 D579	iD579	TYA
 D57A		PHA
 D57B		JSR $D534	; New Line
 D57E		PLA
 D57F		LDX #$2E
 D581		JSR $D731	; Output 2 Ascii Chars
 D584		JMP $D52E


; Perform [r]

 D587		LDX #$00
 D589	iD589	LDA $D55C,X	; '<cr>     pc  irq  sr ac xr yr sp'		DATA
 D58C		JSR $F266	; chrout	Output One Character
 D58F		INX
 D590		CPX #$1D
 D592		BNE $D589
 D594		LDY #$3B
 D596		JSR $D579	; Do New Line
 D599		LDA $0200	; System INPUT Buffer
 D59C		JSR $D722	; Output 2-digit Byte
 D59F		LDA $0201
 D5A2		JSR $D722	; Output 2-digit Byte
 D5A5		JSR $D531	; Print Space
 D5A8		LDA $0207
 D5AB		JSR $D722	; Output 2-digit Byte
 D5AE		LDA $0208
 D5B1		JSR $D722	; Output 2-digit Byte
 D5B4		JSR $D523	; ?
 D5B7		JSR $D4F7	; Display Memory 
 D5BA		BEQ $D5F5


; Perform [m]

 D5BC		JSR $D798	; ?
 D5BF		JSR $D754	; ?
 D5C2		BCC $D5F8
 D5C4		JSR $D744	; Swap Add_ with Add_
 D5C7		JSR $D798	; ?
 D5CA		JSR $D754	; ?
 D5CD		BCC $D5F8
 D5CF		JSR $D744	; Swap Add_ with Add_
 D5D2	iD5D2	JSR $F335	; -	-stop-
 D5D5		BEQ $D5F5
 D5D7		LDX $DE		; Cassette Read / Write Block Count
 D5D9		BNE $D5F5
 D5DB		SEC
 D5DC		LDA $FD		; Tape Load Temps
 D5DE		SBC $FB		; I/O Start Address
 D5E0		LDA $FE
 D5E2		SBC $FC
 D5E4		BCC $D5F5
 D5E6		LDY #$3A
 D5E8		JSR $D579	; Do New Line
 D5EB		JSR $D717	; Output 4-digit Address
 D5EE		LDA #$08
 D5F0		JSR $D4F7	; Display Memory 
 D5F3		BEQ $D5D2
 D5F5	iD5F5	JMP $D4BA	; *Get Command
 D5F8	iD5F8	JMP $D7A4	; Print '?'


; Perform [;]

 D5FB		JSR $D763	; Input Hex Byte
 D5FE		JSR $D754	; ?
 D601		BCC $D606
 D603		JSR $D4EC
 D606	iD606	JSR $F215	; chrin	Input a byte
 D609		JSR $D754	; ?
 D60C		BCC $D618
 D60E		LDA $FB		; I/O Start Address
 D610		STA $0208
 D613		LDA $FC
 D615		STA $0207
 D618	iD618	JSR $D523	; ?
 D61B		BNE $D627


; Perform [:]

 D61D		JSR $D763	; Input Hex Byte
 D620		JSR $D754	; ?
 D623		BCC $D5F8
 D625		LDA #$08
 D627	iD627	STA $B5
 D629	iD629	JSR $D798	; ?
 D62C		JSR $D50B	; ?
 D62F		BNE $D629
 D631		BEQ $D5F5


; Perform [g]

 D633		JSR $F215	; chrin	Input a byte
 D636		CMP #$0D
 D638		BEQ $D646
 D63A		CMP #$20
 D63C		BNE $D5F8
 D63E		JSR $D754	; ?
 D641		BCC $D646
 D643		JSR $D4EC
 D646	iD646	LDX $0206
 D649		TXS
 D64A		SEI
 D64B		LDA $0207
 D64E		STA $91
 D650		LDA $0208
 D653		STA $90		; Vector: Hardware Interrupt [3: E62E, 4: E455]
 D655		LDA $0200	; System INPUT Buffer
 D658		PHA
 D659		LDA $0201
 D65C		PHA
 D65D		LDA $0202
 D660		PHA
 D661		LDA $0203
 D664		LDX $0204
 D667		LDY $0205
 D66A		RTI


; Perform [x]

 D66B		LDX $0206
 D66E		TXS
 D66F		JMP $B3FF	; ready	Restart BASIC

 D672	iD672	JMP $D7A4	; Print '?'


; Perform [l/s]

 D675		LDY #$01
 D677		STY $D4		; Current Device Number
 D679		DEY
 D67A		STY $D1		; Length of Current File Name
 D67C		STY $96		; Kernal I/O Status Word: ST
 D67E		STY $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 D680		LDA #$02
 D682		STA $DB
 D684		LDA #$09
 D686		STA $DA		; Pointer: Current File Name
 D688	iD688	JSR $F215	; chrin	Input a byte
 D68B		CMP #$20
 D68D		BEQ $D688
 D68F		CMP #$0D
 D691		BEQ $D6AD
 D693		CMP #$22
 D695	iD695	BNE $D672
 D697	iD697	JSR $F215	; chrin	Input a byte
 D69A		CMP #$22
 D69C		BEQ $D6C2
 D69E		CMP #$0D
 D6A0		BEQ $D6AD
 D6A2		STA ($DA),Y	; Pointer: Current File Name
 D6A4		INC $D1		; Length of Current File Name
 D6A6		INY
 D6A7		CPY #$10
 D6A9	iD6A9	BEQ $D672
 D6AB		BNE $D697
 D6AD	iD6AD	LDA $B4
 D6AF		CMP #$06
 D6B1	iD6B1	BNE $D695
 D6B3		JSR $F356
 D6B6		JSR $F92B	; ?
 D6B9		LDA $96		; Kernal I/O Status Word: ST
 D6BB		AND #$10
 D6BD	iD6BD	BNE $D6B1
 D6BF		JMP $D4BA	; *Get Command
 D6C2	iD6C2	JSR $F215	; chrin	Input a byte
 D6C5		CMP #$0D
 D6C7		BEQ $D6AD
 D6C9		CMP #$2C
 D6CB	iD6CB	BNE $D6BD
 D6CD		JSR $D763	; Input Hex Byte
 D6D0		AND #$0F
 D6D2	iD6D2	BEQ $D6A9
 D6D4		CMP #$03
 D6D6		BEQ $D6D2
 D6D8		STA $D4		; Current Device Number
 D6DA		JSR $F215	; chrin	Input a byte
 D6DD		CMP #$0D
 D6DF		BEQ $D6AD
 D6E1		CMP #$2C
 D6E3	iD6E3	BNE $D6CB
 D6E5		JSR $D754	; ?
 D6E8		JSR $D744	; Swap Add_ with Add_
 D6EB		JSR $F215	; chrin	Input a byte
 D6EE		CMP #$2C
 D6F0	iD6F0	BNE $D6E3
 D6F2		JSR $D754	; ?
 D6F5		LDA $FB		; I/O Start Address
 D6F7		STA $C9		; Tape End Addresses/End of Program
 D6F9		LDA $FC
 D6FB		STA $CA
 D6FD		JSR $D744	; Swap Add_ with Add_
 D700	iD700	JSR $F215	; chrin	Input a byte
 D703		CMP #$20
 D705		BEQ $D700
 D707		CMP #$0D
 D709	iD709	BNE $D6F0
 D70B		LDA $B4
 D70D		CMP #$07
 D70F		BNE $D709
 D711		JSR $F6E3
 D714		JMP $D4BA	; *Get Command


; Output 4-digit Address

 D717	iD717	LDX #$01
 D719		LDA $FA,X	; Tape Motor Interlock #2
 D71B		PHA
 D71C		LDA $FB,X	; I/O Start Address
 D71E		JSR $D722	; Output 2-digit Byte
 D721		PLA


; Output 2-digit Byte

 D722	iD722	PHA
 D723		LSR
 D724		LSR
 D725		LSR
 D726		LSR
 D727		JSR $D73A	; Byte to 2 Ascii
 D72A		TAX
 D72B		PLA
 D72C		AND #$0F
 D72E		JSR $D73A	; Byte to 2 Ascii


; Output 2 Ascii Chars

 D731	iD731	PHA
 D732		TXA
 D733		JSR $F266	; chrout	Output One Character
 D736		PLA
 D737		JMP $F266	; chrout	Output One Character


; Byte to 2 Ascii

 D73A	iD73A	CLC
 D73B		ADC #$F6
 D73D		BCC $D741
 D73F		ADC #$06
 D741	iD741	ADC #$3A
 D743		RTS


; Swap Add_ with Add_

 D744	iD744	LDX #$02
 D746	iD746	LDA $FA,X	; Tape Motor Interlock #2
 D748		PHA
 D749		LDA $FC,X
 D74B		STA $FA,X	; Tape Motor Interlock #2
 D74D		PLA
 D74E		STA $FC,X
 D750		DEX
 D751		BNE $D746
 D753		RTS


; ?

 D754	iD754	JSR $D763	; Input Hex Byte
 D757		BCC $D75B
 D759		STA $FC
 D75B	iD75B	JSR $D763	; Input Hex Byte
 D75E		BCC $D762
 D760		STA $FB		; I/O Start Address
 D762	iD762	RTS


; Input Hex Byte

 D763	iD763	LDA #$00
 D765		STA $0100	; Micro-Processor System Stack Area
 D768		JSR $D798	; ?
 D76B		CMP #$20
 D76D		BNE $D778
 D76F		JSR $D798	; ?
 D772		CMP #$20
 D774		BNE $D785
 D776		CLC
 D777		RTS
 D778	iD778	JSR $D78D	; Evaluate Hex Digit
 D77B		ASL
 D77C		ASL
 D77D		ASL
 D77E		ASL
 D77F		STA $0100	; Micro-Processor System Stack Area
 D782		JSR $D798	; ?
 D785	iD785	JSR $D78D	; Evaluate Hex Digit
 D788		ORA $0100	; Micro-Processor System Stack Area
 D78B		SEC
 D78C		RTS


; Evaluate Hex Digit

 D78D	iD78D	CMP #$3A
 D78F		PHP
 D790		AND #$0F
 D792		PLP
 D793		BCC $D797
 D795		ADC #$08
 D797	iD797	RTS


; ?

 D798	iD798	JSR $F215	; chrin	Input a byte
 D79B		CMP #$0D
 D79D		BNE $D797
 D79F		PLA
 D7A0		PLA
 D7A1		JMP $D4BA	; *Get Command


; Print '?'

;
; DOS
;

 D7A4	iD7A4	LDA #$3F
 D7A6		JSR $F266	; chrout	Output One Character
 D7A9		JMP $D4BA	; *Get Command

 D7AC	iD7AC	JMP $BF00	; synerr	Output ?SYNTAX Error



; Patched Power-Up Message			DATA

 DEA4		.byte 2A 2A 2A 20 43 4F 4D 4D  ;*** comm
 DEAC		.byte 4F 44 4F 52 45 20 42 41  ;odore ba
 DEB4		.byte 53 49 43 20 34 2E 30 20  ;sic 4.0 
 DEBC		.byte 2A 2A 2A 0D 0D 00        ;***...



;
; Editor (E000-E7FF)
;

; cint	Initialize Editor & Screen

 E000	iE000	JMP $E04B	; ?

 E003		JMP $E0A7	; lp2	Get Character From Keyboard Buffer

 E006		JMP $E116	; Input From Screen or Keyboard

 E009		JMP $E202	; -	Output to Screen

 E00C		JMP $E442	; -	Main IRQ Entry Point

 E00F		JMP $E455	; ?

 E012		JMP $E600	; -	Return From Interrupt

 E015		JMP $E051	; -	Clear Screen

 E018		JMP $E07A	; Initialize CRTC --

 E01B		JMP $E082	; Initialize CRTC --


; Initialize CRTC (with custom values)

 E01E		JMP $E088

 E021		JMP $E3C8	; ?

 E024		JMP $E3E8	; -	Scroll Screen

 E027		JMP $E4BE	; scnkey	Scan Keyboard

 E02A		JMP $E6A7	; ?

 E02D		JMP $E036	; Set REPEAT Flag

 E030		JMP $E1E1	; Set Window Top

 E033		JMP $E1DC	; Set Window Bottom


; Set REPEAT Flag

 E036	iE036	STA $E4		; 4.80: Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
 E038		RTS

 E039		TAX
 E03A		TAX
 E03B		TAX
 E03C		TAX
 E03D		TAX
 E03E		TAX
 E03F		TAX
 E040		TAX
 E041		TAX
 E042		TAX
 E043		TAX
 E044		TAX
 E045		TAX
 E046		TAX
 E047		TAX
 E048		TAX
 E049		TAX
 E04A		TAX


; ?

 E04B	iE04B	JSR $E60F	; cint1	Initialize I/O
 E04E		JSR $E07A	; Initialize CRTC --


; -	Clear Screen

 E051	iE051	LDX $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E053		DEX
 E054	iE054	INX
 E055		JSR $E06C
 E058		JSR $E1C1	; -	Clear Screen Line
 E05B		CPX $E1		; 4.80: last line of window
 E05D		BCC $E054
 E05F	iE05F	LDX $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E061		STX $D8		; Current Cursor Physical Line Number
 E063	iE063	LDY $E2		; 4.80: first column of window
 E065		STY $C6		; Cursor Column on Current Line


; -	Set Screen Pointers

 E067	iE067	LDX $D8		; Current Cursor Physical Line Number
 E069		JMP $E06F

 E06C	iE06C	LDY $E2		; 4.80: first column of window
 E06E		DEY
 E06F	iE06F	LDA $E755,X	; -	Screen Line Addresses LO		DATA
 E072		STA $C4		; Pointer: Current Screen Line Address
 E074		LDA $E76E,X	; -	Screen Line Addresses HI		DATA
 E077		STA $C5
 E079		RTS


; Initialize CRTC --

 E07A	iE07A	LDA #$2A
 E07C		LDX #$E7
 E07E		LDY #$0E
 E080		BNE $E088


; Initialize CRTC --

 E082	iE082	LDA #$3C
 E084		LDX #$E7
 E086		LDY #$0C
 E088	iE088	STA $C7		; Pointer: Tape Buffer/ Screen Scrolling
 E08A		STX $C8
 E08C		LDA $E84C
 E08F		AND #$F0
 E091		STA $D1		; Length of Current File Name
 E093		TYA
 E094		ORA $D1		; Length of Current File Name
 E096		STA $E84C
 E099		LDY #$11
 E09B	iE09B	LDA ($C7),Y	; Pointer: Tape Buffer/ Screen Scrolling
 E09D		STY $E880	; 6545/6845 CRT					CHIP
 E0A0		STA $E881
 E0A3		DEY
 E0A4		BPL $E09B
 E0A6		RTS


; lp2	Get Character From Keyboard Buffer

 E0A7	iE0A7	LDY $026F
 E0AA		LDX #$00
 E0AC	iE0AC	LDA $0270,X	; Keyboard Buffer Queue (FIFO)
 E0AF		STA $026F,X
 E0B2		INX
 E0B3		CPX $9E		; No. of Chars. in Keyboard Buffer (Queue)
 E0B5		BNE $E0AC
 E0B7		DEC $9E		; No. of Chars. in Keyboard Buffer (Queue)
 E0B9		TYA
 E0BA		CLI
 E0BB		RTS

 E0BC	iE0BC	JSR $E68C
 E0BF	iE0BF	LDA $9E		; No. of Chars. in Keyboard Buffer (Queue)
 E0C1		STA $A7		; Cursor Blink enable: 0 = Flash Cursor
 E0C3		BEQ $E0BF
 E0C5		SEI
 E0C6		LDA $AA		; Flag: Last Cursor Blink On/Off
 E0C8		BEQ $E0D3
 E0CA		LDA $A9		; Character Under Cursor
 E0CC		LDY #$00
 E0CE		STY $AA		; Flag: Last Cursor Blink On/Off
 E0D0		JSR $E606	; ?
 E0D3	iE0D3	JSR $E0A7	; lp2	Get Character From Keyboard Buffer
 E0D6		CMP #$83
 E0D8		BNE $E0EA
 E0DA		SEI
 E0DB		LDX #$09
 E0DD		STX $9E		; No. of Chars. in Keyboard Buffer (Queue)
 E0DF	iE0DF	LDA $E720,X
 E0E2		STA $026E,X
 E0E5		DEX
 E0E6		BNE $E0DF
 E0E8		BEQ $E0BF
 E0EA	iE0EA	CMP #$0D
 E0EC		BNE $E0BC
 E0EE		LDY $D5		; Physical Screen Line Length
 E0F0		STY $AC		; Flag: INPUT or GET from Keyboard
 E0F2	iE0F2	LDA ($C4),Y	; Pointer: Current Screen Line Address
 E0F4		CMP #$20
 E0F6		BNE $E0FB
 E0F8		DEY
 E0F9		BNE $E0F2
 E0FB	iE0FB	INY
 E0FC		STY $A1		; Pointer: End of Logical Line for INPUT
 E0FE		JSR $E1CB	; Goto Left Border
 E101		NOP
 E102		STY $CD		; Flag: Editor in Quote Mode, $00 = NO
 E104		LDA $A3		; Cursor Y-X Pos. at Start of INPUT
 E106		BMI $E121
 E108		CMP $D8		; Current Cursor Physical Line Number
 E10A		BNE $E121
 E10C		LDA $A4
 E10E		STA $C6		; Cursor Column on Current Line
 E110		CMP $A1		; Pointer: End of Logical Line for INPUT
 E112		BCC $E121
 E114		BCS $E144


; Input From Screen or Keyboard

 E116	iE116	TYA
 E117		PHA
 E118		TXA
 E119		PHA
 E11A		JMP ($00E9)	; 4.80: input from screen vector (from E006)
 E11D		LDA $AC		; Flag: INPUT or GET from Keyboard
 E11F		BEQ $E0BF
 E121	iE121	LDY $C6		; Cursor Column on Current Line
 E123		LDA ($C4),Y	; Pointer: Current Screen Line Address
 E125		STA $D9		; Current Character to Print
 E127		AND #$3F
 E129		ASL $D9		; Current Character to Print
 E12B		BIT $D9
 E12D		BPL $E131
 E12F		ORA #$80
 E131	iE131	BCC $E137
 E133		LDX $CD		; Flag: Editor in Quote Mode, $00 = NO
 E135		BNE $E13B
 E137	iE137	BVS $E13B
 E139		ORA #$40
 E13B	iE13B	INC $C6		; Cursor Column on Current Line
 E13D		JSR $E16A	; check For Quotes
 E140		CPY $A1		; Pointer: End of Logical Line for INPUT
 E142		BNE $E15B
 E144	iE144	LDA #$00
 E146		STA $AC		; Flag: INPUT or GET from Keyboard
 E148		LDA #$0D
 E14A		LDX $AF		; Default Input Device (0)
 E14C		CPX #$03
 E14E		BEQ $E156
 E150		LDX $B0		; Default Output (CMD) Device (3)
 E152		CPX #$03
 E154		BEQ $E159
 E156	iE156	JSR $E202	; -	Output to Screen
 E159	iE159	LDA #$0D
 E15B	iE15B	STA $D9		; Current Character to Print
 E15D		PLA
 E15E		TAX
 E15F		PLA
 E160		TAY
 E161		LDA $D9		; Current Character to Print
 E163		CMP #$DE
 E165		BNE $E169
 E167		LDA #$FF
 E169	iE169	RTS


; check For Quotes

 E16A	iE16A	CMP #$22
 E16C		BNE $E176
 E16E		LDA $CD		; Flag: Editor in Quote Mode, $00 = NO
 E170		EOR #$01
 E172		STA $CD		; Flag: Editor in Quote Mode, $00 = NO
 E174		LDA #$22
 E176	iE176	RTS


; Ascii to Screen Code

 E177	iE177	ORA #$40
 E179	iE179	LDX $9F		; Flag: Print Reverse Chars. -1=Yes, 0=No Used
 E17B		BEQ $E17F
 E17D	iE17D	ORA #$80
 E17F	iE17F	LDX $DC		; Flag: Insert Mode, >0 = # INSTs
 E181		BEQ $E185
 E183		DEC $DC		; Flag: Insert Mode, >0 = # INSTs
 E185	iE185	JSR $E606	; ?
 E188		INC $C6		; Cursor Column on Current Line
 E18A		LDY $D5		; Physical Screen Line Length
 E18C		CPY $C6		; Cursor Column on Current Line
 E18E		BCS $E199
 E190		LDX $D8		; Current Cursor Physical Line Number
 E192	iE192	JSR $E3A3	; -	Go to Next Line
 E195		LDY $E2		; 4.80: first column of window
 E197		STY $C6		; Cursor Column on Current Line
 E199	iE199	LDA #$00
 E19B		STA $E8		; 4.80: Home Count
 E19D	iE19D	PLA
 E19E		TAY
 E19F		LDA $DC		; Flag: Insert Mode, >0 = # INSTs
 E1A1		BEQ $E1A5
 E1A3		LSR $CD		; Flag: Editor in Quote Mode, $00 = NO
 E1A5	iE1A5	PLA
 E1A6		TAX
 E1A7		PLA
 E1A8		CLI
 E1A9		RTS

 E1AA	iE1AA	LDY $D5		; Physical Screen Line Length
 E1AC		LDX $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E1AE		CPX $D8		; Current Cursor Physical Line Number
 E1B0		BCC $E1BA
 E1B2		LDY $E2		; 4.80: first column of window
 E1B4		STY $C6		; Cursor Column on Current Line
 E1B6		PLA
 E1B7		PLA
 E1B8		BNE $E199
 E1BA	iE1BA	DEC $D8		; Current Cursor Physical Line Number
 E1BC		STY $C6		; Cursor Column on Current Line
 E1BE		JMP $E067	; -	Set Screen Pointers


; -	Clear Screen Line

 E1C1	iE1C1	LDA #$20
 E1C3	iE1C3	INY
 E1C4		STA ($C4),Y	; Pointer: Current Screen Line Address
 E1C6		CPY $D5		; Physical Screen Line Length
 E1C8		BCC $E1C3
 E1CA		RTS


; Goto Left Border

 E1CB	iE1CB	LDY $E2		; 4.80: first column of window
 E1CD		STY $C6		; Cursor Column on Current Line
 E1CF		LDY #$00
 E1D1		RTS


; Exit Window

 E1D2	iE1D2	LDA #$00
 E1D4		TAX
 E1D5		JSR $E1E1	; Set Window Top
 E1D8		LDA #$18
 E1DA		LDX #$4F


; Set Window Bottom

 E1DC	iE1DC	STA $E1		; 4.80: last line of window
 E1DE		STX $D5		; Physical Screen Line Length
 E1E0		RTS


; Set Window Top

 E1E1	iE1E1	STA $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E1E3		STX $E2		; 4.80: first column of window
 E1E5		RTS


; Unused					EMPTY

 E1E6		.byte AA AA AA AA AA AA AA AA  ;........
 E1EE		.byte AA AA AA AA AA AA AA AA  ;........
 E1F6		.byte AA AA AA AA AA AA AA AA  ;........
 E1FE		.byte AA AA AA AA              ;....


; -	Output to Screen

 E202	iE202	PHA
 E203		STA $D9		; Current Character to Print
 E205		TXA
 E206		PHA
 E207		TYA
 E208		PHA
 E209		JMP ($00EB)	; 4.80: print to screen vector (from E009)

 E20C		LDA #$00
 E20E		STA $AC		; Flag: INPUT or GET from Keyboard
 E210		LDY $C6		; Cursor Column on Current Line
 E212		LDA $D9		; Current Character to Print
 E214		AND #$7F
 E216		CMP #$1B
 E218		BNE $E21D
 E21A		JMP $E3BD
 E21D	iE21D	LDA $D9		; Current Character to Print
 E21F		BPL $E224	; -	-unshifted characters-
 E221		JMP $E2F4	; -	-shifted characters-


; -	-unshifted characters-

 E224	iE224	CMP #$0D
 E226		BNE $E22B
 E228		JMP $E3B6	; -	Output <CR>
 E22B	iE22B	CMP #$20
 E22D		BCC $E237
 E22F		AND #$3F
 E231		JSR $E16A	; check For Quotes
 E234		JMP $E179
 E237	iE237	LDX $DC		; Flag: Insert Mode, >0 = # INSTs
 E239		BEQ $E23E
 E23B		JMP $E17D
 E23E	iE23E	CMP #$14
 E240		BNE $E262
 E242		LDY $E2		; 4.80: first column of window
 E244		CPY $C6		; Cursor Column on Current Line
 E246		BCC $E24D
 E248		JSR $E1AA
 E24B		BNE $E25C
 E24D	iE24D	DEC $C6		; Cursor Column on Current Line
 E24F		LDY $C6		; Cursor Column on Current Line
 E251	iE251	INY
 E252		LDA ($C4),Y	; Pointer: Current Screen Line Address
 E254		DEY
 E255		STA ($C4),Y	; Pointer: Current Screen Line Address
 E257		INY
 E258		CPY $D5		; Physical Screen Line Length
 E25A		BNE $E251
 E25C	iE25C	LDA #$20
 E25E		STA ($C4),Y	; Pointer: Current Screen Line Address
 E260		BNE $E299
 E262	iE262	LDX $CD		; Flag: Editor in Quote Mode, $00 = NO
 E264		BEQ $E269
 E266		JMP $E17D
 E269	iE269	CMP #$12
 E26B		BNE $E26F
 E26D		STA $9F		; Flag: Print Reverse Chars. -1=Yes, 0=No Used
 E26F	iE26F	CMP #$13
 E271		BNE $E283
 E273		LDA $E8		; 4.80: Home Count
 E275		BPL $E27B
 E277		JSR $E1D2	; Exit Window
 E27A		CLC
 E27B	iE27B	ROR $E8		; 4.80: Home Count
 E27D		JSR $E05F
 E280		JMP $E19D
 E283	iE283	CMP #$1D
 E285		BNE $E292
 E287		INY
 E288		STY $C6		; Cursor Column on Current Line
 E28A		DEY
 E28B		CPY $D5		; Physical Screen Line Length
 E28D		BCC $E299
 E28F		JMP $E192
 E292	iE292	CMP #$11
 E294		BNE $E29C
 E296		JSR $E3A3	; -	Go to Next Line
 E299	iE299	JMP $E199
 E29C	iE29C	CMP #$09
 E29E		BNE $E2D0
 E2A0		JSR $E570	; ?
 E2A3	iE2A3	LDY $033A	; Tape I/O Buffer #2
 E2A6		INC $033A	; Tape I/O Buffer #2
 E2A9		CPY $D5		; Physical Screen Line Length
 E2AB		BCC $E2B6
 E2AD		LDA $D5		; Physical Screen Line Length
 E2AF		STA $C6		; Cursor Column on Current Line
 E2B1		DEC $033A	; Tape I/O Buffer #2
 E2B4		BNE $E299
 E2B6	iE2B6	ASL $033E	; 4: DOS 8-bit syntax checking flag
 E2B9		BNE $E2C5
 E2BB		INX
 E2BC		CPX #$0A
 E2BE		BEQ $E299
 E2C0		LDA #$01
 E2C2		STA $033E	; 4: DOS 8-bit syntax checking flag
 E2C5	iE2C5	LDA $03EE,X	; 4.80: Table of 80 bits to set TABs
 E2C8		AND $033E	; 4: DOS 8-bit syntax checking flag
 E2CB		BEQ $E2A3
 E2CD		INY
 E2CE		STY $C6		; Cursor Column on Current Line
 E2D0	iE2D0	CMP #$16
 E2D2		BNE $E2E0
 E2D4		LDA #$20
 E2D6		DEY
 E2D7	iE2D7	INY
 E2D8		STA ($C4),Y	; Pointer: Current Screen Line Address
 E2DA		CPY $D5		; Physical Screen Line Length
 E2DC		BCC $E2D7
 E2DE		BCS $E299
 E2E0	iE2E0	CMP #$15
 E2E2		BEQ $E2E7
 E2E4		JMP $E591	; (?)
 E2E7	iE2E7	LDA $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E2E9		PHA
 E2EA		LDA $D8		; Current Cursor Physical Line Number
 E2EC		STA $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E2EE		JSR $E3E8	; -	Scroll Screen
 E2F1		JMP $E5CA


; -	-shifted characters-

 E2F4	iE2F4	AND #$7F
 E2F6		CMP #$7F
 E2F8		BNE $E2FC
 E2FA		LDA #$5E
 E2FC	iE2FC	CMP #$20
 E2FE		BCC $E303
 E300		JMP $E177	; Ascii to Screen Code
 E303	iE303	CMP #$0D
 E305		BNE $E30A
 E307		JMP $E3B6	; -	Output <CR>
 E30A	iE30A	LDX $CD		; Flag: Editor in Quote Mode, $00 = NO
 E30C		BNE $E342
 E30E		CMP #$14
 E310		BNE $E33E
 E312		LDY $D5		; Physical Screen Line Length
 E314		LDA ($C4),Y	; Pointer: Current Screen Line Address
 E316		CMP #$20
 E318		BNE $E38C
 E31A		CPY $C6		; Cursor Column on Current Line
 E31C		BCC $E38C
 E31E		BEQ $E38C
 E320		LDY $D5		; Physical Screen Line Length
 E322	iE322	DEY
 E323		LDA ($C4),Y	; Pointer: Current Screen Line Address
 E325		INY
 E326		STA ($C4),Y	; Pointer: Current Screen Line Address
 E328		DEY
 E329		CPY $C6		; Cursor Column on Current Line
 E32B		BNE $E322
 E32D		LDA #$20
 E32F		STA ($C4),Y	; Pointer: Current Screen Line Address
 E331		LDA $D5		; Physical Screen Line Length
 E333		SEC
 E334		SBC $C6		; Cursor Column on Current Line
 E336		SBC $DC		; Flag: Insert Mode, >0 = # INSTs
 E338		BMI $E38C
 E33A		INC $DC		; Flag: Insert Mode, >0 = # INSTs
 E33C		BNE $E38C
 E33E	iE33E	LDX $DC		; Flag: Insert Mode, >0 = # INSTs
 E340		BEQ $E347
 E342	iE342	ORA #$40
 E344		JMP $E17D
 E347	iE347	CMP #$11
 E349		BNE $E358
 E34B		LDX $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E34D		CPX $D8		; Current Cursor Physical Line Number
 E34F		BCS $E38C
 E351		DEC $D8		; Current Cursor Physical Line Number
 E353		JSR $E067	; -	Set Screen Pointers
 E356		BNE $E38C
 E358	iE358	CMP #$12
 E35A		BNE $E360
 E35C		LDA #$00
 E35E		STA $9F		; Flag: Print Reverse Chars. -1=Yes, 0=No Used
 E360	iE360	CMP #$1D
 E362		BNE $E373
 E364		LDY $E2		; 4.80: first column of window
 E366		CPY $C6		; Cursor Column on Current Line
 E368		BCC $E36F
 E36A		JSR $E1AA
 E36D		BNE $E38C
 E36F	iE36F	DEC $C6		; Cursor Column on Current Line
 E371		BPL $E38C
 E373	iE373	CMP #$13
 E375		BNE $E37C
 E377		JSR $E051	; -	Clear Screen
 E37A		BNE $E38C
 E37C	iE37C	CMP #$09
 E37E		BNE $E38F
 E380		JSR $E570	; ?
 E383		LDA $03EE,X	; 4.80: Table of 80 bits to set TABs
 E386		EOR $033E	; 4: DOS 8-bit syntax checking flag
 E389		STA $03EE,X	; 4.80: Table of 80 bits to set TABs
 E38C	iE38C	JMP $E199
 E38F	iE38F	CMP #$16
 E391		BEQ $E396
 E393		JMP $E5BC
 E396	iE396	LDA #$20
 E398		LDY $E2		; 4.80: first column of window
 E39A	iE39A	CPY $C6		; Cursor Column on Current Line
 E39C		BCS $E38C
 E39E		STA ($C4),Y	; Pointer: Current Screen Line Address
 E3A0		INY
 E3A1		BNE $E39A


; -	Go to Next Line

 E3A3	iE3A3	LSR $A3		; Cursor Y-X Pos. at Start of INPUT
 E3A5		LDX $D8		; Current Cursor Physical Line Number
 E3A7		CPX $E1		; 4.80: last line of window
 E3A9		BCC $E3B1
 E3AB		JSR $E3E8	; -	Scroll Screen
 E3AE		JMP $E067	; -	Set Screen Pointers
 E3B1	iE3B1	INC $D8		; Current Cursor Physical Line Number
 E3B3		JMP $E067	; -	Set Screen Pointers


; -	Output <CR>

 E3B6	iE3B6	LDY $E2		; 4.80: first column of window
 E3B8		STY $C6		; Cursor Column on Current Line
 E3BA		JSR $E3A3	; -	Go to Next Line
 E3BD	iE3BD	LDA #$00
 E3BF		STA $DC		; Flag: Insert Mode, >0 = # INSTs
 E3C1		STA $9F		; Flag: Print Reverse Chars. -1=Yes, 0=No Used
 E3C3		STA $CD		; Flag: Editor in Quote Mode, $00 = NO
 E3C5		JMP $E199


; ?

 E3C8	iE3C8	LDX $E1		; 4.80: last line of window
 E3CA		INX
 E3CB	iE3CB	DEX
 E3CC		JSR $E06C
 E3CF		CPX $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E3D1		BEQ $E408
 E3D3		LDA $E754,X
 E3D6		STA $C7		; Pointer: Tape Buffer/ Screen Scrolling
 E3D8		LDA $E76D,X
 E3DB		STA $C8
 E3DD	iE3DD	INY
 E3DE		LDA ($C7),Y	; Pointer: Tape Buffer/ Screen Scrolling
 E3E0		STA ($C4),Y	; Pointer: Current Screen Line Address
 E3E2		CPY $D5		; Physical Screen Line Length
 E3E4		BCC $E3DD
 E3E6		BCS $E3CB


; -	Scroll Screen

 E3E8	iE3E8	LDX $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E3EA		DEX
 E3EB	iE3EB	INX
 E3EC		JSR $E06C
 E3EF		CPX $E1		; 4.80: last line of window
 E3F1		BCS $E408
 E3F3		LDA $E756,X
 E3F6		STA $C7		; Pointer: Tape Buffer/ Screen Scrolling
 E3F8		LDA $E76F,X
 E3FB		STA $C8
 E3FD	iE3FD	INY
 E3FE		LDA ($C7),Y	; Pointer: Tape Buffer/ Screen Scrolling
 E400		STA ($C4),Y	; Pointer: Current Screen Line Address
 E402		CPY $D5		; Physical Screen Line Length
 E404		BCC $E3FD
 E406		BCS $E3EB
 E408	iE408	JSR $E1C1	; -	Clear Screen Line
 E40B		LDA $E812
 E40E		CMP #$FE
 E410		BNE $E420
 E412		LDY #$00
 E414	iE414	NOP
 E415		DEX
 E416		BNE $E414
 E418		DEY
 E419		BNE $E414
 E41B	iE41B	LDY #$00
 E41D		STY $9E		; No. of Chars. in Keyboard Buffer (Queue)
 E41F	iE41F	RTS
 E420	iE420	CMP #$DF
 E422		BNE $E41F
 E424	iE424	LDA $E812
 E427		CMP #$DF
 E429		BEQ $E424
 E42B		CMP #$FF
 E42D		BEQ $E424
 E42F		BNE $E41B
 E431	iE431	JSR $FFEA	; jmp $f768	udtim	Update System Jiffy Clock
 E434		INC $F8		; 4.80: Counter to speed TI by 6/5
 E436		LDA $F8		; 4.80: Counter to speed TI by 6/5
 E438		CMP #$06
 E43A		BNE $E458
 E43C		LDA #$00
 E43E		STA $F8		; 4.80: Counter to speed TI by 6/5
 E440		BEQ $E431


; -	Main IRQ Entry Point

 E442	iE442	PHA
 E443		TXA
 E444		PHA
 E445		TYA
 E446		PHA
 E447		TSX
 E448		LDA $0104,X
 E44B		AND #$10
 E44D		BEQ $E452
 E44F		JMP ($0092)	; Vector: BRK Instr. Interrupt [3: FD17, 4: D478]
 E452	iE452	JMP ($0090)	; Vector: Hardware Interrupt [3: E62E, 4: E455]


; ?

 E455	iE455	JMP $E431
 E458	iE458	LDA $A7		; Cursor Blink enable: 0 = Flash Cursor
 E45A		BNE $E47A
 E45C		DEC $A8		; Timer: Countdown to Toggle Cursor
 E45E		BNE $E47A
 E460		LDA #$14
 E462		BIT $E4
 E464		BPL $E468
 E466		LDA #$02
 E468	iE468	STA $A8		; Timer: Countdown to Toggle Cursor
 E46A		LDY $C6		; Cursor Column on Current Line
 E46C		LSR $AA		; Flag: Last Cursor Blink On/Off
 E46E		LDA ($C4),Y	; Pointer: Current Screen Line Address
 E470		BCS $E476
 E472		INC $AA		; Flag: Last Cursor Blink On/Off
 E474		STA $A9		; Character Under Cursor
 E476	iE476	EOR #$80
 E478		STA ($C4),Y	; Pointer: Current Screen Line Address
 E47A	iE47A	LDY #$00
 E47C		LDA $E810	; PIA 1						CHIP
 E47F		AND #$F0
 E481		STA $E810	; PIA 1						CHIP
 E484		LDA $E810	; PIA 1						CHIP
 E487		ASL
 E488		ASL
 E489		ASL
 E48A		BPL $E495
 E48C		STY $F9		; Tape Motor Interlock #1
 E48E		LDA $E813
 E491		ORA #$08
 E493		BNE $E49E
 E495	iE495	LDA $F9		; Tape Motor Interlock #1
 E497		BNE $E4A1
 E499		LDA $E813
 E49C		AND #$F7
 E49E	iE49E	STA $E813
 E4A1	iE4A1	BCC $E4AC
 E4A3		STY $FA		; Tape Motor Interlock #2
 E4A5		LDA $E840	; VIA						CHIP
 E4A8		ORA #$10
 E4AA		BNE $E4B5
 E4AC	iE4AC	LDA $FA		; Tape Motor Interlock #2
 E4AE		BNE $E4B8
 E4B0		LDA $E840	; VIA						CHIP
 E4B3		AND #$EF
 E4B5	iE4B5	STA $E840	; VIA						CHIP
 E4B8	iE4B8	JSR $E4BE	; scnkey	Scan Keyboard
 E4BB		JMP $E600	; -	Return From Interrupt


; scnkey	Scan Keyboard

 E4BE	iE4BE	LDY #$FF
 E4C0		STY $A6		; Key Image
 E4C2		INY
 E4C3		STY $98		; Flag: Print Shifted Chars.
 E4C5		LDA $E4		; 4.80: Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
 E4C7		AND #$7F
 E4C9		STA $E4		; 4.80: Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
 E4CB		LDX #$50
 E4CD	iE4CD	LDY #$08
 E4CF		LDA $E812
 E4D2		CMP $E812
 E4D5		BNE $E4CD
 E4D7	iE4D7	LSR
 E4D8		BCS $E4F9
 E4DA		PHA
 E4DB		LDA $E6D0,X
 E4DE		BNE $E4E6
 E4E0		LDA #$01
 E4E2		STA $98		; Flag: Print Shifted Chars.
 E4E4		BNE $E4F8
 E4E6	iE4E6	CMP #$10
 E4E8		BNE $E4F2
 E4EA		LDA $E4		; 4.80: Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
 E4EC		ORA #$80
 E4EE		STA $E4		; 4.80: Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
 E4F0		BMI $E4F8
 E4F2	iE4F2	CMP #$FF
 E4F4		BEQ $E4F8
 E4F6		STA $A6		; Key Image
 E4F8	iE4F8	PLA
 E4F9	iE4F9	DEX
 E4FA		BEQ $E504	; -	Process Key Image
 E4FC		DEY
 E4FD		BNE $E4D7
 E4FF		INC $E810	; PIA 1						CHIP
 E502		BNE $E4CD


; -	Process Key Image

 E504	iE504	LDA $A6		; Key Image
 E506		CMP $97		; Current Key Pressed: 255 = No Key
 E508		BEQ $E510
 E50A		LDX #$10
 E50C		STX $E6		; 4.80: Repeat Delay Counter
 E50E		BNE $E53F
 E510	iE510	BIT $E4
 E512		BMI $E532
 E514		BVS $E56F
 E516		CMP #$FF
 E518		BEQ $E56F
 E51A		CMP #$14
 E51C		BEQ $E52A
 E51E		CMP #$20
 E520		BEQ $E52A
 E522		CMP #$1D
 E524		BEQ $E52A
 E526		CMP #$11
 E528		BNE $E56F
 E52A	iE52A	LDX $E6		; 4.80: Repeat Delay Counter
 E52C		BEQ $E532
 E52E		DEC $E6		; 4.80: Repeat Delay Counter
 E530		BNE $E56F
 E532	iE532	DEC $E5		; 4.80: Repeat Speed Counter
 E534		BNE $E56F
 E536		LDX #$04
 E538		STX $E5		; 4.80: Repeat Speed Counter
 E53A		LDX $9E		; No. of Chars. in Keyboard Buffer (Queue)
 E53C		DEX
 E53D		BPL $E56F
 E53F	iE53F	STA $97		; Current Key Pressed: 255 = No Key
 E541		CMP #$FF
 E543		BEQ $E56F
 E545		TAX
 E546		PHP
 E547		AND #$7F
 E549		PLP
 E54A		BMI $E563
 E54C		LSR $98		; Flag: Print Shifted Chars.
 E54E		BCC $E563
 E550		CMP #$2C
 E552		BCC $E561
 E554		CMP #$3C
 E556		BCS $E561
 E558		SBC #$0F
 E55A		CMP #$20
 E55C		BCS $E563
 E55E		ADC #$20
 E560		BIT $8009
; *** E560: ADDRESS DIFFER. This may indicate misassembly ***
 E563	iE563	LDX $9E		; No. of Chars. in Keyboard Buffer (Queue)
 E565		CPX $E3		; 4.80: Size of Keyboard Buffer
 E567		BCS $E56F
 E569		STA $026F,X
 E56C		INX
 E56D		STX $9E		; No. of Chars. in Keyboard Buffer (Queue)
 E56F	iE56F	RTS


; ?

 E570	iE570	LDA $C6		; Cursor Column on Current Line
 E572		AND #$F8
 E574		STA $033A	; Tape I/O Buffer #2
 E577		LSR
 E578		LSR
 E579		LSR
 E57A		TAX
 E57B		LDA #$01
 E57D		STA $033E	; 4: DOS 8-bit syntax checking flag
 E580		LDY $C6		; Cursor Column on Current Line
 E582	iE582	CPY $033A	; Tape I/O Buffer #2
 E585		BEQ $E590
 E587		ASL $033E	; 4: DOS 8-bit syntax checking flag
 E58A		INC $033A	; Tape I/O Buffer #2
 E58D		JMP $E582
 E590	iE590	RTS


; (?)

 E591	iE591	CMP #$19
 E593		BNE $E59B
 E595		JSR $E3E8	; -	Scroll Screen
 E598		JMP $E5D9
 E59B	iE59B	CMP #$0F
 E59D		BNE $E5AA
 E59F		LDA $D8		; Current Cursor Physical Line Number
 E5A1		STA $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E5A3		LDA $C6		; Cursor Column on Current Line
 E5A5		STA $E2		; 4.80: first column of window
 E5A7	iE5A7	JMP $E199
 E5AA	iE5AA	CMP #$0E
 E5AC		BNE $E5B3
 E5AE		JSR $E07A	; Initialize CRTC --
 E5B1		BMI $E5A7
 E5B3	iE5B3	CMP #$07
 E5B5		BNE $E5A7
 E5B7		JSR $E6A7	; ?
 E5BA		BEQ $E5A7
 E5BC	iE5BC	CMP #$15
 E5BE		BNE $E5D2
 E5C0		LDA $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E5C2		PHA
 E5C3		LDA $D8		; Current Cursor Physical Line Number
 E5C5		STA $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E5C7		JSR $E3C8	; ?
 E5CA	iE5CA	PLA
 E5CB		STA $E0		; 3+4.40: Screen Line Link Table / Editor Temps
 E5CD		JSR $E063
 E5D0		BNE $E5EA
 E5D2	iE5D2	CMP #$19
 E5D4		BNE $E5DE
 E5D6		JSR $E3C8	; ?
 E5D9	iE5D9	JSR $E067	; -	Set Screen Pointers
 E5DC		BNE $E5EA
 E5DE	iE5DE	CMP #$0F
 E5E0		BNE $E5ED
 E5E2		LDA $D8		; Current Cursor Physical Line Number
 E5E4		STA $E1		; 4.80: last line of window
 E5E6		LDA $C6		; Cursor Column on Current Line
 E5E8		STA $D5		; Physical Screen Line Length
 E5EA	iE5EA	JMP $E199
 E5ED	iE5ED	CMP #$0E
 E5EF		BNE $E5B3
 E5F1		JSR $E082	; Initialize CRTC --
 E5F4		BMI $E5EA
 E5F6		TAX
 E5F7		TAX
 E5F8		TAX
 E5F9		TAX
 E5FA		TAX
 E5FB		TAX
 E5FC		TAX
 E5FD		TAX
 E5FE		TAX
 E5FF		TAX


; -	Return From Interrupt

 E600	iE600	PLA
 E601		TAY
 E602		PLA
 E603		TAX
 E604		PLA
 E605		RTI


; ?

 E606	iE606	LDY $C6		; Cursor Column on Current Line
 E608		STA ($C4),Y	; Pointer: Current Screen Line Address
 E60A		LDA #$02
 E60C		STA $A8		; Timer: Countdown to Toggle Cursor
 E60E		RTS


; cint1	Initialize I/O

 E60F	iE60F	LDA #$7F
 E611		STA $E84E
 E614		LDX #$6D
 E616		LDA #$00
 E618		STA $E8		; 4.80: Home Count
 E61A		STA $E4		; 4.80: Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
 E61C	iE61C	STA $8D,X	; Real-Time Jiffy Clock (approx) 1/60 Sec
 E61E		DEX
 E61F		BPL $E61C
 E621		LDA #$55
 E623		STA $90		; Vector: Hardware Interrupt [3: E62E, 4: E455]
 E625		LDA #$E4
 E627		STA $91
 E629		LDA #$09
 E62B		STA $E3		; 4.80: Size of Keyboard Buffer
 E62D		LDA #$03
 E62F		STA $B0		; Default Output (CMD) Device (3)
 E631		LDA #$0F
 E633		STA $E810	; PIA 1						CHIP
 E636		ASL
 E637		STA $E840	; VIA						CHIP
 E63A		STA $E842
 E63D		STX $E822
 E640		STX $E845
 E643		LDA #$3D
 E645		STA $E813
 E648		BIT $E812
 E64B		LDA #$3C
 E64D		STA $E821
 E650		STA $E823
 E653		STA $E811
 E656		STX $E822
 E659		LDA #$0E
 E65B		STA $A8		; Timer: Countdown to Toggle Cursor
 E65D		STA $A7		; Cursor Blink enable: 0 = Flash Cursor
 E65F		STA $E6		; 4.80: Repeat Delay Counter
 E661		STA $E5		; 4.80: Repeat Speed Counter
 E663		STA $E84E
 E666		JSR $E1D2	; Exit Window
 E669		LDX #$0C
 E66B		LDA #$00
 E66D	iE66D	STA $03EE,X	; 4.80: Table of 80 bits to set TABs
 E670		DEX
 E671		BPL $E66D
 E673		LDA #$1D
 E675		LDX #$E1
 E677		STA $E9		; 4.80: input from screen vector (from E006)
 E679		STX $EA
 E67B		LDA #$0C
 E67D		LDX #$E2
 E67F		STA $EB		; 4.80: print to screen vector (from E009)
 E681		STX $EC
 E683		LDA #$10
 E685		STA $E7		; 4.80: Chime Time
 E687		JSR $E6A4
 E68A		BEQ $E6A4
 E68C	iE68C	JSR $E202	; -	Output to Screen
 E68F		TAX
 E690		LDA $D5		; Physical Screen Line Length
 E692		SEC
 E693		SBC $C6		; Cursor Column on Current Line
 E695		CMP #$05
 E697		BNE $E6D0
 E699		TXA
 E69A		CMP #$1D
 E69C		BEQ $E6A4
 E69E		AND #$7F
 E6A0		CMP #$20
 E6A2		BCC $E6D0
 E6A4	iE6A4	JSR $E6A7	; ?


; ?

 E6A7	iE6A7	LDY $E7		; 4.80: Chime Time
 E6A9		BEQ $E6D0
 E6AB		LDA #$10
 E6AD		STA $E84B
 E6B0		LDA #$0F
 E6B2		STA $E84A
 E6B5		LDX #$07
 E6B7	iE6B7	LDA $E74D,X	; Timer 2 LO Values			DATA
 E6BA		STA $E848
 E6BD		LDA $E7		; 4.80: Chime Time
 E6BF	iE6BF	DEY
 E6C0		BNE $E6BF
 E6C2		SEC
 E6C3		SBC #$01
 E6C5		BNE $E6BF
 E6C7		DEX
 E6C8		BNE $E6B7
 E6CA		STX $E84A
 E6CD		STX $E84B
 E6D0	sE6D0	RTS


; -	Keyboard decoding table			DATA

; 00 = Shift
; 10 = Repeat
; 80   flags unshiftable key
; FF = No key
;

 E6D1		.byte 16 04 3A 03 39 36 33 DF  ;..:.963.
 E6D9		.byte B1 2F 15 13 4D 20 58 12  ;./..m x.
 E6E1		.byte B2 10 0F B0 2C 4E 56 5A  ;....,nvz
 E6E9		.byte B3 00 19 AE 2E 42 43 00  ;.....bc.
 E6F1		.byte B4 5D 4F 11 55 54 45 51  ;.]o.uteq
 E6F9		.byte 14 50 49 C0 59 52 57 09  ;.pi.yrw.
 E701		.byte B6 5B 4C 0D 4A 47 44 41  ;.[l.jgda
 E709		.byte B5 5C 4B 3B 48 46 53 9B  ;.\k;hfs.
 E711		.byte B9 06 DE B7 B0 37 34 31  ;.....741
 E719		.byte 05 0E 1D B8 2D 38 35     ;....-85
 E720	sE720	.byte 32                       ;2


; Shitf-Run Equivalent			DATA

 E721		.byte 44 CC 22 2A 0D 52 55 4E  ;dL"*.run
 E729		.byte 0D                       ;.


; -	Video Chip Setup Table -- e07a		DATA

 E72A		.byte 31 28 29 0F 27 00 19 20  ;1().'.. 
 E732		.byte 00 09 00 00 10 00 00 00  ;........
 E73A		.byte 00 00                    ;..


; -	Video Chip Setup Table -- e08a		DATA

 E73C		.byte 31 28 29 0F 31 00 19 25  ;1().1..%
 E744		.byte 00 07 00 00 10 00 00 00  ;........
 E74C		.byte 00                       ;.


; Timer 2 LO Values			DATA

 E74D	sE74D	.byte 00 0E 1E 3E 7E 3E 1E     ;...>~>.
 E754	sE754	.byte 0E                       ;.


; -	Screen Line Addresses LO		DATA

 E755	sE755	.byte 00                       ;.
 E756	sE756	.byte 50 A0 F0 40 90 E0 30 80  ;p..@..0.
 E75E		.byte D0 20 70 C0 10 60 B0 00  ;P P..`..
 E766		.byte 50 A0 F0 40 90 E0 30     ;p..@..0
 E76D	sE76D	.byte 80                       ;.


; -	Screen Line Addresses HI		DATA

 E76E	sE76E	.byte 80                       ;.
 E76F	sE76F	.byte 80 80 80 81 81 81 82 82  ;........
 E777		.byte 82 83 83 83 84 84 84 85  ;........
 E77F		.byte 85 85 85 86 86 86 87 87  ;........
 E787		.byte BF                       ;.




; PIA 1						CHIP

 E810	sE810	.byte F9                       ;.
 E811	sE811	.byte 3C                       ;<
 E812	sE812	.byte FF                       ;.
 E813	sE813	.byte 3D F9 3C FF 3D F9 3C FF  ;=.<.=.<.
 E81B		.byte 3D F9 3C FF 3D           ;=.<.=


; PIA 2						CHIP

 E820	sE820	.byte FF                       ;.
 E821	sE821	.byte BC                       ;.
 E822	sE822	.byte FF                       ;.
 E823	sE823	.byte 3C FF BC FF 3C FF BC FF  ;<...<...
 E82B		.byte 3C FF BC FF 3C F9 3C FF  ;<...<.<.
 E833		.byte 3C F9 3C FF 3C F9 3C FF  ;<.<.<.<.
 E83B		.byte 3C F9 3C FF 3C           ;<.<.<


; VIA						CHIP

 E840	sE840	.byte FE FF                    ;..
 E842	sE842	.byte 1E 00                    ;..
 E844	sE844	.byte 5B                       ;[
 E845	sE845	.byte F9 77 FF                 ;.W.
 E848	sE848	.byte 7D                       ;}
 E849	sE849	.byte 26                       ;&
 E84A	sE84A	.byte 00                       ;.
 E84B	sE84B	.byte 00                       ;.
 E84C	sE84C	.byte 0E 00                    ;..
 E84E	sE84E	.byte 80 FF FE FF 1E 00 5B F9  ;......[.
 E856		.byte 77 FF 3E 5B 00 00 0E 00  ;W.>[....
 E85E		.byte 80 FF FE FF 1E 00 5B F9  ;......[.
 E866		.byte 77 FF 01 E9 00 00 0E 00  ;W.......
 E86E		.byte 80 FF FE BC 1E 00 5B B8  ;......[.
 E876		.byte 77 3D C9 0C 00 00 0E 00  ;W=I.....
 E87E		.byte 80 3D                    ;.=




; -	Table of Kernal I/O Messages		DATA

; Addr	ErrNr	Message
;
; F000	 00	'too many files'
; F00E	 0e	'file open'
; F018	 18	'file not open '
; F024	 24	'file not found'
; F032	 32	'<cr>searching.'
; F03D	 3d	'for.'
; F041	 41	'<cr>press play.'
; F04D	 4d	'& record.'
; F056	 56	'on tape .'
; F05F	 5f	'<cr>load'
; F064	 64	'<cr>writing.'
; F06D	 6d	'<cr>verify'
; F074	 74	'device not present'
; F086	 86	'not input file'
; F094	 94	'not output file'
; F0A3	 a3	'<cr>found.'
; F0AA	 aa	'<cr>ok<cr>'
; F0AE	 ae	'<cr>ready.<cr>'
; F0B6	 b6	'<cr>are you sure ?'
; F0C5	 c5	'<cr>? bad disk <cr>'
;

 F000	sF000	.byte 54 4F 4F 20 4D 41 4E 59  ;too many
 F008		.byte 20 46 49 4C 45 D3 46 49  ; fileSfi
 F010		.byte 4C 45 20 4F 50 45 CE 46  ;le opeNf
 F018		.byte 49 4C 45 20 4E 4F 54 20  ;ile not 
 F020		.byte 4F 50 45 CE 46 49 4C 45  ;opeNfile
 F028		.byte 20 4E 4F 54 20 46 4F 55  ; not fou
 F030		.byte 4E C4 0D 53 45 41 52 43  ;nD.searc
 F038		.byte 48 49 4E 47 A0 46 4F 52  ;hing.for
 F040		.byte A0 0D 50 52 45 53 53 20  ;..press 
 F048		.byte 50 4C 41 59 A0 26 20 52  ;play.& r
 F050		.byte 45 43 4F 52 44 A0 4F 4E  ;ecord.on
 F058		.byte 20 54 41 50 45 20 A3 0D  ; tape ..
 F060		.byte 4C 4F 41 C4 0D 57 52 49  ;loaD.wri
 F068		.byte 54 49 4E 47 A0 0D 56 45  ;ting..ve
 F070		.byte 52 49 46 D9 44 45 56 49  ;rifYdevi
 F078		.byte 43 45 20 4E 4F 54 20 50  ;ce not p
 F080		.byte 52 45 53 45 4E D4 4E 4F  ;resenTno
 F088		.byte 54 20 49 4E 50 55 54 20  ;t input 
 F090		.byte 46 49 4C C5 4E 4F 54 20  ;filEnot 
 F098		.byte 4F 55 54 50 55 54 20 46  ;output f
 F0A0		.byte 49 4C C5 0D 46 4F 55 4E  ;ilE.foun
 F0A8		.byte 44 A0 0D 4F 4B 8D 0D 52  ;d..ok..r
 F0B0		.byte 45 41 44 59 2E 8D 0D 41  ;eady...a
 F0B8		.byte 52 45 20 59 4F 55 20 53  ;re you s
 F0C0		.byte 55 52 45 20 BF 0D 3F 20  ;ure ..? 
 F0C8		.byte 42 41 44 20 44 49 53 4B  ;bad disk
 F0D0		.byte 20 8D                    ; .


; talk	Send TALK Command on IEEE Bus

 F0D2	iF0D2	LDA #$40
 F0D4		BIT $20A9

; *** Resyncing ***

; listn	Send LISTEN Command on IEEE Bus

 F0D5	iF0D5	LDA #$20
 F0D7	iF0D7	PHA
 F0D8		LDA $E840	; VIA						CHIP
 F0DB		ORA #$02
 F0DD		STA $E840	; VIA						CHIP
 F0E0		LDA #$3C
 F0E2		STA $E821
 F0E5		BIT $A0
 F0E7		BEQ $F0FA
 F0E9		LDA #$34
 F0EB		STA $E811
 F0EE		JSR $F109	; -	Send Data On IEEE Bus
 F0F1		LDA #$00
 F0F3		STA $A0		; Flag: IEEE Bus-Output Char. Buffered
 F0F5		LDA #$3C
 F0F7		STA $E811
 F0FA	iF0FA	PLA
 F0FB		ORA $D4		; Current Device Number
 F0FD		STA $A5		; Buffered Character for IEEE Bus
 F0FF	iF0FF	LDA $E840	; VIA						CHIP
 F102		BPL $F0FF
 F104		AND #$FB
 F106		STA $E840	; VIA						CHIP


; -	Send Data On IEEE Bus

;	-	Flag Errors

 F109	iF109	LDA #$3C
 F10B		STA $E823
 F10E		LDA $E840	; VIA						CHIP
 F111		AND #$41
 F113		CMP #$41
 F115		BEQ $F16C	; -	Status #80 - device not present
 F117		LDA $A5		; Buffered Character for IEEE Bus
 F119		EOR #$FF
 F11B		STA $E822
 F11E	iF11E	BIT $E840
 F121		BVC $F11E
 F123		LDA #$34
 F125		STA $E823
 F128	iF128	LDA #$FF
 F12A		STA $E845
 F12D	iF12D	LDA $E840	; VIA						CHIP
 F130		BIT $E84D
 F133		BVS $F151
 F135		LSR
 F136		BCC $F12D
 F138	iF138	LDA #$3C
 F13A		STA $E823
 F13D		LDA #$FF
 F13F		STA $E822
 F142		RTS
 F143	iF143	STA $A5		; Buffered Character for IEEE Bus
 F145		JSR $F109	; -	Send Data On IEEE Bus
 F148	iF148	LDA $E840	; VIA						CHIP
 F14B		ORA #$04
 F14D		STA $E840	; VIA						CHIP
 F150		RTS
 F151	iF151	LDA $03FC	; 4: Flag: Kernal Variable for IEEE Timeout
 F154		BPL $F165	; -	Status #01 - ??
 F156		JSR $F343	; stop	Check STOP Key
 F159		BNE $F128
 F15B	iF15B	LDA $03FC	; 4: Flag: Kernal Variable for IEEE Timeout
 F15E		BPL $F170	; -	Status #02 - read timeout
 F160		JSR $F343	; stop	Check STOP Key
 F163		BNE $F1CD


; -	Status #01 - ??

 F165	iF165	LDA #$01
 F167	iF167	JSR $FBC4	; -	Set Status Bit
 F16A		BNE $F138


; -	Status #80 - device not present

 F16C	iF16C	LDA #$80
 F16E		BMI $F167


; -	Status #02 - read timeout

 F170	iF170	LDA #$02
 F172		JSR $FBC4	; -	Set Status Bit
 F175	iF175	LDA $E840	; VIA						CHIP
 F178		AND #$FD
 F17A		STA $E840	; VIA						CHIP
 F17D		LDA #$34
 F17F		STA $E821
 F182		LDA #$0D
 F184		RTS


; -	Print Message

 F185	iF185	LDA $F000,Y	; -	Table of Kernal I/O Messages		DATA
 F188		PHP
 F189		AND #$7F
 F18B		JSR $E202	; -	Output to Screen
 F18E		INY
 F18F		PLP
 F190		BPL $F185	; -	Print Message
 F192		RTS
 F193	iF193	STA $A5		; Buffered Character for IEEE Bus
 F195		JSR $F109	; -	Send Data On IEEE Bus
 F198	iF198	JSR $F175
 F19B		JMP $F148
 F19E	iF19E	BIT $A0
 F1A0		BMI $F1A6
 F1A2		DEC $A0		; Flag: IEEE Bus-Output Char. Buffered
 F1A4		BNE $F1AB
 F1A6	iF1A6	PHA
 F1A7		JSR $F109	; -	Send Data On IEEE Bus
 F1AA		PLA
 F1AB	iF1AB	STA $A5		; Buffered Character for IEEE Bus
 F1AD		RTS


; untlk	Send UNTALK

 F1AE	iF1AE	LDA $E840	; VIA						CHIP
 F1B1		AND #$FB
 F1B3		STA $E840	; VIA						CHIP
 F1B6		LDA #$5F
 F1B8		BIT $3FA9

; *** Resyncing ***

; untlk	Send UNLISTEN

 F1B9	iF1B9	LDA #$3F
 F1BB		JSR $F0D7
 F1BE		BNE $F148
 F1C0	iF1C0	LDA #$34
 F1C2		STA $E821
 F1C5		LDA $E840	; VIA						CHIP
 F1C8		ORA #$02
 F1CA		STA $E840	; VIA						CHIP
 F1CD	iF1CD	LDA #$FF
 F1CF		STA $E845
 F1D2	iF1D2	BIT $E84D
 F1D5		BVS $F15B
 F1D7		BIT $E840
 F1DA		BMI $F1D2
 F1DC		LDA $E840	; VIA						CHIP
 F1DF		AND #$FD
 F1E1		STA $E840	; VIA						CHIP
 F1E4		BIT $E810
 F1E7		BVS $F1EE
 F1E9		LDA #$40
 F1EB		JSR $FBC4	; -	Set Status Bit
 F1EE	iF1EE	LDA $E820	; PIA 2						CHIP
 F1F1		EOR #$FF
 F1F3		PHA
 F1F4		LDA #$3C
 F1F6		STA $E821
 F1F9	iF1F9	BIT $E840
 F1FC		BPL $F1F9
 F1FE		LDA #$34
 F200		STA $E821
 F203		PLA
 F204		RTS


; -	Input From Screen or Keyboard

 F205	iF205	LDA #$00
 F207		STA $96		; Kernal I/O Status Word: ST
 F209		LDA $AF		; Default Input Device (0)
 F20B		BNE $F224
 F20D		LDA $9E		; No. of Chars. in Keyboard Buffer (Queue)
 F20F		BEQ $F262
 F211		SEI
 F212		JMP $E0A7	; lp2	Get Character From Keyboard Buffer


; chrin	Input a byte

 F215	iF215	LDA $AF		; Default Input Device (0)
 F217		BNE $F224
 F219		LDA $C6		; Cursor Column on Current Line
 F21B		STA $A4
 F21D		LDA $D8		; Current Cursor Physical Line Number
 F21F		STA $A3		; Cursor Y-X Pos. at Start of INPUT
 F221		JMP $E116	; Input From Screen or Keyboard
 F224	iF224	CMP #$03
 F226		BNE $F231	; -	Get From Tape / IEEE
 F228		STA $AC		; Flag: INPUT or GET from Keyboard
 F22A		LDA $D5		; Physical Screen Line Length
 F22C		STA $A1		; Pointer: End of Logical Line for INPUT
 F22E		JMP $E116	; Input From Screen or Keyboard


; -	Get From Tape / IEEE

 F231	iF231	BCS $F25C
 F233		STX $AD		; X save in tape handling (saves cassette #)
 F235		JSR $F249
 F238		PHA
 F239		JSR $F249
 F23C		BNE $F243
 F23E		LDA #$40
 F240		JSR $FBC4	; -	Set Status Bit
 F243	iF243	DEC $BA,X
 F245		LDX $AD		; X save in tape handling (saves cassette #)
 F247		PLA
 F248		RTS
 F249	iF249	JSR $F84B	; -	Bump Tape Pointer
 F24C		BNE $F259
 F24E		JSR $F89A	; -	Initiate Tape Read
 F251		LDX $D4		; Current Device Number
 F253		LDA #$00
 F255		STA $BA,X
 F257		BEQ $F249
 F259	iF259	LDA ($D6),Y	; Pointer: Start of Tape Buffer
 F25B		RTS
 F25C	iF25C	LDA $96		; Kernal I/O Status Word: ST
 F25E		BEQ $F263
 F260		LDA #$0D
 F262	iF262	RTS
 F263	iF263	JMP $F1C0


; chrout	Output One Character

 F266	iF266	PHA
 F267		LDA $B0		; Default Output (CMD) Device (3)
 F269		CMP #$03
 F26B		BNE $F271
 F26D		PLA
 F26E		JMP $E202	; -	Output to Screen
 F271	iF271	BMI $F277
 F273		PLA
 F274		JMP $F19E
 F277	iF277	PLA
 F278	iF278	STA $B4
 F27A		CMP #$0A
 F27C		BEQ $F262
 F27E		PHA
 F27F		TXA
 F280		PHA
 F281		TYA
 F282		PHA
 F283		JSR $F84B	; -	Bump Tape Pointer
 F286		BNE $F298
 F288		JSR $F8CB	; -	Initiate Tape Write
 F28B		LDX $D4		; Current Device Number
 F28D		LDA #$01
 F28F		STA $BA,X
 F291		LDY #$00
 F293		LDA #$02
 F295		STA ($D6),Y	; Pointer: Start of Tape Buffer
 F297		INY
 F298	iF298	LDA $B4
 F29A		STA ($D6),Y	; Pointer: Start of Tape Buffer
 F29C	iF29C	PLA
 F29D		TAY
 F29E		PLA
 F29F		TAX
 F2A0		PLA
 F2A1		RTS


; clall	Abort All Files

 F2A2	iF2A2	LDA #$00
 F2A4		STA $AE		; No. of Open Files / Index to File Table


; clrchn	Restore Default I/O

 F2A6	iF2A6	LDA $B0		; Default Output (CMD) Device (3)
 F2A8		CMP #$04
 F2AA		BCC $F2AF
 F2AC		JSR $F1B9	; untlk	Send UNLISTEN
 F2AF	iF2AF	LDA $AF		; Default Input Device (0)
 F2B1		CMP #$04
 F2B3		BCC $F2B8
 F2B5		JSR $F1AE	; untlk	Send UNTALK
 F2B8	iF2B8	LDA #$03
 F2BA		STA $B0		; Default Output (CMD) Device (3)
 F2BC		LDA #$00
 F2BE		STA $AF		; Default Input Device (0)
 F2C0		RTS

 F2C1	iF2C1	LDX $AE		; No. of Open Files / Index to File Table
 F2C3	iF2C3	DEX
 F2C4		BMI $F2DC
 F2C6		CMP $0251,X	; KERNAL Table: Active Logical File No's.
 F2C9		BEQ $F2DC
 F2CB		BNE $F2C3
 F2CD	iF2CD	LDA $0251,X	; KERNAL Table: Active Logical File No's.
 F2D0		STA $D2		; Current Logical File Number
 F2D2		LDA $025B,X	; KERNAL Table: Device No. for Each File
 F2D5		STA $D4		; Current Device Number
 F2D7		LDA $0265,X	; KERNAL Table: Second Address Each File
 F2DA		STA $D3		; Current Secondary Address
 F2DC	iF2DC	RTS


; closet	Perform [close]

 F2DD	iF2DD	JSR $F50D
 F2E0		LDA $D2		; Current Logical File Number
 F2E2	iF2E2	JSR $F2C1
 F2E5		BNE $F334
 F2E7	iF2E7	JSR $F2CD
 F2EA		TXA
 F2EB		PHA
 F2EC		LDA $D4		; Current Device Number
 F2EE		BEQ $F318
 F2F0		CMP #$03
 F2F2		BEQ $F318
 F2F4		BCS $F315
 F2F6		LDA $D3		; Current Secondary Address
 F2F8		AND #$0F
 F2FA		BEQ $F318
 F2FC		JSR $F695	; -	Get Buffer Address
 F2FF		LDA #$00
 F301		JSR $F278
 F304		JSR $F8CB	; -	Initiate Tape Write
 F307		LDA $D3		; Current Secondary Address
 F309		CMP #$62
 F30B		BNE $F318
 F30D		LDA #$05
 F30F		JSR $F619
 F312		JMP $F318
 F315	iF315	JSR $F72F
 F318	iF318	PLA
 F319		TAX
 F31A		DEC $AE		; No. of Open Files / Index to File Table
 F31C		CPX $AE		; No. of Open Files / Index to File Table
 F31E		BEQ $F334
 F320		LDY $AE		; No. of Open Files / Index to File Table
 F322		LDA $0251,Y	; KERNAL Table: Active Logical File No's.
 F325		STA $0251,X	; KERNAL Table: Active Logical File No's.
 F328		LDA $025B,Y	; KERNAL Table: Device No. for Each File
 F32B		STA $025B,X	; KERNAL Table: Device No. for Each File
 F32E		LDA $0265,Y	; KERNAL Table: Second Address Each File
 F331		STA $0265,X	; KERNAL Table: Second Address Each File
 F334	iF334	RTS


; -	-stop-

 F335	iF335	LDA $9B		; Flag: STOP key / RVS key
 F337		CMP #$EF
 F339		BNE $F342
 F33B		PHP
 F33C		JSR $F2A6	; clrchn	Restore Default I/O
 F33F		STA $9E		; No. of Chars. in Keyboard Buffer (Queue)
 F341		PLP
 F342	iF342	RTS


; stop	Check STOP Key

 F343	iF343	JSR $F335	; -	-stop-
 F346		JMP $B7C6	; stop	Perform [stop], [end], break


; -	Print Message if Direct

 F349	iF349	JSR $F351	; Check Direct
 F34C		BNE $F342
 F34E		JMP $F185	; -	Print Message


; Check Direct

 F351	iF351	LDA $78
 F353		CMP #$02
 F355		RTS

 F356	iF356	LDA $D4		; Current Device Number
 F358		BNE $F35D
 F35A	iF35A	JMP $BF00	; synerr	Output ?SYNTAX Error
 F35D	iF35D	CMP #$03
 F35F		BEQ $F35A
 F361		BCC $F3D4
 F363		LDA #$60
 F365		STA $D3		; Current Secondary Address
 F367		LDY $D1		; Length of Current File Name
 F369		BNE $F36E
 F36B		JMP $BF00	; synerr	Output ?SYNTAX Error
 F36E	iF36E	JSR $F449
 F371		JSR $F4A5
 F374		JSR $F0D2	; talk	Send TALK Command on IEEE Bus
 F377		LDA $D3		; Current Secondary Address
 F379		JSR $F193
 F37C		JSR $F1C0
 F37F		STA $FB		; I/O Start Address
 F381		LDA $96		; Kernal I/O Status Word: ST
 F383		LSR
 F384		LSR
 F385		BCS $F3C1
 F387		JSR $F1C0
 F38A		STA $FC
 F38C		JSR $F46D
 F38F	iF38F	LDA #$FD
 F391		AND $96		; Kernal I/O Status Word: ST
 F393		STA $96		; Kernal I/O Status Word: ST
 F395		JSR $F343	; stop	Check STOP Key
 F398		JSR $F1C0
 F39B		TAX
 F39C		LDA $96		; Kernal I/O Status Word: ST
 F39E		LSR
 F39F		LSR
 F3A0		BCS $F38F
 F3A2		TXA
 F3A3		LDY $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 F3A5		BEQ $F3B3
 F3A7		DEY
 F3A8		CMP ($FB),Y	; I/O Start Address
 F3AA		BEQ $F3B5
 F3AC		LDA #$10
 F3AE		ORA $96		; Kernal I/O Status Word: ST
 F3B0		STA $96		; Kernal I/O Status Word: ST
 F3B2		BIT $FB91
; *** F3B2: ADDRESS DIFFER. This may indicate misassembly ***
 F3B5	iF3B5	INC $FB		; I/O Start Address
 F3B7		BNE $F3BB
 F3B9		INC $FC
 F3BB	iF3BB	BIT $96
 F3BD		BVS $F3C6
 F3BF		BVC $F38F
 F3C1	iF3C1	LDY #$24
 F3C3		JMP $F5AF
 F3C6	iF3C6	LDA $FB		; I/O Start Address
 F3C8		STA $C9		; Tape End Addresses/End of Program
 F3CA		LDA $FC
 F3CC		STA $CA
 F3CE		JSR $F1AE	; untlk	Send UNTALK
 F3D1		JMP $F72F
 
 
 
; Tape LOAD (assumes parameters are set) PtP#242
 F3D4	iF3D4	JSR $F695	; -	Get Buffer Address
 F3D7		JSR $F857	; -	Print "PRESS PLAY ON TAPE"
 F3DA		JSR $F449
 F3DD	iF3DD	LDA $D1		; Length of Current File Name
 F3DF		BEQ $F3E9
 F3E1		JSR $F4D3
 F3E4		BNE $F3EE
 F3E6	iF3E6	JMP $F5AD
 F3E9	iF3E9	JSR $F5E5
 F3EC		BEQ $F3E6
 F3EE	iF3EE	CPX #$01
 F3F0		BNE $F3DD
 F3F2		LDA $96		; Kernal I/O Status Word: ST
 F3F4		AND #$10
 F3F6		BNE $F46C
 
; Load rest of program PtP#242
 F3F8		JSR $F67B
 F3FB		JSR $F46D
 F3FE		JMP $F8A3


; verfyt	Perform [load]

 F401	iF401	LDA #$00
 F403		STA $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 F405	iF405	JSR $F47D	; slpara	Get Parameters For LOAD/SAVE
 F408	iF408	JSR $F6CC	; ?
 F40B		LDA #$FF
 F40D	iF40D	CMP $9B		; Flag: STOP key / RVS key
 F40F		BNE $F40D
 F411		CMP $9B		; Flag: STOP key / RVS key
 F413		BNE $F40D
 F415		JSR $F356
 F418		LDA $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 F41A		BNE $F46C
 F41C		JSR $F92B	; ?
 F41F		LDA $96		; Kernal I/O Status Word: ST
 F421		AND #$10
 F423		BEQ $F42E
 F425		LDY #$00
 F427		STY $9E		; No. of Chars. in Keyboard Buffer (Queue)
 F429		LDY #$60
 F42B		JMP $F5AF
 F42E	iF42E	LDY #$AE
 F430		JSR $F349	; -	Print Message if Direct
 F433		JSR $F351	; Check Direct
 F436		BNE $F443
 F438		LDA $CA
 F43A		STA $2B
 F43C		LDA $C9		; Tape End Addresses/End of Program
 F43E		STA $2A		; Pointer: Start of BASIC Variables
 F440		JMP $B4AD
 F443	iF443	JSR $B622	; stxpt	Reset TXTPTR
 F446		JMP $B60B
 F449	iF449	JSR $F351	; Check Direct
 F44C		BNE $F46C
 F44E		LDY #$32
 F450		JSR $F185	; -	Print Message
 F453		LDA $D1		; Length of Current File Name
 F455		BEQ $F46C
 F457		LDY #$3D
 F459		JSR $F185	; -	Print Message
 F45C	iF45C	LDY $D1		; Length of Current File Name
 F45E		BEQ $F46C
 F460		LDY #$00
 F462	iF462	LDA ($DA),Y	; Pointer: Current File Name
 F464		JSR $F266	; chrout	Output One Character
 F467		INY
 F468		CPY $D1		; Length of Current File Name
 F46A		BNE $F462
 F46C	iF46C	RTS

 F46D	iF46D	LDY #$5F
 F46F		LDA $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 F471		BEQ $F475
 F473		LDY #$6D
 F475	iF475	JSR $F349	; -	Print Message if Direct
 F478		LDY #$39
 F47A		JMP $F349	; -	Print Message if Direct


; slpara	Get Parameters For LOAD/SAVE

 F47D	iF47D	LDX #$00
 F47F		STX $96		; Kernal I/O Status Word: ST
 F481		STX $D1		; Length of Current File Name
 F483		STX $D3		; Current Secondary Address
 F485		INX
 F486		STX $D4		; Current Device Number
 F488		JSR $F54D	; ?
 F48B		JSR $F53C
 F48E		JSR $F54D	; ?
 F491		JSR $F49F	; combyt	Get Next One Byte Parameter
 F494		STX $D4		; Current Device Number
 F496		JSR $F54D	; ?
 F499		JSR $F49F	; combyt	Get Next One Byte Parameter
 F49C		STX $D3		; Current Secondary Address
 F49E	iF49E	RTS


; combyt	Get Next One Byte Parameter

 F49F	iF49F	JSR $F555	; cmmerr	Check For Comma
 F4A2		JMP $C8D4	; -Eval Byte Parameter

 F4A5	iF4A5	LDA $D3		; Current Secondary Address
 F4A7		BMI $F49E
 F4A9		LDY $D1		; Length of Current File Name
 F4AB		BEQ $F49E
 F4AD		JSR $F0D5	; listn	Send LISTEN Command on IEEE Bus
 F4B0		LDA $D3		; Current Secondary Address
 F4B2		ORA #$F0
 F4B4	iF4B4	JSR $F143
 F4B7		LDA $96		; Kernal I/O Status Word: ST
 F4B9		BPL $F4C0
 F4BB	iF4BB	LDY #$74
 F4BD		JMP $F5AF
 F4C0	iF4C0	LDA $D1		; Length of Current File Name
 F4C2		BEQ $F4D0
 F4C4		LDY #$00
 F4C6	iF4C6	LDA ($DA),Y	; Pointer: Current File Name
 F4C8		JSR $F19E
 F4CB		INY
 F4CC		CPY $D1		; Length of Current File Name
 F4CE		BNE $F4C6
 F4D0	iF4D0	JMP $F1B9	; untlk	Send UNLISTEN

; Load named header PtP#242
 F4D3	iF4D3	JSR $F5E5
 F4D6		BEQ $F4F5
 F4D8		LDY #$05
 F4DA		STY $B5
 F4DC		LDY #$00
 F4DE		STY $B4
 F4E0	iF4E0	CPY $D1		; Length of Current File Name
 F4E2		BEQ $F4F4
 F4E4		LDA ($DA),Y	; Pointer: Current File Name
 F4E6		LDY $B5
 F4E8		CMP ($D6),Y	; Pointer: Start of Tape Buffer
 F4EA		BNE $F4D3
 F4EC		INC $B4
 F4EE		INC $B5
 F4F0		LDY $B4
 F4F2		BNE $F4E0
 F4F4	iF4F4	TYA
 F4F5	iF4F5	RTS


; verfyt	Perform [verify]

 F4F6	iF4F6	LDA #$01
 F4F8		STA $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 F4FA		JSR $F405
 F4FD		LDA $96		; Kernal I/O Status Word: ST
 F4FF		AND #$10
 F501		BEQ $F508
 F503		LDY #$6E
 F505		JMP $F5AF
 F508	iF508	LDY #$AA
 F50A		JMP $F185	; -	Print Message

 F50D	iF50D	LDX #$00
 F50F		STX $D3		; Current Secondary Address
 F511		STX $96		; Kernal I/O Status Word: ST
 F513		STX $D1		; Length of Current File Name
 F515		INX
 F516		STX $D4		; Current Device Number
 F518		JSR $F558
 F51B		JSR $C8D4	; -Eval Byte Parameter
 F51E		STX $D2		; Current Logical File Number
 F520		JSR $F54D	; ?
 F523		JSR $F49F	; combyt	Get Next One Byte Parameter
 F526		STX $D4		; Current Device Number
 F528		CPX #$03
 F52A		BCC $F52E
 F52C		DEC $D3		; Current Secondary Address
 F52E	iF52E	JSR $F54D	; ?
 F531		JSR $F49F	; combyt	Get Next One Byte Parameter
 F534		STX $D3		; Current Secondary Address
 F536		JSR $F54D	; ?
 F539		JSR $F555	; cmmerr	Check For Comma
 F53C	iF53C	JSR $BD98	; frmevl	Evaluate Expression in Text
 F53F		JSR $C7B5	; frestr	Perform String Housekeeping
 F542		STA $D1		; Length of Current File Name
 F544		LDA $1F		; Utility Pointer Area
 F546		STA $DA		; Pointer: Current File Name
 F548		LDA $20
 F54A		STA $DB
 F54C		RTS


; ?

 F54D	iF54D	JSR $0076	; Entry to Get Same Byte of Text Again
 F550		BNE $F554
 F552		PLA
 F553		PLA
 F554	iF554	RTS


; cmmerr	Check For Comma

 F555	iF555	JSR $BEF5	; -Test comma-
 F558	iF558	JSR $0076	; Entry to Get Same Byte of Text Again
 F55B		BNE $F554
 F55D	iF55D	JMP $BF00	; synerr	Output ?SYNTAX Error


; opent	Perform [open]

 F560	iF560	JSR $F50D
 F563	iF563	LDA $D2		; Current Logical File Number
 F565	iF565	BEQ $F55D
 F567		LDY #$0E
 F569		JSR $F2C1
 F56C		BEQ $F5AF
 F56E		LDX $AE		; No. of Open Files / Index to File Table
 F570		LDY #$00
 F572		STY $96		; Kernal I/O Status Word: ST
 F574		CPX #$0A
 F576		BEQ $F5AF
 F578		INC $AE		; No. of Open Files / Index to File Table
 F57A		LDA $D2		; Current Logical File Number
 F57C		STA $0251,X	; KERNAL Table: Active Logical File No's.
 F57F		LDA $D3		; Current Secondary Address
 F581		ORA #$60
 F583		STA $D3		; Current Secondary Address
 F585		STA $0265,X	; KERNAL Table: Second Address Each File
 F588		LDA $D4		; Current Device Number
 F58A		STA $025B,X	; KERNAL Table: Device No. for Each File
 F58D		BEQ $F5E4
 F58F		CMP #$03
 F591		BEQ $F5E4
 F593		BCC $F598
 F595		JMP $F4A5
 F598	iF598	LDA $D3		; Current Secondary Address
 F59A		AND #$0F
 F59C		BNE $F5C9
 F59E		JSR $F857	; -	Print "PRESS PLAY ON TAPE"
 F5A1		JSR $F449
 F5A4		LDA $D1		; Length of Current File Name
 F5A6		BEQ $F5C2
 F5A8		JSR $F4D3
 F5AB		BNE $F5D1
 F5AD	iF5AD	LDY #$24
 F5AF	iF5AF	JSR $F2A2	; clall	Abort All Files
 F5B2		LDA #$0D
 F5B4		JSR $F266	; chrout	Output One Character
 F5B7		LDA #$3F
 F5B9		JSR $F266	; chrout	Output One Character
 F5BC		JSR $F185	; -	Print Message
 F5BF		JMP $B3ED
 F5C2	iF5C2	JSR $F5E5
 F5C5		BEQ $F5AD
 F5C7		BNE $F5D1
 F5C9	iF5C9	JSR $F88C	; -	Print "PRESS PLAY & RECORD..."
 F5CC		LDA #$04
 F5CE		JSR $F619
 F5D1	iF5D1	LDX $D4		; Current Device Number
 F5D3		LDA #$BF
 F5D5		LDY $D3		; Current Secondary Address
 F5D7		CPY #$60
 F5D9		BEQ $F5E2
 F5DB		LDY #$00
 F5DD		LDA #$02
 F5DF		STA ($D6),Y	; Pointer: Start of Tape Buffer
 F5E1		TYA
 F5E2	iF5E2	STA $BA,X
 F5E4	iF5E4	RTS

; Load next header PtP#242
 F5E5	iF5E5	LDA $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 F5E7		PHA
 F5E8	iF5E8	JSR $F89A	; -	Initiate Tape Read
 F5EB		LDY #$00
 F5ED		LDA ($D6),Y	; Pointer: Start of Tape Buffer
 F5EF		CMP #$05
 F5F1		BEQ $F614
 F5F3		CMP #$01
 F5F5		BEQ $F5FB
 F5F7		CMP #$04
 F5F9		BNE $F5E8
 F5FB	iF5FB	TAX
 F5FC		JSR $F351	; Check Direct
 F5FF		BNE $F612
 F601		LDY #$A3
 F603		JSR $F185	; -	Print Message
 F606		LDY #$05
 F608	iF608	LDA ($D6),Y	; Pointer: Start of Tape Buffer
 F60A		JSR $FFD2	; chrout	Output Vector, chrout
 F60D		INY
 F60E		CPY #$15
 F610		BNE $F608
 F612	iF612	LDY #$01
 F614	iF614	PLA
 F615		STA $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 F617		TYA
 F618		RTS

; Write header (LDA #1) or EOT (LDA #5) PtP#242
 F619	iF619	STA $B4
 F61B		JSR $F695	; -	Get Buffer Address
 F61E		LDA $FC
 F620		PHA
 F621		LDA $FB		; I/O Start Address
 F623		PHA
 F624		LDA $CA
 F626		PHA
 F627		LDA $C9		; Tape End Addresses/End of Program
 F629		PHA
 F62A		LDY #$BF
 F62C		LDA #$20
 F62E	iF62E	STA ($D6),Y	; Pointer: Start of Tape Buffer
 F630		DEY
 F631		BNE $F62E
 F633		LDA $B4
 F635		STA ($D6),Y	; Pointer: Start of Tape Buffer
 F637		INY
 F638		LDA $FB		; I/O Start Address
 F63A		STA ($D6),Y	; Pointer: Start of Tape Buffer
 F63C		INY
 F63D		LDA $FC
 F63F		STA ($D6),Y	; Pointer: Start of Tape Buffer
 F641		INY
 F642		LDA $C9		; Tape End Addresses/End of Program
 F644		STA ($D6),Y	; Pointer: Start of Tape Buffer
 F646		INY
 F647		LDA $CA
 F649		STA ($D6),Y	; Pointer: Start of Tape Buffer
 F64B		INY
 F64C		STY $B5
 F64E		LDY #$00
 F650		STY $B4
 F652	iF652	LDY $B4
 F654		CPY $D1		; Length of Current File Name
 F656		BEQ $F664
 F658		LDA ($DA),Y	; Pointer: Current File Name
 F65A		LDY $B5
 F65C		STA ($D6),Y	; Pointer: Start of Tape Buffer
 F65E		INC $B4
 F660		INC $B5
 F662		BNE $F652
 F664	iF664	JSR $F6AB	; -	Set Buffer Stat / End Pointers
 F667		LDA #$69
 F669		STA $C3		; Cassette Short Cnt (64=00AB): counter of seconds before tape write / checksum
 F66B		JSR $F8D5
 F66E		PLA
 F66F		STA $C9		; Tape End Addresses/End of Program
 F671		PLA
 F672		STA $CA
 F674		PLA
 F675		STA $FB		; I/O Start Address
 F677		PLA
 F678		STA $FC
 F67A		RTS

 F67B	iF67B	JSR $F92B	; ?
 F67E		LDX #$00
 F680		LDY #$01
 F682	iF682	LDA ($D6),Y	; Pointer: Start of Tape Buffer
 F684		STA $C7,X	; Pointer: Tape Buffer/ Screen Scrolling
 F686		INX
 F687		INY
 F688		CPX #$04
 F68A		BNE $F682
 F68C		LDA $C7		; Pointer: Tape Buffer/ Screen Scrolling
 F68E		STA $FB		; I/O Start Address
 F690		LDA $C8
 F692		STA $FC
 F694		RTS


; -	Get Buffer Address

 F695	iF695	LDA #$7A
 F697		STA $D6		; Pointer: Start of Tape Buffer
 F699		LDA #$02
 F69B		STA $D7
 F69D		LDA $D4		; Current Device Number
 F69F		LSR
 F6A0		BCS $F6AA
 F6A2		LDA #$3A
 F6A4		STA $D6		; Pointer: Start of Tape Buffer
 F6A6		LDA #$03
 F6A8		STA $D7
 F6AA	iF6AA	RTS


; -	Set Buffer Stat / End Pointers

 F6AB	iF6AB	JSR $F92B	; ?
 F6AE		JSR $F695	; -	Get Buffer Address
 F6B1		LDA $D6		; Pointer: Start of Tape Buffer
 F6B3		STA $FB		; I/O Start Address
 F6B5		CLC
 F6B6		ADC #$C0
 F6B8		STA $C9		; Tape End Addresses/End of Program
 F6BA		LDA $D7
 F6BC		STA $FC
 F6BE		ADC #$00
 F6C0		STA $CA
 F6C2		RTS


; syst	Perform [sys]

 F6C3	iF6C3	JSR $BD84	; frmnum	Confirm Result
 F6C6		JSR $C92D	; getadr	Convert FAC#1 to Integer in LINNUM
 F6C9		JMP ($0011)	; Temp: Integer Value


; ?

 F6CC	iF6CC	LDA $2A		; Pointer: Start of BASIC Variables
 F6CE		STA $C9		; Tape End Addresses/End of Program
 F6D0		LDA $2B
 F6D2		STA $CA
 F6D4		LDA $29
 F6D6		STA $FC
 F6D8		LDA $28		; Pointer: Start of BASIC Text [0401]
 F6DA		STA $FB		; I/O Start Address
 F6DC		RTS


; savet	Perform [save]

 F6DD	iF6DD	JSR $F47D	; slpara	Get Parameters For LOAD/SAVE
 F6E0	iF6E0	JSR $F6CC	; ?
 F6E3	iF6E3	LDA $D4		; Current Device Number
 F6E5		BNE $F6EC
 F6E7	iF6E7	LDY #$74
 F6E9		JMP $F5AF
 F6EC	iF6EC	CMP #$03
 F6EE		BEQ $F6E7
 F6F0		BCC $F742		; branch if it's a tape device
 F6F2		LDA #$61
 F6F4		STA $D3		; Current Secondary Address
 F6F6		LDY $D1		; Length of Current File Name
 F6F8		BNE $F6FD
 F6FA		JMP $BF00	; synerr	Output ?SYNTAX Error
 F6FD	iF6FD	JSR $F4A5
 F700		JSR $F0D5	; listn	Send LISTEN Command on IEEE Bus
 F703		LDA $D3		; Current Secondary Address
 F705		JSR $F143
 F708		LDY #$00
 F70A		JSR $FBBB	; -	Reset Tape Pointer
 F70D		LDA $C7		; Pointer: Tape Buffer/ Screen Scrolling
 F70F		JSR $F19E
 F712		LDA $C8
 F714		JSR $F19E
 F717	iF717	JSR $FD0B
 F71A		BEQ $F72C
 F71C		LDA ($C7),Y	; Pointer: Tape Buffer/ Screen Scrolling
 F71E		JSR $F19E
 F721		JSR $F343	; stop	Check STOP Key
 F724		INC $C7		; Pointer: Tape Buffer/ Screen Scrolling
 F726		BNE $F717
 F728		INC $C8
 F72A		BNE $F717
 F72C	iF72C	JSR $F1B9	; untlk	Send UNLISTEN
 F72F	iF72F	BIT $D3
 F731		BMI $F7AB
 F733		JSR $F0D5	; listn	Send LISTEN Command on IEEE Bus
 F736		LDA $D3		; Current Secondary Address
 F738		AND #$EF
 F73A		ORA #$E0
 F73C		JSR $F143
 F73F		JMP $F1B9	; untlk	Send UNLISTEN
 
; Tape SAVE (assumes parameters are set) PtP#242
 F742	iF742	JSR $F695	; -	Get Buffer Address
 F745		JSR $F88C	; -	Print "PRESS PLAY & RECORD..."
 F748		JSR $F351	; Check Direct
 F74B		BNE $F755
 F74D		LDY #$64
 F74F		JSR $F185	; -	Print Message
 F752		JSR $F45C
 F755	iF755	LDA #$01
 F757		JSR $F619
 F75A		JSR $F8CE
 F75D		LDA $D3		; Current Secondary Address
 F75F		AND #$02
 F761		BEQ $F7AB
 F763		LDA #$05
 F765		JMP $F619


; Update Jiffy Clock

 F768	iF768	INC $99		; Jiffy clock correction: 623rd 1/60 sec does not increment time
 F76A		LDA $99		; Jiffy clock correction: 623rd 1/60 sec does not increment time
 F76C		BNE $F770
 F76E		INC $9A
 F770	iF770	CMP #$6F
 F772		BNE $F77A
 F774		LDA $9A
 F776		CMP #$02
 F778		BEQ $F79B
 F77A	iF77A	INC $8F
 F77C		BNE $F784
 F77E		INC $8E
 F780		BNE $F784
 F782		INC $8D		; Real-Time Jiffy Clock (approx) 1/60 Sec
 F784	iF784	LDX #$00
 F786	iF786	LDA $8D,X	; Real-Time Jiffy Clock (approx) 1/60 Sec
 F788		CMP $F7AC,X	; ?						DATA
 F78B		BCC $F7A1
 F78D		INX
 F78E		CPX #$03
 F790		BNE $F786
 F792		LDA #$00
 F794	iF794	STA $8C,X
 F796		DEX
 F797		BNE $F794
 F799		BEQ $F7A1
 F79B	iF79B	LDA #$00
 F79D		STA $99		; Jiffy clock correction: 623rd 1/60 sec does not increment time
 F79F		STA $9A
 F7A1	iF7A1	LDA $E812
 F7A4		CMP $E812
 F7A7		BNE $F7A1
 F7A9		STA $9B		; Flag: STOP key / RVS key
 F7AB	iF7AB	RTS


; ?						DATA

 F7AC	sF7AC	.byte 4F 1A 01                 ;o..


; chkin	Set Input Device

 F7AF	iF7AF	PHA
 F7B0		TXA
 F7B1		PHA
 F7B2		TYA
 F7B3		PHA
 F7B4		LDA #$00
 F7B6		STA $96		; Kernal I/O Status Word: ST
 F7B8		TXA
 F7B9		JSR $F2C1
 F7BC		BEQ $F7C3
 F7BE	iF7BE	LDY #$17
 F7C0	iF7C0	JMP $F5AF
 F7C3	iF7C3	JSR $F2CD
 F7C6		LDA $D4		; Current Device Number
 F7C8		BEQ $F7DA
 F7CA		CMP #$03
 F7CC		BEQ $F7DA
 F7CE		BCS $F7DF
 F7D0		LDX $D3		; Current Secondary Address
 F7D2		CPX #$60
 F7D4		BEQ $F7DA
 F7D6		LDY #$86
 F7D8		BNE $F7C0
 F7DA	iF7DA	STA $AF		; Default Input Device (0)
 F7DC		JMP $F29C
 F7DF	iF7DF	PHA
 F7E0		JSR $DBE1	; ?
 F7E3		JSR $F0D2	; talk	Send TALK Command on IEEE Bus
 F7E6		LDA $D3		; Current Secondary Address
 F7E8		BPL $F7F0
 F7EA		JSR $F198
 F7ED		JMP $F7F3
 F7F0	iF7F0	JSR $F193
 F7F3	iF7F3	LDA $96		; Kernal I/O Status Word: ST
 F7F5		BPL $F7FA
 F7F7		JMP $F4BB
 F7FA	iF7FA	PLA
 F7FB		JMP $F7DA


; chkout	Set Output Device

 F7FE	iF7FE	PHA
 F7FF		TXA
 F800		PHA
 F801		TYA
 F802		PHA
 F803		LDA #$00
 F805		STA $96		; Kernal I/O Status Word: ST
 F807		TXA
 F808		JSR $F2C1
 F80B		BNE $F7BE
 F80D		JSR $F2CD
 F810		LDA $D4		; Current Device Number
 F812		BNE $F818
 F814		LDY #$94
 F816		BNE $F7C0
 F818	iF818	CMP #$03
 F81A		BEQ $F828
 F81C		BCS $F82D
 F81E		LDX $D3		; Current Secondary Address
 F820		CPX #$60
 F822		BNE $F828
 F824		LDY #$94
 F826		BNE $F7C0
 F828	iF828	STA $B0		; Default Output (CMD) Device (3)
 F82A		JMP $F29C
 F82D	iF82D	PHA
 F82E		JSR $DBE1	; ?
 F831		JSR $F0D5	; listn	Send LISTEN Command on IEEE Bus
 F834		LDA $D3		; Current Secondary Address
 F836		BPL $F83D
 F838		JSR $F148
 F83B		BNE $F840
 F83D	iF83D	JSR $F143
 F840	iF840	LDA $96		; Kernal I/O Status Word: ST
 F842		BPL $F847
 F844		JMP $F4BB
 F847	iF847	PLA
 F848		JMP $F828


; -	Bump Tape Pointer

 F84B	iF84B	JSR $F695	; -	Get Buffer Address
 F84E		LDX $D4		; Current Device Number
 F850		INC $BA,X
 F852		LDY $BA,X
 F854		CPY #$C0
 F856		RTS


; -	Print "PRESS PLAY ON TAPE"

 F857	iF857	JSR $F87A	; -	Check Tape Status
 F85A		BEQ $F88B
 F85C		LDY #$41
 F85E	iF85E	JSR $F185	; -	Print Message
 F861		LDY #$56
 F863		JSR $F185	; -	Print Message
 F866		LDA $D4		; Current Device Number
 F868		ORA #$30
 F86A		JSR $E202	; -	Output to Screen
 F86D	iF86D	JSR $F935
 F870		JSR $F87A	; -	Check Tape Status
 F873		BNE $F86D
 F875		LDY #$AA
 F877		JMP $F185	; -	Print Message


; -	Check Tape Status

 F87A	iF87A	LDA #$10
 F87C		LDX $D4		; Current Device Number
 F87E		DEX
 F87F		BEQ $F883
 F881		LDA #$20
 F883	iF883	BIT $E810
 F886		BNE $F88B
 F888		BIT $E810
 F88B	iF88B	RTS


; -	Print "PRESS PLAY & RECORD..."

 F88C	iF88C	JSR $F87A	; -	Check Tape Status
 F88F		BEQ $F88B
 F891		LDY #$41
 F893		JSR $F185	; -	Print Message
 F896		LDY #$4D
 F898		BNE $F85E


; -	Initiate Tape Read

 F89A	iF89A	LDA #$00
 F89C		STA $96		; Kernal I/O Status Word: ST
 F89E		STA $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 F8A0		JSR $F6AB	; -	Set Buffer Stat / End Pointers
 
 ; Load any data PtP#242
 F8A3	iF8A3	JSR $F92B	; ?
 F8A6		JSR $F857	; -	Print "PRESS PLAY ON TAPE"
 F8A9		SEI
 F8AA		LDA #$00
 F8AC		STA $C2		; Cassette Temp (64=00AA) read flags: 0=scan, 15=count, $40=load, $80=end of tape marker
 F8AE		STA $CE		; Cassette Temp (64=00B4): Tape read timer flag =IRQ enabled for Timer 1
 F8B0		STA $CB		; Tape Timing Constants
 F8B2		STA $C0		; Index to Cassette File name/Header ID for Tape write.
 F8B4		STA $C1		; Tape Pass 2 Error Log
 F8B6		STA $B2		; Flag: Tape Byte-Received
 F8B8		LDX $D4		; Current Device Number
 F8BA		DEX
 F8BB		BEQ $F8C4
 F8BD		LDA #$90
 F8BF		STA $E84E
 F8C2		BNE $F8C7
 F8C4	iF8C4	INC $E811
 F8C7	iF8C7	LDX #$0E
 F8C9		BNE $F8E0	; -	Common Tape Code


; -	Initiate Tape Write

 F8CB	iF8CB	JSR $F6AB	; -	Set Buffer Stat / End Pointers
 F8CE	iF8CE	JSR $F92B	; ?
 F8D1		LDA #$14
 
; Save program or own header etc. PtP#242
 F8D3		STA $C3		; Cassette Short Cnt (64=00AB): counter of seconds before tape write / checksum
 F8D5	iF8D5	JSR $F88C	; -	Print "PRESS PLAY & RECORD..."
 F8D8		SEI
 F8D9		LDA #$A0
 F8DB		STA $E84E
 F8DE		LDX #$08


; -	Common Tape Code

 F8E0	iF8E0	JSR $FCE0	; -	Set IRQ Vector
 F8E3		LDA #$02
 F8E5		STA $DE		; Cassette Read / Write Block Count
 F8E7		JSR $FBC9	; -	New Character Setup
 F8EA		DEC $E813
 F8ED		LDX $D4		; Current Device Number
 F8EF		DEX
 F8F0		BNE $F8FB
 F8F2		LDA #$34
 F8F4		STA $E813
 F8F7		STA $F9		; Tape Motor Interlock #1
 F8F9		BNE $F905
 F8FB	iF8FB	LDA $E840	; VIA						CHIP
 F8FE		STX $FA		; Tape Motor Interlock #2
 F900		AND #$EF
 F902		STA $E840	; VIA						CHIP
 F905	iF905	LDX #$FF
 F907	iF907	LDY #$FF
 F909	iF909	DEY
 F90A		BNE $F909
 F90C		DEX
 F90D		BNE $F907
 F90F		STA $E849
 F912		CLI


; -	Wait For Tape

 F913	iF913	LDA #$E4
 F915		CMP $91
 F917		BEQ $F92A
 F919		JSR $F935
 F91C		BIT $E813
 F91F		BPL $F913	; -	Wait For Tape
 F921		BIT $E812
 F924		JSR $F768	; Update Jiffy Clock
 F927		JMP $F913	; -	Wait For Tape
 F92A	iF92A	RTS


; ?

 F92B	iF92B	JSR $F935
 F92E		LDA #$E4
 F930		CMP $91
 F932		BNE $F92B	; ?
 F934		RTS

 F935	iF935	JSR $F335	; -	-stop-
 F938		BNE $F942
 F93A		JSR $FCC0	; -	Wind Up Tape I/O
 F93D		JSR $F2B8
 F940		STA $10		; 3: width of source (unused - from TTY)
 F942	iF942	JMP $B7C6	; stop	Perform [stop], [end], break

 F945	iF945	STX $CC
 F947		LDA $CB		; Tape Timing Constants
 F949		ASL
 F94A		ASL
 F94B		CLC
 F94C		ADC $CB		; Tape Timing Constants
 F94E		CLC
 F94F		ADC $CC
 F951		STA $CC
 F953		LDA #$00
 F955		BIT $CB
 F957		BMI $F95A
 F959		ROL
 F95A	iF95A	ASL $CC
 F95C		ROL
 F95D		ASL $CC
 F95F		ROL
 F960		TAX
 F961	iF961	LDA $E848
 F964		CMP #$15
 F966		BCC $F961
 F968		ADC $CC
 F96A		STA $E844
 F96D		TXA
 F96E		ADC $E849
 F971		STA $E845
 F974		CLI
 F975		RTS


; -	Read Tape Bits

 F976	iF976	LDX $E849
 F979		LDY #$FF
 F97B		TYA
 F97C		SBC $E848
 F97F		CPX $E849
 F982		BNE $F976	; -	Read Tape Bits
 F984		STX $CC
 F986		TAX
 F987		STY $E848
 F98A		STY $E849
 F98D		TYA
 F98E		SBC $CC
 F990		STX $CC
 F992		LSR
 F993		ROR $CC
 F995		LSR
 F996		ROR $CC
 F998		LDA $CB		; Tape Timing Constants
 F99A		CLC
 F99B		ADC #$3C
 F99D		BIT $E840
 F9A0		BIT $E810
 F9A3		CMP $CC
 F9A5		BCS $F9F1
 F9A7		LDX $B2		; Flag: Tape Byte-Received
 F9A9		BEQ $F9AE
 F9AB		JMP $FA9C	; -	Store Tape Characters
 F9AE	iF9AE	LDX $B7		; Temp Data Area (64=00A3)
 F9B0		BMI $F9CD
 F9B2		LDX #$00
 F9B4		ADC #$30
 F9B6		ADC $CB		; Tape Timing Constants
 F9B8		CMP $CC
 F9BA		BCS $F9D8
 F9BC		INX
 F9BD		ADC #$26
 F9BF		ADC $CB		; Tape Timing Constants
 F9C1		CMP $CC
 F9C3		BCS $F9DC
 F9C5		ADC #$2C
 F9C7		ADC $CB		; Tape Timing Constants
 F9C9		CMP $CC
 F9CB		BCC $F9D0
 F9CD	iF9CD	JMP $FA4C
 F9D0	iF9D0	LDA $CE		; Cassette Temp (64=00B4): Tape read timer flag =IRQ enabled for Timer 1
 F9D2		BEQ $F9F1
 F9D4		STA $BE		; Cassette Temp (64=00A8)
 F9D6		BNE $F9F1
 F9D8	iF9D8	INC $BF		; RS-232 Flag: Check for Start Bit (64=00A9)
 F9DA		BCS $F9DE
 F9DC	iF9DC	DEC $BF		; RS-232 Flag: Check for Start Bit (64=00A9)
 F9DE	iF9DE	SEC
 F9DF		SBC #$13
 F9E1		SBC $CC
 F9E3		ADC $9C		; Timing Constant for Tape
 F9E5		STA $9C		; Timing Constant for Tape
 F9E7		LDA $B9		; Temp Data Area (64=00A4)
 F9E9		EOR #$01
 F9EB		STA $B9		; Temp Data Area (64=00A4)
 F9ED		BEQ $FA10
 F9EF		STX $D9		; Current Character to Print
 F9F1	iF9F1	LDA $CE		; Cassette Temp (64=00B4): Tape read timer flag =IRQ enabled for Timer 1
 F9F3		BEQ $FA0D
 F9F5		BIT $E84D
 F9F8		BVC $FA0D
 F9FA		LDA #$00
 F9FC		STA $B9		; Temp Data Area (64=00A4)
 F9FE		LDA $B7		; Temp Data Area (64=00A3)
 FA00		BPL $FA33
 FA02		BMI $F9CD
 FA04	iFA04	LDX #$A6
 FA06		JSR $F945
 FA09		LDA $B1		; Tape Character Parity
 FA0B		BNE $F9D0
 FA0D	iFA0D	JMP $E600	; -	Return From Interrupt
 FA10	iFA10	LDA $9C		; Timing Constant for Tape
 FA12		BEQ $FA1C
 FA14		BMI $FA1A
 FA16		DEC $CB		; Tape Timing Constants
 FA18		DEC $CB		; Tape Timing Constants
 FA1A	iFA1A	INC $CB		; Tape Timing Constants
 FA1C	iFA1C	LDA #$00
 FA1E		STA $9C		; Timing Constant for Tape
 FA20		CPX $D9		; Current Character to Print
 FA22		BNE $FA33
 FA24		TXA
 FA25		BNE $F9D0
 FA27		LDA $BF		; RS-232 Flag: Check for Start Bit (64=00A9)
 FA29		BMI $F9F1
 FA2B		CMP #$10
 FA2D		BCC $F9F1
 FA2F		STA $AB		; Cassette Sync No. (64=0096)
 FA31		BCS $F9F1
 FA33	iFA33	TXA
 FA34		EOR $B1		; Tape Character Parity
 FA36		STA $B1		; Tape Character Parity
 FA38		LDA $CE		; Cassette Temp (64=00B4): Tape read timer flag =IRQ enabled for Timer 1
 FA3A		BEQ $FA0D
 FA3C		DEC $B7		; Temp Data Area (64=00A3)
 FA3E		BMI $FA04
 FA40		LSR $D9		; Current Character to Print
 FA42		ROR $DF		; IEEE Word Buffer
 FA44		LDX #$DA
 FA46		JSR $F945
 FA49		JMP $E600	; -	Return From Interrupt

 FA4C	iFA4C	LDA $AB		; Cassette Sync No. (64=0096)
 FA4E		BEQ $FA54
 FA50		LDA $CE		; Cassette Temp (64=00B4): Tape read timer flag =IRQ enabled for Timer 1
 FA52		BEQ $FA5B
 FA54	iFA54	LDA $B7		; Temp Data Area (64=00A3)
 FA56		BMI $FA5B
 FA58		JMP $F9DC
 FA5B	iFA5B	LSR $CC
 FA5D		LDA #$93
 FA5F		SEC
 FA60		SBC $CC
 FA62		ADC $CB		; Tape Timing Constants
 FA64		ASL
 FA65		TAX
 FA66		JSR $F945
 FA69		INC $B2		; Flag: Tape Byte-Received
 FA6B		LDA $CE		; Cassette Temp (64=00B4): Tape read timer flag =IRQ enabled for Timer 1
 FA6D		BNE $FA80
 FA6F		LDA $AB		; Cassette Sync No. (64=0096)
 FA71		BEQ $FA99
 FA73		STA $BE		; Cassette Temp (64=00A8)
 FA75		LDA #$00
 FA77		STA $AB		; Cassette Sync No. (64=0096)
 FA79		LDA #$C0
 FA7B		STA $E84E
 FA7E		STA $CE		; Cassette Temp (64=00B4): Tape read timer flag =IRQ enabled for Timer 1
 FA80	iFA80	LDA $AB		; Cassette Sync No. (64=0096)
 FA82		STA $CF		; End of tape read
 FA84		BEQ $FA8F
 FA86		LDA #$00
 FA88		STA $CE		; Cassette Temp (64=00B4): Tape read timer flag =IRQ enabled for Timer 1
 FA8A		LDA #$40
 FA8C		STA $E84E
 FA8F	iFA8F	LDA $DF		; IEEE Word Buffer
 FA91		STA $DD		; Cassette Temp
 FA93		LDA $BE		; Cassette Temp (64=00A8)
 FA95		ORA $BF		; RS-232 Flag: Check for Start Bit (64=00A9)
 FA97		STA $D0		; Read character error
 FA99	iFA99	JMP $E600	; -	Return From Interrupt


; -	Store Tape Characters

 FA9C	iFA9C	JSR $FBC9	; -	New Character Setup
 FA9F		STA $B2		; Flag: Tape Byte-Received
 FAA1		LDX #$DA
 FAA3		JSR $F945
 FAA6		LDA $DE		; Cassette Read / Write Block Count
 FAA8		BEQ $FAAC
 FAAA		STA $BD		; Cassette Temp (64=00A7)
 FAAC	iFAAC	LDA #$0F
 FAAE		BIT $C2
 FAB0		BPL $FAC9
 FAB2		LDA $CF		; End of tape read
 FAB4		BNE $FAC2
 FAB6		LDX $DE		; Cassette Read / Write Block Count
 FAB8		DEX
 FAB9		BNE $FAC6
 FABB		LDA #$08
 FABD		JSR $FBC4	; -	Set Status Bit
 FAC0		BNE $FAC6
 FAC2	iFAC2	LDA #$00
 FAC4		STA $C2		; Cassette Temp (64=00AA) read flags: 0=scan, 15=count, $40=load, $80=end of tape marker
 FAC6	iFAC6	JMP $E600	; -	Return From Interrupt
 FAC9	iFAC9	BVS $FAFC
 FACB		BNE $FAE5
 FACD		LDA $CF		; End of tape read
 FACF		BNE $FAC6
 FAD1		LDA $D0		; Read character error
 FAD3		BNE $FAC6
 FAD5		LDA $BD		; Cassette Temp (64=00A7)
 FAD7		LSR
 FAD8		LDA $DD		; Cassette Temp
 FADA		BMI $FADF
 FADC		BCC $FAF6
 FADE		CLC
 FADF	iFADF	BCS $FAF6
 FAE1		AND #$0F
 FAE3		STA $C2		; Cassette Temp (64=00AA) read flags: 0=scan, 15=count, $40=load, $80=end of tape marker
 FAE5	iFAE5	DEC $C2		; Cassette Temp (64=00AA) read flags: 0=scan, 15=count, $40=load, $80=end of tape marker
 FAE7		BNE $FAC6
 FAE9		LDA #$40
 FAEB		STA $C2		; Cassette Temp (64=00AA) read flags: 0=scan, 15=count, $40=load, $80=end of tape marker
 FAED		JSR $FBBB	; -	Reset Tape Pointer
 FAF0		LDA #$00
 FAF2		STA $C3		; Cassette Short Cnt (64=00AB): counter of seconds before tape write / checksum
 FAF4		BEQ $FAC6
 FAF6	iFAF6	LDA #$80
 FAF8		STA $C2		; Cassette Temp (64=00AA) read flags: 0=scan, 15=count, $40=load, $80=end of tape marker
 FAFA		BNE $FAC6
 FAFC	iFAFC	LDA $CF		; End of tape read
 FAFE		BEQ $FB0A
 FB00		LDA #$04
 FB02		JSR $FBC4	; -	Set Status Bit
 FB05		LDA #$00
 FB07		JMP $FB8B
 FB0A	iFB0A	JSR $FD0B
 FB0D		BNE $FB12
 FB0F		JMP $FB89
 FB12	iFB12	LDX $BD		; Cassette Temp (64=00A7)
 FB14		DEX
 FB15		BEQ $FB44
 FB17		LDA $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 FB19		BEQ $FB27
 FB1B		LDY #$00
 FB1D		LDA $DD		; Cassette Temp
 FB1F		CMP ($C7),Y	; Pointer: Tape Buffer/ Screen Scrolling
 FB21		BEQ $FB27
 FB23		LDA #$01
 FB25		STA $D0		; Read character error
 FB27	iFB27	LDA $D0		; Read character error
 FB29		BEQ $FB77
 FB2B		LDX #$3D
 FB2D		CPX $C0		; Index to Cassette File name/Header ID for Tape write.
 FB2F		BCC $FB70
 FB31		LDX $C0		; Index to Cassette File name/Header ID for Tape write.
 FB33		LDA $C8
 FB35		STA $0101,X
 FB38		LDA $C7		; Pointer: Tape Buffer/ Screen Scrolling
 FB3A		STA $0100,X	; Micro-Processor System Stack Area
 FB3D		INX
 FB3E		INX
 FB3F		STX $C0		; Index to Cassette File name/Header ID for Tape write.
 FB41		JMP $FB77
 FB44	iFB44	LDX $C1		; Tape Pass 2 Error Log
 FB46		CPX $C0		; Index to Cassette File name/Header ID for Tape write.
 FB48		BEQ $FB81
 FB4A		LDA $C7		; Pointer: Tape Buffer/ Screen Scrolling
 FB4C		CMP $0100,X	; Micro-Processor System Stack Area
 FB4F		BNE $FB81
 FB51		LDA $C8
 FB53		CMP $0101,X
 FB56		BNE $FB81
 FB58		INC $C1		; Tape Pass 2 Error Log
 FB5A		INC $C1		; Tape Pass 2 Error Log
 FB5C		LDA $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 FB5E		BEQ $FB6C
 FB60		LDA $DD		; Cassette Temp
 FB62		LDY #$00
 FB64		CMP ($C7),Y	; Pointer: Tape Buffer/ Screen Scrolling
 FB66		BEQ $FB81
 FB68		LDA #$01
 FB6A		STA $D0		; Read character error
 FB6C	iFB6C	LDA $D0		; Read character error
 FB6E		BEQ $FB77
 FB70	iFB70	LDA #$10
 FB72		JSR $FBC4	; -	Set Status Bit
 FB75		BNE $FB81
 FB77	iFB77	LDA $9D		; Flag: 0 = Load, 1 = Verify (Kernel)
 FB79		BNE $FB81
 FB7B		LDA $DD		; Cassette Temp
 FB7D		LDY #$00
 FB7F		STA ($C7),Y	; Pointer: Tape Buffer/ Screen Scrolling
 FB81	iFB81	INC $C7		; Pointer: Tape Buffer/ Screen Scrolling
 FB83		BNE $FBB8
 FB85		INC $C8
 FB87		BNE $FBB8
 FB89	iFB89	LDA #$80
 FB8B	iFB8B	STA $C2		; Cassette Temp (64=00AA) read flags: 0=scan, 15=count, $40=load, $80=end of tape marker
 FB8D		LDX $DE		; Cassette Read / Write Block Count
 FB8F		DEX
 FB90		BMI $FB94
 FB92		STX $DE		; Cassette Read / Write Block Count
 FB94	iFB94	DEC $BD		; Cassette Temp (64=00A7)
 FB96		BEQ $FBA0
 FB98		LDA $C0		; Index to Cassette File name/Header ID for Tape write.
 FB9A		BNE $FBB8
 FB9C		STA $DE		; Cassette Read / Write Block Count
 FB9E		BEQ $FBB8
 FBA0	iFBA0	JSR $FCC0	; -	Wind Up Tape I/O
 FBA3		JSR $FBBB	; -	Reset Tape Pointer
 FBA6		LDY #$00
 FBA8		STY $C3		; Cassette Short Cnt (64=00AB): counter of seconds before tape write / checksum
 FBAA		JSR $FCF9
 FBAD		LDA $C3		; Cassette Short Cnt (64=00AB): counter of seconds before tape write / checksum
 FBAF		EOR $DD		; Cassette Temp
 FBB1		BEQ $FBB8
 FBB3		LDA #$20
 FBB5		JSR $FBC4	; -	Set Status Bit
 FBB8	iFBB8	JMP $E600	; -	Return From Interrupt


; -	Reset Tape Pointer

 FBBB	iFBBB	LDA $FC
 FBBD		STA $C8
 FBBF		LDA $FB		; I/O Start Address
 FBC1		STA $C7		; Pointer: Tape Buffer/ Screen Scrolling
 FBC3		RTS


; -	Set Status Bit

 FBC4	iFBC4	ORA $96		; Kernal I/O Status Word: ST
 FBC6		STA $96		; Kernal I/O Status Word: ST
 FBC8		RTS


; -	New Character Setup

 FBC9	iFBC9	LDA #$08
 FBCB		STA $B7		; Temp Data Area (64=00A3)
 FBCD		LDA #$00
 FBCF		STA $B9		; Temp Data Area (64=00A4)
 FBD1		STA $BE		; Cassette Temp (64=00A8)
 FBD3		STA $B1		; Tape Character Parity
 FBD5		STA $BF		; RS-232 Flag: Check for Start Bit (64=00A9)
 FBD7		RTS


; -	Write Transition to Tape

 FBD8	iFBD8	LDA $DD		; Cassette Temp
 FBDA		LSR
 FBDB		LDA #$60
 FBDD		BCC $FBE1
 FBDF	iFBDF	LDA #$B0
 FBE1	iFBE1	LDX #$00
 FBE3	iFBE3	STA $E848
 FBE6		STX $E849
 FBE9		LDA $E840	; VIA						CHIP
 FBEC		EOR #$08
 FBEE		STA $E840	; VIA						CHIP
 FBF1		AND #$08
 FBF3		RTS


; -	Write Data to Tape

 FBF4	iFBF4	SEC
 FBF5		ROR $C8
 FBF7		BMI $FC35


; -	IRQ Entry Point

 FBF9		LDA $BE		; Cassette Temp (64=00A8)
 FBFB		BNE $FC0F
 FBFD		LDA #$10
 FBFF		LDX #$01
 FC01		JSR $FBE3
 FC04		BNE $FC35
 FC06		INC $BE		; Cassette Temp (64=00A8)
 FC08		LDA $C8
 FC0A		BPL $FC35
 FC0C		JMP $FC86
 FC0F	iFC0F	LDA $BF		; RS-232 Flag: Check for Start Bit (64=00A9)
 FC11		BNE $FC1C
 FC13		JSR $FBDF
 FC16		BNE $FC35
 FC18		INC $BF		; RS-232 Flag: Check for Start Bit (64=00A9)
 FC1A		BNE $FC35
 FC1C	iFC1C	JSR $FBD8	; -	Write Transition to Tape
 FC1F		BNE $FC35
 FC21		LDA $B9		; Temp Data Area (64=00A4)
 FC23		EOR #$01
 FC25		STA $B9		; Temp Data Area (64=00A4)
 FC27		BEQ $FC38
 FC29		LDA $DD		; Cassette Temp
 FC2B		EOR #$01
 FC2D		STA $DD		; Cassette Temp
 FC2F		AND #$01
 FC31		EOR $B1		; Tape Character Parity
 FC33		STA $B1		; Tape Character Parity
 FC35	iFC35	JMP $E600	; -	Return From Interrupt
 FC38	iFC38	LSR $DD		; Cassette Temp
 FC3A		DEC $B7		; Temp Data Area (64=00A3)
 FC3C		LDA $B7		; Temp Data Area (64=00A3)
 FC3E		BEQ $FC7D
 FC40		BPL $FC35
 FC42	iFC42	JSR $FBC9	; -	New Character Setup
 FC45		CLI
 FC46		LDA $BA
 FC48		BEQ $FC5C
 FC4A		LDX #$00
 FC4C		STX $D9		; Current Character to Print
 FC4E		DEC $BA
 FC50		LDX $DE		; Cassette Read / Write Block Count
 FC52		CPX #$02
 FC54		BNE $FC58
 FC56		ORA #$80
 FC58	iFC58	STA $DD		; Cassette Temp
 FC5A		BNE $FC35
 FC5C	iFC5C	JSR $FD0B
 FC5F		BCC $FC6B
 FC61		BNE $FBF4	; -	Write Data to Tape
 FC63		INC $C8
 FC65		LDA $D9		; Current Character to Print
 FC67		STA $DD		; Cassette Temp
 FC69		BCS $FC35
 FC6B	iFC6B	LDY #$00
 FC6D		LDA ($C7),Y	; Pointer: Tape Buffer/ Screen Scrolling
 FC6F		STA $DD		; Cassette Temp
 FC71		EOR $D9		; Current Character to Print
 FC73		STA $D9		; Current Character to Print
 FC75		INC $C7		; Pointer: Tape Buffer/ Screen Scrolling
 FC77		BNE $FC35
 FC79		INC $C8
 FC7B		BNE $FC35
 FC7D	iFC7D	LDA $B1		; Tape Character Parity
 FC7F		EOR #$01
 FC81		STA $DD		; Cassette Temp
 FC83	iFC83	JMP $E600	; -	Return From Interrupt

 FC86	iFC86	DEC $DE		; Cassette Read / Write Block Count
 FC88		BNE $FC8D
 FC8A		JSR $FCEB	; -	Kill Tape Motor
 FC8D	iFC8D	LDA #$50
 FC8F		STA $BD		; Cassette Temp (64=00A7)
 FC91		LDX #$08
 FC93		SEI
 FC94		JSR $FCE0	; -	Set IRQ Vector
 FC97		BNE $FC83


; -	Write Tape Leader

 FC99		LDA #$78
 FC9B		JSR $FBE1
 FC9E		BNE $FC83
 FCA0		DEC $BD		; Cassette Temp (64=00A7)
 FCA2		BNE $FC83
 FCA4		JSR $FBC9	; -	New Character Setup
 FCA7		DEC $C3		; Cassette Short Cnt (64=00AB): counter of seconds before tape write / checksum
 FCA9		BPL $FC83
 FCAB		LDX #$0A
 FCAD		JSR $FCE0	; -	Set IRQ Vector
 FCB0		CLI
 FCB1		INC $C3		; Cassette Short Cnt (64=00AB): counter of seconds before tape write / checksum
 FCB3		LDA $DE		; Cassette Read / Write Block Count
 FCB5		BEQ $FCDB
 FCB7		JSR $FBBB	; -	Reset Tape Pointer
 FCBA		LDX #$09
 FCBC		STX $BA
 FCBE		BNE $FC42


; -	Wind Up Tape I/O

 FCC0	iFCC0	PHP
 FCC1		SEI
 FCC2		JSR $FCEB	; -	Kill Tape Motor
 FCC5		LDA #$7F
 FCC7		STA $E84E
 FCCA		LDA #$3C
 FCCC		STA $E811
 FCCF		LDA #$3D
 FCD1		STA $E813
 FCD4		LDX #$0C
 FCD6		JSR $FCE0	; -	Set IRQ Vector
 FCD9		PLP
 FCDA		RTS
 FCDB	iFCDB	JSR $FCC0	; -	Wind Up Tape I/O
 FCDE		BEQ $FC83


; -	Set IRQ Vector

 FCE0	iFCE0	LDA $FD4C,X	; -	Kernal Reset Vectors			WORD
 FCE3		STA $90		; Vector: Hardware Interrupt [3: E62E, 4: E455]
 FCE5		LDA $FD4D,X
 FCE8		STA $91
 FCEA		RTS


; -	Kill Tape Motor

 FCEB	iFCEB	LDA #$3C
 FCED		STA $E813
 FCF0		LDA $E840	; VIA						CHIP
 FCF3		ORA #$10
 FCF5		STA $E840	; VIA						CHIP
 FCF8		RTS

 FCF9	iFCF9	LDA ($C7),Y	; Pointer: Tape Buffer/ Screen Scrolling
 FCFB		EOR $C3		; Cassette Short Cnt (64=00AB): counter of seconds before tape write / checksum
 FCFD		STA $C3		; Cassette Short Cnt (64=00AB): counter of seconds before tape write / checksum
 FCFF		INC $C7		; Pointer: Tape Buffer/ Screen Scrolling
 FD01		BNE $FD05
 FD03		INC $C8
 FD05	iFD05	JSR $FD0B
 FD08		BNE $FCF9
 FD0A		RTS

 FD0B	iFD0B	LDA $C8
 FD0D		CMP $CA
 FD0F		BNE $FD15
 FD11		LDA $C7		; Pointer: Tape Buffer/ Screen Scrolling
 FD13		CMP $C9		; Tape End Addresses/End of Program
 FD15	iFD15	RTS


; -	Power-Up RESET Entry

 FD16		LDX #$FF
 FD18		SEI
 FD19		TXS
 FD1A		CLD
 FD1B		JSR $E000	; cint	Initialize Editor & Screen
 FD1E		LDA #$FF
 FD20		STA $94		; Vector: Non-Maskable Interrupt [3:C389,4: B3FF]
 FD22		LDA #$B3
 FD24		STA $95
 FD26		LDA #$78
 FD28		STA $92		; Vector: BRK Instr. Interrupt [3: FD17, 4: D478]
 FD2A		LDA #$D4
 FD2C		STA $93
 FD2E		LDA #$A4
 FD30		STA $03FA	; Monitor extension vector [D7A4]
 FD33		LDA #$D7
 FD35		STA $03FB
 FD38		LDA #$00
 FD3A		STA $03FC	; 4: Flag: Kernal Variable for IEEE Timeout
 FD3D		CLI
 FD3E		LDA $E810	; PIA 1						CHIP
 FD41		BMI $FD46
 FD43		JMP $D472	; Perform [monitor]
 FD46	iFD46	JMP $D3B6	; initcz	Initialize BASIC RAM


; -	NMI Transfer Entry

 FD49		JMP ($0094)	; Vector: Non-Maskable Interrupt [3:C389,4: B3FF]


; -	Kernal Reset Vectors			WORD

 FD4C	sFD4C	.word 0000 0000 0000 0000


; -	IRQ Vectors For Tape I/O		WORD

 FD54		.word FC99 FBF9 E455 F976
; *** Resyncing *** F5F9



; Perform [open]

 FFC0		JMP $F560	; opent	Perform [open]


; Perform [close]

 FFC3		JMP $F2DD	; closet	Perform [close]


; chkin	Set Input

 FFC6	iFFC6	JMP $F7AF	; chkin	Set Input Device


; chkout	Set Output

 FFC9	iFFC9	JMP $F7FE	; chkout	Set Output Device


; clrch	Restore I/O Vector

 FFCC	iFFCC	JMP $F2A6	; clrchn	Restore Default I/O


; chrin	Input Vector, chrin

 FFCF	iFFCF	JMP $F215	; chrin	Input a byte


; chrout	Output Vector, chrout

 FFD2	iFFD2	JMP $F266	; chrout	Output One Character


; Perform [load]

 FFD5		JMP $F401	; verfyt	Perform [load]


; Perform [save]

 FFD8		JMP $F6DD	; savet	Perform [save]


; Perform [verify]

 FFDB		JMP $F4F6	; verfyt	Perform [verify]


; sys	Perform [sys]

 FFDE		JMP $F6C3	; syst	Perform [sys]


; jmp $f343	stop	Test-Stop

 FFE1	iFFE1	JMP $F343	; stop	Check STOP Key


; jmp $f205	getin	Get From Keyboad

 FFE4	iFFE4	JMP $F205	; -	Input From Screen or Keyboard


; jmp $f2a2	clall	Close All Channels And Files

 FFE7	iFFE7	JMP $F2A2	; clall	Abort All Files


; jmp $f768	udtim	Update System Jiffy Clock

;fff6	Vectors

 FFEA	iFFEA	JMP $F768	; Update Jiffy Clock



; [fd49]		NMI		WORD

 FFFA		.word FD49


; [fd16]		RESET		WORD

 FFFC		.word FD16


; [e442]		IRQ		WORD

 FFFE		.word E442


; Misassembly source v1.3   Generated  Wed May 31 19:01:40 EET DST 1995


