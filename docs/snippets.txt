;--------------------------------------------------------------
;
;       RLENCODE ( srcaddr targaddr srclen -- targend uncompressed? )
;
; encode length {srclen} bytes from source address {srcaddr} to
; target address {targaddr}.  Return target end address {targend}
; and a flag indication if the data was compressed or not.
;
; If the length of the target exceeds {srclen}-1, RLENCODE will
; return a flag value of $4000 and simply store the data,
; otherwise it returns {uncompressed?} = 0.
;
#ifdef HEADERS
rlencodelfa
    .byt $de,$ad
    .byt (rlencode-*-1)|bit7
    .asc "RLENCOD","E"|bit7
#endif
rlencode
    ldy #2
    jsr locals      ; TOS = srclen; N0 = srcaddr; N1 = targaddr
    brk
    .byt ld | TOS
    .byt st | R11   ; output counter - when this hits zero, we're in negative compression
    .byt st | R10   ; input counter - when this hits zero, we're done

    .byt push       ; original size in case we go in the red
    .byt ld | N1
    .byt push       ; original targaddr
    .byt ld | N0
    .byt push       ; original srcaddr

    .byt set | R9   ; constant used to initialize (max repeat counter)
    .word $100
rlencode00
    .byt ld | R9    ; also the unfindable prev character
rlencode01
    .byt st | N2    ; set prev char
    .byt ld | R11   ; are we done?
    .byt bz , <(rlencode06-*-2)
    .byt ld | R10   ; are we in the red?
    .byt bz , <(rlencode07-*-2)
    .byt ldi | N0   ; read input stream
    .byt dcr | R11
    .byt sti | N1   ; write output stream
    .byt dcr | R10
    .byt cpr | N2   ; compare to prev
    .byt bnz , <(rlencode01-*-2) ; different? go get more

    .byt ld | R9
    .byt st | N3    ; count backwards from 256
    .byt dcr | N3   ; count the one already in output stream
rlencode02
    .byt dcr | N3
    .byt bz , <(rlencode04-*-2)  ; overflow?
    .byt ld | R11
    .byt bz , <(rlencode04-*-2)  ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | R11
    .byt cpr | N2
    .byt bz , <(rlencode02-*-2)
;different char
    .byt inr | R11              ; un-get from input stream
    .byt dcr | N0
;overflow/end of input
rlencode04
    .byt ld | R9
    .byt sub | N3
    .byt sti | N1               ; write count to output stream
    .byt dcr | R10
    .byt br , <(rlencode00-*-2)

rlencode06                      ; win
    .byt pull
    .byt pull
    .byt pull
    .byt ld | N1
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt

rlencode07                      ; lose - copy
    .byt pull
    .byt st | N0
    .byt pull
    .byt st | N1
    .byt pull
rlencode08
    .byt ldi | N0
    .byt sti | N1
    .byt dcr | TOS
    .byt bnz , <(rlencode08-*-2)
    .byt ld | N1
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt nxt

;--------------------------------------------------------------
;
;       MKPKT ( blkbuf -- packetsize )
;
; Build a packet at BLKBUF from the current video screen.
; The first three bytes of the packet are the linewrap bits for
; lines 1..24.  This is followed by RLE-encoded (or stored)
; screen codes, with the last two bytes being the packet header.
;
;": mkpkt   ( blkbuf -- size )
;     25 wrapabove
;                                 ( blkbuf d )
;     rot dup >r
;                                 ( d blkbuf ) ( R; blkbuf )
;     dup 3 + >r
;                                 ( d blkbuf ) ( R; blkbuf blkbuf+3 )
;     3c!
;                                 ( ) ( R; blkbuf blkbuf+3 )
;     vidram b/scr -trailing
;                                 ( vidram nonblanksize ) ( R; blkbuf blkbuf+3 )
;     r> swap
;                                 ( vidram blkbuf+3 nonblanksize ) ( R; blkbuf )
;     rlencode
;                                 ( targend uncompressed? ) ( R; blkbuf )
;     over r> - >r
;                                 ( targend uncompressed? ) ( R; size )
;     over 2+ or vidram or swap !
;                                 ( ) ( R; size )
;     r> ;
;                                 ( size )
;
;pscrstorelfa
;    .byt $de,$ad
;    .byt (pscrstore-*-1)|bit7
;    .asc "(SCR!",")"|bit7
pscrstore


;--------------------------------------------------------------
;
;       (SCR!)   ( pkt blkbuf newsize oldsize vmbuf -- blkbuf pkt-newsize+2 newsize vmbuf vmbuf+oldsize-newsize pkt-oldsize-vmbuf+2 )
;
; Uses Sweet16 to take a lot of the ridiculousness out of the
; pointer math involved in juggling packets in the buffer.
; This sets up for two MOVE operations.  The first move opens
; a hole correctly sized for the replacement packet.  The new
; packet is then moved into the hole.
;
;pscrstorelfa
;    .byt $de,$ad
;    .byt (pscrstore-*-1)|bit7
;    .asc "(SCR!",")"|bit7
pscrstore
    ldy #4
    jsr locals    ; TOS = vmbuf; N0 = pkt; N1 = blkbuf; N2 = newsize; N3 = oldsize
    brk
    .byt ld | TOS
    .byt st | R9                ; vmbuf -> R9
    .byt ld | N1
    .byt st | TOS               ; blkbuf
    .byt ldd | N0               ; pkt += 2
    .byt ld | N0
    .byt sub | N2
    .byt push                   ; pkt-newsize+2
    .byt ld | N2
    .byt push                   ; newsize
    .byt ld | R9
    .byt push                   ; vmbuf
    .byt add | N3
    .byt sub | N2
    .byt push                   ; vmbuf+oldsize-newsize
    .byt ld | N0
    .byt sub | N3
    .byt sub | R9
    .byt push                   ; pkt-oldsize-vmbuf+2
    .byt nxt

;--------------------------------------------------------------
;
;       SCR!   ( scr -- )
;
; Store the current screen in the block buffer.  It uses a
; helper word (SCR!) to set up the pointers, then performs
; two moves to open the correct amount of space in the packet
; buffer, and to move the current screen packet into that
; space.  If the current screen is uneditable, SCR! exits
; without changing the packet buffer.
;
;": scr!   ( scr -- )
;     editable? @
;     if
;         pkt@ blkbuf 2dup
;                               ( packet blkbuf packet blkbuf )
;         mkpkt swap @ vmbuf @
;                               ( packet blkbuf newsize oldsize vmbuf )
;         (scr!)
;                               ( packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
;         move move 0
;     then
;     drop ;
scrstorelfa
    .byt $de,$ad
    .byt (_scrstore-*-1)|bit7
    .asc "SCR","!"|bit7
_scrstore
#include "enter.i65"
    .word iseditable
#include "page.i65"
    .word fetch
#include "page.i65"
    .word qbranch
    .byt <(scrstore01-*+1)
#include "pad.i65"
    .word _pktfetch
#include "page.i65"
    .word _blkbuf
#include "page.i65"
    .word _twodup
#include "page.i65"
    .word _mkpkt
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word pscrstore
#include "page.i65"
    .word _move
#include "page.i65"
    .word _move
#include "page.i65"
    .word zero
#include "page.i65"
scrstore01
    .word drop
#include "page.i65"
    .word exit


mkpkt

copy the linewrap table to blkbuf..blkbuf+2
scrsize = find the size of the screen (last non-blank character)
rlencode or store the current screen to blkbuf+3..+scrsize
newsize = get total size of new packet (3(wrap) + min(scrsize,rlencoded size) + 2(header))
or uncompressed? flag
or editable flag (true because we're storing it)
store the packet header at blkbuf+newsize-2

move vmbuf up or down to create a hole newsize bytes
targdata = calculate target address (packet - newsize + 2)
copy blkbuf into the hole   blkbuf



scr
packet address of old copy
compressed size of current screen

vmbuf
size of old copy




linewrap blkbuf
3c!

from to howmany
rlencode

packetheader targend
!


vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2
move

blkbuf packet-newsize+2 newsize
move


>C:0000  00 40 2a 07  02 20 03 30  ef 7b 58 12  80 7c 00 01   .@*.. .0.{X..|..
>C:0010  fd 00 00 01  02 00 ff ff  00 01 01 00  00 ef 86 00   ................
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e 10 05  0e 00 f4 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c 40 80  00 7c 7b 40   ........||@..|{@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

>C:7b80  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7b90  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7ba0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bb0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bc0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bd0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7be0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa 00   ................
>C:7bf0  00 ff ff ff  05 80 ff ff  ff 05 80 ff  ff ff 05 80   ................

>C:7c00  ff ff ff 16  16 17 17 18  18 19 19 19  1a 1a 10 c0   ................
>C:7c10  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20
>C:7c20  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20
>C:7c30  20 20 20 20  20 20 20 20  20 20 20 20  20 20 20 20

after 4 locals
>C:0000  00 40 2a 07  02 20 03 30  ef 7b f4 7b  00 7c 0e 00   .@*.. .0.{.{.|..
>C:0010  05 80 00 01  02 00 ff ff  00 01 01 00  00 ef 86 00   ................
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e 10 05  0e 00 f4 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c 40 80  00 7c 7b 40   ........||@..|{@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

after (scr!)
>C:0000  02 80 2a 07  02 20 03 30  02 80 f6 7b  00 7c 0e 00   ..*.. .0...{.|..
>C:0010  05 80 ef 7b  02 00 ff ff  00 01 01 00  00 f5 f9 2c   ...{...........,
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 05 00  00 0e e6 ef  0e e8 00 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 00 80  7c 7c fb 7b  00 7b 7c 40   ........||.{.{|@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1b  2d 00 0d ae   ..........l.-...

pscrstore
    ldy #4
    jsr locals    ; TOS = vmbuf; N0 = pkt; N1 = blkbuf; N2 = newsize; N3 = oldsize
    brk
    .byt ld | TOS
    .byt st | R9                ; vmbuf -> R9
    .byt ld | N1
    .byt st | TOS               ; blkbuf
    .byt ldd | N0               ; pkt += 2
    .byt ld | N0
    .byt sub | N2
    .byt push                   ; pkt-newsize+2
    .byt ld | N2
    .byt push                   ; newsize
    .byt ld | R9
    .byt push                   ; vmbuf
    .byt add | N3
    .byt sub | N2
    .byt push                   ; vmbuf+oldsize-newsize
    .byt ld | N0
    .byt sub | N3
    .byt sub | R9
    .byt push                   ; pkt-oldsize-vmbuf+2
    .byt nxt

7bef 7be4 7 move
7c00 7be6 10 move
(scr!)
    brk
    .byt ld | TOS
    .byt st | R10               ; newsize
    .byt pull
    .byt add | R10
    .byt st | TOS               ; end of new packet
    .byt popd | TOS             ; new packetheader
    .byt ext
    .word pktheader16
;    N1 = packet header
;    N2 = editable? $8000 if editable, $0000 if data
;    N3 = uncompressed? $4000 if uncompressed, $0000 if compressed
;    R11 = length

: scr!   ( scr -- )
    editable? @
                                ( scr flag )
    if
                                ( scr )
        dup pkt@ blkbuf tuck
                                ( scr blkbuf packet blkbuf )
        vmbuf @ -rot
                                ( scr blkbuf vmbuf packet blkbuf )
        dup mkpkt
                                ( scr blkbuf vmbuf packet blkbuf newlen )
        (scr!)
                                ( scr blkbuf packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
        move
                                ( scr blkbuf packet-newsize+2 newsize )
        move
                                ( scr )
    then
                                ( scr )
    drop ;

7bef 7be4 7 move
7c00 7be6 10 move

>C:7bc0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7bd0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:7be0  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa 00   ................
>C:7bf0  00 ff ff ff ^05 80 ff ff  ff 05 80 ff  ff ff 05 80   ................
>C:7c00  ff ff ff 16  16 17 17 18  18 19 19 19  1a 1a 10 c0   ................
>C:7c10  be be be be  be be be be  be be be be  be be be be   ................
>C:7c20  be be be be  be be be be  be be be be  be be be be   ................
>C:7c30  be be be be  be be be be  be be be be  be be be be   ................
>C:7c40  be be be be  be be be be  be be be be  be be be be   ................

(C:$2d0b) m 0
>C:0000  00 40 2a 07  02 20 03 30  0e 00 a2 12  80 7c 00 01   .@*.. .0.....|..
>C:0010  fd 00 00 01  02 00 ff ff  00 01 01 00  00 ef 86 00   ................
>C:0020  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0030  aa aa aa aa  aa aa aa aa  aa aa aa aa  aa aa aa aa   ................
>C:0040  aa aa aa aa  aa aa 00 0e  10 10 00 f4  ef 00 02 04   ................
>C:0050  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0060  bb bb bb bb  bb bb bb bb  bb bb bb bb  bb bb bb bb   ................
>C:0070  bb bb bb bb  bb bb 7c 7c  40 c0 7c 7b  7b 7c 00 40   ......||@.|{{|.@
>C:0080  ea ea ea ea  ea ea e6 8b  e6 8b 6c 1d  2d 00 07 fe   ..........l.-...
(C:$0090) r
  ADDR AC XR YR SP 00 01 NV-BDIZC LIN CYC  STOPWATCH
.;2ce0 2d 2a 00 f0 00 40 00110000 011 036   31170532

0e      newlen
7c00    blkbuf
7bf4    packet






pscrstore
    brk
    .byt ld | TOS
    .byt st | R10               ; newsize
    .byt pull                   ; blkbuf
    .byt add | R10              ; newpacket
    .byt st | TOS               ; end of new packet
    .byt ldd | TOS              ; new packetheader
    .byt ext
    .word pktheader16
;    N1 = packet header
;    N2 = editable? $8000 if editable, $0000 if data
;    N3 = uncompressed? $4000 if uncompressed, $0000 if compressed
;    R11 = length
    .byt ld | R11
    .byt st | R9                ; newsize
    .byt pull
    .byt st | N0                ; packet
    .byt ldd | TOS              ; old packetheader
    .byt ext
    .word pktheader16
    .pull                       ; vmbuf
    .byt st | N3
    .byt ld | N0
    .byt sub | R9
    .byt st | TOS
    .byt ld | R9
    .byt push
    .byt ld | N3
    .byt push
    .byt add | R11
    .byt sub | R9
    .byt push
    .byt ld | N0
    .byt sub | R11
    .byt sub | N3
    .byt push
    .byt nxt


;--------------------------------------------------------------
;
;       -TRAILING   ( addr +n1 -- addr +n2 )
;
; The character count +n1 of a text string beginning at addr
; is adjusted to exclude trailing spaces.  If +n1 is zero,
; then +n2 is also zero.  If the entire string consists of
; spaces, then +n2 is zero.
;
;": -trailing   ( addr n1 -- addr n2 )
;     dup 0
;     ?do
;         2dup + 1- c@
;         bl <>
;     ?leave
;         1-
;     loop ;
;
#ifdef HEADERS
bashtrailinglfa .byt $de,$ad
    .byt (_bashtrailing-*-1)|bit7
    .asc "+TRAILIN","G"|bit7
#endif
_bashtrailing
#include "enter.i65"
    .word dup
#include "page.i65"
    .word zero
#include "page.i65"
    .word pdo
#include "page.i65"
bashtrailing01
    .word _twodup
#include "page.i65"
    .word plus
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word bl
#include "page.i65"
    .word ne
#include "page.i65"
    .word pqleave
    .byt <(bashtrailing02-*+1)
#include "pad.i65"
    .word oneminus
#include "page.i65"
    .word ploop
    .byt <(bashtrailing01-*+1)
#include "pad.i65"
bashtrailing02
    .word exit



dashtrailing
    brk
    .byt ld | TOS
    .byt st | N0
    .byt pull
    .byt ext
    .word dashtrailing16
    .byt ld | N0
    .byt push
    .byt nxt

sum = addr + size

83e8

bcs exit

size =  3
        e8

    ldy sum_low
    lda #0
    sta sum_low
tight
    dey
    bne a

    bcc nextpage
    bcs zero
    dec sum_high
    dec count_high
    bne a
    sec


a   lda (sum),y
    cmp #' '
    beq tight
foundnonblank
    sty sum_low
    rts


two reasons you can exit
found nonblank
ran out of string


8050
 100

8150
;
;
;inputs
;   TOS (R4) = addr
;   N0 (R5) = addr+size
;   N1 (R6) = count
;returns
;   TOS = addr (unchanged)
;   N0 = addr of last non-blank character (= addr if all are blank)
    ;clc
dashtrailing16
    ldy n                       ; address low byte
    bne dashtrailing16b
dashtrailing16a                 ; another page
    bcs dashtrailing16c
    dec n+1                     ; address high byte
    dec n+3                     ; counter high byte
    bne dashtrailing16b
    sec                         ; flag last page
dashtrailing16b
    dey
    beq dashtrailing16a
    lda (n+2),y
    eor #$20
    beq dashtrailing16b
dashtrailing16c
    sty n
    rts

voctag 1+ c@ max tag so far
voctag c@ 0= core vocabulary
voctag c@ nametag c@ = this word is in current vocab
vocabular definition
jsr dovocab
.byt voctag
.word parent

rehash
target=SYMTAB
            +8 bloom filter
            +32 threads
            +2 newstuff
there is a pile of symbol table sitting at PAD
for each thread 0..f
    for each possible length 1..31
        is the CFA<HERE? if >+ we'll skip this one
            copy it to target
            target = target + symbol size
                 vocabularies have 2 extra bytes at the end



;--------------------------------------------------------------
;
;       DHASH   ( nfa -- hash1 hash2 )
;
; tdict
;
; input is NFA or address of a counted string
; hash1 is the thread index for the core vocabulary (0-15)
; hash2 is used by the Bloom filter
;
;symbol table
;+---------------+
;|    CFA[low]   |  +0      Code field address
;|    CFA[high]  |
;+-+-+-+-+-+-+-+-+
;|     [   len   ]  +2      Length field
;[I]             |          Immediate bit
;| [V]           |          Vocabulary bit
;|   [S]         |          Smudge bit
;+-+-+-+-+-+-+-+-+
;|   name[1]     |  +3      Name field
;|           ... |
;|   name[len]   |
;+~~~~~~~~~~~~~~~+
;?    LFA[low]   ?  +len+3  Link field address
;?    LFA[high]  ?         (present iff Vocabulary)
;+~~~~~~~~~~~~~~~+
;
#ifdef HEADERS
dhashlfa
    .byt $de,$ad
    .byt (dhash-*-1)|bit7
    .asc "DHAS","H"|bit7
#endif
dhash
    stx storex
    ldy #0
    lda (tos),y
    and #$1f                ; turn off 7 and 6, not 5 (smudge)
    sta n                   ; seed hash1 with length
    sty n+1                 ; seed hash2 with 0
    tay                     ; count backwards to 1 from length
    iny                     ;       hash2   hash1
dhash01
    dey                             ;[2]
    beq dhash02                     ;[2]
    ; the pearson hash should return an evenly distributed
    ; value between $00-$0f based on the wordset in the
    ; core dictionary.  In other words, all 16 threads
    ; are initially balanced with the same number of words,
    ; to reduce searches to (on average) 1/16th of the
    ; dictionary.
    lda (tos),y                     ;[5]
    ;sec                             ;[2] ~wut? doesn't and 7 make this unnecessary?
    ;sbc #$20                        ;[2] control chars
    and #(pearsonx-pearson-1)       ;[2]
    tax                             ;[2]
    lda n                           ;[3]
    eor pearson,x                   ;[4]
    sta n                           ;[3]
    ; the bloom filter hash tries to answer the question,
    ; 'is this a number or does it contain numbers?'
    ; returning zero (no digits present) or the sum (mod64)
    ; of all digits in this word
    lda (tos),y             ;[5]
    and #$7f                ;[2]    ; ignore bit7
    clc                     ;[2]
    adc #$FF-('9')          ;[2]
    adc #'9'-'0'+1          ;[2]    ; carry is set only
    ; for digits '0'-'9'
    bcc dhash01             ;[3]  [12]hash2 [27]hash1
    adc n+1                 ; 0> -1 0 1 2 3 0= 0< 0<> sp0 rp0
    sta n+1                 ; 1+ 1- 2+ 2- 2/ 2* forth-83 dr0 dr1
    jmp dhash01             ; 2drop 2dup 2over 2rot 2swap 2! 2@
    ; 2constant 2variable d0= d2/ d2*
dhash02
    lda n
    lsr
    lsr                     ; xor the pearson hash byte
    lsr                     ; into a single nybble
    lsr                     ; - - - - [ 7 6 5 4 ]
    eor n                   ; 7 6 5 4 [ 3 2 1 0 ]
    and #$0f                ; - - - - [4bit hash]
    sta tos
    sty tos+1       ; for both hashes, high byte always 0
    lda n+1         ; sum of all digits 0..9
    ldx storex
    jmp pushya


;--------------------------------------------------------------
;
;        SYMSIZ   ( -- n )
;
; returns the size of the symbol table
;
#ifdef HEADERS
symsizlfa
    .byt $de,$ad
    .byt (_symsiz-*-1)|bit7
    .asc "SYMSI","Z"|bit7
#endif
_symsiz
#include "enter.i65"
    .word _tosyms
#include "page.i65"
    .word dup
#include "page.i65"
    .word twoplus
#include "page.i65"
symsiz01
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $1f
#include "page.i65"
    .word andx
#include "page.i65"
    .word qdup
#include "page.i65"
    .word qbranch
    .byt <(symsiz02-*-2)
#include "pad.i65"
    .word plus
#include "page.i65"
    .word three
#include "page.i65"
    .word plus
#include "page.i65"
    .word branch
    .byt <(symsiz01-*-2)
#include "pad.i65"
symsiz02
    .word swap
#include "page.i65"
    .word minus
#include "page.i65"
    .word exit      ; [38]

code symsiz   ( symbols -- )
    brk
    .byt inr | TOS
    .byt inr | TOS
    .byt rtn
symsiz01
    lda (tos),y

nfatocfa
    sec
    lda tos
    sbc #2
    sta tos
    bcs nfatocfa01
    dec tos+1
nfatocfa01
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    tay
    pla
    jmp put ;[24]

nfatocfa
    sec
    lda tos
    sbc #2
    sta n
    lda tos+1
    sbc #0
    sta n+1
    ldy #0
    lda (n),y
    sta tos
    iny
    lda (n),y
    sta tos+1
    jmp next ;[28]


;--------------------------------------------------------------
;
;       BLOOMHASH   ( nfa -- bloomhash )
;
; Calculate the bloom filter hash.  For words containing any
; digits at all, this will be a total of each digit+1, or a
; nonzero value 1..63.  For words which have no digits, return
; bloomhash will be zero.  This is expected to sparsely populate
; the 64 bloom filter bits, allowing FIND to bypass the symbol
; table search if the bit is turned off.
;
#ifdef HEADERS
bloomhashlfa
    .byt $de,$ad
    .byt (bloomhash-*-1)|bit7
    .asc "BLOOMHAS","H"|bit7
#endif
bloomhash
    stx storex
    ldy #0
    lda (tos),y
    and #$1f
    sty n
    tay
bloomhash01
    lda (tos),y                 ;[5]
    clc                         ;[2]
    adc #$FF-('9')              ;[2]
    adc #'9'-'0'+1              ;[2]
    bcc bloomhash02             ;[3] carry is set only for digits
    adc n                       ;[3] anything with digits is nonzero
    and #(8*(bloomx-bloom))-1   ;[2] keep it within the filter bits
    sta n                       ;[3]
    bne bloomhash02
    ldy #1                      ; if total of digits hits some multiple
    tya                         ; of 64, returns a nonzero value
bloomhash02
    dey
    bne bloomhash01
bloomhash03
    ;lda n
    ;ldy #0
    ldx storex
    jmp put

;": eligible?   ( hash searchlen nfa -- pearsonhash bloomhash flag )
;     dup c@ $1f and
;     ( hash searchlen nfa len )
;     rot =
;     ( hash nfa samelength? )
;     if
;         dup indict?
;
;         2drop true ( more processing later )
;     else
;         2drop false
;     then ;
#ifdef HEADERS
eligibleqlfa
    .byt $de,$ad
    .byt (eligibleq-*-1)|bit7
    .asc "ELIGIBLE","?"|bit7
#endif
eligibleq
    ldy #2
    jsr locals
    ;ldy #0
    lda (tos),y
    and #$1f
    eor n                       ; same length?
    bne eligibleq05
    brk
    .byt set | R11
    .word uarea+userdp-userarea
    .byt set | R10
    .word uarea+usertdict-userarea
    .byt popd | TOS             ; CFA
    .byt st | N2
    .byt ldd | R11              ; DP
    .byt cpr | N2
    .byt bm , <(eligibleq02-*-2)    ; not in core dictionary? bail
    .byt cpr | R10              ; TDICT
    .byt bp , <(eligibleq02-*-2)    ; not in temp dictionary either? bail
    .byt rtn
    jsr dhash6502

eligibleq02
    .byt rtn


;": indict?   ( nfa -- flag )
;       nfa>cfa tdict @ over u< swap here u< or ;
#include "enter.i65"
    .word dup
#include "page.i65"
    .word cfetch
#include "page.i65"
    .word clit
    .byt $1f
#include "pad.i65"
    .word andx
#include "page.i65"
    .word rot
#include "page.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(eligibleq04-*+1)
#include "pad.i65"
    .word twodrop
#include "page.i65"
    .word true
#include "page.i65"
    .word branch
    .byt <(eligibleq05-*+1)
#include "pad.i65"
eligibleq04
    .word twodrop
#include "page.i65"
    .word false
#include "page.i65"
eligibleq05
    .word exit

nfatocfa01
    ldy #0
    lda (tos),y
    pha
    iny
    lda (tos),y
    tay
    pla
    jmp put ;[13]

;--------------------------------------------------------------
;
;       SYMBYSIZE   ( searchlen nfa -- flag )
;
; returns true iff
; searchleng matches the current length? (I)
; and (CFA < DP or CFA > TDICT?)
;
;": symbysize   ( searchlen nfa -- flag )
;     dup nfalen rot =
;     ( nfa samelength? )
;      dup
;      if
;          ( nfa samelength? )
;          drop indict?
;      then ;  ( flag )
;
;--------------------------------------------------------------
;
;       SYMBYHASH   ( hash nfa -- flag )
;
; returns true iff
; calculate its pearson hash
; and that matches the current hash?
;
; this word tries to be cheap with processing
;
;": symbyhash   ( hash nfa -- flag )
;     pearsonhash = ;
;
;--------------------------------------------------------------
;
;       ELIGIBLE?   ( hash searchlen nfa -- flag )
;
; returns true iff
; searchleng matches the current length? (I)
; and (CFA < DP or CFA > TDICT?)
; calculate its pearson hash
; and that matches the current hash?
;
; this word tries to be cheap with processing
;
;": eligible?   ( hash searchlen nfa -- flag )
;     dup nfalen
;     ( hash searchlen nfa len )
;     rot =
;     ( hash nfa samelength? )
;     if
;         ( hash nfa )
;         dup indict?
;         ( hash nfa indict? )
;         if
;             ( hash nfa )
;             pearsonhash =
;             ( flag )
;         else                  ( code smell alert -- )
;             2drop false       ( both elses are sort of cheesily combined )
;         then
;     else
;         2drop false
;     then ;
;
;--------------------------------------------------------------
;
;       SYMSORT   ( 'compare searchfor src dest -- src+ dest+ )
;
; Make a pass through the symbol table at PAD, copying eligible
; symbols to target
;": symsort   ( 'compare searchfor src dest )
;     >r 2+
;     ( 'compare searchfor nfa ) ( R; target )
;     begin
;         \ not done yet?
;         dup nfalen
;         ( 'compare searchfor nfa currlen ) ( R; target )
;     while
;         ( 'compare searchfor nfa ) ( R; target )
;         3dup rot execute
;         ( 'compare searchfor nfa flag ) ( R; target )
;         if
;             \ copy it up to the new symbol table
;             ( 'compare searchfor nfa ) ( R; target )
;             r@ over
;             ( 'compare searchfor nfa target nfa ) ( R; target )
;             sym+
;             ( 'compare searchfor nfa ) ( R; target )
;             \ advance target pointer
;             r> 2+ nfa+ 2- >r
;             ( 'compare searchfor nfa ) ( R; target+ )
;         then
;         \ advance source pointer
;         nfa+
;         ( 'compare searchfor nfa+ ) ( R; target+ )
;     repeat
;     ( 'compare searchlen nfa+ ) ( R; target+ )
;     r> 2swap 2drop ;   ( target+ )
;
: (rehash)   ( src targ 'compare -- )
    do rot drop i -rot symsort loop 2drop ;
: rehash  ( -- )
    pad >syms 2dup swap
    32 1 ['] symbysize (rehash)
    symtab @ 32 erase
    [ bloom ] literal 8 erase
    16 0 ['] symbyhash (rehash)

.C:0d23   .twominus:
.C:0d23  38          SEC
.C:0d24  A5 08       LDA $08
.C:0d26  E9 02       SBC #$02
.C:0d28  85 08       STA $08
.C:0d2a  B0 02       BCS .twominus01
.C:0d2c  C6 09       DEC $09
.C:0d2e   .twominus01:
.C:0d2e  4C 86 00    JMP .next
.C:0d31   .twoslash:

ldy tos
cpy #2
dey
dey
tya
ldy tos+1
bcs +
dey
jmp put

lda tos
sec
sbc #2
ldy tos+1
bcs +
dey
jmp put

;--------------------------------------------------------------
;
;       2+
;
twoplus
    ldy tos+1
    lda #2
twoplusminus
    clc
    adc tos
    bcc twoplus01
    iny
twoplus01
    jmp put                     ; TOS = YA

;--------------------------------------------------------------
;
;       2-
;
twominus
    ldy tos+1
    dey
    lda #$fe
    bne twoplusminus            ; bra

;--------------------------------------------------------------
;
;       2+
;
twoplus
    lda #2
twoplusminus
    ldy tos+1
    clc
    adc tos
    bcc twoplus01
    iny
twoplus01
    jmp put                     ; TOS = YA

;--------------------------------------------------------------
;
;       2-
;
twominus
    dec tos+1
    lda #$fe
    bne twoplusminus            ; bra

twominus
    dec tos+1
    lda #$fe
    .byt $2c ; 'bit absolute'
twoplus
    lda #2
    clc
    adc tos
    sta tos
    bcc twoplus01
    inc tos+1
twoplus01
    jmp next

;--------------------------------------------------------------
;
;       DOCONST
;
doconst
    ldy #2
    .byt $2c
;--------------------------------------------------------------
;
;       DOCCONST
;
docconst
    ldy #1
    pla
    sta n
    pla
    sta n+1
doconst01
    lda (n),y       ; high byte if CONST, low byte if CCONST
    pha
    ora #$7f
    bmi neg
    lda #0
neg
    dey
    beq done

    lda (n),y       ; high byte if CONST, low byte if CCONST
done
    sta tos+1
    jmp next     ;[30]


;--------------------------------------------------------------
;
;       DOCONST
;
doconst
    ldy #2
    .byt $2c
;--------------------------------------------------------------
;
;       DOCCONST
;
docconst
    ldy #1
    pla
    sta n
    pla
    sta n+1
doconst01
    lda (n),y       ; high byte if CONST, low byte if CCONST
    pha
    ora #$7f
    bmi neg
    lda #0
neg
    dey
    beq done

    lda (n),y       ; high byte if CONST, low byte if CCONST
done
    sta tos+1
    jmp next     ;[30]


;--------------------------------------------------------------
;
;       DOCONST
;
doconst
    ldy #2
    .byt $2c
;--------------------------------------------------------------
;
;       DOCCONST
;
docconst
    ldy #1
    pla
    sta n
    pla
    sta n+1         ; [11]
doconst01
    lda (n),y       ; high byte if CONST, low byte if CCONST
    sta n+2
    dey
    bne twobytes
    asl n+2
    bcc +
    dey
+   jmp pushya
twobytes
    lda (n),y
    ldy n+2
out
    jmp pushya  ;[33]


doconst01
    jsr slip
-   lda (n),y       ; high byte if CONST, low byte if CCONST
    sta tos-1,y
    dey
    bne -           ;[11]

Y was 2, we're out


;--------------------------------------------------------------
;
;       DOCCONST
;
docconst
    clc
    .byt $24
;--------------------------------------------------------------
;
;       DOCONST
;
doconst
    sec
    pla
    sta n
    pla
    sta n+1
    ldy #1
    lda (n),y
    pha
    bcs doconst02
    bpl doconst01
    dey
doconst01
    dey
    bcc doconst03
doconst02
    iny
    lda (n),y
    tay
doconst03
    pla
    jmp pushya      ; [30]


    bcs a
    dey
c   clc
    iny
a   lda (n),y
    pha
    dey
    bcs c

    pla
    bcs b

b   tay
    pla
    jmp pushya

    sty n+2
    iny
    iny
    sta n+2
+
    dey
    lda (n),y
    pha

    ldy #1
    lda (n),y
    bcc lowonly

    pha                 ; LSB of constant
    bcs get2nd
    ora #$7f
    bmi out2
    dey
    beq out3



get2nd
    iny
    lda (n),y           ; MSB of constant
out2
    tay
out3
    pla
    jmp pushya      ; [30]



;--------------------------------------------------------------
;
;       DOCONST
;
doconst
    pla
    sta n
    pla
    sta n+1
    ldy #2
    lda (n),y
    sta n+2         ; high byte
    dey
    lda (n),y       ; low byte
    ldy n+2
    jmp pushya  ;[20]



-   lda (n),y
    sta n+1,y
    dey
    bne -           ; [22]

    pla
    sta n
    pla
    sta n+1         ; [9]
    jsr slip
    ldy #2
    bcs +
    dey
+
    dey
    bne +
    bcs out
    sty tos+1
    asl
    bcc out
    dec tos+1
out
    jmp next


    bcc +
    asl

    dey
    bne +

    pla
    sta n






    lda (n),y       ; high byte if CONST, low byte if CCONST
    sta tos+2
    dey
    beq out
    bne twobytes
    asl n+2
    bcc +
    dey
+   jmp pushya
twobytes
    lda (n),y
    ldy n+2
out
    jmp pushya  ;[33]




twobytes
    lda (n),y       ; high byte if CONST, low byte if CCONST
onebyte
    sta tos+1
    jmp next     ;[30]


        ; calculates upper byte of sign-extension of A
        ora #$7F
        bmi neg
        lda #0
neg:

    sta n+2
    dey
    lda (n),y       ; low byte
    ldy n+2
    jmp pushya


;--------------------------------------------------------------
;
;       (FIND)   ( name nfa fflag -- name false | cfa flag )
;
; * outer interpreter
;
; name is the address of a counted string we are searching for.
; nfa is the first nfa in the list
; fflag is the type of search we are doing
;   0 = corelist - names are in ascending order by size
;   1 = newlist - names are random sizes, with a 0-length name to terminate
;
; returns
;       ( cfa -1 ) if found normal word
;       ( cfa 1 ) if found immediate word
;       ( name 0 ) if not in dictionary
;
;#ifdef HEADERS
;pfindlfa
;    .byt $de,$ad
;    .byt (pfind-*-1)|bit7
;    .asc "(FIND",")"|bit7
;#endif
pfind
    brk
    .byt sub | R0
    .byt st | N3
    .byt ld | TOS
    .byt st | N2
    .byt pull
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | R11           ; set search length
    .byt st | N1
    .byt ld | N2
pfind02
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | N1            ; search length
    .byt cpr | R11          ; dict length
    .byt bnc , <(pfind06-*-2)       ; we went past it.  outtie
    .byt bnz , <(pfind03-*-2)       ; different lengths, skip
    .byt ext
    .word strcomp16
    .byt bc , <(pfind04-*-2)
pfind03
    .byt ldd | N0                   ; hop
    .byt br , <(pfind02-*-2)
pfind04 ;winner!
    .byt ldd | N0           ; add 2 to the LFA
    .byt ld | N0            ; now it's an NFA
    .byt add | N1           ; add the length
    .byt st | TOS           ; now it's almost a CFA
    .byt inr | TOS          ; add 1, now it's a CFA
    .byt ldi | N0           ; fetch dictionary length byte
    .byt sub | N1           ; subtract clean length leaving only bits
    .byt set | N0
    .word $80
    .byt dcr | N3           ; assume it's a normal word
    .byt cpr | N0
    .byt bz , <(pfind06-*-2)
    .byt inr | N3
    .byt inr | N3
pfind06
    .byt ld | N3
    .byt push
    .byt st | TOS
    .byt nxt

;--------------------
;--------------------------------------------------------------
;
;       (FIND)   ( name nfa fflag -- name false | cfa flag )
;
; * outer interpreter
;
; name is the address of a counted string we are searching for.
; nfa is the first nfa in the list
; fflag is the type of search we are doing
;   0 = corelist - names are in ascending order by size
;   1 = newlist - names are random sizes, with a 0-length name to terminate
;
; returns
;       ( cfa -1 ) if found normal word
;       ( cfa 1 ) if found immediate word
;       ( name 0 ) if not in dictionary
;
;#ifdef HEADERS
;pfindlfa
;    .byt $de,$ad
;    .byt (pfind-*-1)|bit7
;    .asc "(FIND",")"|bit7
;#endif
pfind
    brk
    .byt ld | TOS
    .byt st | N2            ; findflag 0=sorted; 1=unsorted
    .byt pull
    .byt st | N0            ; nfa of search list
    .byt pull
    .byt ldi | TOS          ; name to search for
    .byt dcr | TOS
    .byt st | N1            ; length
pfind01



    .byt sub | R0
    .byt st | N3
    .byt ld | TOS
    .byt st | N2
    .byt pull
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | R11           ; set search length
    .byt st | N1
    .byt ld | N2
pfind02
    .byt st | N0
    .byt ext
    .word wordlen16
    .byt ld | N1            ; search length
    .byt cpr | R11          ; dict length
    .byt bnc , <(pfind06-*-2)       ; we went past it.  outtie
    .byt bnz , <(pfind03-*-2)       ; different lengths, skip
    .byt ext
    .word strcomp16
    .byt bc , <(pfind04-*-2)
pfind03
    .byt ldd | N0                   ; hop
    .byt br , <(pfind02-*-2)
pfind04 ;winner!
    .byt ldd | N0           ; add 2 to the LFA
    .byt ld | N0            ; now it's an NFA
    .byt add | N1           ; add the length
    .byt st | TOS           ; now it's almost a CFA
    .byt inr | TOS          ; add 1, now it's a CFA
    .byt ldi | N0           ; fetch dictionary length byte
    .byt sub | N1           ; subtract clean length leaving only bits
    .byt set | N0
    .word $80
    .byt dcr | N3           ; assume it's a normal word
    .byt cpr | N0
    .byt bz , <(pfind06-*-2)
    .byt inr | N3
    .byt inr | N3
pfind06
    .byt ld | N3
    .byt push
    .byt st | TOS
    .byt nxt

;       (FIND)   ( name nfa fflag -- name false | cfa flag )
pfind
    brk
    .byt ld | TOS
    .byt st | N2                ; N2 = findflag
    .byt pull
    .byt st | N1                ; N1 = symbols
    .byt pull
    .byt st | N0                ; N0 = name
    .byt ext
    .word wordlen16             ; get length of NFA (TOS)
    .byt ld | R11
    .byt st | N3                ; length we are searching for
    .byt ld | N1
    .byt st | TOS
    .byt rtn

    jsr nfalen01
    sta n+5
    brk
    .byt ld | N1
    .byt st | TOS
    .byt rtn

    brk
    .byt ld | TOS
    .byt st | N2            ; findflag 0=sorted; 1=unsorted
    .byt pull
    .byt st | N0            ; nfa of search list
    .byt pull
    .byt ldi | TOS          ; name to search for
    .byt dcr | TOS
    .byt st | N1            ; length
pfind01

------------------------------------------
;
;       FIND   ( addr1 -- addr2 flag )
;
; * 83 interpreter tdict
;
; addr1 is the address of a counted string, which is the word to look
; up in the dictionary.
;
; if not found, addr2 is the original addr1, and flag = 0
; if found, addr2 is the code field address of the word,
; and flag = -1 for normal words, +1 for immediate words
;
; for vocabularies
; if context is nonzero, append the vocabulary id to the end of the
; word and extend its length by 1
; first search symnew, then core
; if not found, chain up to its parent vocabulary and repeat
; if parent vocabulary = core, strip off the vocabulary id
; and repeat
: find   ( addr1 -- addr2 flag )
    >r
    ( )
    0 0
    ( 0 0 )
    r@ pearsonhash 2* symtab @ + @ 2+ 0
    ( 0 0  corethread 0 )
    symnew @ 2+ 1
    ( 0 0  corethread 0  newthread 1 )
    false
    ( 0 0  corethread 0  newthread 1  found? )
    begin
        ( 0 0  corethread 0  newthread 1  found? )
        r@ over 0= 2over or and
        ( 0 0  corethread 0  newthread 1  found? name !found?&more?  )
    while
        ( 0 0  corethread 0  newthread 1  found? name )
        nip -rot (find)
        ( 0 0  corethread 0  name newthread 1  )
    repeat ;

#ifdef HEADERS
findlfa
    .byt $de,$ad
    .byt (_find-*-1)|bit7
    .asc "FIN","D"|bit7
#endif
_find
#include "enter.i65"        ; ( name )
    .word tor
#include "page.i65"
    .word zero
#include "page.i65"
    .word dup
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word false
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word one
#include "page.i65"
    .word false
#include "page.i65"
find01
    .word rfetch
#include "page.i65"
    .word over
#include "page.i65"
    .word zeq
#include "page.i65"
    .word twoover
#include "page.i65"
    .word orx
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(find02-*+1)
#include "pad.i65"
    .word nip
#include "page.i65"
    .word _dashrot
#include "page.i65"
    .word pfind
#include "page.i65"
    .word branch
    .byt <(find01-*+1)
#include "page.i65"
find02
    .word xyzzy
#include "page.i65"
    .word exit


;--------------------------------------------------------------
;
;       SKIP   ( addr1 size1 char -- addr2 count2 )
;
; * headerless
;
; addr1 is the starting address in the input stream where up
; to size1 bytes are skipped *WHILE* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
skip
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
skip01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bz, <(skip01-*-2)
    .byt br, <(skipscan04-*-2)      ; exit

;--------------------------------------------------------------
;
;       SCAN   ( addr count char -- addr count )
;
; * headerless
;
; addr1 is the starting address in the input stream where up
; to count1 bytes are skipped *UNTIL* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
scan
    brk
    .byt bs, <(skipscan01-*-2)      ; setup
scan01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bnz, <(scan01-*-2)
    .byt br, <(skipscan04-*-2)

skipscan01
    .byt ld | TOS   ; char
    .byt st | N1
    .byt pull
    .byt st | N0
    .byt pull       ; addr
    .byt rs
skipscan02
    .byt ldi | TOS
    .byt dcr | N0
    .byt bm1 , <(skipscan03-*-2)    ; leave if count < 0
    .byt sub | N1
    .byt rs
skipscan03
    .byt popd | R12 ; drop the BS return
skipscan04
    .byt dcr | TOS
    .byt inr | N0
    .byt rtn
    lda n
    ldy n+1
    jmp pushya

;       SKIP   ( addr1 size1 char -- addr2 count2 )
; addr1 is the starting address in the input stream where up
; to size1 bytes are skipped *WHILE* they match char.  Returns
; addr2 as the address of the first non-matching character and
; count2 as the remaining number of bytes in the buffer.
skip
    stx storex
    ldy #2
    jsr locals                  ; TOS=char; N0=addr1; N1=size1
                                ; sw16, N1=char; N0=size1; TOS=addr1
skip01
    ldy #0
    lda (n),y
    pha
    lda n+2
    bne skip02
    dec n+3                     ; DCR size1
    bmi leave
skip02
    dec n+2
    pla
    eor tos
    beq skip01

    dec $0,x
    .byt bs, <(skipscan01-*-2)      ; setup
skip01
    .byt bs, <(skipscan02-*-2)      ; next char
    .byt bz, <(skip01-*-2)
    .byt br, <(skipscan04-*-2)      ; exit

PLACE( str len addr -- )  => "FORTH"

    Place the string _str len_ at _addr_, formatting it as a counted string.

      : PLACE  2DUP 2>R  1+ SWAP  MOVE  2R> C! ;
      : PLACE  2DUP C!   1+ SWAP CMOVE ;

$!

;inputs
;   X = Sweet16 register address e.g. TOS = 8
;returns
;   decrements that 16-bit register once or twice (X)=(X)-2
decx2
    jsr DCR
decx
    jmp DCR

;inputs
;   X = Sweet16 register address e.g. TOS = 8
;returns
;   increments that 16-bit register once or twice (X)=(X)-2
incx2
    jsr INR
incx
    jmp INR

   ( c addr size -- addr size )
scan
    lda #$ff
    .byt $2c
skip
    lda #$0
    sta n+2                     ; mask
    ldy #1
    jsr locals                  ; N0 = addr; stackl,x = char
    jsr invert                  ; instead of counting down, count up
skipscan01
    jsr inctos                  ; must pre-increment after eor FFFF
    beq skipscan03
    lda (n),y
    eor stackl,x
    php
    pla
    eor n+2
    lsr
    lsr
    inc n
    bne skipscan02
    inc n+1
skipscan02
    bcc loop
skipscan03
    jsr donegate
    lda n                       ; addr
    ldy n+1
    jsr slip2
    jmp next



QUERY EXPECT BLK B/BUF HERE
LATEST 'STREAM TIB #TIB >IN SPAN WORD SKIP SCAN

 : 'stream   ( -- addr size )
      blk @ ?dup
      if      block b/buf
      else    tib #tib @
      then
  ( addr size )
      >in @ over
  ( addr size >in size )
      min >r
  ( addr size ) ( R; size' )
      swap r@ +
  ( size addr+size' ) ( R; size' )
      swap r> - ;
  ( addr+size' size-size' )


          SPAN         -- addr                       U,83
               The address of a variable containing the count of characters
               actually received and stored by the last execution of
               EXPECT .  See:  EXPECT

  |Now is the time for all |good men to come to the aid of their country|
  ^                        ^                                            ^
TIB                        |                                            |
                           |                                          SPAN
                          >IN

          Interpreter layer

                #  #>  #S  #TIB  '  (  -TRAILING  .  .(  <#  >BODY  >IN
ABORT  BASE  BLK  CONVERT  DECIMAL  DEFINITIONS  FIND
FORGET  FORTH  FORTH-83  HERE  HOLD  LOAD  PAD  QUIT  SIGN
SPAN  TIB  U.  WORD
          SPAN         -- addr                       U,83
               The address of a variable containing the count of characters
               actually received and stored by the last execution of
               EXPECT .  See:  EXPECT

;       #TIB
;
; * 83 interpreter
;
;  The address of a variable containing the number of bytes in
;  the text input buffer.  #TIB is accessed by WORD when BLK is
;" zero.  {{0..capacity of TIB}}

;" : word   ( c -- nfa )
;      >r                              ; ( -- ) ( R; c )
;  ( ) ( R; c )
;      'stream
;  ( addr size ) ( R; c )
;      under
;  ( addr addr size ) ( R; c )
;      r@ skip
;  ( addr addr2 count2 ) ( R; c )
;      under
;  ( addr addr2 addr2 count2 ) ( R; c )
;      r> scan
;  ( addr addr2 addr3 count )
;      drop 2dup swap -
;  ( addr addr2 addr3 size )
;      >r
;  ( addr addr2 addr3 ) ( R; size )
;      rot - 1+
;  ( addr2 addr3 size2 ) ( R; size )
;      >in +!
;  ( addr2 addr3 ) ( R; size )
;      r> here
;  ( addr2 addr3 size here )
;      2dup c!
;  ( addr2 addr3 size here )
;      1+ swap cmove
;  ( addr2 )
;      here bl over
;  ( addr2 here bl here )
;      count + c! ;
;  ( addr2 here )
: word   ( c -- nfa )
    dup>r
  ( c )
    'stream
  ( c addr size )

  ( c addr size )
    skip
  ( c addr size )
    scan
  ( addr2 size )

  bl word  ( -- nfa )

;--------------------------------------------------------------
;
;       CMOVE>   ( from to howmany -- )
;
; * 83 nucleus
;
; Move the u bytes beginning at address addr1 to
; addr2.  The move begins by moving the byte at
; (addr1 plus u minus 1) to (addr2 plus u minus 1)
; and proceeds to successively lower addresses
; for u bytes.  If u is zero nothing is moved.
; Useful for sliding a string towards higher addresses.
;
;": cmove>   ( from to howmany -- )
;     dup>r 1- tuck
;  ( from howmany-1 to howmany-1 )
;     + -rot + r@
;  ( to+howmany-1 from+howmany-1 howmany )
;     >6502
;     ldy #2
;     jsr locals                ; N0 = to; N1 = from
#ifdef HEADERS
cmovegtlfa
    .byt $de,$ad
    .byt (_cmovegt-*-1)|bit7
    .asc "CMOVE",">"|bit7
#endif
_cmovegt
#include "enter.i65"
    .word duptor
    brk
    .byt ld | TOS
    .byt st | N2                ; howmany
    .byt dcr | N2
    .byt pull
    .byt add | N2
    .byt st | N1                ; to
    .byt pull
    .byt add | N2
    .byt st | N0                ; from
    .byt ld | N2
    .byt bp, <(cmovegt06-*-2)
    .byt pull
    .byt nxt
cmovegt06
    .byt inr | N2
    .byt rtn
    clc
    ldy #0                     ; done by Sweet16
    stx storex
    ldx #0
cmovegt01
    dec n+5
    bpl cmovegt03
cmovegt02       ; last page
    ldx n+4
    beq cmovegt05
    sec
cmovegt03
    lda (n),y
    sta (n+2),y
    tya
    bne cmovegt04
    dec n+1
    dec n+3
cmovegt04
    dey
    dex
    bne cmovegt03
    bcc cmovegt01
cmovegt05
    ldx storex
    jmp pops

: (vocablist)   ( -- 0 id id ... )
    0 >r  context
    begin
        @ dup 2+ c@  dup>r  0=
    until
    drop r>
    begin
        r> ?dup  0=
    until ;

: (find)   ( vocid name  -- name 0 | cfa -1|1 )

;--------------------------------------------------------------
;
;       FIND   ( addr1 -- addr2 flag )
;
; * 83 interpreter tdict
;
; addr1 is the address of a counted string, which is the word to look
; up in the dictionary.
;
; if not found, addr2 is the original addr1, and flag = 0
; if found, addr2 is the code field address of the word,
; and flag = -1 for normal words, +1 for immediate words
;
;": find   ( addr1 -- addr2 flag )
;     >r
;     ( )
;     (vocablist)
;     ( 0 [ vocid ... ] )


;     r@ pearsonhash 2* symtab @ + @ 2+ 0
;     ( 0 0  corethread 0 )
;     symnew @ 2+ 1
;     ( 0 0  corethread 0  newthread 1 )
;     r@ false
;     ( 0 0  corethread 0  newthread 1  name found? )
;     begin
;         ( 0 0  corethread 0  newthread 1  name found? )
;         2over or over 0= and
;         \ flag is set if word not found yet and more places to look
;         ( 0 0  corethread 0  newthread 1  name found? !found?&more?  )
;     while
;         ( 0 0  corethread 0  newthread 1  name found? )
;         drop -rot (find)
;     repeat
;         ( 0 0 ... name found? )
; \ save the results
;     >r >r
;     begin
;         or 0=
;     until
;     r> r> ;
; \ then get rid of the stack down to the two zeroes
; \ return the results
#ifdef HEADERS
findlfa
    .byt $de,$ad
    .byt (_find-*-1)|bit7
    .asc "FIN","D"|bit7
#endif
_find
#include "enter.i65"        ; ( name )
    .word tor
#include "page.i65"
    .word zero
#include "page.i65"
    .word dup
#include "page.i65"
    .word rfetch
#include "page.i65"
    .word pearsonhash
#include "page.i65"
    .word twostar
#include "page.i65"
    .word symtab
#include "page.i65"
    .word fetch
#include "page.i65"
    .word plus
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word false
#include "page.i65"
    .word symnew
#include "page.i65"
    .word fetch
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word one
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word false
#include "page.i65"
find01
    .word twoover
#include "page.i65"
    .word orx
#include "page.i65"
    .word over
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word qbranch
    .byt <(find02-*+1)
#include "pad.i65"
    .word drop
#include "page.i65"
    .word _dashrot
#include "page.i65"
    .word pfind
#include "page.i65"
    .word branch
    .byt <(find01-*+1)
#include "pad.i65"
find02
    .word tor
#include "page.i65"
    .word tor
#include "page.i65"
find03
    .word orx
#include "page.i65"
    .word zeq
#include "page.i65"
    .word qbranch
    .byt <(find03-*+1)
#include "pad.i65"
    .word rfrom
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word exit


: find   ( addr1 -- addr2 flag )
    >r
  ( ) ( R; name )
    (vocablist)
  ( 0 [ vocid ... ] ) ( R; name )
    true r@ false
    begin
        over or
  ( vocid vocid ) ( R; name )
        while
            dup (vocfind)
        then
  ( vocid )
         r@ (find)
    until

find
    txa

;--------------------------------------------------------------
;
;       (FIND)   ( name -- name false | cfa flag )
;
; * outer interpreter
;
; name is the address of a counted string we are searching for.
; nfa is the first nfa in the hash list
;
; vocid identifies which vocabulary to search.  Vocabularies may be
; nested.  FIND walks up the CONTEXT tree and leaves a set of hashed
; NFAs (with the vocid appended to the name before hashing) on the stack.
; The final vocabulary searched will be core, and (FIND) will exit afterward.
;   0 = corelist
;   1 = editor
;   2 = assembler
;   3+ = additional user vocabularies
;
; (FIND) first searches the unsorted names beginning at SYMTAIL, and keeps
; going without regard to name length.  If it fails to find the word there,
; it tries the hash list, which is expected to be sorted in ascending size
; order.  Vocabularies are searched first, beginning with CONTEXT and chaining
; up until core (0) is reached.  The vocid is appended to the word when
; searching that vocabulary.  Only one symbol within a vocabulary may be
; active (unsmudged) at a time.  Smudged words are ignored.  The same symbol
; may exist within more than one vocabulary.
;
;" For example, at cold start the user types in,
;" VOCABULARY LATIN          \ creates a new user vocabulary with vocid = 3
;" LATIN DEFINITIONS         \ sets CURRENT to LATIN, definitions added there
;" : EPLURIBUSUNUM ;         \ adds a new word to the LATIN vocabulary
;" VOCABULARY PIGLATIN       \ creates a new user vocabulary with vocid = 4
;"                           \ PIGLATIN is a member of the LATIN vocabulary
;" PIGLATIN DEFINITIONS      \ sets CURRENT to PIGLATIN, new definitions there
;" : IXNAY ;                 \ adds a new word to the PIGLATIN vocabulary
;" FORTH                     \ set CONTEXT to core
;" IXNAY  not found          \ IXNAY is a member of PIGLATIN, out of context
;" PIGLATIN  not found       \ PIGLATIN is a member of LATIN vocabulary
;" LATIN PIGLATIN            \ set context to LATIN; set context to PIGLATIN
;" IXNAY  ok                 \ search for "IXNAY" + $04, found in PIGLATIN(4)
;" EPLURIBUSUNUM  ok         \ search for "EPLURIBUSUNUM" + $04, not found.
;"                           \ search for "EPLURIBUSUNUM" + $03, in LATIN(3)
;" DEPTH .  0 ok             \ search for "DEPTH" + $04, not found in PIGLATIN(4)
;"                           \ search for "DEPTH" + $03, not found in LATIN(3)
;                            \ search for "DEPTH", found in core(0)
;
; returns
;       ( cfa -1 ) if found normal word
;       ( cfa 1 ) if found immediate word
;       ( name 0 ) if not in dictionary
;
;#ifdef HEADERS
;pfindlfa
;    .byt $de,$ad
;    .byt (pfind-*-1)|bit7
;    .asc "(FIND",")"|bit7
;#endif
pfind
#ifdef SWEET16
    brk
    .byt sub | R0
    .byt st | R9                ; result flag
    .byt st | N2                ; assume core mode
    .byt ld | TOS
    .byt bz , <(pfind01-*-2)
    .byt dcr | N2               ; N2 = findflag, testable by BIT instr
pfind01
    .byt pull
    .byt st | N1                ; N1 = start of symbol table list
    .byt pull
    .byt st | N0                ; N0 = name
    .byt ext
    .word wordlen16             ; get length of name (TOS)
    .byt ld | R11
    .byt st | N3                ; length we are searching for
    .byt ld | N1
    .byt st | TOS               ; set TOS = first on search list
    .byt rtn
pfind02
    jsr nfalen01
    beq pfind07                 ; end of list? return ( NAME 0 )
    bcs pfind03                 ; smudged? not findable. next!
    cmp n+6                     ; compare lengths
    beq pfind04                 ; same length, compare strings too
    bcc pfind03                 ; shorter length?  next!
    bit n+4                     ; check unsorted mode vs. core mode
    bmi pfind03                 ; look at all names on this list
    bpl pfind07                 ; core mode, and we've gone past it
pfind03
    jsr nfaplus01
    bne pfind02                 ; bra
pfind04
    jsr strcomp
    bcc pfind03                 ; non-match? next!

    ; winner!
    inc n+10                    ; assume immediate (returns +1)
    ;ldy #0                     ; thank you, strcomp
    lda (tos),y                 ; length and flags
    bmi pfind06                 ; immediate?
    dey
    sty r9
    sty r9+1                    ; set R9 = -1
pfind06
    brk
    .byt popd | TOS             ; get the CFA
    .byt br , <(pfind08-*-2)
pfind07
    ; loser...
    brk
    .byt ld | N0
pfind08
    .byt st | TOS               ; CFA or original NAME
    .byt ld | R9                ; status flag
    .byt push
    .byt nxt
#endif

: (find)   ( name -- cfa flag | nfa 0 )
    1 symnew @ ((find))
    ?dup 0=
    if
        0 over pearsonhash 2* symtab @ + @ ((find))
    then ;


: voc@   ( -- vocid )
    context @ 2+ c@ ;

: (vocablist)   ( -- 0 id id ... )
      vocabs$  context
  ( vocabs$ context )
      begin
  ( vocabs$ context )
          @ dup 2+ c@
  ( vocabs$ vocab id )
          rot 2dup
  ( vocab id vocabs$ id vocabs$ )
          c! 1+ -rot
  ( vocabs$+ vocab id )
          0=
      until
      2drop ;



: smudge   ( -- )
    latest @ $20 cbit^ ;        \ toggle $20 bit on last word defined



: create   ( -- )
    exists?
    if
  ( cfa )
        [ RVSON ] cliteral emit
        here count type
        [ RVSOFF ] cliteral emit
        ."  EXISTS"
\ navigate to the NFA
\ smudge the previously existing word
\ leave the address of the name
  ( here )
    then
  ( here )
\ here is the name
    current @ 2+ c@ ?dup
    if
\ concatenate the vocabulary id
        under voc+
    then
  ( here )
    symtail @                   \ add the symbol to the symbol table
  ( symtail )
    r@ 2dup 2 +under
  ( symtail here symtail+2 here )
    over latest !               \ set LATEST variable to new word's NFA
  ( symtail here symtail+2 here )
    nfalen 1+ 3dup cmove smudge \ move symbol to symtail+2, smudge it
  ( symtail here symtail+2 len+1 )
    +
  ( symtail here symtail+2+len+1 )
    dup 3 erase                 \ mark the new symtail 00 00 00
  ( symtail here symtail+2+len+1 )
    symtail !                   \ update symtail
  ( symtail here )
    swap !                      \ set the CFA of the new symbol to HERE
  ( )
    [ docreate ] literal ,cfa ; \ enclose "JSR DOCREATE" in the dictionary


;": create   ( -- )
;     bl word
;                               ( addr )
;     dup dup find
;                               ( here addr cfa flag )
;     swap drop
;                               ( here addr flag )
;     if
;                               ( here addr )
;         RVSON emit
;                               ( here addr )
;         over count type
;                               ( here addr )
;         RVSOFF emit
;                               ( here addr )
;         ."  exists"
;                               ( here addr )
;     then
;                               ( nfa addr )
;     drop >r $80 r@ c@ 2dup or
;                               ( $80 len $80|len ) ( R; nfa )
;     r@ c!
;                               ( $80 len ) ( R; nfa ) ( R; nfa )
;     r@ + dup c@
;                               ( $80 cfa-1 lastchar ) ( R; nfa )
;     rot or over c!
;                               ( cfa-1 ) ( R; nfa )
;     1+ dp !
;                               ( ) ( R; nfa )
;     ['] docreate ,cfa         ( enclose 'jsr docreate' )
;                               ( ) ( R; nfa )
;     r@ dhash
;                               ( hash1 hash2 ) ( R; nfa )
;     bloom!
;                               ( hash1 ) ( R; nfa )
;     r> 2- swap dhash! ;
;                               ( )

: isdup?   ( name -- flag )

: id.   ( nfa -- )
    dup nfalen  over c@
  ( nfa len len|flags )
    $40 and             \ check vocab bit
  ( nfa len isvoc? )
    if
        1-
    then
    1 +under type ;

\ if current vocabulary isn't root, append the vocid
: ?vocab   ( name -- name )
    current @ 2+ c@ ?dup
    if
        over voc+
    then ;

: create   ( -- )
\ parse input stream to here, and search context and its parents for name
    exists?
  ( xfa flag )
    here ?vocab swap
  ( xfa here flag )
    if
  ( xfa here )
\ is potential duplicate word in the current (not a parent) vocabulary?
\ otherwise it's not a redefinition, treat it as a new word
        nip (find)
  ( nfa xfa flag )
        if
  ( nfa cfa )
            [ RVSON ] cliteral emit
            over id.
            [ RVSOFF ] cliteral emit
            ."  EXISTS"
            drop smudge         \ smudge the previously existing word
            here
  ( here )
        then
  ( here )
    then
  ( here )
    symtail @                   \ add the symbol to the symbol table
  ( here symtail )
    over 2dup 2 +under
  ( here symtail here symtail+2 here )
    over latest !             \ set LATEST variable to new word's NFA
  ( here symtail here symtail+2 here )
    nfalen 1+ 3dup cmove smudge \ move symbol to symtail+2, smudge it
  ( here symtail here symtail+2 len+1 )
    +
  ( here symtail here symtail+2+len+1 )
    dup 3 erase                 \ mark the new symtail 00 00 00
  ( here symtail here symtail+2+len+1 )
    symtail !                   \ update symtail
  ( here symtail here )
    swap !                      \ set the CFA of the new symbol to HERE
  ( )
    [ docreate ] literal ,cfa ; \ enclose "JSR DOCREATE" in the dictionary
;--------------------------------------------------------------
;
;       (VOCABLIST)   ( -- )
;
; Sets the VOCABS$ string to the list of vocabularies, chaining up
; from CONTEXT to core
;
;": (vocablist)   ( -- )
;       vocabs$  context
;  ( vocabs$ context )
;     begin
;  ( vocabs$ context )
;         dup @ swap vocid
;  ( vocabs$ vocab id )
;         rot 2dup
;  ( vocab id vocabs$ id vocabs$ )
;         c! 1+ -rot
;  ( vocabs$+ vocab id )
;         0=
;     until
;     2drop ;

: :   ( -- )
    [ enter ] literal
    !csp  current @ context !  (create)
    latest @ dup smudge ] ;

#ifdef HEADERS
colonlfa
    .byt $de,$ad
    .byt (_colon-*-1)|bit7
    .asc ":"|bit7
#endif
_colon
#include "enter.i65"
    .word _storecsp
#include "page.i65"
    .word current
#include "page.i65"
    .word fetch
#include "page.i65"
    .word context
#include "page.i65"
    .word store
#include "page.i65"
    .word _create
#include "page.i65"
    .word latest
#include "page.i65"
    .word fetch
#include "page.i65"
    .word smudge
#include "page.i65"
    .word _rbracket
#include "page.i65"
    .word _psemi
    jmp enter



;--------------------------------------------------------------
;
;       CFA!   ( addr nfa -- )
;
; puts a JSR addr at cfa, taking page alignment into account
;
#ifdef HEADERS
cfastorelfa
    .byt $de,$ad
    .byt (cfastore-*-1)|bit7
    .asc "CFA","!"|bit7
#endif
_cfastore
#include "enter.i65"
    .word dup
#include "page.i65"
    .word clit
    .byt #$ff
#include "pad.i65"
    .word andx
#include "page.i65"
    .word clit
    .byt #$fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(cfastore01-*+1)
#include "pad.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word dup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
cfastore01
    .word clit
    .byt $20
#include "pad.i65"
    .word dup
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"

;--------------------------------------------------------------
;
;       ,CFA   ( addr -- )
;
; set the code field of a new definition, taking page alignment
; into account.
;
; compiler tdict
;
;": ,cfa   ( xt -- )
;     herelsb $fc =
;     if
;         $ea c,
;     then
;     $20 c,
;     , ;
;
;#ifdef HEADERS
;commacfalfa
;    .byt $de,$ad
;    .byt (_commacfa-*-1)|bit7
;    .asc ",CF","A"|bit7
;#endif
_commacfa
#include "enter.i65"
    .word _herelsb
#include "page.i65"
    .word clit
    .byt $fc
#include "pad.i65"
    .word eq
#include "page.i65"
    .word qbranch
    .byt <(commacfa01-*+1)
#include "page.i65"
    .word clit
    .byt $ea
#include "pad.i65"
    .word _ccomma
#include "page.i65"
commacfa01
#include "page.i65"
    .word clit
    .byt $20
#include "pad.i65"
    .word _ccomma
#include "page.i65"
    .word _comma
#include "page.i65"
    .word exit

;
;       (VOCABLIST)   ( -- )
;
; Sets the VOCABS$ string to the list of vocabularies, chaining up
; from CONTEXT to core
;
: (vocablist)   ( -- )
       vocabs$  context
  ( vocabs$ context )
     begin
  ( vocabs$ context )
         dup @
  ( vocabs$ context parent )
         -rot
  ( parent vocabs$ context )
         vocid
  ( parent vocabs$ vocid )
         tuck
  ( parent vocid vocabs$ vocid )
         c!+
  ( parent id vocabs$+ )
         -rot
  ( vocabs$+ vocab id )
         0=
     until
     2drop ;
;

;--------------------------------------------------------------
;
;       ANCESTOR?   ( -- )
;
; description
;
#ifdef HEADERS
ancestorqlfa
    .byt $de,$ad
    .byt (_ancestorq-*-1)|bit7
    .asc "ANCESTOR","?"|bit7
#endif
_ancestorq

: ?candidate   ( descendant candidate -- )
  ( descendant candidate )
    \ candidate is inactive?
    dup c@ $20 and
  ( descendant candidate flag )
    if
  ( descendant candidate )
        \ candidate remains in dictionary?
        \ and is more recent than prior candidates?
        dup name>  ancestor @  newdp @  between?
  ( descendant candidate flag )
        if
  ( descendant candidate )
            2dup sameasme?
  ( descendant candidate flag )
            if
                dup name> ancestor !
            then
        then
    then
    2drop ;

;--------------------------------------------------------------
;
;       ?ANCESTOR   ( descendant nfa -- )
;
; Searches for a qualifying ancestor and activates it
;
: ?ancestor   ( descendant startnfa -- )
  ( descendant startnfa )
    ancestor off
  ( descendant startnfa )
    begin
  ( descendant nfa )
        dup nfalen
  ( descendant nfa length )
    while
  ( descendant nfa )
        2dup ?candidate
        nfa+
    repeat

;--------------------------------------------------------------
;
;       C,   ( b -- )
;
; * compiler tdict
;
#ifdef HEADERS
ccommalfa
    .byt $de,$ad
    .byt (_ccomma-*-1)|bit7
    .asc "C",","|bit7
#endif
_ccomma
#include "enter.i65"
    .word here
#include "page.i65"20
    .word cstore
#include "page.i65"
    .word one
#include "page.i65"
    .word _allot
#include "page.i65"
    .word exit

ccomma
    lda #<(uarea+userdp-userarea)
    sta n
    lda #>(uarea+userdp-userarea)
    sta n+1
    ldy #1
    lda (n),y
    sta n+3
    dey
    lda (n),y
    sta n+2
    lda tos
    sta (n+2),y
    clc
    lda (n),y
    adc #1
    sta (n),y
    bcc ccomma01
    iny
    lda (n),y
    adc #0
    sta (n),y
    jmp pops

: >pkt   ( n -- packet )
    blkbuf 2-
    begin
        over 0>
    while
        dup @ $7ff and -
        -1 +under
    repeat
    nip ;

: >pkt   ( n -- packet )
    blkbuf 2-
 ( n addr )
    begin
 ( n junk )
        swap 1-
 ( n junk )
        dup @
        - swap 1- swap
    repeat
    swap drop ;


;         #vmpkt @ - 0
; ( howmany junk )
;         begin
; ( howmany junk )
;             drop 1-
; ( howmany )
;             editmode @ pkt+
; ( howmany packet )
;             over 0<
;         until
; ( howmany packet )
;         nip
; ( howmany packet )

;--------------------------------------------------------------
;
;       PKTHEAD   ( packet -- uncompressed? len )
;
; Given the address of a packet, set the EDITBLK uservariable to
; true if the packet is editable, false otherwise.
;
#ifdef HEADERS
pktheadlfa
    .byt $de,$ad
    .byt (pkthead-*-1)|bit7
    .asc "PKTHEA","D"|bit7
#endif
pkthead



;--------------------------------------------------------------
;
;       UNPKT ( packet -- blkbuf )
;
; Given the address of a packet (its size/flags word, at the top)
; this will unpack the packet to the block buffer and return
; the address of the unpacked block. Distinguishes among
; compressed/uncompressed and editable/uneditable packets
; * set the EDITBLK flag true if packet is editable, false if readonly
; * leave the linewrap in BLKBUF first 3 bytes if editor
;
: unpkt   ( packet -- blkbuf )
    dup @ dup 0< editblk !
 ( packet header )
    dup 2* 0< >r
 ( packet header ) ( R; uncompressed? )
    $7ff and 2dup - 2+
 ( packet size data ) ( R; uncompressed? )
    blkbuf dup>r rswap b/buf blank
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
    editblk @
 ( packet size data blkbuf editable? ) ( R; blkbuf uncompressed? )
    if
 ( packet size data blkbuf ) ( R; blkbuf uncompressed? )
        over 3c@ third 3c!
        3+ rot 3- rot 3+ rot
    then
    rot 2- r>
 ( packet data blkbuf size uncompressed? ) ( R;  )
 ( packet size data blkbuf uncompressed? )
    if
        cmove
    else
        rldecode
    then
    rfrom ;

    dup @ dup 0< editblk !
 ( packet header ) ( R; blkbuf )
    tuck $7ff and
 ( header packet size ) ( R; blkbuf )
    dup>r - 2+ r> r>
 ( header data size blkbuf )
    2swap editblk @
 ( size blkbuf header data editable? )
    if
 ( header data size ) ( R; blkbuf )
        dup 3c@ r@ 3c!
        3+ r> 3+ >r -3 +under
    then
 ( data blkbuf size uncompressed? )
    if
        cmove
    else
        rldecode
    then
 ( packet header size packet data ) ( R; blkbuf )
    editblk @
 ( packet header size packet data editable? ) ( R; blkbuf )
    if
 ( packet header size packet data ) ( R; blkbuf )
        dup 3c@ r@ 3c!
        r> 3+ >r
        3+ -3 +under
    then
 ( packet header packet size' data' ) ( R; blkbuf )

 ( packet blkbuf )
    over @ $7ff and
 ( packet blkbuf len )

;#ifdef HEADERS
;unpktlfa
;    .byt $de,$ad
;    .byt (_unpkt-*-1)|bit7|bit5
;    .asc "UNPK","T"|bit7
;    .byt 1
;#endif
_unpkt
#ifdef SWEET16
#include "enter.i65"
    .word _blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word _blank                ; blank the block buffer
#include "page.i65"
    .word to6502
    brk                         ; ( packet blkbuf )
    .byt ld | TOS
    .byt st | R9                ; blkbuf
    .byt st | R10               ; "to"
    .byt pull
    .byt st | N0                ; packet address
    .byt ldd | TOS              ; get packet header
    .byt ext
    .word pktheader16           ; get R11=packet length, N2=editable? N3=uncompressed?
    .byt ld | N0
    .byt sub | R11              ; address of packet data
    .byt st | R13               ; "from" (don't use R12, it turns the packet into the Sweet16 return stack!)
    .byt ld | N2
    .byt bz , <(unpkt01-*-2)    ; data packet?
    .byt ldi | R13              ; copy 3 bytes of linewrap from packet
    .byt sti | R10
    .byt dcr | R11              ; subtract 3 from length
    .byt ldi | R13
    .byt sti | R10
    .byt dcr | R11
    .byt ldi | R13
    .byt sti | R10
    .byt dcr | R11
unpkt01                         ; start stacking it back up
    .byt ld | R9
    .byt st | TOS               ; blkbuf
    .byt ld | R13
    .byt push                   ; from
    .byt ld | R10
    .byt push                   ; to
    .byt ld | R11
    .byt push                   ; howmany
    .byt ld | N3
    .byt push                   ; uncompressed?
    .byt ld | N2
    .byt push                   ; editable?
    .byt rtn
#include "toforth.i65"
    .word editblk
#include "page.i65"
    .word store
#include "page.i65"
    .word qbranch               ; IF
    .byt <(unpkt03-*+1)
#include "page.i65"
    .word cmove
#include "page.i65"
    .word branch
    .byt <(unpkt04-*+1)
#include "page.i65"
unpkt03                         ; ELSE
    .word rldecode
#include "page.i65"
unpkt04                         ; THEN
    .word exit
                                ; ( blkbuf )
#endif


* make a packet



: scr!   ( scr -- )
    editblk? @
                                ( scr flag )
    if
                                ( scr )
        dup >pkt blkbuf tuck
                                ( scr blkbuf packet blkbuf )
        vmbuf @ -rot
                                ( scr blkbuf vmbuf packet blkbuf )
        dup mkpkt
                                ( scr blkbuf vmbuf packet blkbuf newsize )
        (scr!)
                                ( scr blkbuf packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
        over vmbuf !
                                ( scr blkbuf packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
        move
                                ( scr blkbuf packet-newsize+2 newsize )
        move
                                 ( scr )
    then
                                ( scr )
    drop ;

;--------------------------------------------------------------
;
;       -TRAILING   ( addr +n1 -- addr +n2 )
;
; The character count +n1 of a text string beginning at addr
; is adjusted to exclude trailing spaces.  If +n1 is zero,
; then +n2 is also zero.  If the entire string consists of
; spaces, then +n2 is zero.
;
;": -trailing   ( addr n1 -- addr n2 )
;     dup 0
;     ?do
;         2dup + 1- c@
;         bl <>
;     ?leave
;         1-
;     loop ;
;
dashtrailing
    lda stackl,x
    sta n
    lda stackh,x
    sta n+1                     ; N0 = addr

    ldy tos
    lda tos+1
    beq dashtrailing01
    clc
    adc n+1
    sta n+1
dashtrailing01
    dey
    cpy #$ff
    bne dashtrailing02
    dec n+1
    lda tos+1
    beq dashtrailing03
    dec tos+1
dashtrailing02
    lda (n),y
    eor #' '
    beq loop
dashtrailing03
    tya
    ldy tos+1
    inx
    jmp puts

;": scr>pkt   ( scr -- )
;     editblk? @
;                                 ( scr flag )
;     if
;                                 ( scr )
;         dup >pkt blkbuf tuck
;                                 ( scr blkbuf packet blkbuf )
;         vmbuf @ -rot
;                                 ( scr blkbuf vmbuf packet blkbuf )
;         dup mkpkt
;                                 ( scr blkbuf vmbuf packet blkbuf newsize )
;         (scr!)
;                                 ( scr blkbuf packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
;         over vmbuf !
;                                 ( scr blkbuf packet-newsize+2 newsize vmbuf vmbuf+oldsize-newsize packet-oldsize-vmbuf+2 )
;         move
;                                 ( scr blkbuf packet-newsize+2 newsize )
;         move
;                                 ( scr )
;     then
;                                 ( scr )
;     drop ;

: scr>pkt   ( scr -- )
    writable? @
 ( scr flag )
    if
 ( scr )
        blkbuf dup mkpkt
 ( scr blkbuf newsize )
        third @ $7ff and
 ( scr blkbuf newsize oldsize )
        vmbuf @
 ( scr blkbuf newsize oldsize vmbuf )
        >6502
    ldy #4
    jsr locals
    brk


        jsr toforth
 ( vmbuf oldtail delta )
        +move
 ( blkbuf newtail newsize )
        cmove
    then
    drop ;




oldpacket
oldsize
newsize
vmbuf
blkbuf
delta
oldtail = oldpacket-oldsize+2
newtail = oldpacket-newsize

vmbuf oldtail delta +move
blkbuf newtail newsize cmove


; * mkpkt in the block buffer
 ( newsize )
; * calculate the delta between the existing packet size and the new packet size
; delta = oldpacketsize - newsize
; * calculate the bottom address of the old packet

( scr )
>pkt dup @
( addr header )
$7ff and + 2+
 ( bottom )

; vmbuf
; * +MOVE vmbuf "00" through the following packet header by delta bytes
; * MOVE the packet in BLKBUF into place
;
: scr>pkt   ( scr -- )
    writable? @
    if

;": cmove>   ( from to howmany -- )
;     dup>r 1- tuck
;  ( from howmany-1 to howmany-1 ) ( R; howmany )
;     + -rot + r>
;  ( to+howmany-1 from+howmany-1 howmany )
;     >6502



1- dup>r
+under r@ +
r> 1+

L2: ; assert Y = 0
        ldx ptr3 ; Get the low byte of n
        beq done ; something to copy

L3: lda (ptr1),Y ; copy a byte
        sta (ptr2),Y
        iny
        dex
        bne L3


_memcpy:
        jsr memcpy_getparams

memcpy_upwards: ; assert Y = 0
        ldx ptr3+1 ; Get high byte of n
        beq L2 ; Jump if zero

L1: .repeat 2 ; Unroll this a bit to make it faster...
        lda (ptr1),Y ; copy a byte
        sta (ptr2),Y
        iny
        .endrepeat
        bne L1
        inc ptr1+1
        inc ptr2+1
        dex ; Next 256 byte block
        bne L1 ; Repeat if any

        ; the following section could be 10% faster if we were able to copy
        ; back to front - unfortunately we are forced to copy strict from
        ; low to high since this function is also used for
        ; memmove and blocks could be overlapping!
        ; {
L2: ; assert Y = 0
        ldx ptr3 ; Get the low byte of n
        beq done ; something to copy

L3: lda (ptr1),Y ; copy a byte
        sta (ptr2),Y
        iny
        dex
        bne L3

        ; }

done: jmp popax ; Pop ptr and return as result

sed -n '/\;----------------------------/{n;n;p;}' modules/core-nucleus.a65


: [ state off ; immediate

: ] state on
begin
?stack exists? dup
while
?branch 20
0<
if
 ?branch 8
,
else
 branch 32
execute
 branch 26

 drop number dpl @ 1+
if
 ?branch 8
 dliteral
 else
  branch 6
 drop literal
then
 true quit?
repeat
 ?branch -58
 ;

: quit
blk         10bc
off         0dbc
[           15ba
>1c9b<
rp!         0cd3
cr          0b18
query        1762
run          1c6c
state        1109
@            0ede
0=           0d33
?branch 8    08c6 1cb3
." ok"       03 " ok"
branch -26   08ac 1c9b
;

: query
tib          1030
clit 80      0871 50
expect       1758
span         1126
@            0ede
#tib         1155
!            0f02
blk          10bc
off          0dbc
>in          10c5
off ;        0dbc

: run
state        1109
@            0ede
?branch 20   08c6 1c88
]            15c6
state        1109
@            0ede
not          0c9e
?branch 10   08c6 1c8a
interpret    1bb6
branch 4     08ac 1c8a
interpet     1bb6
;            0ce9




;~~~
: INTERPRET
begin
    find
    if
        state @ <
        if
            ,xt
        else
            execute
        then
    else
        number dpl @ 1+
        if
            dlit
        else
            drop literal
        then
    then
    ?stack
again ;
 .word DOCOL
 .word DASHFIND ;-62
 .word ZBRAN
 .word 30
 .word STATE
 .word FETCH
 .word LT
 .word ZBRAN
 .word 10
 .word CFA
 .word COMMA
 .word BRANCH
 .word 6
 .word CFA ;10
 .word EXECUTE
 .word QSTACK
 .word BRANCH
 .word 28
 .word HERE ;30
 .word NUMBER
 .word DPL
 .word FETCH
 .word ONEP
 .word ZBRAN
 .word 8
 .word DLIT
 .word BRANCH
 .word 6
 .word DROP ;8
 .word LITERAL
 .word QSTACK ;6
 .word BRANCH
 .word -62


;~~~
L13a5 .byt 4 | bit7
 .asc "QUI","T"|bit7
 .word L1398
QUIT
 .word DOCOL
QUITENTRY
 .word ZERO
 .word BLK
 .word STORE
 .word LBRACK
 .word RPSTORE
 .word CR ; -25
 .word QUERY
 .word INTERPRET
 .word STATE
 .word FETCH
 .word ZEQ
 .word ZBRAN
 .word 7
 .word PDOTQ
 .byt 2
 .byt 0," "
 .word BRANCH
 .word -25
 .word SEMIS ; 7

rbracket01
    .word _existsq
#include "page.i65"
    .word dup
#include "page.i65"
    .word qbranch
    .byt <(rbracket03-*+1)
#include "pad.i65"
    .word zlt
#include "page.i65"
    .word qbranch
    .byt <(rbracket02-*+1)
#include "pad.i65"
    .word _commaxt
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket02
    .word execute
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket03
    .word drop
#include "page.i65"
    .word _number
#include "page.i65"
    .word dpl
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word qbranch
    .byt <(rbracket04-*+1)
#include "pad.i65"
    .word _dliteral
#include "page.i65"
    .word branch
    .byt <(rbracket05-*+1)
#include "pad.i65"
rbracket04
    .word drop
#include "page.i65"
    .word _literal
#include "page.i65"
rbracket05
    .word true
#include "page.i65"
    .word _quitq
#include "page.i65"
    .word qbranch
    .byt <(rbracket01-*+1)
#include "pad.i65"
    .word exit

ml monitor save routine
.S "FILENAME",01,1000,1007

.C:d675  A0 01       LDY #$01
.C:d677  84 D4       STY $D4    ; current device number
.C:d679  88          DEY
.C:d67a  84 D1       STY $D1    ; length of filename 0=noname
.C:d67c  84 96       STY $96    ; status byte ST
.C:d67e  84 9D       STY $9D    ; flag 0=load 1=verify
.C:d680  A9 02       LDA #$02
.C:d682  85 DB       STA $DB
.C:d684  A9 09       LDA #$09
.C:d686  85 DA       STA $DA    ; ($DA) pointer to start of filename
.C:d688  20 15 F2    JSR $F215  ; CHRIN
.C:d68b  C9 20       CMP #$20
.C:d68d  F0 F9       BEQ $D688
.C:d68f  C9 0D       CMP #$0D
.C:d691  F0 1A       BEQ $D6AD
.C:d693  C9 22       CMP #$22
.C:d695  D0 DB       BNE $D672
.C:d697  20 15 F2    JSR $F215
.C:d69a  C9 22       CMP #$22
.C:d69c  F0 24       BEQ $D6C2
.C:d69e  C9 0D       CMP #$0D
.C:d6a0  F0 0B       BEQ $D6AD
.C:d6a2  91 DA       STA ($DA),Y
.C:d6a4  E6 D1       INC $D1
.C:d6a6  C8          INY
.C:d6a7  C0 10       CPY #$10
.C:d6a9  F0 C7       BEQ $D672
.C:d6ab  D0 EA       BNE $D697
.C:d6ad  A5 B4       LDA $B4
.C:d6af  C9 06       CMP #$06
.C:d6b1  D0 E2       BNE $D695
.C:d6b3  20 56 F3    JSR $F356
.C:d6b6  20 2B F9    JSR $F92B
.C:d6b9  A5 96       LDA $96
.C:d6bb  29 10       AND #$10
.C:d6bd  D0 F2       BNE $D6B1
.C:d6bf  4C BA D4    JMP $D4BA
.C:d6c2  20 15 F2    JSR $F215
.C:d6c5  C9 0D       CMP #$0D
.C:d6c7  F0 E4       BEQ $D6AD
.C:d6c9  C9 2C       CMP #$2C
.C:d6cb  D0 F0       BNE $D6BD
.C:d6cd  20 63 D7    JSR $D763
.C:d6d0  29 0F       AND #$0F
.C:d6d2  F0 D5       BEQ $D6A9
.C:d6d4  C9 03       CMP #$03
.C:d6d6  F0 FA       BEQ $D6D2
.C:d6d8  85 D4       STA $D4
.C:d6da  20 15 F2    JSR $F215
.C:d6dd  C9 0D       CMP #$0D
.C:d6df  F0 CC       BEQ $D6AD
.C:d6e1  C9 2C       CMP #$2C
.C:d6e3  D0 E6       BNE $D6CB
.C:d6e5  20 54 D7    JSR $D754
.C:d6e8  20 44 D7    JSR $D744
.C:d6eb  20 15 F2    JSR $F215
.C:d6ee  C9 2C       CMP #$2C
.C:d6f0  D0 F1       BNE $D6E3
.C:d6f2  20 54 D7    JSR $D754
.C:d6f5  A5 FB       LDA $FB
.C:d6f7  85 C9       STA $C9
.C:d6f9  A5 FC       LDA $FC
.C:d6fb  85 CA       STA $CA
.C:d6fd  20 44 D7    JSR $D744
.C:d700  20 15 F2    JSR $F215
.C:d703  C9 20       CMP #$20
.C:d705  F0 F9       BEQ $D700
.C:d707  C9 0D       CMP #$0D
.C:d709  D0 E5       BNE $D6F0
.C:d70b  A5 B4       LDA $B4
.C:d70d  C9 07       CMP #$07
.C:d70f  D0 F8       BNE $D709
.C:d711  20 E3 F6    JSR $F6E3
.C:d714  4C BA D4    JMP $D4BA
.C:d717  A2 01       LDX #$01

.C:0070  E6 77       INC $77
.C:0072  D0 02       BNE $0076
.C:0074  E6 78       INC $78
.C:0076  AD 01 02    LDA $0201
.C:0079  C9 3A       CMP #$3A
.C:007b  B0 0A       BCS $0087
.C:007d  C9 20       CMP #$20
.C:007f  F0 EF       BEQ $0070
.C:0081  38          SEC
.C:0082  E9 30       SBC #$30
.C:0084  38          SEC
.C:0085  E9 D0       SBC #$D0
.C:0087  60          RTS


kernel save from basic
.C:f6dd  20 7D F4    JSR $F47D ; fetch parameters for load, save or verify

$D1 = length of string
($DA) = pointer to start of string
$D3 = secondary address
$D4 = device number

.C:f6e0  20 CC F6    JSR $F6CC
.C:f6e3  A5 D4       LDA $D4
.C:f6e5  D0 05       BNE $F6EC
.C:f6e7  A0 74       LDY #$74
.C:f6e9  4C AF F5    JMP $F5AF
.C:f6ec  C9 03       CMP #$03
.C:f6ee  F0 F7       BEQ $F6E7
.C:f6f0  90 50       BCC $F742
.C:f6f2  A9 61       LDA #$61
.C:f6f4  85 D3       STA $D3
.C:f6f6  A4 D1       LDY $D1
.C:f6f8  D0 03       BNE $F6FD
.C:f6fa  4C 00 BF    JMP $BF00
.C:f6fd  20 A5 F4    JSR $F4A5
.C:f700  20 D5 F0    JSR $F0D5
.C:f703  A5 D3       LDA $D3
.C:f705  20 43 F1    JSR $F143
(C:$f708) d f6c3
.C:f6c3  20 84 BD    JSR $BD84
.C:f6c6  20 2D C9    JSR $C92D
.C:f6c9  6C 11 00    JMP ($0011)
.C:f6cc  A5 2A       LDA $2A
.C:f6ce  85 C9       STA $C9
.C:f6d0  A5 2B       LDA $2B
.C:f6d2  85 CA       STA $CA
.C:f6d4  A5 29       LDA $29
.C:f6d6  85 FC       STA $FC
.C:f6d8  A5 28       LDA $28
.C:f6da  85 FB       STA $FB
.C:f6dc  60          RTS
.C:f6dd  20 7D F4    JSR $F47D
.C:f6e0  20 CC F6    JSR $F6CC
.C:f6e3  A5 D4       LDA $D4
.C:f6e5  D0 05       BNE $F6EC
.C:f6e7  A0 74       LDY #$74
.C:f6e9  4C AF F5    JMP $F5AF
(C:$f6ec) d
.C:f6ec  C9 03       CMP #$03
.C:f6ee  F0 F7       BEQ $F6E7
.C:f6f0  90 50       BCC $F742
.C:f6f2  A9 61       LDA #$61
.C:f6f4  85 D3       STA $D3
.C:f6f6  A4 D1       LDY $D1
.C:f6f8  D0 03       BNE $F6FD
.C:f6fa  4C 00 BF    JMP $BF00
.C:f6fd  20 A5 F4    JSR $F4A5
.C:f700  20 D5 F0    JSR $F0D5
.C:f703  A5 D3       LDA $D3
.C:f705  20 43 F1    JSR $F143
.C:f708  A0 00       LDY #$00
.C:f70a  20 BB FB    JSR $FBBB
.C:f70d  A5 C7       LDA $C7
.C:f70f  20 9E F1    JSR $F19E
.C:f712  A5 C8       LDA $C8
.C:f714  20 9E F1    JSR $F19E
(C:$f717) 



kernel jump table
.C:ff93  4C C7 DA    JMP $DAC7
.C:ff96  4C 42 D9    JMP $D942
.C:ff99  4C 07 DA    JMP $DA07
.C:ff9c  4C AF D7    JMP $D7AF
.C:ff9f  4C D2 D9    JMP $D9D2
.C:ffa2  4C 65 DA    JMP $DA65
.C:ffa5  4C 7E DA    JMP $DA7E
.C:ffa8  4C A7 DA    JMP $DAA7
.C:ffab  4C 77 D9    JMP $D977
.C:ffae  4C 0D DB    JMP $DB0D
.C:ffb1  4C 3A DB    JMP $DB3A
.C:ffb4  4C 73 D8    JMP $D873
.C:ffb7  4C 55 DB    JMP $DB55
.C:ffba  4C 66 DB    JMP $DB66
.C:ffbd  4C 95 D9    JMP $D995
.C:ffc0  4C 60 F5    JMP $F560
.C:ffc3  4C DD F2    JMP $F2DD
.C:ffc6  4C AF F7    JMP $F7AF
.C:ffc9  4C FE F7    JMP $F7FE
.C:ffcc  4C A6 F2    JMP $F2A6
.C:ffcf  4C 15 F2    JMP $F215
.C:ffd2  4C 66 F2    JMP $F266
.C:ffd5  4C 01 F4    JMP $F401
.C:ffd8  4C DD F6    JMP $F6DD
.C:ffdb  4C F6 F4    JMP $F4F6
.C:ffde  4C C3 F6    JMP $F6C3
.C:ffe1  4C 43 F3    JMP $F343
.C:ffe4  4C 05 F2    JMP $F205
.C:ffe7  4C A2 F2    JMP $F2A2
.C:ffea  4C 68 F7    JMP $F768



_cstoreplus
#include "enter.i65"
    .word over
#include "page.i65"
    .word cstore
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word exit
cstoreplus  ( addr c -- addr+1 )
	lda tos
	pha
	jsr slide
	ldy #0
	pla
	sta (tos),y
	jsr inctos
	jmp next

cfetchplus   ( addr -- addr+1 c )
	ldy #0
	lda (tos),y
	jsr inctos
	jmp pushya




$D1 = length of filename; 0=no name
($DA) = pointer to start of filename
$D3 = secondary address
$D4 = device number
$96 = status = 0
$9D = flag for load=0 or verify=1

($C9) tape save start address


F6E3 is the save money shot


D675 S "xyzzy",01,5c00,5e00
d4 = 1
d1 = 0
96 = 0
9d = 0
(da) = 0209

d4 = drv#
d1 = length
(da) = name
fb = to
fd = from
(c9) = to

.C:f3d4  20 95 F6    JSR $F695 (d6) = 27a #1 | 33a #2
.C:f3d7  20 57 F8    JSR $F857 press play on tape #
.C:f3da  20 49 F4    JSR $F449 searching...
.C:f3dd  A5 D1       LDA $D1
.C:f3df  F0 08       BEQ $F3E9
.C:f3e1  20 D3 F4    JSR $F4D3 search for a named tape header block
.C:f3e4  D0 08       BNE $F3EE
.C:f3e6  4C AD F5    JMP $F5AD file not found error? exit
.C:f3e9  20 E5 F5    JSR $F5E5 load next tape header
.C:f3ec  F0 F8       BEQ $F3E6
.C:f3ee  E0 01       CPX #$01
.C:f3f0  D0 EB       BNE $F3DD
.C:f3f2  A5 96       LDA $96
.C:f3f4  29 10       AND #$10
.C:f3f6  D0 74       BNE $F46C
.C:f3f8  20 7B F6    JSR $F67B (fb) = start (c9) = end
.C:f3fb  20 6D F4    JSR $F46D print LOADING or VERIFYING
.C:f3fe  4C A3 F8    JMP $F8A3 raw tape read, skips setting (fb) (c9)
.C:f401  A9 00       LDA #$00
.C:f403  85 9D       STA $9D
.C:f405  20 7D F4    JSR $F47D
.C:f408  20 CC F6    JSR $F6CC sets (fb) (c9) to start and end of basic, used in load
.C:f40b  A9 FF       LDA #$FF
.C:f40d  C5 9B       CMP $9B
.C:f40f  D0 FC       BNE $F40D
.C:f411  C5 9B       CMP $9B
.C:f413  D0 F8       BNE $F40D
.C:f415  20 56 F3    JSR $F356 load a basic program or other RAM image, after pointers have been set
.C:f418  A5 9D       LDA $9D
.C:f41a  D0 50       BNE $F46C
.C:f41c  20 2B F9    JSR $F92B wait for IRQ to return to normal. test for stop key
.C:f41f  A5 96       LDA $96
.C:f421  29 10       AND #$10
.C:f423  F0 09       BEQ $F42E
.C:f425  A0 00       LDY #$00
.C:f427  84 9E       STY $9E
.C:f429  A0 60       LDY #$60
.C:f42b  4C AF F5    JMP $F5AF SYNTAX ERROR?
.C:f42e  A0 AE       LDY #$AE
.C:f430  20 49 F3    JSR $F349 echo message from $FOOO table (Y=#0e = FILE OPEN)
.C:f433  20 51 F3    JSR $F351
.C:f436  D0 0B       BNE $F443
.C:f438  A5 CA       LDA $CA
.C:f43a  85 2B       STA $2B
.C:f43c  A5 C9       LDA $C9
.C:f43e  85 2A       STA $2A
.C:f440  4C AD B4    JMP $B4AD
.C:f443  20 22 B6    JSR $B622
.C:f446  4C 0B B6    JMP $B60B
.C:f449  20 51 F3    JSR $F351
.C:f44c  D0 1E       BNE $F46C

	size=c9-fb
	fb = pad
	c9 = pad+size

	to=blkbuf-size

	pad to size cmove
	to vmbuf !
	count packets #pkts !
