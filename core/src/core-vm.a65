; core-vm.a65
#echo .       core-vm.a65               Virtual Memory

;--------------------------------------------------------------
#if 0
name=B/BUF
stack=( -- 1024 )
tags=const,forth-83
!!!Constant
bytes per buffer = 1024
#endif
bperbuf
    jsr doconst
    .word BPERBUF

;--------------------------------------------------------------
#if 0
name=B/SCR
stack=( -- 1000 )
tags=const,vm
!!!Constant
bytes per screen.  Not what it usually means in other Forths,
(not blocks per screen = 1)
#endif
bperscr
    jsr doconst
    .word BPERSCR

;--------------------------------------------------------------
#if 0
name=BLKBUF
stack=( -- addr )
tags=vm
Returns the address of the 1K virtual memory block buffer.

There is only a single 1K fixed block buffer on the system, and
all data and screen packets are retrieved from the packet buffer
through it.

Copying a block to a different block can be achieved by using [[PAD]] as
temporary storage.  When [[REHASH]] rebuilds the symbol
table, it performs [[automatic memory allocation|AUTOMEM]]
and may move `BLKBUF` (and its contents) to a new location.

!!! pronounced: "b-l-k-buff"

```
: blkbuf   ( -- addr )
    symtab @  ?: symtab memsiz  @ b/buf - ;
```
#endif
#include "align.i65"
blkbuf
    ldy usersymtab+1            ; always a page boundary
    bne blkbuf02                ; or 0 if `symtab` is off
    ldy usermemsiz+1            ; okay use memsize in core mode
blkbuf02
    dey
    dey
    dey
    dey                         ; -1K (1024 bytes aka `b/buf`)
    lda #0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=EDITING?
stack=( -- flag )
tags=vm,ext,nosymbol
Retrieves the EDITING user variable

```
: editing?
    editing @ ;
```
#endif
editingq
    lda userediting+1
    jmp uncompressedq01

;--------------------------------------------------------------
#if 0
name=ISSCR?
stack=( -- flag )
tags=vm,ext,nosymbol
Returns a `flag`, `true` when `pkt` type is screen
`false` when the `pkt` type is data

```
: isscr?   ( -- flag )
    <n8 @ $4000 and ;
```
~#packrat
#endif
isscrq
    sec
    .byt $29                    ; AND imm
    ;fall through
;--------------------------------------------------------------
#if 0
name=UNCOMPRESSED?
stack=( -- flag )
tags=vm,ext,nosymbol
Returns a `flag`, `true` when the packet is simply stored by `cmove` or
`false` when the packet is runlength-encoded

```
: uncompressed?   ( -- flag )
    blk @ >pkt @ $4000 and ;
```
~#packrat
#endif
uncompressedq
    clc
    ldy #1
    lda (ACC+2*N8),y            ; packet header msb
    bcs uncompressedq01
    asl
uncompressedq01
    asl                         ; normalize `flag`
    jmp xpushc

;--------------------------------------------------------------
#if 0
name=CAS1BUF
stack=( -- $027A )
tags=const,vm
!!!Constant
Address of the first tape buffer (device #1)
#endif
cas1buf
    jsr doconst
    .word CAS1BUF

;--------------------------------------------------------------
#if 0
name=CAS2BUF
stack=( -- $033A )
tags=const,vm
!!!Constant
Address of the second tape buffer (device #1)
base address of cassette buffer #2, used (for now) as a line buffer
to unpack screens and blocks into lines
#endif
cas2buf
    jsr doconst
    .word CAS2BUF

;--------------------------------------------------------------
#if 0
name=(CASBUF)
stack=( -- 027a|033a )
tags=vm,kernel,nosymbol
Returns the tape buffer address for most recently accessed
device `FA ($d4)`

```
: (casbuf)   ( -- 027a|033a )
    [ SETCASBUF ] call  [ TAPE1 ] cliteral @ ;
```
#endif
casbuf
    brk
    .byt ext
    .word SETCASBUF
    .byt set | N0
    .word TAPE1
    .byt ldd | N0
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=RLENCODE
stack=( from to size -- targend uncompressed? )
tags=vm,sweet16
This works a lot like `cmove` with its `from to howmany` stack signature, but
the target is a `packet` of `virtual memory` that can be permanently stored
to cassette tape.  The other difference is the two return values provided by
`rlencode`.

* `targend` End of the compressed|stored output
* `uncompressed?` Flag reveals whether RLE compression was used.

encode length {srclen} bytes from source address {srcaddr} to
target address {targaddr}.  Return target end address {targend}
#endif
rlencode
    ; tos   src (pristine)
    ; n0    src (in)
    ; n1    size (in)
    ; n2    targ (out)
    ; n3    size (out)
    ; n4    repeat
    ; n5    prev
    ; n6    $100
    ; n7    targ (pristine)
    ; r11   size (pristine)
    brk
    .byt ld | TOS               ; size
    .byt st | N1                ; size (in)
    .byt st | N3                ; size (out)
    .byt st | R11               ; size (pristine)
    .byt pull                   ; to
    .byt st | N2                ; targ (out)
    .byt st | N7                ; targ (pristine)
    .byt pull                   ; from -- TOS = src (pristine)
    .byt st | N0                ; src (pristine)
    .byt set | N6               ; constant to initialize repeat counter
    .word $100
rlencode01
    .byt ld | N6                ; also unfindable character
rlencode02
    .byt st | N5                ; prev character
    .byt ld | N3
    .byt bm , <(rlencode07-*-2) ; is RL encoding no size benefit?
    .byt ld | N1
    .byt bz , <(rlencode06-*-2) ; done with input?
    .byt ldi | N0               ; read input stream
    .byt dcr | N1
    .byt sti | N2               ; write output stream
    .byt dcr | N3
    .byt cpr | N5               ; compare to prev
    .byt bnz , <(rlencode02-*-2) ; different? go get more
    .byt ld | N6
    .byt st | N4                ; count backwards from 256
    .byt dcr | N4               ; count the one already in output stream
rlencode03
    .byt dcr | N4
    .byt bz , <(rlencode04-*-2) ; overflow?
    .byt ld | N1
    .byt bz , <(rlencode04-*-2) ; end of input?
    .byt ldi | N0               ; get from input stream
    .byt dcr | N1
    .byt cpr | N5
    .byt bz , <(rlencode03-*-2) ; same char? loop

    .byt dcr | N0               ; different char?
    .byt inr | N1               ; un-get from input stream
rlencode04                      ; overflow/end of input
    .byt ld | N6
    .byt sub | N4
    .byt sti | N2               ; write count to output stream
    .byt dcr | N3
    .byt br , <(rlencode01-*-2)

rlencode06                      ; win
    .byt ld | N2                ; targ (out)
    .byt st | TOS
    .byt sub | ACC
    .byt push
    .byt nxt
;    rlencode
;( targend uncompressed?        ; floor  pkt )

rlencode07                      ; lose - copy
    .byt ld | TOS
    .byt st | N0                ; keep pristine TOS
    .byt ld | R11               ; return original `size`
    .byt add | N7               ; +pristine targ
    .byt st | TOS
    .byt set | ACC
    .word $4000
    .byt push
    .byt ld | N0                ; from
    .byt push
    .byt ld | N7                ; to
    .byt push
    .byt ld | R11               ; howmany
    .byt push
    .byt rtn
    jmp cmove

;--------------------------------------------------------------
#if 0
name=RLDECODE
stack=( from to size -- )
tags=vm,sweet16
decode length {srclen} bytes beginning at source address
{srcaddr} to the target address (targaddr).
#endif
rldecode
    jsr harvests4
    brk
    .byt set | N4
    .word $100
rldecode01
    .byt ld | N4
    .byt st | N2                ; set prev to unmatchable value
rldecode02
    .byt ld | TOS
    .byt bz , <(rldecode06-*-2)
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; read source stream
    .byt sti | N1               ; write target stream
    .byt cpr | N2
    .byt st | N2
    .byt ld | R13
    .byt bnz , <(rldecode02-*-2) ; different? go get more
rldecode03
    .byt dcr | TOS              ; decrement source counter
    .byt ldi | N0               ; get the repeat count
    .byt bnz, <(rldecode04-*-2)
    .byt ld | N4
rldecode04
    .byt st | N3
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
rldecode05
    .byt dcr | N3
    .byt bz , <(rldecode01-*-2)
    .byt ld | N2
    .byt sti | N1               ; write target stream
    .byt br , <(rldecode05-*-2)
rldecode06
    .byt pull                   ; drop srclen
    .byt nxt

;--------------------------------------------------------------
#if 0
name=PKT.SIZE
stack=( pkt -- pkt size )
tags=vm,ext,nosymbol
Return unaltered `pkt` and `size` of this packet

```
: pkt.size    ( pkt -- pkt size )
    dup @ psize ;
```
#endif
#include "align.i65"
_pktsize
    jsr enter
#include "page.i65"
    .word dup
#include "page.i65"
    .word fetch
#include "page.i65"
    .word psize
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PKT.NXT
stack=( pkt -- pkt' )
tags=vm,ext,nosymbol
Return next

```
: pkt.next    ( pkt -- pkt' )
    pkt.size - ;
```
#endif
#include "align.i65"
_pktnxt
    jsr enter
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word minus
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=PSIZE
stack=( header -- addr )
tags=vm,ext,nosymbol
Return size of this packet header

```
: psize  ( header -- size )
    $7FF and ;
```
#endif
psize
    lda tos+1
    and #7
    sta tos+1
    jmp next

;--------------------------------------------------------------
#if 0
name=>PKT
stack=( u -- )
tags=vm,ext
Set `n8` to `pkt` address of block `u`

```
: >pkt
    blkbuf 2-
    begin
        over
    while
        1-under
        @+ psize - 2-
        dup @ psize -
    repeat
    n8 ! ;
```
#endif
#include "align.i65"
_topkt
    jsr enter
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
topktb01
#include "page.i65"
    .word over
#include "pass.i65"
    .word qbranch
    .byt <(topktb02-*+1)
#include "page.i65"
    .word oneminusunder
#include "page.i65"
    .word _pktnxt
#include "pass.i65"
    .word branch
    .byt <(topktb01-*+1)
#include "pass.i65"
topktb02
    .word clit
    .byt ACC+2*N8
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=3C@
stack=( addr -- d )
tags=nucleus

 fetches three bytes as a double.  Useful for retrieving screen
 linewrap bits from the beginning of the block buffer or the jiffy
 clock

|msb|addr+0|
|2sb|addr+1|
|lsb|addr+2|

```
: 3c@   ( addr -- d )
     dup 1+ @ swap c@ ;
     c@+ swap @ ;
     @+ swap c@ ;

threecfetch
    jsr slip
    ldy #2
    jsr fetchunders
    jmp cfetch
;[11]

fetchunders
    lda (tos),y         ; msb
    sta stackl,x
    dey
    lda (tos),y
    sta stackh,x
    rts
```
#endif
#include "align.i65"
_threecfetch
    jsr enter
#include "page.i65"
    .word cfetchplus
#include "page.i65"
    .word swap
#include "page.i65"
    .word fetch
#include "page.i65"
    .word cswap
#include "page.i65"
    .word swap
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=3C!
stack=( d addr -- )
tags=nucleus
 store low 3 bytes of d at addr in jiffy clock order

|msb|addr|
|2sb|addr+1|
|lsb|addr+2|

Order inverted to write timer last for EVENTS, and to find the bits from
left to right for linewrap masks

```
: 3c!    ( lo hi addr -- )
    1+ rot cswap !+ 3- c! ;
```
#endif
#include "align.i65"
_threecstore
    jsr enter
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word rot
#include "page.i65"
    .word cswap
#include "page.i65"
    .word _storeplus
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word cstore                ; low word
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=-@
stack=( nfa -- cfa )
tags=extra
decrement `tos` and fetch the value

#endif
minusfetch
;--------------------------------------------------------------
#if 0
name=NAME>
stack=( nfa -- cfa )
tags=compiler
Returns the Code Field Address (`cfa`) of the provided Name
Field Address (`nfa`)

```
: name>   ( nfa -- cfa )
    2- @ ;
```
#endif
namefrom
    jsr tos2minus
namefrom01
    jmp fetch

;--------------------------------------------------------------
#if 0
name=WRAPZAP12
stack=( -- )
tags=editor,subroutine,nosymbol
Zero R0..R5 (12 bytes)

!!!pronounced: "wrap zap twelve"
#endif
wrapzap12
    jsr slip                    ; dup, so this won't overwrite `tos`
    lda #12                     ; default # of bytes to clear
    ;fall through
;--------------------------------------------------------------
#if 0
name=WRAPZAPS
stack=( x -- 0 )
tags=editor,subroutine,nosymbol
Does not alter data stack pointer, but `x` is safely stored in `z`

|pass:|A|bytes to clear|
|return:|A|0|
||Z|stack|

!!!pronounced: "wrap zap"
#endif
wrapzaps
    stx z                       ; preserve Forth data stack pointer
    tax
    lda #0
wrapzap01
    dex
    sta 0,x
    bne wrapzap01
    ldx z
    rts

;--------------------------------------------------------------
#if 0
name=WRAPROLLS
stack=( x -- 0 )
tags=editor,subroutine,nosymbol
pass in `c` flag and `x` as starting address,

appends linewrap bit to a zeropage double beginning at `x`

!!!pronounced: "wrap rolls"
#endif
wraprolls
    rol 0,x
    rol 1,x
    rol 2,x
    rol 3,x
    rts
;[9]

;--------------------------------------------------------------
#if 0
name=WRAPUMAX
stack=( -- )
tags=editor,subroutine,nosymbol
Iteratively double a 32-bit `wrapd` until it is left-aligned (as close to
`umax` as possible without going over)

!!!pronounced: "wrap umax"
#endif
wrapumax
    sec                         ; return the `1` bit for line 0
    lda 3,x
    bmi wrapumax02
wrapumax01
    jsr wraprolls
    bpl wrapumax01
wrapumax02
    rts

;--------------------------------------------------------------
#if 0
name=WRAP@
stack=( -- wrapd  )
tags=primitive
Retrieve the 25-bit linewrap table at `$E0..F8` as a double

#endif
wrapfetch
    jsr wrapzap12
    ldy #$FF
    ldx #tos                    ; put it in `tos(hi) n0(lo)`
wrapfetch01
    iny
    lda LDTB1,y
    asl
    jsr wraprolls
    beq wrapfetch01
    ldx z
    ldy ACC+2*N0+1
    lda ACC+2*N0
    jmp pushya

;--------------------------------------------------------------
#if 0
name=WRAP!
stack=( wrapd -- )
tags=primitive

Updates the linewrap table at $E1-F8 to reflect the low 24 bits
in double `wrapd`.  Since line 0 ($E0) is never a continuation
line, (always $80) it is not written to.  Only 24 bits are
written to $E1-$F8, not 25.  Although unused, the most
significant (2^24) bit may be set, as a framing bit, used
to detect when the wrap double is full.

#endif
wrapstore
    jsr swaps
    jsr harvests2
    stx z
    ldx #tos
    jsr wrapumax
    ldx #<(-25)
wrapstore01
    txa
    asl <(LDTB1+25),x
    ldx #tos
    jsr wraprolls
    tax
    ror <(LDTB1+25),x
    inx
    bne wrapstore01
    ldx z
    jmp drop

;--------------------------------------------------------------
#if 0
name=NOWRAP
stack=( -- )
tags=editor,nosymbol

 reset the linewrap table and force this block to be a screen
 even if it was a data packet

~#packrat
#endif
#include "align.i65"
_nowrap
    jsr enter
#include "page.i65"
    .word true
#include "page.i65"
    .word true
#include "page.i65"
    .word wrapstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BUF?
stack=( -- buf )
tags=vm,nosymbol
Return address of buffer


```
: buf?   ( -- buf )
    editing? ?: vidram blkbuf ;
```
#endif
#include "align.i65"
_bufq
    jsr enter
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word vidram
    .word blkbuf
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=DIRTYBUF
stack=( -- )
tags=vm,nosymbol
Mark `blkbuf` dirty to force `block` to reload from `vmbuf`

```
: dirtybuf   ( -- )
    prev on ;
```
#endif
#include "align.i65"
_dirtybuf
    jsr enter
#include "page.i65"
    .word prev
#include "page.i65"
    .word on
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=#BLK!
stack=( -- )
tags=vm,nosymbol
Reset `vmbuf` pointer and `#blk` by running through all packets

```
: #blk!   ( -- )
    #blk off  blkbuf 2-
    begin
        pkt.size ?dup
    while
        #blk 1+!
        -
    repeat
    vmbuf ! ;

: #blk!   ( -- )
    #blk 8 erase  dirtybuf
    blkbuf 2-
    begin
        dup pkt.nxt tuck <>
    while
        #blk 1+!
    repeat
    vmbuf ! ;
```
#endif
#include "align.i65"
_numblkstore
    jsr enter
#include "page.i65"
    .word numblk
#include "page.i65"
    .word eight
#include "page.i65"
    .word erase
#include "page.i65"
    .word _dirtybuf
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
numblkstore01
    .word _pktsize
#include "page.i65"
    .word qdup
#include "pass.i65"
    .word qbranch
    .byt <(numblkstore02-*+1)
#include "page.i65"
    .word numblk
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word minus
#include "pass.i65"
    .word branch
    .byt <(numblkstore01-*+1)
#include "page.i65"
numblkstore02
    .word vmbuf
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=MKSCR
stack=( -- addr )
tags=compiler,nosymbol

#endif
mkscr
    jsr docreate
    .byt 5, $FF, $FF, $FF, $05, $80

;--------------------------------------------------------------
#if 0
name=MKDATA
stack=( -- addr )
tags=compiler,nosymbol

#endif
mkdata
    jsr docreate
    .byt 2, $02, $40

;--------------------------------------------------------------
#if 0
name=(PKT+)
stack=( size -- size floor #blk )
tags=compiler,nosymbol

#endif
ppktplus
    brk
    .byt set | N0
    .word usernumblk
    .byt popd | N0              ; `vmbuf`
    .byt st | N8                ; `pkt`
    .byt sub | TOS              ; `pkt` - `size`
    .byt std | N0               ; set `vmbuf`
    .byt push
    .byt sub | ACC
    .byt std | TOS              ; `vmbuf off`
    .byt ld | N0                ; #blk
    .byt push
    .byt nxt

;--------------------------------------------------------------
#if 0
name=PKT+
stack=( -- )
tags=compiler,nosymbol
Append a new data or screen packet (per `editing`) to `vmbuf` tail

```
: pkt+   ( -- )
    editing? ?: mkscr mkdata
    count (pkt+)
    1+! swap cmove ;
```
#endif
#include "align.i65"
_pktplus
    jsr enter
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word mkscr
    .word mkdata
#include "page.i65"
    .word count
#include "page.i65"
    .word ppktplus
#include "page.i65"
    .word oneplusstore
#include "page.i65"
    .word swap
#include "page.i65"
    .word cmove
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SCREDIDX
stack=( -- index  )
tags=vm,ext,nosymbol
return `index`:
0 quitmode; data
2 quitmode; scr
4 editmode; data
6 editmode; scr

~#packrat
#endif
scredidx
    ldy #1
    lda (ACC+2*N8),y
    asl
    tya
    and userediting
    rol
    asl
    jmp push0a

;--------------------------------------------------------------
#if 0
name=DWRAP@
stack=( -- wrapd  )
tags=vm,ext,nosymbol

```
: dwrap@   ( -- wrapd )
    3c@ benjamin or ;
```
#endif
#include "align.i65"
_dwrapfetch
    jsr enter
#include "page.i65"
   .word _threecfetch
#include "page.i65"
   .word benjamin
#include "page.i65"
   .word orx                    ; the Cars guy
#include "pass.i65"
   .word exit

;--------------------------------------------------------------
#if 0
name=PKTWRAP
stack=( -- addr )
tags=vm,ext,nosymbol
address of 3-byte area where `wrapd` is stored in the block buffer

~#packrat
#endif
#include "align.i65"
_pktwrap
    jsr enter
#include "pass.i65"
   .word zpfrom
   .byt ACC+2*N8
#include "page.i65"
   .word threeminus
#include "pass.i65"
   .word exit

;--------------------------------------------------------------
#if 0
name=BUFWRAP
stack=( wrapd -- )
tags=vm,ext,nosymbol
address of 3-byte area where `wrapd` is stored in the block buffer

~#packrat
#endif
#include "align.i65"
_bufwrap
    jsr enter
#include "page.i65"
   .word blkbuf
#include "page.i65"
   .word bperscr
#include "page.i65"
   .word plus
#include "pass.i65"
   .word exit

;--------------------------------------------------------------
#if 0
name=BUFWRAP!
stack=( wrapd -- )
tags=vm,ext,nosymbol
address of 3-byte area where `wrapd` is stored in the block buffer

~#packrat
#endif
#include "align.i65"
_bufwrapstore
    jsr enter
#include "page.i65"
    .word _bufwrap
#include "page.i65"
   .word _threecstore
#include "pass.i65"
   .word exit

;--------------------------------------------------------------
#if 0
name=EMPTY-BUFFERS
stack=( -- )
tags=i/o,forth-83
Unassign all virtual memory.  UPDATEed blocks are not written
to mass storage.

```
: empty-buffers   ( -- )
    blkbuf 2-  dup vmbuf !  off  blk off  scr off  #blk! ;
```
#endif
#include "align.i65"
_emptybuffers
    jsr enter
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word twominus
#include "page.i65"
    .word off
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=?MKPKTS
stack=( u -- )
tags=vm,nosymbol


```
: ?mkpkts   ( u -- )
    begin                       \ make packets loop
        #blk @ over 1+ <
     while
        pkt+
    repeat
    >pkt ;                 \ sets `n8`

#endif
#include "align.i65"
_qmkpkts
    jsr enter
#include "page.i65"
qmkpkts01
    .word numblk
#include "page.i65"
    .word fetch
#include "page.i65"
    .word over
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word lt
#include "pass.i65"
    .word qbranch
    .byt <(qmkpkts02-*+1)
#include "page.i65"
    .word _pktplus
#include "pass.i65"
    .word branch
    .byt <(qmkpkts01-*+1)
#include "page.i65"
qmkpkts02
    .word _topkt
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=BLOCK
stack=( blk -- buf )
tags=vm,fig,forth-79,forth-83
Unpack a screen or data packet from `vmbuf` to `blkbuf` or `vidram`

```

: block   ( u -- addr )
    ?mkpkts curbuf              ( addr )
    prev 2@ =
    editing? 0= and  ?exit      \ block already loaded?
    blk @ prev !                \ inhibit redundant reloading
    dup b/buf  isscr?
    ?: blank erase              \ wipe the buffer
    dup pkt.size tuck -
    isscr?
    if
        3-under <n8 3- dwrap@
        editing?  ?: wrap! bufwrap!
    then
    -rot uncompressed?
    ?: cmove rldecode ;

: curpkt   ( -- )
    editing? ?: scr prev
    >pkt drop ;

: update   ( -- )
    curpkt

    bufwrap dwrap!

: block   ( u -- addr )
    begin                       \ make packets loop
        #blk @ over 1+ <
     while
        pkt+
    repeat
    >pkt                        \ sets `n8`
    editing?  ?: vidram blkbuf  ( addr )
    nip                         \ don't need `pkt` address
    prev 2@ =                   \ blkbuf already loaded?
    editing? 0= and  ?exit
    blk @ prev !                \ inhibit redundant reloading
    dup b/buf isscr?
    ?: blank erase
    dup pkt.size tuck -
    isscr?
    if                          \ handle linewrap for screen packets
        3-under <n8 3- dwrap@
        editing? ?: wrap! bufwrap!
    then
    -rot                        \ unpack or copy the contents to vidram|blkbuf
    uncompressed? ?: cmove rldecode ;

: block   ( n -- addr )
    ?mkpkts  buf? prev 2@ =
    editing? 0= and  ?exit
    blk@ prev !  dup b/buf
    isscr? ?: blank erase
    dup pkt.size tuck - isscr?
    if
        3-under <n8 3- dwrap@
        editing? wrap! bufwrap!
    then
    uncompressed? ?: cmove rldecode ;
```
~#packrat
#endif
#include "align.i65"
_block
    jsr enter
#include "page.i65"
    .word _qmkpkts
#include "page.i65"
    .word _bufq
#include "page.i65"
    .word prev
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word eq
#include "page.i65"
    .word editingq
#include "page.i65"
    .word zeq
#include "page.i65"
    .word andx
#include "page.i65"
    .word _qexit
#include "page.i65"
    .word blkfetch
#include "page.i65"
    .word prev
#include "page.i65"
    .word store
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word pquerycolon
    .word blank
    .word erase
#include "page.i65"
    .word dup
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word tuck
#include "page.i65"
    .word minus
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(blk02-*+1)
#include "page.i65"
    .word threeminusunder
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N8               ; `pkt`
#include "page.i65"
    .word threeminus
#include "page.i65"
    .word _dwrapfetch
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word wrapstore
    .word _bufwrapstore
#include "page.i65"
blk02
    .word uncompressedq
#include "pass.i65"
    .word pquerycolon
    .word cmove
    .word rldecode
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(UPD1)
stack=( source size b/buf vmbuf -- source vmbuf' floor from to howmany )
tags=nosymbol
First, `update` creates

* calculate `floor`
* calculate new `vmbuf`
* set up for `cmove`

~#packrat
#endif
pupd1
    brk
    .byt ext
    .word harvests4
    .byt ld | N8                ; `pkt`
    .byt sub | N1               ; `- 1024`
    .byt st | N2                ; `floor`
    .byt ldd | TOS              ; vmbuf @
    .byt sub | N1               ; `- 1024`
    .byt add | N0               ; `+ size`
    .byt st | N3                ; `vmbuf'`
    .byt st | N0                ; `to`
    .byt popd | TOS             ; vmbuf
    .byt st | N1
    .byt ld | N2                ; `floor`
    .byt sub | N0               ; `- vmbuf'`
    .byt st | TOS               ; `howmany`
    .byt ext
    .word plants8
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(UPD2)
stack=( vmbuf' targend mask -- vmbuf' from to howmany )
tags=nosymbol
* set packet header
* close gap at end of new packet
* set `vmbuf`
#endif
pupd2
    brk
    .byt ext
    .word harvests4
    .byt ld | N1                ; targend+3
    .byt sub | N7               ; - floor
    .byt st | N2
    .byt add | TOS
    .byt std | N8               ; write updated packet header
    .byt ld | N1
    .byt sub | N0
    .byt st | TOS               ; `howmany`
    .byt ld | N0
    .byt st | N1
    .byt ld | N8
    .byt sub | TOS
    .byt st | N0
    .byt st | N2
    .byt popd | N8              ; leave `pkt` undisturbed
    .byt ext
    .word plants6
    .byt nxt

;--------------------------------------------------------------
#if 0
name=SUP
stack=( vidram|blkbuf scr|blk -- )
tags=forth-83,vm,nosymbol


```
\ sprog of update
: sup ( vidram|blkbuf -- )
    @ >pkt pkt.size b/buf 2nip vmbuf
    (upd1) cmove                ;( source vmbuf floor )
    rot tuck
    isscr?
    if
        b/scr -trailing
    else
        b/buf -nulls
    then
    nip rlencode
          ?: b/scr b/buf
    isscr?  ?: -trailing -nulls nip
    rlencode
    isscr?
    if
( wrapd vmbuf' uncompressed? targend )
        >r twoswap r@ 3c! r> 3+
    then


    rlencode
    editing? vidram and
    (upd2)
    uncompressed?  ?: cmove rlencode ;
#endif
#include "align.i65"
_sup
    jsr enter
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word nip
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word pupd1
#include "page.i65"
    .word cmove                 ; temporarily allocate 1K space in the packet
#include "page.i65"
    .word rot
#include "page.i65"
    .word tuck
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(sup01-*+1)
#include "page.i65"
    .word bperscr
#include "page.i65"
    .word dashtrailing
#include "pass.i65"
    .word branch
    .byt <(sup02-*+1)
#include "page.i65"
sup01
    .word bperbuf
#include "page.i65"
    .word dashnulls
#include "page.i65"
sup02
    .word nip
#include "page.i65"
    .word rlencode              ; attempt to run-length encode the buffer
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(sup03-*+1)
#include "page.i65"
    .word vidram
#include "page.i65"
    .word orx
#include "page.i65"
    .word tor
#include "page.i65"
    .word twoswap
#include "page.i65"
    .word third
#include "page.i65"
    .word _threecstore           ; append linewrap
#include "page.i65"
    .word threeplus
#include "page.i65"
    .word rfrom
#include "page.i65"
sup03
    .word twoplusunder
#include "page.i65"
    .word pupd2
#include "page.i65"
    .word twominus
#include "page.i65"
    .word cmovegt               ; move the bottom of `vmbuf` back up
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word store                 ; set `vmbuf`
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VMBOTTOM
stack=( -- )
tags=vm
Return the lowest used address of `vmbuf` (including prepended `STOP-DEL`
screen packet, if present)

```
: vmbottom   ( -- addr )
    vmbuf @ pkt.nxt ;
```
#endif
#include "align.i65"
_vmbottom
    jsr enter
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _pktnxt
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=UPDATE
stack=( -- )
tags=forth-83,vm
Copies and compresses from either the `vidram` or `blkbuf` into a
[[virtual memory packet buffer|PETTIL system memory map]].  `update`
is the antonym of `block` (which retrieves from `vmbuf`).

tests:
~\ block 0
~\ nonzero block numbers
~\ empty block
~\ blank block
~\ screen 1000+3 in blkbuf
~\ for all combinations of `isscr?` and `editing?`
~\ for both packet types
~\ with and without compression
~\ fill blkbuf half with $DEADBEEF
~\ fill blkbuf all with $DEADBEEF
~\ fill blkbuf half with '!'
~\ fill blkbuf all with '!'
~\ fill screen with 80-column uncompressable ($555555 wrap)
~\ fill screen with normal source code
~\ fill screen half with '!'
~\ fill blkbuf all with '!'
~\ fill blkbuf all with '!'

```

<n8 3- drwap@                   \ get wrap from the packet (block)

<n8 3- dwrap!                   \ set packet wrap (update)

editing? ?: wrap! bufwrap!      \ block

vmbottom dup 1024 - <n8 pkt.size dup>r +under r> - third - 2+
cmove

: update   ( -- )
    \ source is either (isscr?) `vidram` or `blkbuf`
    editing? 2* isscr? xor 2*  ( -4 -2 0 2 )





    editing? ?: scr blk  @ >pkt
    editing?
    if
        isscr?
        if
            wrap@
            vidram scr sup
        \ else
        \   nothing to do -- vidram can't hold data block
        then
    else
        isscr?
        if
            blkbuf 1000 + 3c@
        then
        blkbuf prev sup
    then ;

```
#endif
#include "align.i65"
_update
    jsr enter
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word pquerycolon
    .word scr
    .word prev
#include "page.i65"
    .word fetch
#include "page.i65"
    .word _topkt
#include "page.i65"
    .word _vmbottom
#include "page.i65"
    .word dup
#include "page.i65"
    .word bperbuf
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word minus
#include "pass.i65"
    .word zpfrom
    .byt ACC+2*N8
#include "page.i65"
    .word _pktsize
#include "page.i65"
    .word duptor
#include "page.i65"
    .word plusunder
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word minus
#include "page.i65"
    .word third
#include "page.i65"
    .word minus
#include "page.i65"
    .word twoplus
#include "page.i65"
    .word cmove
#include "page.i65"
    .word xyzzy

#include "page.i65"
    .word fetch
#include "page.i65"
    .word fetch
#include "page.i65"
;vmbottom dup 1024 - <n8 pkt.size dup>r +under r> - third -
#include "page.i65"
    .word editingq
#include "pass.i65"
    .word qbranch
    .byt <(upd01-*+1)
#include "page.i65"
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(upd02-*+1)
#include "page.i65"
    .word wrapfetch
#include "page.i65"
    .word vidram
#include "page.i65"
    .word scr
#include "page.i65"
    .word _sup
#include "pass.i65"
    .word branch
    .byt <(upd02-*+1)
#include "page.i65"
upd01
    .word isscrq
#include "pass.i65"
    .word qbranch
    .byt <(upd03-*+1)
#include "page.i65"
    .word _bufwrap
#include "page.i65"
    .word twofetch
#include "page.i65"
upd03
    .word blkbuf
#include "page.i65"
    .word prev
#include "page.i65"
    .word _sup
#include "pass.i65"
upd02
    .word exit

;--------------------------------------------------------------
#if 0
name=STASH-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol,magic-number
Subroutine to preserve the data stack pointer, stack, Sweet16 and
other Forth zero page during a BASIC system call

#endif
stashforth
    stx stashforth01
    jsr aufwiedersehen
    lda #2                      ; set direct mode in CHRGET routine
    sta $78                     ; so we get prompts during i/o
    rts
stashforth01 .byt 0             ; temp storage for X register during tape I/O

;--------------------------------------------------------------
#if 0
name=RESTORE-FORTH
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Restore Forth stack after BASIC system call

#endif
restoreforth
    jsr aloha2
    ldx stashforth01            ; this messes up BASIC's USR() function
    jmp exit

;--------------------------------------------------------------
#if 0
name=DOTAPEIO
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Perform a ROM call framed between calls to `aloha`. This is
needed in particular for tape I/O, which might error out to a
Commodore BASIC `ready.` prompt.

Like `execute` and the Sweet-16 interpreter, this word
uses the machine stack ($0100-$01ff) and RTS trick to transfer
control from one subroutine to the next, so that code executes
in this order:

~wut?  this is a little crashy returning from hitting the [[STOP]] key

```
stashforth
RTS
caller's ROM routine
RTS
restoreforth
EXIT
```
#endif
#include "align.i65"
_dotapeio
    jsr enter
#include "pass.i65"
    .word plit
    .word restoreforth-1
#include "page.i65"
    .word caller
#include "page.i65"
    .word fetch
#include "page.i65"
    .word oneminus
#include "page.i65"
    .word twotor
#include "pass.i65"
    .word stashforth

;--------------------------------------------------------------
#if 0
name=(SAVEPRG)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
psaveprg
    jsr _dotapeio
    .word SAVEPRG

;--------------------------------------------------------------
#if 0
name=(READHEAD)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preadhead
    jsr _dotapeio
    .word READHEAD

;--------------------------------------------------------------
#if 0
name=(READDATA)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
#endif
preaddata
    jsr _dotapeio
    .word READDATA

;--------------------------------------------------------------
#if 0
name=CURRNAME
stack=( -- addr )
tags=vm,i/o
filename

todo: All parameter and no code, maybe a string variable?
#endif
currname
    jsr docreate
    .byt (currname01-*-1)
    .asc "PETTILPACKETS",
currname01
    .asc              "           "
        ;"@0:full16characters,s,w "
        ; 123456789.123456789.1234

;--------------------------------------------------------------
#if 0
name=FILE
stack=( filename device secondary -- )
tags=vm,i/o
Set up parameters for file i/o

```
: file
    sa# ! drv# ! filename ! ;
```
#endif
#include "align.i65"
_file
    jsr enter
#include "page.i65"
    .word sanum
#include "page.i65"
    .word store
#include "page.i65"
    .word drvnum
#include "page.i65"
    .word store
#include "page.i65"
    .word filename
#include "page.i65"
    .word store
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(FILE)
stack=( -- )
tags=vm,i/o,nosymbol
Called at start of tape or disk i/o, sets up zero page variables.
Retrieves DRV# SA# and FILENAME uservariables and stores them
in zero page locations FA SA FNLEN FNADR.

Relies on [[SA#]], [[DRV#]], and [[FILENAME]] being adjacent in uarea

|zero page|<|value|set by|description|h
|^STATUS|^96|^0|rom|^i/o status byte|
|^VERCK|^9d|^0|(file)|^0=load; 1=verify|
|^TAPEID|^b4|^1|(prg-file)|^01=PRG; 02=data; 04=SEQ; 05=EOT|
|^SAL|^c7-c8|^||^start address|
|^EAL|^c9-ca|^||^end address|
|^FNLEN|^d1|^FILENAME[0]|(file)|^File name length|
|^LA|^d2|^0|(file)|^logical file #|
|^SA|^d3|^SA#|(prg-file)|Secondary address|
|^FA|^d4|^DRV#|(file)|Device number|
|^FNADR|^da-db|^FILENAME[1..]|(file)|^File name address|
|^STAL|^fb-fc|^||^start address|

|save|load|verify|open|name|address|description|h
|^?|^?|^?|^?|^FNLEN|^d1|^Length of file name|
|^?|^?|^?|^?|^FNADR|^da-db|^File name address|
|^&nbsp;|<|<|<|<|<|<|
|^0|^0|^0|^0|^STATUS|^96|^Status byte ST|
|^?|^0|^1|^?|^VERCK|^9d|^Load/Verify flag (0,1)|
|^01|^?|^?|^?|^TAPEID|^b4|^Tape buffer leading char<br/>01=PRG 05=EOT|
|^?|^?|^?|^?|^EAL|^c9-ca|^Tape end address|
|^?|^?|^?|^?|^LA|^d2|^logical file number|
|^?|^?|^?|^?|^SA|^d3|^secondary address|
|^?|^?|^?|^?|^FA|^d4|^First address (device number)|
|^?|^?|^?|^?|^TAPE1|^d6|^Pointer - start of tape buffer|
|^?|^?|^?|^?|^FSBLK|^de|^Cassette read/write block count|
|^?|^?|^?|^?|^STAL|^fb-fc|^I/O start address|
|''?'' = don't care<br/>''x'' = don't initialize|<|<|<|<|<|<|f

#endif
pfile
    brk
    .byt set | N0
    .word userfilename
    .byt ldd | N0               ; FILENAME
    .byt st | N2                ; pointer to FILENAME[0] or 0
    .byt bz , <(pfile01-*-2)
    .byt ldi | N2
pfile01
    .byt set | N1               ; N1 walks through FNLEN, LA, SA, FA on a PET
    .word FNLEN
    .byt sti | N1               ; set FNLEN ($d1)

;    .byt set | N1
;    .word LA
    .byt sub | ACC              ; 0
    .byt sti | N1               ; set LA ($d2)

;    .byt set | N1
;    .word SA
    .byt ldd | N0               ; get SA#
    .byt sti | N1               ; set SA ($d3)

;    .byt set | N1
;    .word FA
    .byt ldd | N0               ; DRV#
    .byt sti | N1               ; set FA ($d4)

    .byt set | N1
    .word FNADR
    .byt ld | N2
    .byt std | N1               ; set FNADR ($da)
    .byt nxt

;--------------------------------------------------------------
#if 0
name=(PRG-FILE)
stack=( -- )
tags=vm,i/o,nosymbol
Turn off SA# and set up for PRG file tape i/o

* sets SA# = 0
* sets TAPEID = 1
* invoke [[(FILE)]]
** copy `SA#` to SA
** copy `DRV#` to FA
** copy `FILENAME` to FNADR, FNLEN
** set TAPEID to $01 (PRG)
** set TAPE1 to point to CAS1BUF (or possibly CAS2BUF on a real PET)

```
: (prg-file)   ( -- )
    sa# off  1 TAPEID c!  (file) ;
```
#endif
#include "align.i65"
_pprgfile
    jsr enter
#include "page.i65"
    .word sanum
#include "page.i65"
    .word off
#include "page.i65"
    .word one
#include "pass.i65"
    .word clit                  ; ~ can remove this if using $f619
    .byt TAPEID
#include "page.i65"
    .word cstore
#include "page.i65"
    .word pfile
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=SAVE-BUFFERS
stack=( -- )
tags=vm,forth-83,i/o,kernel
Writes the virtual memory area between [[VMBUF]] and [[BLKBUF]] out
to a PRG file on cassette or disk

Also called by STOP-S in the editor

```
: save-buffers   ( -- )
    (prg-file)
    (vmbuf) next-1
    >r 2>r
    [ SETEALSTAL , ]
    (saveprg) ;
```
#endif
#include "align.i65"
_savebuffers
    jsr enter
#include "page.i65"
    .word _pprgfile             ; set up z.p. device, secondary, filename
#include "page.i65"
    .word vmbuf
#include "page.i65"
    .word fetch
#include "page.i65"
    .word blkbuf
#include "pass.i65"
    .word clit
    .byt <(next-1)              ; stupid stack tricks
#include "page.i65"
    .word tor
#include "page.i65"
    .word twotor
#include "page.i65"
    .word SETEALSTAL            ; invoke a ROM routine, RTS to NEXT
#include "page.i65"
    .word psaveprg
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=(LOADVERIFY)
stack=( -- )
tags=vm,i/o,kernel,nosymbol
Load or compare a batch of packets from tape to [[VMBUF]]

```
: (loadverify)   ( flag -- )
    [ VERCK ] literal c!
    (prg-file) (readhead)
    blkbuf dup (casbuf) 1+ dup>r
    2@ - - r> 2! ;
```
#endif
#include "align.i65"
_ploadverify
    jsr enter
#include "pass.i65"
    .word clit
    .byt VERCK
#include "page.i65"
    .word cstore
#include "page.i65"
    .word _pprgfile
#include "page.i65"
    .word preadhead
#include "page.i65"
    .word blkbuf
#include "page.i65"
    .word dup
#include "page.i65"
    .word casbuf
#include "page.i65"
    .word oneplus
#include "page.i65"
    .word duptor
#include "page.i65"
    .word twofetch
#include "page.i65"
    .word minus
#include "page.i65"
    .word minus
#include "page.i65"
    .word rfrom
#include "page.i65"
    .word twostore
#include "page.i65"
    .word preaddata
#include "page.i65"
    .word _numblkstore
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=LOAD-BUFFERS
stack=( -- )
tags=vm,i/o,kernel
Load a batch of packets from the file to [[VMBUF]]

called by STOP-L in the editor

```
: load-buffers   ( -- )
    0 (loadverify) ;
```
#endif
#include "align.i65"
_loadbuffers
    jsr enter
#include "page.i65"
    .word zero                  ; LOAD
#include "page.i65"
    .word _ploadverify
#include "pass.i65"
    .word exit

;--------------------------------------------------------------
#if 0
name=VERIFY-BUFFERS
stack=( -- )
tags=vm
Verifies the [[VMBUF]] area following a write

called by STOP-V in the editor

```
: verify-buffers   ( -- )
    1 (loadverify)
    ST c@  if  ." error"  then ;
```
#endif
#include "align.i65"
_verifybuffers
    jsr enter
#include "page.i65"
    .word one                   ; VERIFY
#include "page.i65"
    .word _ploadverify
#include "pass.i65"
    .word clit
    .byt STATUS
#include "page.i65"
    .word cfetch
#include "pass.i65"
    .word qbranch
    .byt <(verifybuffers05-*+1)
#include "pass.i65"
    .word _pdq
    .byt (verifybuffers06-*-1)
    .asc "ERROR"
verifybuffers06
#include "pass.i65"
verifybuffers05
    .word exit

#print (*-bperbuf)
